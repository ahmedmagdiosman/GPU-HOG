# 1 "../src/Vec2.cu"
# 1 "/home/doni/Documents/Research/CUDA_Workspace/HOGCUDA/Debug//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 1
# 59 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/host_config.h" 1
# 119 "/usr/local/cuda-6.5/bin/..//include/host_config.h"
# 1 "/usr/include/features.h" 1 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 386 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 120 "/usr/local/cuda-6.5/bin/..//include/host_config.h" 2
# 60 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2







# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 56 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/device_types.h" 1
# 53 "/usr/local/cuda-6.5/bin/..//include/device_types.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/host_defines.h" 1
# 54 "/usr/local/cuda-6.5/bin/..//include/device_types.h" 2







enum __attribute__((device_builtin)) cudaRoundMode
{
    cudaRoundNearest,
    cudaRoundZero,
    cudaRoundPosInf,
    cudaRoundMinInf
};
# 57 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/driver_types.h" 1
# 70 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 152 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 71 "/usr/local/cuda-6.5/bin/..//include/driver_types.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 72 "/usr/local/cuda-6.5/bin/..//include/driver_types.h" 2
# 128 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
enum __attribute__((device_builtin)) cudaError
{





    cudaSuccess = 0,





    cudaErrorMissingConfiguration = 1,





    cudaErrorMemoryAllocation = 2,





    cudaErrorInitializationError = 3,
# 163 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorLaunchFailure = 4,
# 172 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorPriorLaunchFailure = 5,
# 182 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorLaunchTimeout = 6,
# 191 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorLaunchOutOfResources = 7,





    cudaErrorInvalidDeviceFunction = 8,
# 206 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorInvalidConfiguration = 9,





    cudaErrorInvalidDevice = 10,





    cudaErrorInvalidValue = 11,





    cudaErrorInvalidPitchValue = 12,





    cudaErrorInvalidSymbol = 13,




    cudaErrorMapBufferObjectFailed = 14,




    cudaErrorUnmapBufferObjectFailed = 15,





    cudaErrorInvalidHostPointer = 16,





    cudaErrorInvalidDevicePointer = 17,





    cudaErrorInvalidTexture = 18,





    cudaErrorInvalidTextureBinding = 19,






    cudaErrorInvalidChannelDescriptor = 20,





    cudaErrorInvalidMemcpyDirection = 21,
# 287 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorAddressOfConstant = 22,
# 296 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorTextureFetchFailed = 23,
# 305 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorTextureNotBound = 24,
# 314 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorSynchronizationError = 25,





    cudaErrorInvalidFilterSetting = 26,





    cudaErrorInvalidNormSetting = 27,







    cudaErrorMixedDeviceExecution = 28,






    cudaErrorCudartUnloading = 29,




    cudaErrorUnknown = 30,







    cudaErrorNotYetImplemented = 31,
# 363 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorMemoryValueTooLarge = 32,






    cudaErrorInvalidResourceHandle = 33,







    cudaErrorNotReady = 34,






    cudaErrorInsufficientDriver = 35,
# 398 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorSetOnActiveProcess = 36,





    cudaErrorInvalidSurface = 37,





    cudaErrorNoDevice = 38,





    cudaErrorECCUncorrectable = 39,




    cudaErrorSharedObjectSymbolNotFound = 40,




    cudaErrorSharedObjectInitFailed = 41,





    cudaErrorUnsupportedLimit = 42,





    cudaErrorDuplicateVariableName = 43,





    cudaErrorDuplicateTextureName = 44,





    cudaErrorDuplicateSurfaceName = 45,
# 460 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorDevicesUnavailable = 46,




    cudaErrorInvalidKernelImage = 47,







    cudaErrorNoKernelImageForDevice = 48,
# 486 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorIncompatibleDriverContext = 49,






    cudaErrorPeerAccessAlreadyEnabled = 50,






    cudaErrorPeerAccessNotEnabled = 51,





    cudaErrorDeviceAlreadyInUse = 54,






    cudaErrorProfilerDisabled = 55,







    cudaErrorProfilerNotInitialized = 56,






    cudaErrorProfilerAlreadyStarted = 57,






     cudaErrorProfilerAlreadyStopped = 58,







    cudaErrorAssert = 59,






    cudaErrorTooManyPeers = 60,





    cudaErrorHostMemoryAlreadyRegistered = 61,





    cudaErrorHostMemoryNotRegistered = 62,




    cudaErrorOperatingSystem = 63,





    cudaErrorPeerAccessUnsupported = 64,






    cudaErrorLaunchMaxDepthExceeded = 65,







    cudaErrorLaunchFileScopedTex = 66,







    cudaErrorLaunchFileScopedSurf = 67,
# 611 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorSyncDepthExceeded = 68,
# 623 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorLaunchPendingCountExceeded = 69,




    cudaErrorNotPermitted = 70,





    cudaErrorNotSupported = 71,
# 643 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorHardwareStackError = 72,







    cudaErrorIllegalInstruction = 73,
# 660 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorMisalignedAddress = 74,
# 671 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    cudaErrorInvalidAddressSpace = 75,







    cudaErrorInvalidPc = 76,







    cudaErrorIllegalAddress = 77,





    cudaErrorInvalidPtx = 78,




    cudaErrorInvalidGraphicsContext = 79,





    cudaErrorStartupFailure = 0x7f,







    cudaErrorApiFailureBase = 10000
};




enum __attribute__((device_builtin)) cudaChannelFormatKind
{
    cudaChannelFormatKindSigned = 0,
    cudaChannelFormatKindUnsigned = 1,
    cudaChannelFormatKindFloat = 2,
    cudaChannelFormatKindNone = 3
};




struct __attribute__((device_builtin)) cudaChannelFormatDesc
{
    int x;
    int y;
    int z;
    int w;
    enum cudaChannelFormatKind f;
};




typedef struct cudaArray *cudaArray_t;




typedef const struct cudaArray *cudaArray_const_t;

struct cudaArray;




typedef struct cudaMipmappedArray *cudaMipmappedArray_t;




typedef const struct cudaMipmappedArray *cudaMipmappedArray_const_t;

struct cudaMipmappedArray;




enum __attribute__((device_builtin)) cudaMemoryType
{
    cudaMemoryTypeHost = 1,
    cudaMemoryTypeDevice = 2
};




enum __attribute__((device_builtin)) cudaMemcpyKind
{
    cudaMemcpyHostToHost = 0,
    cudaMemcpyHostToDevice = 1,
    cudaMemcpyDeviceToHost = 2,
    cudaMemcpyDeviceToDevice = 3,
    cudaMemcpyDefault = 4
};






struct __attribute__((device_builtin)) cudaPitchedPtr
{
    void *ptr;
    size_t pitch;
    size_t xsize;
    size_t ysize;
};






struct __attribute__((device_builtin)) cudaExtent
{
    size_t width;
    size_t height;
    size_t depth;
};






struct __attribute__((device_builtin)) cudaPos
{
    size_t x;
    size_t y;
    size_t z;
};




struct __attribute__((device_builtin)) cudaMemcpy3DParms
{
    cudaArray_t srcArray;
    struct cudaPos srcPos;
    struct cudaPitchedPtr srcPtr;

    cudaArray_t dstArray;
    struct cudaPos dstPos;
    struct cudaPitchedPtr dstPtr;

    struct cudaExtent extent;
    enum cudaMemcpyKind kind;
};




struct __attribute__((device_builtin)) cudaMemcpy3DPeerParms
{
    cudaArray_t srcArray;
    struct cudaPos srcPos;
    struct cudaPitchedPtr srcPtr;
    int srcDevice;

    cudaArray_t dstArray;
    struct cudaPos dstPos;
    struct cudaPitchedPtr dstPtr;
    int dstDevice;

    struct cudaExtent extent;
};




struct cudaGraphicsResource;




enum __attribute__((device_builtin)) cudaGraphicsRegisterFlags
{
    cudaGraphicsRegisterFlagsNone = 0,
    cudaGraphicsRegisterFlagsReadOnly = 1,
    cudaGraphicsRegisterFlagsWriteDiscard = 2,
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,
    cudaGraphicsRegisterFlagsTextureGather = 8
};




enum __attribute__((device_builtin)) cudaGraphicsMapFlags
{
    cudaGraphicsMapFlagsNone = 0,
    cudaGraphicsMapFlagsReadOnly = 1,
    cudaGraphicsMapFlagsWriteDiscard = 2
};




enum __attribute__((device_builtin)) cudaGraphicsCubeFace
{
    cudaGraphicsCubeFacePositiveX = 0x00,
    cudaGraphicsCubeFaceNegativeX = 0x01,
    cudaGraphicsCubeFacePositiveY = 0x02,
    cudaGraphicsCubeFaceNegativeY = 0x03,
    cudaGraphicsCubeFacePositiveZ = 0x04,
    cudaGraphicsCubeFaceNegativeZ = 0x05
};




enum __attribute__((device_builtin)) cudaResourceType
{
    cudaResourceTypeArray = 0x00,
    cudaResourceTypeMipmappedArray = 0x01,
    cudaResourceTypeLinear = 0x02,
    cudaResourceTypePitch2D = 0x03
};




enum __attribute__((device_builtin)) cudaResourceViewFormat
{
    cudaResViewFormatNone = 0x00,
    cudaResViewFormatUnsignedChar1 = 0x01,
    cudaResViewFormatUnsignedChar2 = 0x02,
    cudaResViewFormatUnsignedChar4 = 0x03,
    cudaResViewFormatSignedChar1 = 0x04,
    cudaResViewFormatSignedChar2 = 0x05,
    cudaResViewFormatSignedChar4 = 0x06,
    cudaResViewFormatUnsignedShort1 = 0x07,
    cudaResViewFormatUnsignedShort2 = 0x08,
    cudaResViewFormatUnsignedShort4 = 0x09,
    cudaResViewFormatSignedShort1 = 0x0a,
    cudaResViewFormatSignedShort2 = 0x0b,
    cudaResViewFormatSignedShort4 = 0x0c,
    cudaResViewFormatUnsignedInt1 = 0x0d,
    cudaResViewFormatUnsignedInt2 = 0x0e,
    cudaResViewFormatUnsignedInt4 = 0x0f,
    cudaResViewFormatSignedInt1 = 0x10,
    cudaResViewFormatSignedInt2 = 0x11,
    cudaResViewFormatSignedInt4 = 0x12,
    cudaResViewFormatHalf1 = 0x13,
    cudaResViewFormatHalf2 = 0x14,
    cudaResViewFormatHalf4 = 0x15,
    cudaResViewFormatFloat1 = 0x16,
    cudaResViewFormatFloat2 = 0x17,
    cudaResViewFormatFloat4 = 0x18,
    cudaResViewFormatUnsignedBlockCompressed1 = 0x19,
    cudaResViewFormatUnsignedBlockCompressed2 = 0x1a,
    cudaResViewFormatUnsignedBlockCompressed3 = 0x1b,
    cudaResViewFormatUnsignedBlockCompressed4 = 0x1c,
    cudaResViewFormatSignedBlockCompressed4 = 0x1d,
    cudaResViewFormatUnsignedBlockCompressed5 = 0x1e,
    cudaResViewFormatSignedBlockCompressed5 = 0x1f,
    cudaResViewFormatUnsignedBlockCompressed6H = 0x20,
    cudaResViewFormatSignedBlockCompressed6H = 0x21,
    cudaResViewFormatUnsignedBlockCompressed7 = 0x22
};




struct __attribute__((device_builtin)) cudaResourceDesc {
 enum cudaResourceType resType;

 union {
  struct {
   cudaArray_t array;
  } array;
        struct {
            cudaMipmappedArray_t mipmap;
        } mipmap;
  struct {
   void *devPtr;
   struct cudaChannelFormatDesc desc;
   size_t sizeInBytes;
  } linear;
  struct {
   void *devPtr;
   struct cudaChannelFormatDesc desc;
   size_t width;
   size_t height;
   size_t pitchInBytes;
  } pitch2D;
 } res;
};




struct __attribute__((device_builtin)) cudaResourceViewDesc
{
    enum cudaResourceViewFormat format;
    size_t width;
    size_t height;
    size_t depth;
    unsigned int firstMipmapLevel;
    unsigned int lastMipmapLevel;
    unsigned int firstLayer;
    unsigned int lastLayer;
};




struct __attribute__((device_builtin)) cudaPointerAttributes
{




    enum cudaMemoryType memoryType;
# 1011 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
    int device;





    void *devicePointer;





    void *hostPointer;




    int isManaged;
};




struct __attribute__((device_builtin)) cudaFuncAttributes
{





   size_t sharedSizeBytes;





   size_t constSizeBytes;




   size_t localSizeBytes;






   int maxThreadsPerBlock;




   int numRegs;






   int ptxVersion;






   int binaryVersion;





   int cacheModeCA;
};




enum __attribute__((device_builtin)) cudaFuncCache
{
    cudaFuncCachePreferNone = 0,
    cudaFuncCachePreferShared = 1,
    cudaFuncCachePreferL1 = 2,
    cudaFuncCachePreferEqual = 3
};





enum __attribute__((device_builtin)) cudaSharedMemConfig
{
    cudaSharedMemBankSizeDefault = 0,
    cudaSharedMemBankSizeFourByte = 1,
    cudaSharedMemBankSizeEightByte = 2
};




enum __attribute__((device_builtin)) cudaComputeMode
{
    cudaComputeModeDefault = 0,
    cudaComputeModeExclusive = 1,
    cudaComputeModeProhibited = 2,
    cudaComputeModeExclusiveProcess = 3
};




enum __attribute__((device_builtin)) cudaLimit
{
    cudaLimitStackSize = 0x00,
    cudaLimitPrintfFifoSize = 0x01,
    cudaLimitMallocHeapSize = 0x02,
    cudaLimitDevRuntimeSyncDepth = 0x03,
    cudaLimitDevRuntimePendingLaunchCount = 0x04
};




enum __attribute__((device_builtin)) cudaOutputMode
{
    cudaKeyValuePair = 0x00,
    cudaCSV = 0x01
};




enum __attribute__((device_builtin)) cudaDeviceAttr
{
    cudaDevAttrMaxThreadsPerBlock = 1,
    cudaDevAttrMaxBlockDimX = 2,
    cudaDevAttrMaxBlockDimY = 3,
    cudaDevAttrMaxBlockDimZ = 4,
    cudaDevAttrMaxGridDimX = 5,
    cudaDevAttrMaxGridDimY = 6,
    cudaDevAttrMaxGridDimZ = 7,
    cudaDevAttrMaxSharedMemoryPerBlock = 8,
    cudaDevAttrTotalConstantMemory = 9,
    cudaDevAttrWarpSize = 10,
    cudaDevAttrMaxPitch = 11,
    cudaDevAttrMaxRegistersPerBlock = 12,
    cudaDevAttrClockRate = 13,
    cudaDevAttrTextureAlignment = 14,
    cudaDevAttrGpuOverlap = 15,
    cudaDevAttrMultiProcessorCount = 16,
    cudaDevAttrKernelExecTimeout = 17,
    cudaDevAttrIntegrated = 18,
    cudaDevAttrCanMapHostMemory = 19,
    cudaDevAttrComputeMode = 20,
    cudaDevAttrMaxTexture1DWidth = 21,
    cudaDevAttrMaxTexture2DWidth = 22,
    cudaDevAttrMaxTexture2DHeight = 23,
    cudaDevAttrMaxTexture3DWidth = 24,
    cudaDevAttrMaxTexture3DHeight = 25,
    cudaDevAttrMaxTexture3DDepth = 26,
    cudaDevAttrMaxTexture2DLayeredWidth = 27,
    cudaDevAttrMaxTexture2DLayeredHeight = 28,
    cudaDevAttrMaxTexture2DLayeredLayers = 29,
    cudaDevAttrSurfaceAlignment = 30,
    cudaDevAttrConcurrentKernels = 31,
    cudaDevAttrEccEnabled = 32,
    cudaDevAttrPciBusId = 33,
    cudaDevAttrPciDeviceId = 34,
    cudaDevAttrTccDriver = 35,
    cudaDevAttrMemoryClockRate = 36,
    cudaDevAttrGlobalMemoryBusWidth = 37,
    cudaDevAttrL2CacheSize = 38,
    cudaDevAttrMaxThreadsPerMultiProcessor = 39,
    cudaDevAttrAsyncEngineCount = 40,
    cudaDevAttrUnifiedAddressing = 41,
    cudaDevAttrMaxTexture1DLayeredWidth = 42,
    cudaDevAttrMaxTexture1DLayeredLayers = 43,
    cudaDevAttrMaxTexture2DGatherWidth = 45,
    cudaDevAttrMaxTexture2DGatherHeight = 46,
    cudaDevAttrMaxTexture3DWidthAlt = 47,
    cudaDevAttrMaxTexture3DHeightAlt = 48,
    cudaDevAttrMaxTexture3DDepthAlt = 49,
    cudaDevAttrPciDomainId = 50,
    cudaDevAttrTexturePitchAlignment = 51,
    cudaDevAttrMaxTextureCubemapWidth = 52,
    cudaDevAttrMaxTextureCubemapLayeredWidth = 53,
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54,
    cudaDevAttrMaxSurface1DWidth = 55,
    cudaDevAttrMaxSurface2DWidth = 56,
    cudaDevAttrMaxSurface2DHeight = 57,
    cudaDevAttrMaxSurface3DWidth = 58,
    cudaDevAttrMaxSurface3DHeight = 59,
    cudaDevAttrMaxSurface3DDepth = 60,
    cudaDevAttrMaxSurface1DLayeredWidth = 61,
    cudaDevAttrMaxSurface1DLayeredLayers = 62,
    cudaDevAttrMaxSurface2DLayeredWidth = 63,
    cudaDevAttrMaxSurface2DLayeredHeight = 64,
    cudaDevAttrMaxSurface2DLayeredLayers = 65,
    cudaDevAttrMaxSurfaceCubemapWidth = 66,
    cudaDevAttrMaxSurfaceCubemapLayeredWidth = 67,
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68,
    cudaDevAttrMaxTexture1DLinearWidth = 69,
    cudaDevAttrMaxTexture2DLinearWidth = 70,
    cudaDevAttrMaxTexture2DLinearHeight = 71,
    cudaDevAttrMaxTexture2DLinearPitch = 72,
    cudaDevAttrMaxTexture2DMipmappedWidth = 73,
    cudaDevAttrMaxTexture2DMipmappedHeight = 74,
    cudaDevAttrComputeCapabilityMajor = 75,
    cudaDevAttrComputeCapabilityMinor = 76,
    cudaDevAttrMaxTexture1DMipmappedWidth = 77,
    cudaDevAttrStreamPrioritiesSupported = 78,
    cudaDevAttrGlobalL1CacheSupported = 79,
    cudaDevAttrLocalL1CacheSupported = 80,
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81,
    cudaDevAttrMaxRegistersPerMultiprocessor = 82,
    cudaDevAttrManagedMemory = 83,
    cudaDevAttrIsMultiGpuBoard = 84,
    cudaDevAttrMultiGpuBoardGroupID = 85
};




struct __attribute__((device_builtin)) cudaDeviceProp
{
    char name[256];
    size_t totalGlobalMem;
    size_t sharedMemPerBlock;
    int regsPerBlock;
    int warpSize;
    size_t memPitch;
    int maxThreadsPerBlock;
    int maxThreadsDim[3];
    int maxGridSize[3];
    int clockRate;
    size_t totalConstMem;
    int major;
    int minor;
    size_t textureAlignment;
    size_t texturePitchAlignment;
    int deviceOverlap;
    int multiProcessorCount;
    int kernelExecTimeoutEnabled;
    int integrated;
    int canMapHostMemory;
    int computeMode;
    int maxTexture1D;
    int maxTexture1DMipmap;
    int maxTexture1DLinear;
    int maxTexture2D[2];
    int maxTexture2DMipmap[2];
    int maxTexture2DLinear[3];
    int maxTexture2DGather[2];
    int maxTexture3D[3];
    int maxTexture3DAlt[3];
    int maxTextureCubemap;
    int maxTexture1DLayered[2];
    int maxTexture2DLayered[3];
    int maxTextureCubemapLayered[2];
    int maxSurface1D;
    int maxSurface2D[2];
    int maxSurface3D[3];
    int maxSurface1DLayered[2];
    int maxSurface2DLayered[3];
    int maxSurfaceCubemap;
    int maxSurfaceCubemapLayered[2];
    size_t surfaceAlignment;
    int concurrentKernels;
    int ECCEnabled;
    int pciBusID;
    int pciDeviceID;
    int pciDomainID;
    int tccDriver;
    int asyncEngineCount;
    int unifiedAddressing;
    int memoryClockRate;
    int memoryBusWidth;
    int l2CacheSize;
    int maxThreadsPerMultiProcessor;
    int streamPrioritiesSupported;
    int globalL1CacheSupported;
    int localL1CacheSupported;
    size_t sharedMemPerMultiprocessor;
    int regsPerMultiprocessor;
    int managedMemory;
    int isMultiGpuBoard;
    int multiGpuBoardGroupID;
};
# 1375 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
typedef __attribute__((device_builtin)) struct __attribute__((device_builtin)) cudaIpcEventHandle_st
{
    char reserved[64];
}cudaIpcEventHandle_t;




typedef __attribute__((device_builtin)) struct __attribute__((device_builtin)) cudaIpcMemHandle_st
{
    char reserved[64];
}cudaIpcMemHandle_t;
# 1397 "/usr/local/cuda-6.5/bin/..//include/driver_types.h"
typedef __attribute__((device_builtin)) enum cudaError cudaError_t;




typedef __attribute__((device_builtin)) struct CUstream_st *cudaStream_t;




typedef __attribute__((device_builtin)) struct CUevent_st *cudaEvent_t;




typedef __attribute__((device_builtin)) struct cudaGraphicsResource *cudaGraphicsResource_t;




typedef __attribute__((device_builtin)) struct CUuuid_st cudaUUID_t;




typedef __attribute__((device_builtin)) enum cudaOutputMode cudaOutputMode_t;
# 58 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/surface_types.h" 1
# 84 "/usr/local/cuda-6.5/bin/..//include/surface_types.h"
enum __attribute__((device_builtin)) cudaSurfaceBoundaryMode
{
    cudaBoundaryModeZero = 0,
    cudaBoundaryModeClamp = 1,
    cudaBoundaryModeTrap = 2
};




enum __attribute__((device_builtin)) cudaSurfaceFormatMode
{
    cudaFormatModeForced = 0,
    cudaFormatModeAuto = 1
};




struct __attribute__((device_builtin)) surfaceReference
{



    struct cudaChannelFormatDesc channelDesc;
};




typedef __attribute__((device_builtin)) unsigned long long cudaSurfaceObject_t;
# 59 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/texture_types.h" 1
# 84 "/usr/local/cuda-6.5/bin/..//include/texture_types.h"
enum __attribute__((device_builtin)) cudaTextureAddressMode
{
    cudaAddressModeWrap = 0,
    cudaAddressModeClamp = 1,
    cudaAddressModeMirror = 2,
    cudaAddressModeBorder = 3
};




enum __attribute__((device_builtin)) cudaTextureFilterMode
{
    cudaFilterModePoint = 0,
    cudaFilterModeLinear = 1
};




enum __attribute__((device_builtin)) cudaTextureReadMode
{
    cudaReadModeElementType = 0,
    cudaReadModeNormalizedFloat = 1
};




struct __attribute__((device_builtin)) textureReference
{



    int normalized;



    enum cudaTextureFilterMode filterMode;



    enum cudaTextureAddressMode addressMode[3];



    struct cudaChannelFormatDesc channelDesc;



    int sRGB;



    unsigned int maxAnisotropy;



    enum cudaTextureFilterMode mipmapFilterMode;



    float mipmapLevelBias;



    float minMipmapLevelClamp;



    float maxMipmapLevelClamp;
    int __cudaReserved[15];
};




struct __attribute__((device_builtin)) cudaTextureDesc
{



    enum cudaTextureAddressMode addressMode[3];



    enum cudaTextureFilterMode filterMode;



    enum cudaTextureReadMode readMode;



    int sRGB;



    int normalizedCoords;



    unsigned int maxAnisotropy;



    enum cudaTextureFilterMode mipmapFilterMode;



    float mipmapLevelBias;



    float minMipmapLevelClamp;



    float maxMipmapLevelClamp;
};




typedef __attribute__((device_builtin)) unsigned long long cudaTextureObject_t;
# 60 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/vector_types.h" 1
# 60 "/usr/local/cuda-6.5/bin/..//include/vector_types.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 60 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/vector_types.h" 1
# 60 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 2
# 61 "/usr/local/cuda-6.5/bin/..//include/vector_types.h" 2
# 96 "/usr/local/cuda-6.5/bin/..//include/vector_types.h"
struct __attribute__((device_builtin)) char1
{
    signed char x;
};

struct __attribute__((device_builtin)) uchar1
{
    unsigned char x;
};


struct __attribute__((device_builtin)) __attribute__((aligned(2))) char2
{
    signed char x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(2))) uchar2
{
    unsigned char x, y;
};

struct __attribute__((device_builtin)) char3
{
    signed char x, y, z;
};

struct __attribute__((device_builtin)) uchar3
{
    unsigned char x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) char4
{
    signed char x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) uchar4
{
    unsigned char x, y, z, w;
};

struct __attribute__((device_builtin)) short1
{
    short x;
};

struct __attribute__((device_builtin)) ushort1
{
    unsigned short x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) short2
{
    short x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) ushort2
{
    unsigned short x, y;
};

struct __attribute__((device_builtin)) short3
{
    short x, y, z;
};

struct __attribute__((device_builtin)) ushort3
{
    unsigned short x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(8))) short4 { short x; short y; short z; short w; };
struct __attribute__((device_builtin)) __attribute__((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; };

struct __attribute__((device_builtin)) int1
{
    int x;
};

struct __attribute__((device_builtin)) uint1
{
    unsigned int x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(8))) int2 { int x; int y; };
struct __attribute__((device_builtin)) __attribute__((aligned(8))) uint2 { unsigned int x; unsigned int y; };

struct __attribute__((device_builtin)) int3
{
    int x, y, z;
};

struct __attribute__((device_builtin)) uint3
{
    unsigned int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) int4
{
    int x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) uint4
{
    unsigned int x, y, z, w;
};

struct __attribute__((device_builtin)) long1
{
    long int x;
};

struct __attribute__((device_builtin)) ulong1
{
    unsigned long x;
};






struct __attribute__((device_builtin)) __attribute__((aligned(2*sizeof(long int)))) long2
{
    long int x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(2*sizeof(unsigned long int)))) ulong2
{
    unsigned long int x, y;
};



struct __attribute__((device_builtin)) long3
{
    long int x, y, z;
};

struct __attribute__((device_builtin)) ulong3
{
    unsigned long int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) long4
{
    long int x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulong4
{
    unsigned long int x, y, z, w;
};

struct __attribute__((device_builtin)) float1
{
    float x;
};
# 272 "/usr/local/cuda-6.5/bin/..//include/vector_types.h"
struct __attribute__((device_builtin)) __attribute__((aligned(8))) float2 { float x; float y; };




struct __attribute__((device_builtin)) float3
{
    float x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) float4
{
    float x, y, z, w;
};

struct __attribute__((device_builtin)) longlong1
{
    long long int x;
};

struct __attribute__((device_builtin)) ulonglong1
{
    unsigned long long int x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) longlong2
{
    long long int x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulonglong2
{
    unsigned long long int x, y;
};

struct __attribute__((device_builtin)) longlong3
{
    long long int x, y, z;
};

struct __attribute__((device_builtin)) ulonglong3
{
    unsigned long long int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) longlong4
{
    long long int x, y, z ,w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulonglong4
{
    unsigned long long int x, y, z, w;
};

struct __attribute__((device_builtin)) double1
{
    double x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) double2
{
    double x, y;
};

struct __attribute__((device_builtin)) double3
{
    double x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) double4
{
    double x, y, z, w;
};
# 360 "/usr/local/cuda-6.5/bin/..//include/vector_types.h"
typedef __attribute__((device_builtin)) struct char1 char1;
typedef __attribute__((device_builtin)) struct uchar1 uchar1;
typedef __attribute__((device_builtin)) struct char2 char2;
typedef __attribute__((device_builtin)) struct uchar2 uchar2;
typedef __attribute__((device_builtin)) struct char3 char3;
typedef __attribute__((device_builtin)) struct uchar3 uchar3;
typedef __attribute__((device_builtin)) struct char4 char4;
typedef __attribute__((device_builtin)) struct uchar4 uchar4;
typedef __attribute__((device_builtin)) struct short1 short1;
typedef __attribute__((device_builtin)) struct ushort1 ushort1;
typedef __attribute__((device_builtin)) struct short2 short2;
typedef __attribute__((device_builtin)) struct ushort2 ushort2;
typedef __attribute__((device_builtin)) struct short3 short3;
typedef __attribute__((device_builtin)) struct ushort3 ushort3;
typedef __attribute__((device_builtin)) struct short4 short4;
typedef __attribute__((device_builtin)) struct ushort4 ushort4;
typedef __attribute__((device_builtin)) struct int1 int1;
typedef __attribute__((device_builtin)) struct uint1 uint1;
typedef __attribute__((device_builtin)) struct int2 int2;
typedef __attribute__((device_builtin)) struct uint2 uint2;
typedef __attribute__((device_builtin)) struct int3 int3;
typedef __attribute__((device_builtin)) struct uint3 uint3;
typedef __attribute__((device_builtin)) struct int4 int4;
typedef __attribute__((device_builtin)) struct uint4 uint4;
typedef __attribute__((device_builtin)) struct long1 long1;
typedef __attribute__((device_builtin)) struct ulong1 ulong1;
typedef __attribute__((device_builtin)) struct long2 long2;
typedef __attribute__((device_builtin)) struct ulong2 ulong2;
typedef __attribute__((device_builtin)) struct long3 long3;
typedef __attribute__((device_builtin)) struct ulong3 ulong3;
typedef __attribute__((device_builtin)) struct long4 long4;
typedef __attribute__((device_builtin)) struct ulong4 ulong4;
typedef __attribute__((device_builtin)) struct float1 float1;
typedef __attribute__((device_builtin)) struct float2 float2;
typedef __attribute__((device_builtin)) struct float3 float3;
typedef __attribute__((device_builtin)) struct float4 float4;
typedef __attribute__((device_builtin)) struct longlong1 longlong1;
typedef __attribute__((device_builtin)) struct ulonglong1 ulonglong1;
typedef __attribute__((device_builtin)) struct longlong2 longlong2;
typedef __attribute__((device_builtin)) struct ulonglong2 ulonglong2;
typedef __attribute__((device_builtin)) struct longlong3 longlong3;
typedef __attribute__((device_builtin)) struct ulonglong3 ulonglong3;
typedef __attribute__((device_builtin)) struct longlong4 longlong4;
typedef __attribute__((device_builtin)) struct ulonglong4 ulonglong4;
typedef __attribute__((device_builtin)) struct double1 double1;
typedef __attribute__((device_builtin)) struct double2 double2;
typedef __attribute__((device_builtin)) struct double3 double3;
typedef __attribute__((device_builtin)) struct double4 double4;







struct __attribute__((device_builtin)) dim3
{
    unsigned int x, y, z;

    __attribute__((host)) __attribute__((device)) dim3(unsigned int vx = 1, unsigned int vy = 1, unsigned int vz = 1) : x(vx), y(vy), z(vz) {}
    __attribute__((host)) __attribute__((device)) dim3(uint3 v) : x(v.x), y(v.y), z(v.z) {}
    __attribute__((host)) __attribute__((device)) operator uint3(void) { uint3 t; t.x = x; t.y = y; t.z = z; return t; }

};

typedef __attribute__((device_builtin)) struct dim3 dim3;
# 60 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 2
# 68 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/channel_descriptor.h" 1
# 62 "/usr/local/cuda-6.5/bin/..//include/channel_descriptor.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h" 1
# 143 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 144 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/cuda_device_runtime_api.h" 1
# 99 "/usr/local/cuda-6.5/bin/..//include/cuda_device_runtime_api.h"
extern "C"
{
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceSynchronize(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetLastError(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaPeekAtLastError(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) const char* cudaGetErrorString(cudaError_t error);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceCount(int *count);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetDevice(int *device);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamDestroy(cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventDestroy(cudaEvent_t event);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFree(void *devPtr);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(void **devPtr, size_t size);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaRuntimeGetVersion(int *runtimeVersion);

extern __attribute__((device)) __attribute__((cudart_builtin)) void * cudaGetParameterBuffer(size_t alignment, size_t size);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) void * cudaGetParameterBufferV2(void *func, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDeviceV2(void *parameterBuffer, cudaStream_t stream);

extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize);
}
namespace {
template <typename T> __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(T **devPtr, size_t size);
template <typename T> __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, T *entry);
template <typename T> __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, T func, int blockSize, size_t dynamicSmemSize);
}
# 145 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h" 2
# 174 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern "C" {
# 207 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceReset(void);
# 224 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceSynchronize(void);
# 309 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetLimit(enum cudaLimit limit, size_t value);
# 338 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);
# 369 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);
# 404 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetStreamPriorityRange(int *leastPriority, int *greatestPriority);
# 446 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetCacheConfig(enum cudaFuncCache cacheConfig);
# 475 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);
# 517 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetSharedMemConfig(enum cudaSharedMemConfig config);
# 540 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetByPCIBusId(int *device, const char *pciBusId);
# 567 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetPCIBusId(char *pciBusId, int len, int device);
# 609 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t *handle, cudaEvent_t event);
# 644 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcOpenEventHandle(cudaEvent_t *event, cudaIpcEventHandle_t handle);
# 682 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t *handle, void *devPtr);
# 732 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcOpenMemHandle(void **devPtr, cudaIpcMemHandle_t handle, unsigned int flags);
# 762 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcCloseMemHandle(void *devPtr);
# 802 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadExit(void);
# 826 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadSynchronize(void);
# 885 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadSetLimit(enum cudaLimit limit, size_t value);
# 916 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadGetLimit(size_t *pValue, enum cudaLimit limit);
# 951 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadGetCacheConfig(enum cudaFuncCache *pCacheConfig);
# 997 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadSetCacheConfig(enum cudaFuncCache cacheConfig);
# 1051 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetLastError(void);
# 1092 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaPeekAtLastError(void);
# 1107 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) const char* cudaGetErrorName(cudaError_t error);
# 1122 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) const char* cudaGetErrorString(cudaError_t error);
# 1152 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceCount(int *count);
# 1388 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceProperties(struct cudaDeviceProp *prop, int device);
# 1548 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);
# 1567 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaChooseDevice(int *device, const struct cudaDeviceProp *prop);
# 1601 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDevice(int device);
# 1618 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDevice(int *device);
# 1647 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetValidDevices(int *device_arr, int len);
# 1707 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDeviceFlags( unsigned int flags );
# 1745 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamCreate(cudaStream_t *pStream);
# 1774 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);
# 1817 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithPriority(cudaStream_t *pStream, unsigned int flags, int priority);
# 1841 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamGetPriority(cudaStream_t hStream, int *priority);
# 1862 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamGetFlags(cudaStream_t hStream, unsigned int *flags);
# 1883 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamDestroy(cudaStream_t stream);
# 1915 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
# 1929 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
typedef void ( *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void *userData);
# 1991 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamAddCallback(cudaStream_t stream,
        cudaStreamCallback_t callback, void *userData, unsigned int flags);
# 2011 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamSynchronize(cudaStream_t stream);
# 2032 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamQuery(cudaStream_t stream);
# 2098 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamAttachMemAsync(cudaStream_t stream, void *devPtr, size_t length, unsigned int flags);
# 2134 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventCreate(cudaEvent_t *event);
# 2168 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
# 2199 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);
# 2231 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventQuery(cudaEvent_t event);
# 2263 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventSynchronize(cudaEvent_t event);
# 2288 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventDestroy(cudaEvent_t event);
# 2329 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventElapsedTime(float *ms, cudaEvent_t start, cudaEvent_t end);
# 2376 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0);
# 2403 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetupArgument(const void *arg, size_t size, size_t offset);
# 2450 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFuncSetCacheConfig(const void *func, enum cudaFuncCache cacheConfig);
# 2501 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFuncSetSharedMemConfig(const void *func, enum cudaSharedMemConfig config);
# 2536 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaLaunch(const void *func);
# 2569 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);
# 2591 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDoubleForDevice(double *d);
# 2613 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDoubleForHost(double *d);
# 2666 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize);
# 2754 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMallocManaged(void **devPtr, size_t size, unsigned int flags);
# 2777 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(void **devPtr, size_t size);
# 2806 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocHost(void **ptr, size_t size);
# 2845 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocPitch(void **devPtr, size_t *pitch, size_t width, size_t height);
# 2887 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocArray(cudaArray_t *array, const struct cudaChannelFormatDesc *desc, size_t width, size_t height = 0, unsigned int flags = 0);
# 2911 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaFree(void *devPtr);
# 2931 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeHost(void *ptr);
# 2953 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeArray(cudaArray_t array);
# 2975 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray);
# 3034 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostAlloc(void **pHost, size_t size, unsigned int flags);
# 3087 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostRegister(void *ptr, size_t size, unsigned int flags);
# 3106 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostUnregister(void *ptr);
# 3133 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);
# 3152 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostGetFlags(unsigned int *pFlags, void *pHost);
# 3187 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMalloc3D(struct cudaPitchedPtr* pitchedDevPtr, struct cudaExtent extent);
# 3322 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMalloc3DArray(cudaArray_t *array, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int flags = 0);
# 3443 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t *mipmappedArray, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int numLevels, unsigned int flags = 0);
# 3469 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t *levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned int level);
# 3566 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3D(const struct cudaMemcpy3DParms *p);
# 3594 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3DPeer(const struct cudaMemcpy3DPeerParms *p);
# 3699 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream = 0);
# 3722 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3DPeerAsync(const struct cudaMemcpy3DPeerParms *p, cudaStream_t stream = 0);
# 3741 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemGetInfo(size_t *free, size_t *total);
# 3762 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaArrayGetInfo(struct cudaChannelFormatDesc *desc, struct cudaExtent *extent, unsigned int *flags, cudaArray_t array);
# 3797 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);
# 3829 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyPeer(void *dst, int dstDevice, const void *src, int srcDevice, size_t count);
# 3863 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind);
# 3897 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromArray(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind);
# 3932 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
# 3974 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2D(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
# 4016 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
# 4058 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DFromArray(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind);
# 4098 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
# 4133 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToSymbol(const void *symbol, const void *src, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyHostToDevice);
# 4168 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromSymbol(void *dst, const void *symbol, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost);
# 4211 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4243 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyPeerAsync(void *dst, int dstDevice, const void *src, int srcDevice, size_t count, cudaStream_t stream = 0);
# 4285 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4327 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromArrayAsync(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4379 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4430 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4480 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4523 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToSymbolAsync(const void *symbol, const void *src, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4566 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromSymbolAsync(void *dst, const void *symbol, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 4592 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset(void *devPtr, int value, size_t count);
# 4622 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset2D(void *devPtr, size_t pitch, int value, size_t width, size_t height);
# 4665 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset3D(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent);
# 4694 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream = 0);
# 4728 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0);
# 4775 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream = 0);
# 4798 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSymbolAddress(void **devPtr, const void *symbol);
# 4820 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSymbolSize(size_t *size, const void *symbol);
# 4974 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaPointerGetAttributes(struct cudaPointerAttributes *attributes, const void *ptr);
# 5012 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceCanAccessPeer(int *canAccessPeer, int device, int peerDevice);
# 5049 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceEnablePeerAccess(int peerDevice, unsigned int flags);
# 5068 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceDisablePeerAccess(int peerDevice);
# 5126 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource);
# 5158 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned int flags);
# 5194 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsMapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);
# 5226 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);
# 5255 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceGetMappedPointer(void **devPtr, size_t *size, cudaGraphicsResource_t resource);
# 5289 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t *array, cudaGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel);
# 5314 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t *mipmappedArray, cudaGraphicsResource_t resource);
# 5354 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetChannelDesc(struct cudaChannelFormatDesc *desc, cudaArray_const_t array);
# 5389 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) struct cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);
# 5436 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindTexture(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t size = (2147483647 * 2U + 1U));
# 5487 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindTexture2D(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t width, size_t height, size_t pitch);
# 5515 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindTextureToArray(const struct textureReference *texref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);
# 5543 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(const struct textureReference *texref, cudaMipmappedArray_const_t mipmappedArray, const struct cudaChannelFormatDesc *desc);
# 5564 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaUnbindTexture(const struct textureReference *texref);
# 5589 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureAlignmentOffset(size_t *offset, const struct textureReference *texref);
# 5614 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureReference(const struct textureReference **texref, const void *symbol);
# 5654 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaBindSurfaceToArray(const struct surfaceReference *surfref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);
# 5673 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSurfaceReference(const struct surfaceReference **surfref, const void *symbol);
# 5888 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaCreateTextureObject(cudaTextureObject_t *pTexObject, const struct cudaResourceDesc *pResDesc, const struct cudaTextureDesc *pTexDesc, const struct cudaResourceViewDesc *pResViewDesc);
# 5903 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDestroyTextureObject(cudaTextureObject_t texObject);
# 5919 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaTextureObject_t texObject);
# 5935 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectTextureDesc(struct cudaTextureDesc *pTexDesc, cudaTextureObject_t texObject);
# 5952 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectResourceViewDesc(struct cudaResourceViewDesc *pResViewDesc, cudaTextureObject_t texObject);
# 5989 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t *pSurfObject, const struct cudaResourceDesc *pResDesc);
# 6004 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject);
# 6019 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSurfaceObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaSurfaceObject_t surfObject);
# 6046 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDriverGetVersion(int *driverVersion);
# 6063 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaRuntimeGetVersion(int *runtimeVersion);




extern __attribute__((host)) cudaError_t cudaGetExportTable(const void **ppExportTable, const cudaUUID_t *pExportTableId);
# 6204 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime_api.h"
}
# 63 "/usr/local/cuda-6.5/bin/..//include/channel_descriptor.h" 2
# 107 "/usr/local/cuda-6.5/bin/..//include/channel_descriptor.h"
template<class T> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
  return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf1(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf2(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf4(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char>(void)
{
  int e = (int)sizeof(char) * 8;




  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);

}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<signed char>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned char>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char1>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar1>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char2>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar2>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char4>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar4>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned short>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short1>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort1>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short2>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort2>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short4>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort4>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned int>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int1>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint1>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int2>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint2>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int4>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint4>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}
# 379 "/usr/local/cuda-6.5/bin/..//include/channel_descriptor.h"
template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float1>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float2>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float4>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}
# 69 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2

# 1 "/usr/local/cuda-6.5/bin/..//include/driver_functions.h" 1
# 53 "/usr/local/cuda-6.5/bin/..//include/driver_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 54 "/usr/local/cuda-6.5/bin/..//include/driver_functions.h" 2
# 79 "/usr/local/cuda-6.5/bin/..//include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz)
{
  struct cudaPitchedPtr s;

  s.ptr = d;
  s.pitch = p;
  s.xsize = xsz;
  s.ysize = ysz;

  return s;
}
# 106 "/usr/local/cuda-6.5/bin/..//include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaPos make_cudaPos(size_t x, size_t y, size_t z)
{
  struct cudaPos p;

  p.x = x;
  p.y = y;
  p.z = z;

  return p;
}
# 132 "/usr/local/cuda-6.5/bin/..//include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d)
{
  struct cudaExtent e;

  e.width = w;
  e.height = h;
  e.depth = d;

  return e;
}
# 71 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2

# 1 "/usr/local/cuda-6.5/bin/..//include/vector_functions.h" 1
# 59 "/usr/local/cuda-6.5/bin/..//include/vector_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 60 "/usr/local/cuda-6.5/bin/..//include/vector_functions.h" 2
# 69 "/usr/local/cuda-6.5/bin/..//include/vector_functions.h"
static __inline__ __attribute__((host)) __attribute__((device)) char1 make_char1(signed char x)
{
  char1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar1 make_uchar1(unsigned char x)
{
  uchar1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char2 make_char2(signed char x, signed char y)
{
  char2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar2 make_uchar2(unsigned char x, unsigned char y)
{
  uchar2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char3 make_char3(signed char x, signed char y, signed char z)
{
  char3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z)
{
  uchar3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char4 make_char4(signed char x, signed char y, signed char z, signed char w)
{
  char4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w)
{
  uchar4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short1 make_short1(short x)
{
  short1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort1 make_ushort1(unsigned short x)
{
  ushort1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short2 make_short2(short x, short y)
{
  short2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort2 make_ushort2(unsigned short x, unsigned short y)
{
  ushort2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short3 make_short3(short x,short y, short z)
{
  short3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z)
{
  ushort3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short4 make_short4(short x, short y, short z, short w)
{
  short4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w)
{
  ushort4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int1 make_int1(int x)
{
  int1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint1 make_uint1(unsigned int x)
{
  uint1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int2 make_int2(int x, int y)
{
  int2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint2 make_uint2(unsigned int x, unsigned int y)
{
  uint2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int3 make_int3(int x, int y, int z)
{
  int3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z)
{
  uint3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int4 make_int4(int x, int y, int z, int w)
{
  int4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w)
{
  uint4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long1 make_long1(long int x)
{
  long1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong1 make_ulong1(unsigned long int x)
{
  ulong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long2 make_long2(long int x, long int y)
{
  long2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong2 make_ulong2(unsigned long int x, unsigned long int y)
{
  ulong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long3 make_long3(long int x, long int y, long int z)
{
  long3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z)
{
  ulong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long4 make_long4(long int x, long int y, long int z, long int w)
{
  long4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w)
{
  ulong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float1 make_float1(float x)
{
  float1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float2 make_float2(float x, float y)
{
  float2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float3 make_float3(float x, float y, float z)
{
  float3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float4 make_float4(float x, float y, float z, float w)
{
  float4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong1 make_longlong1(long long int x)
{
  longlong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong1 make_ulonglong1(unsigned long long int x)
{
  ulonglong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong2 make_longlong2(long long int x, long long int y)
{
  longlong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y)
{
  ulonglong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong3 make_longlong3(long long int x, long long int y, long long int z)
{
  longlong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z)
{
  ulonglong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w)
{
  longlong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w)
{
  ulonglong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double1 make_double1(double x)
{
  double1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double2 make_double2(double x, double y)
{
  double2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double3 make_double3(double x, double y, double z)
{
  double3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double4 make_double4(double x, double y, double z, double w)
{
  double4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}
# 73 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2



# 1 "/usr/local/cuda-6.5/bin/..//include/common_functions.h" 1
# 61 "/usr/local/cuda-6.5/bin/..//include/common_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 62 "/usr/local/cuda-6.5/bin/..//include/common_functions.h" 2


# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 44 "/usr/include/string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 164 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 234 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 261 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 313 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 515 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 644 "/usr/include/string.h" 3 4
}
# 65 "/usr/local/cuda-6.5/bin/..//include/common_functions.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 27 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4



struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 86 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "/usr/include/time.h" 2 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };








struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 66 "/usr/local/cuda-6.5/bin/..//include/common_functions.h" 2

extern "C"
{
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) clock_t clock(void) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void* memset(void*, int, size_t) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void* memcpy(void*, const void*, size_t) throw ();
}
# 169 "/usr/local/cuda-6.5/bin/..//include/common_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/math_functions.h" 1
# 83 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 84 "/usr/local/cuda-6.5/bin/..//include/math_functions.h" 2
# 92 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern "C"
{
# 149 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) int abs(int) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) long int labs(long int) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) long long int llabs(long long int) throw ();
# 194 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fabs(double x) throw ();
# 235 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fabsf(float x) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int min(int, int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned int umin(unsigned int, unsigned int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llmin(long long int, long long int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned long long int ullmin(unsigned long long int, unsigned long long int);
# 256 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fminf(float x, float y) throw ();
# 276 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmin(double x, double y) throw ();



extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int max(int, int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned int umax(unsigned int, unsigned int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llmax(long long int, long long int);
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned long long int ullmax(unsigned long long int, unsigned long long int);
# 300 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmaxf(float x, float y) throw ();
# 320 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmax(double, double) throw ();
# 364 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sin(double x) throw ();
# 397 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cos(double x) throw ();
# 412 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincos(double x, double *sptr, double *cptr) throw ();
# 428 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincosf(float x, float *sptr, float *cptr) throw ();
# 469 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tan(double x) throw ();
# 538 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sqrt(double x) throw ();
# 607 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rsqrt(double x);
# 676 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rsqrtf(float x);
# 728 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log2(double x) throw ();
# 753 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp2(double x) throw ();
# 778 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float exp2f(float x) throw ();
# 802 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp10(double x) throw ();
# 824 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float exp10f(float x) throw ();
# 866 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double expm1(double x) throw ();
# 911 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float expm1f(float x) throw ();
# 966 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log2f(float x) throw ();
# 1020 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log10(double x) throw ();
# 1091 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log(double x) throw ();
# 1185 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log1p(double x) throw ();
# 1282 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log1pf(float x) throw ();
# 1357 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double floor(double x) throw ();
# 1396 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp(double x) throw ();
# 1427 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cosh(double x) throw ();
# 1457 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sinh(double x) throw ();
# 1487 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tanh(double x) throw ();
# 1522 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double acosh(double x) throw ();
# 1560 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float acoshf(float x) throw ();
# 1576 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double asinh(double x) throw ();
# 1592 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float asinhf(float x) throw ();
# 1646 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atanh(double x) throw ();
# 1700 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atanhf(float x) throw ();
# 1759 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double ldexp(double x, int exp) throw ();
# 1815 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ldexpf(float x, int exp) throw ();
# 1867 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double logb(double x) throw ();
# 1922 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float logbf(float x) throw ();
# 1952 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int ilogb(double x) throw ();
# 1982 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int ilogbf(float x) throw ();
# 2058 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double scalbn(double x, int n) throw ();
# 2134 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float scalbnf(float x, int n) throw ();
# 2210 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double scalbln(double x, long int n) throw ();
# 2286 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float scalblnf(float x, long int n) throw ();
# 2364 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double frexp(double x, int *nptr) throw ();
# 2439 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float frexpf(float x, int *nptr) throw ();
# 2453 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double round(double x) throw ();
# 2470 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float roundf(float x) throw ();
# 2488 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lround(double x) throw ();
# 2506 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lroundf(float x) throw ();
# 2524 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llround(double x) throw ();
# 2542 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llroundf(float x) throw ();
# 2557 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rint(double x) throw ();
# 2572 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rintf(float x) throw ();
# 2588 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lrint(double x) throw ();
# 2604 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lrintf(float x) throw ();
# 2620 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llrint(double x) throw ();
# 2636 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llrintf(float x) throw ();
# 2689 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nearbyint(double x) throw ();
# 2742 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nearbyintf(float x) throw ();
# 2804 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double ceil(double x) throw ();
# 2816 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double trunc(double x) throw ();
# 2831 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float truncf(float x) throw ();
# 2857 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fdim(double x, double y) throw ();
# 2883 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fdimf(float x, float y) throw ();
# 2919 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atan2(double y, double x) throw ();
# 2950 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atan(double x) throw ();
# 2973 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double acos(double x) throw ();
# 3005 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double asin(double x) throw ();
# 3045 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double hypot(double x, double y) throw ();
# 3095 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rhypot(double x, double y) throw ();
# 3136 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float hypotf(float x, float y) throw ();
# 3186 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rhypotf(float x, float y) throw ();
# 3270 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cbrt(double x) throw ();
# 3356 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cbrtf(float x) throw ();
# 3408 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rcbrt(double x);
# 3457 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rcbrtf(float x);
# 3517 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sinpi(double x);
# 3577 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinpif(float x);
# 3629 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cospi(double x);
# 3681 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cospif(float x);
# 3711 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincospi(double x, double *sptr, double *cptr);
# 3741 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincospif(float x, float *sptr, float *cptr);
# 4049 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double pow(double x, double y) throw ();
# 4105 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double modf(double x, double *iptr) throw ();
# 4164 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmod(double x, double y) throw ();
# 4250 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double remainder(double x, double y) throw ();
# 4340 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float remainderf(float x, float y) throw ();
# 4394 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double remquo(double x, double y, int *quo) throw ();
# 4448 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float remquof(float x, float y, int *quo) throw ();
# 4489 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double j0(double x) throw ();
# 4527 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float j0f(float x) throw ();
# 4584 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double j1(double x) throw ();
# 4641 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float j1f(float x) throw ();
# 4680 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double jn(int n, double x) throw ();
# 4719 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float jnf(int n, float x) throw ();
# 4767 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double y0(double x) throw ();
# 4815 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float y0f(float x) throw ();
# 4863 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double y1(double x) throw ();
# 4911 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float y1f(float x) throw ();
# 4960 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double yn(int n, double x) throw ();
# 5009 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ynf(int n, float x) throw ();
# 5036 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cyl_bessel_i0(double x) throw ();
# 5062 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cyl_bessel_i0f(float x) throw ();
# 5089 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cyl_bessel_i1(double x) throw ();
# 5115 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cyl_bessel_i1f(float x) throw ();
# 5195 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erf(double x) throw ();
# 5277 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erff(float x) throw ();
# 5337 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfinv(double y);
# 5394 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfinvf(float y);
# 5429 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfc(double x) throw ();
# 5467 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcf(float x) throw ();
# 5595 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double lgamma(double x) throw ();
# 5654 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfcinv(double y);
# 5710 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcinvf(float y);
# 5768 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double normcdfinv(double y);
# 5826 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float normcdfinvf(float y);
# 5869 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double normcdf(double y);
# 5912 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float normcdff(float y);
# 5987 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfcx(double x);
# 6062 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcxf(float x);
# 6192 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float lgammaf(float x) throw ();
# 6301 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tgamma(double x) throw ();
# 6410 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tgammaf(float x) throw ();
# 6423 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double copysign(double x, double y) throw ();
# 6436 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float copysignf(float x, float y) throw ();
# 6473 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nextafter(double x, double y) throw ();
# 6510 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nextafterf(float x, float y) throw ();
# 6526 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nan(const char *tagp) throw ();
# 6542 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nanf(const char *tagp) throw ();



extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinff(float) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnanf(float) throw ();
# 6556 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finite(double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finitef(float) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbit(double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnan(double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinf(double) throw ();


extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbitf(float) throw ();
# 6718 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fma(double x, double y, double z) throw ();
# 6876 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmaf(float x, float y, float z) throw ();







extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbitl(long double) throw ();





extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finitel(long double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinfl(long double) throw ();
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnanl(long double) throw ();
# 6939 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float acosf(float x) throw ();
# 6979 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float asinf(float x) throw ();
# 7019 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atanf(float x) throw ();
# 7052 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atan2f(float y, float x) throw ();
# 7076 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cosf(float x) throw ();
# 7118 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinf(float x) throw ();
# 7160 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tanf(float x) throw ();
# 7184 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float coshf(float x) throw ();
# 7225 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinhf(float x) throw ();
# 7255 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tanhf(float x) throw ();
# 7306 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float logf(float x) throw ();
# 7356 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float expf(float x) throw ();
# 7407 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log10f(float x) throw ();
# 7462 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float modff(float x, float *iptr) throw ();
# 7770 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float powf(float x, float y) throw ();
# 7839 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sqrtf(float x) throw ();
# 7898 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ceilf(float x) throw ();
# 7970 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float floorf(float x) throw ();
# 8029 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmodf(float x, float y) throw ();


}

# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3 4
# 33 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3 4
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3 4
# 42 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 46 "/usr/include/math.h" 2 3 4
# 69 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));




extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 70 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));




extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 89 "/usr/include/math.h" 2 3 4
# 132 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));




extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 133 "/usr/include/math.h" 2 3 4
# 148 "/usr/include/math.h" 3 4
extern int signgam;
# 189 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 301 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 324 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 488 "/usr/include/math.h" 3 4
}
# 8035 "/usr/local/cuda-6.5/bin/..//include/math_functions.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 104 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 136 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 54 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4
}
# 8036 "/usr/local/cuda-6.5/bin/..//include/math_functions.h" 2


# 1 "/usr/include/c++/4.8/cmath" 1 3
# 39 "/usr/include/c++/4.8/cmath" 3
       
# 40 "/usr/include/c++/4.8/cmath" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 1 3
# 184 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;




}
# 426 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/os_defines.h" 1 3
# 427 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/cpu_defines.h" 1 3
# 430 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 2 3
# 42 "/usr/include/c++/4.8/cmath" 2 3
# 1 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
# 68 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 198 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 421 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3

}
# 43 "/usr/include/c++/4.8/cmath" 2 3
# 1 "/usr/include/c++/4.8/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/4.8/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/4.8/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 44 "/usr/include/c++/4.8/cmath" 2 3
# 75 "/usr/include/c++/4.8/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }




  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }



  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 555 "/usr/include/c++/4.8/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 805 "/usr/include/c++/4.8/cmath" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(0, 1, 4,
      3, 2, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }




}
# 8039 "/usr/local/cuda-6.5/bin/..//include/math_functions.h" 2
# 1 "/usr/include/c++/4.8/cstdlib" 1 3
# 39 "/usr/include/c++/4.8/cstdlib" 3
       
# 40 "/usr/include/c++/4.8/cstdlib" 3
# 114 "/usr/include/c++/4.8/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }



}
# 196 "/usr/include/c++/4.8/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 228 "/usr/include/c++/4.8/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 8040 "/usr/local/cuda-6.5/bin/..//include/math_functions.h" 2
# 8074 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(float x) { return __signbitf(x); }



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(double x) { return __signbit(x); }

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int signbit(long double x) { return __signbitl(x);}


__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(float x) { return __finitef(x); }



__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(double x) { return __finite(x); }

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isfinite(long double x) { return __finitel(x); }


__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(float x) { return __isnanf(x); }
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(double x) throw() { return __isnan(x); }
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(long double x) { return __isnanl(x); }

__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(float x) { return __isinff(x); }
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(double x) throw() { return __isinf(x); }
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(long double x) { return __isinfl(x); }
# 8128 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
namespace std
{
  template<typename T> extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) T __pow_helper(T, int);
  template<typename T> extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) T __cmath_power(T, unsigned int);
}

using std::abs;
using std::fabs;
using std::ceil;
using std::floor;
using std::sqrt;
using std::pow;
using std::log;
using std::log10;
using std::fmod;
using std::modf;
using std::exp;
using std::frexp;
using std::ldexp;
using std::asin;
using std::sin;
using std::sinh;
using std::acos;
using std::cos;
using std::cosh;
using std::atan;
using std::atan2;
using std::tan;
using std::tanh;
# 8606 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
namespace std {





extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long long int abs(long long int);





extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long int abs(long int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float abs(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double abs(double);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float fabs(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float ceil(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float floor(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sqrt(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float pow(float, float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float pow(float, int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double pow(double, int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float log(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float log10(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float fmod(float, float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float modf(float, float*);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float exp(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float frexp(float, int*);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float ldexp(float, int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float asin(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sin(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sinh(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float acos(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float cos(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float cosh(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float atan(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float atan2(float, float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float tan(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float tanh(float);
# 8676 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
}



static __inline__ __attribute__((host)) __attribute__((device)) float logb(float a)
{
  return logbf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) int ilogb(float a)
{
  return ilogbf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float scalbn(float a, int b)
{
  return scalbnf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float scalbln(float a, long int b)
{
  return scalblnf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float exp2(float a)
{
  return exp2f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float expm1(float a)
{
  return expm1f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float log2(float a)
{
  return log2f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float log1p(float a)
{
  return log1pf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float acosh(float a)
{
  return acoshf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float asinh(float a)
{
  return asinhf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float atanh(float a)
{
  return atanhf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float hypot(float a, float b)
{
  return hypotf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float cbrt(float a)
{
  return cbrtf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float erf(float a)
{
  return erff(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float erfc(float a)
{
  return erfcf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float lgamma(float a)
{
  return lgammaf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float tgamma(float a)
{
  return tgammaf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float copysign(float a, float b)
{
  return copysignf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float nextafter(float a, float b)
{
  return nextafterf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float remainder(float a, float b)
{
  return remainderf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float remquo(float a, float b, int *quo)
{
  return remquof(a, b, quo);
}

static __inline__ __attribute__((host)) __attribute__((device)) float round(float a)
{
  return roundf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) long int lround(float a)
{
  return lroundf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) long long int llround(float a)
{
  return llroundf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float trunc(float a)
{
  return truncf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float rint(float a)
{
  return rintf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) long int lrint(float a)
{
  return lrintf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) long long int llrint(float a)
{
  return llrintf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float nearbyint(float a)
{
  return nearbyintf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float fdim(float a, float b)
{
  return fdimf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float fma(float a, float b, float c)
{
  return fmaf(a, b, c);
}

static __inline__ __attribute__((host)) __attribute__((device)) float fmax(float a, float b)
{
  return fmaxf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float fmin(float a, float b)
{
  return fminf(a, b);
}
# 8880 "/usr/local/cuda-6.5/bin/..//include/math_functions.h"
static __inline__ __attribute__((host)) __attribute__((device)) float exp10(float a)
{
  return exp10f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float rsqrt(float a)
{
  return rsqrtf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float rcbrt(float a)
{
  return rcbrtf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float sinpi(float a)
{
  return sinpif(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float cospi(float a)
{
  return cospif(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) void sincospi(float a, float *sptr, float *cptr)
{
  sincospif(a, sptr, cptr);
}

static __inline__ __attribute__((host)) __attribute__((device)) void sincos(float a, float *sptr, float *cptr)
{
  sincosf(a, sptr, cptr);
}

static __inline__ __attribute__((host)) __attribute__((device)) float j0(float a)
{
  return j0f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float j1(float a)
{
  return j1f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float jn(int n, float a)
{
  return jnf(n, a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float y0(float a)
{
  return y0f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float y1(float a)
{
  return y1f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float yn(int n, float a)
{
  return ynf(n, a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float cyl_bessel_i0(float a)
{
  return cyl_bessel_i0f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float cyl_bessel_i1(float a)
{
  return cyl_bessel_i1f(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float erfinv(float a)
{
  return erfinvf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float erfcinv(float a)
{
  return erfcinvf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float normcdfinv(float a)
{
  return normcdfinvf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float normcdf(float a)
{
  return normcdff(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) float erfcx(float a)
{
  return erfcxf(a);
}

static __inline__ __attribute__((host)) __attribute__((device)) double copysign(double a, float b)
{
  return copysign(a, (double)b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float copysign(float a, double b)
{
  return copysignf(a, (float)b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned int min(unsigned int a, unsigned int b)
{
  return umin(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned int min(int a, unsigned int b)
{
  return umin((unsigned int)a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned int min(unsigned int a, int b)
{
  return umin(a, (unsigned int)b);
}

static __inline__ __attribute__((host)) __attribute__((device)) long long int min(long long int a, long long int b)
{
  return llmin(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned long long int min(unsigned long long int a, unsigned long long int b)
{
  return ullmin(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned long long int min(long long int a, unsigned long long int b)
{
  return ullmin((unsigned long long int)a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned long long int min(unsigned long long int a, long long int b)
{
  return ullmin(a, (unsigned long long int)b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float min(float a, float b)
{
  return fminf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) double min(double a, double b)
{
  return fmin(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) double min(float a, double b)
{
  return fmin((double)a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) double min(double a, float b)
{
  return fmin(a, (double)b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned int max(unsigned int a, unsigned int b)
{
  return umax(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned int max(int a, unsigned int b)
{
  return umax((unsigned int)a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned int max(unsigned int a, int b)
{
  return umax(a, (unsigned int)b);
}

static __inline__ __attribute__((host)) __attribute__((device)) long long int max(long long int a, long long int b)
{
  return llmax(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned long long int max(unsigned long long int a, unsigned long long int b)
{
  return ullmax(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned long long int max(long long int a, unsigned long long int b)
{
  return ullmax((unsigned long long int)a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) unsigned long long int max(unsigned long long int a, long long int b)
{
  return ullmax(a, (unsigned long long int)b);
}

static __inline__ __attribute__((host)) __attribute__((device)) float max(float a, float b)
{
  return fmaxf(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) double max(double a, double b)
{
  return fmax(a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) double max(float a, double b)
{
  return fmax((double)a, b);
}

static __inline__ __attribute__((host)) __attribute__((device)) double max(double a, float b)
{
  return fmax(a, (double)b);
}
# 170 "/usr/local/cuda-6.5/bin/..//include/common_functions.h" 2
# 77 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/cuda_surface_types.h" 1
# 61 "/usr/local/cuda-6.5/bin/..//include/cuda_surface_types.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 62 "/usr/local/cuda-6.5/bin/..//include/cuda_surface_types.h" 2
# 73 "/usr/local/cuda-6.5/bin/..//include/cuda_surface_types.h"
template<class T, int dim = 1>
struct __attribute__((device_builtin_surface_type)) surface : public surfaceReference
{
  __attribute__((host)) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<T>();
  }

  __attribute__((host)) surface(struct cudaChannelFormatDesc desc)
  {
    channelDesc = desc;
  }
};

template<int dim>
struct __attribute__((device_builtin_surface_type)) surface<void, dim> : public surfaceReference
{
  __attribute__((host)) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<void>();
  }
};
# 78 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/cuda_texture_types.h" 1
# 61 "/usr/local/cuda-6.5/bin/..//include/cuda_texture_types.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 62 "/usr/local/cuda-6.5/bin/..//include/cuda_texture_types.h" 2
# 73 "/usr/local/cuda-6.5/bin/..//include/cuda_texture_types.h"
template<class T, int texType = 0x01, enum cudaTextureReadMode mode = cudaReadModeElementType>
struct __attribute__((device_builtin_texture_type)) texture : public textureReference
{
  __attribute__((host)) texture(int norm = 0,
                   enum cudaTextureFilterMode fMode = cudaFilterModePoint,
                   enum cudaTextureAddressMode aMode = cudaAddressModeClamp)
  {
    normalized = norm;
    filterMode = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc = cudaCreateChannelDesc<T>();
    sRGB = 0;
  }

  __attribute__((host)) texture(int norm,
                   enum cudaTextureFilterMode fMode,
                   enum cudaTextureAddressMode aMode,
                   struct cudaChannelFormatDesc desc)
  {
    normalized = norm;
    filterMode = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc = desc;
    sRGB = 0;
  }
};
# 79 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 1
# 61 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 62 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 71 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern "C"
{
# 82 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __mulhi(int x, int y);
# 92 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __umulhi(unsigned int x, unsigned int y);
# 102 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __mul64hi(long long int x, long long int y);
# 112 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __umul64hi(unsigned long long int x, unsigned long long int y);
# 121 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __int_as_float(int x);
# 130 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __float_as_int(float x);
extern __attribute__((device)) __attribute__((device_builtin)) void __syncthreads(void);
extern __attribute__((device)) __attribute__((device_builtin)) void __prof_trigger(int);
extern __attribute__((device)) __attribute__((device_builtin)) void __threadfence(void);
extern __attribute__((device)) __attribute__((device_builtin)) void __threadfence_block(void);
extern __attribute__((device)) __attribute__((device_builtin)) void __trap(void);
extern __attribute__((device)) __attribute__((device_builtin)) void __brkpt(int c = 0);
# 159 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __saturatef(float x);
# 228 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __sad(int x, int y, unsigned int z);
# 296 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __usad(unsigned int x, unsigned int y, unsigned int z);
# 306 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __mul24(int x, int y);
# 316 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __umul24(unsigned int x, unsigned int y);
# 329 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float fdividef(float x, float y);
# 404 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fdividef(float x, float y);
extern __attribute__((device)) __attribute__((device_builtin)) double fdivide(double x, double y);
# 417 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __sinf(float x) throw ();
# 429 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __cosf(float x) throw ();
# 443 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __tanf(float x) throw ();
# 458 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void __sincosf(float x, float *sptr, float *cptr) throw ();
# 508 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __expf(float x) throw ();
# 540 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __exp10f(float x) throw ();
# 566 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __log2f(float x) throw ();
# 594 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __log10f(float x) throw ();
# 638 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __logf(float x) throw ();
# 681 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __powf(float x, float y) throw ();
# 690 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __float2int_rn(float x);
# 699 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __float2int_rz(float x);
# 708 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __float2int_ru(float);
# 717 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __float2int_rd(float x);
# 726 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __float2uint_rn(float x);
# 735 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __float2uint_rz(float x);
# 744 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __float2uint_ru(float x);
# 753 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __float2uint_rd(float x);
# 762 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __int2float_rn(int x);
# 771 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __int2float_rz(int x);
# 780 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __int2float_ru(int x);
# 789 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __int2float_rd(int x);
# 798 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __uint2float_rn(unsigned int x);
# 807 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __uint2float_rz(unsigned int x);
# 816 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __uint2float_ru(unsigned int x);
# 825 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __uint2float_rd(unsigned int x);
# 834 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __float2ll_rn(float x);
# 843 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __float2ll_rz(float x);
# 852 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __float2ll_ru(float x);
# 861 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __float2ll_rd(float x);
# 870 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __float2ull_rn(float x);
# 879 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __float2ull_rz(float x);
# 888 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __float2ull_ru(float x);
# 897 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __float2ull_rd(float x);
# 906 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __ll2float_rn(long long int x);
# 915 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __ll2float_rz(long long int x);
# 924 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __ll2float_ru(long long int x);
# 933 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __ll2float_rd(long long int x);
# 942 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __ull2float_rn(unsigned long long int x);
# 951 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __ull2float_rz(unsigned long long int x);
# 960 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __ull2float_ru(unsigned long long int x);
# 969 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __ull2float_rd(unsigned long long int x);
# 978 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned short __float2half_rn(float x);
# 987 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __half2float(unsigned short x);
# 999 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fadd_rn(float x, float y);
# 1011 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fadd_rz(float x, float y);
# 1023 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fadd_ru(float x, float y);
# 1035 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fadd_rd(float x, float y);
# 1047 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fsub_rn(float x, float y);
# 1059 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fsub_rz(float x, float y);
# 1071 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fsub_ru(float x, float y);
# 1083 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fsub_rd(float x, float y);
# 1095 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmul_rn(float x, float y);
# 1107 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmul_rz(float x, float y);
# 1119 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmul_ru(float x, float y);
# 1131 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmul_rd(float x, float y);
# 1284 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_rn(float x, float y, float z);
# 1437 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_rz(float x, float y, float z);
# 1590 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ru(float x, float y, float z);
# 1743 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_rd(float x, float y, float z);
# 1776 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __frcp_rn(float x);
# 1809 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __frcp_rz(float x);
# 1842 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __frcp_ru(float x);
# 1875 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __frcp_rd(float x);
# 1906 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fsqrt_rn(float x);
# 1937 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fsqrt_rz(float x);
# 1968 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fsqrt_ru(float x);
# 1999 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fsqrt_rd(float x);
# 2038 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __frsqrt_rn(float x);
# 2049 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fdiv_rn(float x, float y);
# 2060 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fdiv_rz(float x, float y);
# 2071 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fdiv_ru(float x, float y);
# 2082 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fdiv_rd(float x, float y);
# 2091 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __clz(int x);
# 2102 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __ffs(int x);
# 2111 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __popc(unsigned int x);
# 2120 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __brev(unsigned int x);
# 2129 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __clzll(long long int x);
# 2140 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __ffsll(long long int x);
# 2151 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __popcll(unsigned long long int x);
# 2160 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __brevll(unsigned long long int x);
# 2184 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __byte_perm(unsigned int x, unsigned int y, unsigned int s);
# 2196 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __hadd(int, int);
# 2209 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __rhadd(int, int);
# 2221 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uhadd(unsigned int, unsigned int);
# 2234 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __urhadd(unsigned int, unsigned int);
# 2245 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rz(double);
# 2254 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rz(double);
# 2263 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rz(double);
# 2272 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rz(double);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __pm0(void);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __pm1(void);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __pm2(void);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __pm3(void);
# 2294 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vabs2(unsigned int a);
# 2305 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vabsss2(unsigned int a);
# 2316 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vadd2(unsigned int a, unsigned int b);
# 2327 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vaddss2 (unsigned int a, unsigned int b);
# 2337 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vaddus2 (unsigned int a, unsigned int b);
# 2348 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vavgs2(unsigned int a, unsigned int b);
# 2359 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vavgu2(unsigned int a, unsigned int b);
# 2370 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vhaddu2(unsigned int a, unsigned int b);
# 2381 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpeq2(unsigned int a, unsigned int b);
# 2392 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpges2(unsigned int a, unsigned int b);
# 2403 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpgeu2(unsigned int a, unsigned int b);
# 2414 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpgts2(unsigned int a, unsigned int b);
# 2425 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpgtu2(unsigned int a, unsigned int b);
# 2436 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmples2(unsigned int a, unsigned int b);
# 2448 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpleu2(unsigned int a, unsigned int b);
# 2459 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmplts2(unsigned int a, unsigned int b);
# 2470 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpltu2(unsigned int a, unsigned int b);
# 2481 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpne2(unsigned int a, unsigned int b);
# 2492 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vabsdiffu2(unsigned int a, unsigned int b);
# 2503 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vmaxs2(unsigned int a, unsigned int b);
# 2514 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vmaxu2(unsigned int a, unsigned int b);
# 2525 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vmins2(unsigned int a, unsigned int b);
# 2536 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vminu2(unsigned int a, unsigned int b);
# 2547 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vseteq2(unsigned int a, unsigned int b);
# 2558 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetges2(unsigned int a, unsigned int b);
# 2569 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetgeu2(unsigned int a, unsigned int b);
# 2580 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetgts2(unsigned int a, unsigned int b);
# 2591 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetgtu2(unsigned int a, unsigned int b);
# 2602 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetles2(unsigned int a, unsigned int b);
# 2613 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetleu2(unsigned int a, unsigned int b);
# 2624 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetlts2(unsigned int a, unsigned int b);
# 2635 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetltu2(unsigned int a, unsigned int b);
# 2646 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetne2(unsigned int a, unsigned int b);
# 2657 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsadu2(unsigned int a, unsigned int b);
# 2668 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsub2(unsigned int a, unsigned int b);
# 2679 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsubss2 (unsigned int a, unsigned int b);
# 2690 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsubus2 (unsigned int a, unsigned int b);
# 2700 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vneg2(unsigned int a);
# 2710 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vnegss2(unsigned int a);
# 2721 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vabsdiffs2(unsigned int a, unsigned int b);
# 2732 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsads2(unsigned int a, unsigned int b);
# 2742 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vabs4(unsigned int a);
# 2753 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vabsss4(unsigned int a);
# 2764 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vadd4(unsigned int a, unsigned int b);
# 2775 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vaddss4 (unsigned int a, unsigned int b);
# 2785 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vaddus4 (unsigned int a, unsigned int b);
# 2796 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vavgs4(unsigned int a, unsigned int b);
# 2807 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vavgu4(unsigned int a, unsigned int b);
# 2818 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vhaddu4(unsigned int a, unsigned int b);
# 2829 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpeq4(unsigned int a, unsigned int b);
# 2840 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpges4(unsigned int a, unsigned int b);
# 2851 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpgeu4(unsigned int a, unsigned int b);
# 2862 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpgts4(unsigned int a, unsigned int b);
# 2873 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpgtu4(unsigned int a, unsigned int b);
# 2884 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmples4(unsigned int a, unsigned int b);
# 2895 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpleu4(unsigned int a, unsigned int b);
# 2906 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmplts4(unsigned int a, unsigned int b);
# 2917 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpltu4(unsigned int a, unsigned int b);
# 2928 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vcmpne4(unsigned int a, unsigned int b);
# 2939 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vabsdiffu4(unsigned int a, unsigned int b);
# 2950 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vmaxs4(unsigned int a, unsigned int b);
# 2961 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vmaxu4(unsigned int a, unsigned int b);
# 2972 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vmins4(unsigned int a, unsigned int b);
# 2983 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vminu4(unsigned int a, unsigned int b);
# 2994 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vseteq4(unsigned int a, unsigned int b);
# 3005 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetles4(unsigned int a, unsigned int b);
# 3016 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetleu4(unsigned int a, unsigned int b);
# 3027 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetlts4(unsigned int a, unsigned int b);
# 3038 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetltu4(unsigned int a, unsigned int b);
# 3049 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetges4(unsigned int a, unsigned int b);
# 3060 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetgeu4(unsigned int a, unsigned int b);
# 3071 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetgts4(unsigned int a, unsigned int b);
# 3082 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetgtu4(unsigned int a, unsigned int b);
# 3093 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsetne4(unsigned int a, unsigned int b);
# 3104 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsadu4(unsigned int a, unsigned int b);
# 3115 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsub4(unsigned int a, unsigned int b);
# 3126 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsubss4(unsigned int a, unsigned int b);
# 3137 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsubus4(unsigned int a, unsigned int b);
# 3147 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vneg4(unsigned int a);
# 3157 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vnegss4(unsigned int a);
# 3168 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vabsdiffs4(unsigned int a, unsigned int b);
# 3179 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __vsads4(unsigned int a, unsigned int b);






}







static __inline__ __attribute__((device)) int mulhi(int a, int b)
{
  return __mulhi(a, b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(unsigned int a, unsigned int b)
{
  return __umulhi(a, b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(int a, unsigned int b)
{
  return __umulhi((unsigned int)a, b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(unsigned int a, int b)
{
  return __umulhi(a, (unsigned int)b);
}

static __inline__ __attribute__((device)) long long int mul64hi(long long int a, long long int b)
{
  return __mul64hi(a, b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(unsigned long long int a, unsigned long long int b)
{
  return __umul64hi(a, b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(long long int a, unsigned long long int b)
{
  return __umul64hi((unsigned long long int)a, b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(unsigned long long int a, long long int b)
{
  return __umul64hi(a, (unsigned long long int)b);
}

static __inline__ __attribute__((device)) int float_as_int(float a)
{
  return __float_as_int(a);
}

static __inline__ __attribute__((device)) float int_as_float(int a)
{
  return __int_as_float(a);
}

static __inline__ __attribute__((device)) float saturate(float a)
{
  return __saturatef(a);
}

static __inline__ __attribute__((device)) int mul24(int a, int b)
{
  return __mul24(a, b);
}

static __inline__ __attribute__((device)) unsigned int umul24(unsigned int a, unsigned int b)
{
  return __umul24(a, b);
}

static __inline__ __attribute__((device)) void trap(void)
{
  __trap();
}


static __inline__ __attribute__((device)) void brkpt(int c = 0)
{
  __brkpt(c);
}

static __inline__ __attribute__((device)) void syncthreads(void)
{
  __syncthreads();
}

static __inline__ __attribute__((device)) void prof_trigger(int e)
{
       if (e == 0) __prof_trigger( 0);
  else if (e == 1) __prof_trigger( 1);
  else if (e == 2) __prof_trigger( 2);
  else if (e == 3) __prof_trigger( 3);
  else if (e == 4) __prof_trigger( 4);
  else if (e == 5) __prof_trigger( 5);
  else if (e == 6) __prof_trigger( 6);
  else if (e == 7) __prof_trigger( 7);
  else if (e == 8) __prof_trigger( 8);
  else if (e == 9) __prof_trigger( 9);
  else if (e == 10) __prof_trigger(10);
  else if (e == 11) __prof_trigger(11);
  else if (e == 12) __prof_trigger(12);
  else if (e == 13) __prof_trigger(13);
  else if (e == 14) __prof_trigger(14);
  else if (e == 15) __prof_trigger(15);
}

static __inline__ __attribute__((device)) void threadfence(bool global = true)
{
  global ? __threadfence() : __threadfence_block();
}

static __inline__ __attribute__((device)) int float2int(float a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __float2int_rn(a) :
         mode == cudaRoundPosInf ? __float2int_ru(a) :
         mode == cudaRoundMinInf ? __float2int_rd(a) :
                                    __float2int_rz(a);
}

static __inline__ __attribute__((device)) unsigned int float2uint(float a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __float2uint_rn(a) :
         mode == cudaRoundPosInf ? __float2uint_ru(a) :
         mode == cudaRoundMinInf ? __float2uint_rd(a) :
                                    __float2uint_rz(a);
}

static __inline__ __attribute__((device)) float int2float(int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero ? __int2float_rz(a) :
         mode == cudaRoundPosInf ? __int2float_ru(a) :
         mode == cudaRoundMinInf ? __int2float_rd(a) :
                                   __int2float_rn(a);
}

static __inline__ __attribute__((device)) float uint2float(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero ? __uint2float_rz(a) :
         mode == cudaRoundPosInf ? __uint2float_ru(a) :
         mode == cudaRoundMinInf ? __uint2float_rd(a) :
                                   __uint2float_rn(a);
}
# 9405 "/usr/local/cuda-6.5/bin/..//include/device_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_11_atomic_functions.h" 1
# 63 "/usr/local/cuda-6.5/bin/..//include/sm_11_atomic_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 64 "/usr/local/cuda-6.5/bin/..//include/sm_11_atomic_functions.h" 2


extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicAdd(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicAdd(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicExch(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicExch(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) float __fAtomicExch(float *address, float val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicMin(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicMin(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicMax(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicMax(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicInc(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicDec(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicAnd(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicAnd(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicOr(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicOr(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicXor(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicXor(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicCAS(int *address, int compare, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicCAS(unsigned int *address, unsigned int compare, unsigned int val);

}







static __inline__ __attribute__((device)) int atomicAdd(int *address, int val)
{
  return __iAtomicAdd(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicAdd(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, val);
}

static __inline__ __attribute__((device)) int atomicSub(int *address, int val)
{
  return __iAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline__ __attribute__((device)) unsigned int atomicSub(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline__ __attribute__((device)) int atomicExch(int *address, int val)
{
  return __iAtomicExch(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicExch(unsigned int *address, unsigned int val)
{
  return __uAtomicExch(address, val);
}

static __inline__ __attribute__((device)) float atomicExch(float *address, float val)
{
  return __fAtomicExch(address, val);
}

static __inline__ __attribute__((device)) int atomicMin(int *address, int val)
{
  return __iAtomicMin(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicMin(unsigned int *address, unsigned int val)
{
  return __uAtomicMin(address, val);
}

static __inline__ __attribute__((device)) int atomicMax(int *address, int val)
{
  return __iAtomicMax(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicMax(unsigned int *address, unsigned int val)
{
  return __uAtomicMax(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicInc(unsigned int *address, unsigned int val)
{
  return __uAtomicInc(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicDec(unsigned int *address, unsigned int val)
{
  return __uAtomicDec(address, val);
}

static __inline__ __attribute__((device)) int atomicAnd(int *address, int val)
{
  return __iAtomicAnd(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicAnd(unsigned int *address, unsigned int val)
{
  return __uAtomicAnd(address, val);
}

static __inline__ __attribute__((device)) int atomicOr(int *address, int val)
{
  return __iAtomicOr(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicOr(unsigned int *address, unsigned int val)
{
  return __uAtomicOr(address, val);
}

static __inline__ __attribute__((device)) int atomicXor(int *address, int val)
{
  return __iAtomicXor(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicXor(unsigned int *address, unsigned int val)
{
  return __uAtomicXor(address, val);
}

static __inline__ __attribute__((device)) int atomicCAS(int *address, int compare, int val)
{
  return __iAtomicCAS(address, compare, val);
}

static __inline__ __attribute__((device)) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val)
{
  return __uAtomicCAS(address, compare, val);
}
# 9406 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_12_atomic_functions.h" 1
# 63 "/usr/local/cuda-6.5/bin/..//include/sm_12_atomic_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 64 "/usr/local/cuda-6.5/bin/..//include/sm_12_atomic_functions.h" 2


extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __ullAtomicAdd(unsigned long long int *address, unsigned long long int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __ullAtomicExch(unsigned long long int *address, unsigned long long int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __ullAtomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __any(int cond);
extern __attribute__((device)) __attribute__((device_builtin)) int __all(int cond);
}







static __inline__ __attribute__((device)) unsigned long long int atomicAdd(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicAdd(address, val);
}

static __inline__ __attribute__((device)) unsigned long long int atomicExch(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicExch(address, val);
}

static __inline__ __attribute__((device)) unsigned long long int atomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val)
{
  return __ullAtomicCAS(address, compare, val);
}

static __inline__ __attribute__((device)) bool any(bool cond)
{
  return (bool)__any((int)cond);
}

static __inline__ __attribute__((device)) bool all(bool cond)
{
  return (bool)__all((int)cond);
}
# 9407 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h" 1
# 69 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 70 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h" 2



extern "C"
{
# 83 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double_as_longlong(double x);
# 92 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __longlong_as_double(long long int x);
# 249 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rn(double x, double y, double z);
# 406 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rz(double x, double y, double z);
# 563 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_ru(double x, double y, double z);
# 720 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rd(double x, double y, double z);
# 732 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rn(double x, double y);
# 744 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rz(double x, double y);
# 756 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_ru(double x, double y);
# 768 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rd(double x, double y);
# 780 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rn(double x, double y);
# 792 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rz(double x, double y);
# 804 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_ru(double x, double y);
# 816 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rd(double x, double y);
# 828 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rn(double x, double y);
# 840 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rz(double x, double y);
# 852 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_ru(double x, double y);
# 864 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rd(double x, double y);
# 873 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rn(double x);
# 882 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rz(double x);
# 891 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_ru(double x);
# 900 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rd(double x);
# 909 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rn(double x);
# 918 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_ru(double x);
# 927 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rd(double x);
# 936 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rn(double x);
# 945 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_ru(double x);
# 954 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rd(double x);
# 963 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rn(double x);
# 972 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_ru(double x);
# 981 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rd(double x);
# 990 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rn(double x);
# 999 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_ru(double x);
# 1008 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rd(double x);







extern __attribute__((device)) __attribute__((device_builtin)) double __int2double_rn(int x);







extern __attribute__((device)) __attribute__((device_builtin)) double __uint2double_rn(unsigned int x);
# 1033 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rn(long long int x);
# 1042 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rz(long long int x);
# 1051 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_ru(long long int x);
# 1060 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rd(long long int x);
# 1069 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rn(unsigned long long int x);
# 1078 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rz(unsigned long long int x);
# 1087 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_ru(unsigned long long int x);
# 1096 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rd(unsigned long long int x);
# 1105 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2hiint(double x);
# 1114 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2loint(double x);
# 1124 "/usr/local/cuda-6.5/bin/..//include/sm_13_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __hiloint2double(int hi, int lo);
}







static __inline__ __attribute__((device)) double fma(double a, double b, double c, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __fma_rz(a, b, c) :
         mode == cudaRoundPosInf ? __fma_ru(a, b, c) :
         mode == cudaRoundMinInf ? __fma_rd(a, b, c) :
                                   __fma_rn(a, b, c);
}

static __inline__ __attribute__((device)) double dmul(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero ? __dmul_rz(a, b) :
         mode == cudaRoundPosInf ? __dmul_ru(a, b) :
         mode == cudaRoundMinInf ? __dmul_rd(a, b) :
                                   __dmul_rn(a, b);
}

static __inline__ __attribute__((device)) double dadd(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero ? __dadd_rz(a, b) :
         mode == cudaRoundPosInf ? __dadd_ru(a, b) :
         mode == cudaRoundMinInf ? __dadd_rd(a, b) :
                                   __dadd_rn(a, b);
}

static __inline__ __attribute__((device)) double dsub(double a, double b, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero ? __dsub_rz(a, b) :
         mode == cudaRoundPosInf ? __dsub_ru(a, b) :
         mode == cudaRoundMinInf ? __dsub_rd(a, b) :
                                   __dsub_rn(a, b);
}

static __inline__ __attribute__((device)) int double2int(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2int_rn(a) :
         mode == cudaRoundPosInf ? __double2int_ru(a) :
         mode == cudaRoundMinInf ? __double2int_rd(a) :
                                    __double2int_rz(a);
}

static __inline__ __attribute__((device)) unsigned int double2uint(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2uint_rn(a) :
         mode == cudaRoundPosInf ? __double2uint_ru(a) :
         mode == cudaRoundMinInf ? __double2uint_rd(a) :
                                    __double2uint_rz(a);
}

static __inline__ __attribute__((device)) long long int double2ll(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2ll_rn(a) :
         mode == cudaRoundPosInf ? __double2ll_ru(a) :
         mode == cudaRoundMinInf ? __double2ll_rd(a) :
                                    __double2ll_rz(a);
}

static __inline__ __attribute__((device)) unsigned long long int double2ull(double a, enum cudaRoundMode mode = cudaRoundZero)
{
  return mode == cudaRoundNearest ? __double2ull_rn(a) :
         mode == cudaRoundPosInf ? __double2ull_ru(a) :
         mode == cudaRoundMinInf ? __double2ull_rd(a) :
                                    __double2ull_rz(a);
}

static __inline__ __attribute__((device)) double ll2double(long long int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero ? __ll2double_rz(a) :
         mode == cudaRoundPosInf ? __ll2double_ru(a) :
         mode == cudaRoundMinInf ? __ll2double_rd(a) :
                                   __ll2double_rn(a);
}

static __inline__ __attribute__((device)) double ull2double(unsigned long long int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return mode == cudaRoundZero ? __ull2double_rz(a) :
         mode == cudaRoundPosInf ? __ull2double_ru(a) :
         mode == cudaRoundMinInf ? __ull2double_rd(a) :
                                   __ull2double_rn(a);
}

static __inline__ __attribute__((device)) double int2double(int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}

static __inline__ __attribute__((device)) double uint2double(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}

static __inline__ __attribute__((device)) double float2double(float a, enum cudaRoundMode mode = cudaRoundNearest)
{
  return (double)a;
}
# 9408 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_20_atomic_functions.h" 1
# 63 "/usr/local/cuda-6.5/bin/..//include/sm_20_atomic_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 64 "/usr/local/cuda-6.5/bin/..//include/sm_20_atomic_functions.h" 2


extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) float __fAtomicAdd(float *address, float val);
}







static __inline__ __attribute__((device)) float atomicAdd(float *address, float val)
{
  return __fAtomicAdd(address, val);
}
# 9409 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_32_atomic_functions.h" 1
# 63 "/usr/local/cuda-6.5/bin/..//include/sm_32_atomic_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 64 "/usr/local/cuda-6.5/bin/..//include/sm_32_atomic_functions.h" 2


extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) long long __illAtomicMin(long long *address, long long val);
extern __attribute__((device)) __attribute__((device_builtin)) long long __illAtomicMax(long long *address, long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicMin(unsigned long long *address, unsigned long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicMax(unsigned long long *address, unsigned long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicAnd(unsigned long long *address, unsigned long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicOr (unsigned long long *address, unsigned long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicXor(unsigned long long *address, unsigned long long val);
}







static __inline__ __attribute__((device)) long long atomicMin(long long *address, long long val)
{
    return __illAtomicMin(address, val);
}

static __inline__ __attribute__((device)) long long atomicMax(long long *address, long long val)
{
    return __illAtomicMax(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicMin(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicMin(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicMax(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicMax(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicAnd(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicAnd(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicOr(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicOr(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicXor(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicXor(address, val);
}
# 9410 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_35_atomic_functions.h" 1
# 9411 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h" 1
# 63 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 64 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h" 2



extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) void __threadfence_system(void);
# 81 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rn(double x, double y);
# 93 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rz(double x, double y);
# 105 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_ru(double x, double y);
# 117 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rd(double x, double y);
# 151 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rn(double x);
# 185 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rz(double x);
# 219 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_ru(double x);
# 253 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rd(double x);
# 285 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rn(double x);
# 317 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rz(double x);
# 349 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_ru(double x);
# 381 "/usr/local/cuda-6.5/bin/..//include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rd(double x);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __ballot(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_count(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_and(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_or(int);
extern __attribute__((device)) __attribute__((device_builtin)) long long int clock64(void);






extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rn(float, float, float);
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rz(float, float, float);
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_ru(float, float, float);
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rd(float, float, float);
extern __attribute__((device)) __attribute__((device_builtin)) double __rcp64h(double);

}







static __inline__ __attribute__((device)) unsigned int ballot(bool pred)
{
  return __ballot((int)pred);
}

static __inline__ __attribute__((device)) int syncthreads_count(bool pred)
{
  return __syncthreads_count((int)pred);
}

static __inline__ __attribute__((device)) bool syncthreads_and(bool pred)
{
  return (bool)__syncthreads_and((int)pred);
}

static __inline__ __attribute__((device)) bool syncthreads_or(bool pred)
{
  return (bool)__syncthreads_or((int)pred);
}




static __inline__ __attribute__((device)) unsigned int __isGlobal(const void *ptr)
{
    unsigned int ret;
    asm volatile ("{ \n\t"
                  "    .reg .pred p; \n\t"
                  "    isspacep.global p, %1; \n\t"
                  "    selp.u32 %0, 1, 0, p;  \n\t"

                  "} \n\t" : "=r"(ret) : "l"(ptr));




    return ret;
}
# 9412 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_30_intrinsics.h" 1
# 63 "/usr/local/cuda-6.5/bin/..//include/sm_30_intrinsics.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 64 "/usr/local/cuda-6.5/bin/..//include/sm_30_intrinsics.h" 2





extern "C"
{


}
# 93 "/usr/local/cuda-6.5/bin/..//include/sm_30_intrinsics.h"
static __attribute__((device)) __inline__ int __shfl(int var, int srcLane, int width=32) {
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.idx.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(srcLane), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl(unsigned int var, int srcLane, int width=32) {
 return (unsigned int) __shfl((int)var, srcLane, width);
}

static __attribute__((device)) __inline__ int __shfl_up(int var, unsigned int delta, int width=32) {
 int ret;
 int c = (32 -width) << 8;
 asm volatile ("shfl.up.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(delta), "r"(c));
 return ret;
}
static __attribute__((device)) __inline__ unsigned int __shfl_up(unsigned int var, unsigned int delta, int width=32) {
 return (unsigned int) __shfl_up((int)var, delta, width);
}

static __attribute__((device)) __inline__ int __shfl_down(int var, unsigned int delta, int width=32) {
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.down.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(delta), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_down(unsigned int var, unsigned int delta, int width=32) {
 return (unsigned int) __shfl_down((int)var, delta, width);
}

static __attribute__((device)) __inline__ int __shfl_xor(int var, int laneMask, int width=32) {
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.bfly.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(laneMask), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_xor(unsigned int var, int laneMask, int width=32) {
 return (unsigned int) __shfl_xor((int)var, laneMask, width);
}

static __attribute__((device)) __inline__ float __shfl(float var, int srcLane, int width=32) {
 float ret;
    int c;
 c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.idx.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(srcLane), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ float __shfl_up(float var, unsigned int delta, int width=32) {
 float ret;
    int c;
 c = (32 -width) << 8;
 asm volatile ("shfl.up.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(delta), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ float __shfl_down(float var, unsigned int delta, int width=32) {
 float ret;
    int c;
 c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.down.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(delta), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ float __shfl_xor(float var, int laneMask, int width=32) {
 float ret;
    int c;
 c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.bfly.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(laneMask), "r"(c));
 return ret;
}


static __attribute__((device)) __inline__ long long __shfl(long long var, int srcLane, int width=32) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl(hi, srcLane, width);
 lo = __shfl(lo, srcLane, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl(unsigned long long var, int srcLane, int width=32) {
 return (unsigned long long) __shfl((long long) var, srcLane, width);
}

static __attribute__((device)) __inline__ long long __shfl_up(long long var, unsigned int delta, int width=32) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_up(hi, delta, width);
 lo = __shfl_up(lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_up(unsigned long long var, unsigned int delta, int width=32) {
 return (unsigned long long) __shfl_up((long long) var, delta, width);
}

static __attribute__((device)) __inline__ long long __shfl_down(long long var, unsigned int delta, int width=32) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_down(hi, delta, width);
 lo = __shfl_down(lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_down(unsigned long long var, unsigned int delta, int width=32) {
 return (unsigned long long) __shfl_down((long long) var, delta, width);
}

static __attribute__((device)) __inline__ long long __shfl_xor(long long var, int laneMask, int width=32) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_xor(hi, laneMask, width);
 lo = __shfl_xor(lo, laneMask, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width=32) {
 return (unsigned long long) __shfl_xor((long long) var, laneMask, width);
}

static __attribute__((device)) __inline__ double __shfl(double var, int srcLane, int width=32) {
 float lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=f"(lo), "=f"(hi) : "d"(var));
 hi = __shfl(hi, srcLane, width);
 lo = __shfl(lo, srcLane, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "f"(lo), "f"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_up(double var, unsigned int delta, int width=32) {
 float lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=f"(lo), "=f"(hi) : "d"(var));
 hi = __shfl_up(hi, delta, width);
 lo = __shfl_up(lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "f"(lo), "f"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_down(double var, unsigned int delta, int width=32) {
 float lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=f"(lo), "=f"(hi) : "d"(var));
 hi = __shfl_down(hi, delta, width);
 lo = __shfl_down(lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "f"(lo), "f"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_xor(double var, int laneMask, int width=32) {
 float lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=f"(lo), "=f"(hi) : "d"(var));
 hi = __shfl_xor(hi, laneMask, width);
 lo = __shfl_xor(lo, laneMask, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "f"(lo), "f"(hi));
 return var;
}



static __attribute__((device)) __inline__ long __shfl(long var, int srcLane, int width=32) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl((long long) var, srcLane, width) :
  __shfl((int) var, srcLane, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl(unsigned long var, int srcLane, int width=32) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl((unsigned long long) var, srcLane, width) :
  __shfl((unsigned int) var, srcLane, width);
}

static __attribute__((device)) __inline__ long __shfl_up(long var, unsigned int delta, int width=32) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_up((long long) var, delta, width) :
  __shfl_up((int) var, delta, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_up(unsigned long var, unsigned int delta, int width=32) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_up((unsigned long long) var, delta, width) :
  __shfl_up((unsigned int) var, delta, width);
}

static __attribute__((device)) __inline__ long __shfl_down(long var, unsigned int delta, int width=32) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_down((long long) var, delta, width) :
  __shfl_down((int) var, delta, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_down(unsigned long var, unsigned int delta, int width=32) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_down((unsigned long long) var, delta, width) :
  __shfl_down((unsigned int) var, delta, width);
}

static __attribute__((device)) __inline__ long __shfl_xor(long var, int laneMask, int width=32) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_xor((long long) var, laneMask, width) :
  __shfl_xor((int) var, laneMask, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_xor(unsigned long var, int laneMask, int width=32) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_xor((unsigned long long) var, laneMask, width) :
  __shfl_xor((unsigned int) var, laneMask, width);
}
# 9413 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_32_intrinsics.h" 1
# 63 "/usr/local/cuda-6.5/bin/..//include/sm_32_intrinsics.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 64 "/usr/local/cuda-6.5/bin/..//include/sm_32_intrinsics.h" 2





extern "C"
{


}
# 93 "/usr/local/cuda-6.5/bin/..//include/sm_32_intrinsics.h"
static __attribute__((device)) __inline__ long __ldg(const long *ptr) { unsigned long ret; asm volatile ("ld.global.nc.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long)ret; }
static __attribute__((device)) __inline__ unsigned long __ldg(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.nc.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }






static __attribute__((device)) __inline__ char __ldg(const char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __attribute__((device)) __inline__ short __ldg(const short *ptr) { unsigned short ret; asm volatile ("ld.global.nc.s16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __attribute__((device)) __inline__ int __ldg(const int *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __attribute__((device)) __inline__ long long __ldg(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.nc.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __attribute__((device)) __inline__ char2 __ldg(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.nc.v2.s8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __attribute__((device)) __inline__ char4 __ldg(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __attribute__((device)) __inline__ short2 __ldg(const short2 *ptr) { short2 ret; asm volatile ("ld.global.nc.v2.s16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ short4 __ldg(const short4 *ptr) { short4 ret; asm volatile ("ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int2 __ldg(const int2 *ptr) { int2 ret; asm volatile ("ld.global.nc.v2.s32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int4 __ldg(const int4 *ptr) { int4 ret; asm volatile ("ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ longlong2 __ldg(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.nc.v2.s64 %0, [%1];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ unsigned char __ldg(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.u8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (unsigned char)ret; }
static __attribute__((device)) __inline__ unsigned short __ldg(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.nc.u16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned int __ldg(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.nc.u32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned long long __ldg(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.nc.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uchar2 __ldg(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.nc.v2.u8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __attribute__((device)) __inline__ uchar4 __ldg(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __attribute__((device)) __inline__ ushort2 __ldg(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.nc.v2.u16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ushort4 __ldg(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint2 __ldg(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.nc.v2.u32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint4 __ldg(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ulonglong2 __ldg(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.nc.v2.u64 %0, [%1];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ float __ldg(const float *ptr) { float ret; asm volatile ("ld.global.nc.f32 %0, [%1];" : "=f"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double __ldg(const double *ptr) { double ret; asm volatile ("ld.global.nc.f64 %0, [%1];" : "=d"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float2 __ldg(const float2 *ptr) { float2 ret; asm volatile ("ld.global.nc.v2.f32 {%0,%1}, [%2];" : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float4 __ldg(const float4 *ptr) { float4 ret; asm volatile ("ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double2 __ldg(const double2 *ptr) { double2 ret; asm volatile ("ld.global.nc.v2.f64 {%0,%1}, [%2];" : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }
# 138 "/usr/local/cuda-6.5/bin/..//include/sm_32_intrinsics.h"
static __attribute__((device)) inline unsigned int __funnelshift_l(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
static __attribute__((device)) inline unsigned int __funnelshift_lc(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.l.clamp.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}


static __attribute__((device)) inline unsigned int __funnelshift_r(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.r.wrap.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
static __attribute__((device)) inline unsigned int __funnelshift_rc(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.r.clamp.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
# 9414 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/sm_35_intrinsics.h" 1
# 9415 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h" 1
# 61 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 62 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h" 2
# 73 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) uchar1 __surf1Dreadc1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar2 __surf1Dreadc2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar4 __surf1Dreadc4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort1 __surf1Dreads1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort2 __surf1Dreads2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort4 __surf1Dreads4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint1 __surf1Dreadu1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint2 __surf1Dreadu2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint4 __surf1Dreadu4(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong1 __surf1Dreadl1(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong2 __surf1Dreadl2(surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
# 99 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(T *res, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s == 1) ? (void)(*(uchar1 *)res = __surf1Dreadc1(surf, x, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(*(ushort1*)res = __surf1Dreads1(surf, x, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(*(uint1 *)res = __surf1Dreadu1(surf, x, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(*(uint2 *)res = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4 *)res = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;

  surf1Dread(&tmp, surf, x, (int)sizeof(T), mode);

  return tmp;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(T *res, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf1Dread<T>(surf, x, mode);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) signed char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf1Dreadc1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf1Dreadc2(surf, x, cudaBoundaryModeTrap);

  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc2(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf1Dreadc4(surf, x, cudaBoundaryModeTrap);

  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadc4(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf1Dreads1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads1(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf1Dreads2(surf, x, cudaBoundaryModeTrap);

  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads2(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf1Dreads4(surf, x, cudaBoundaryModeTrap);

  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreads4(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);

  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);

  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) long long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned long long int surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf1Dreadl1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf1Dreadl2(surf, x, cudaBoundaryModeTrap);

  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1Dreadl2(surf, x, cudaBoundaryModeTrap);
}
# 386 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float1 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf1Dreadu1(surf, x, cudaBoundaryModeTrap).x));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float2 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap);

  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float4 surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap);

  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}
# 421 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) uchar1 __surf2Dreadc1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar2 __surf2Dreadc2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar4 __surf2Dreadc4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort1 __surf2Dreads1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort2 __surf2Dreads2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort4 __surf2Dreads4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint1 __surf2Dreadu1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint2 __surf2Dreadu2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint4 __surf2Dreadu4(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong1 __surf2Dreadl1(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong2 __surf2Dreadl2(surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
# 447 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s == 1) ? (void)(*(uchar1 *)res = __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(*(ushort1*)res = __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(*(uint1 *)res = __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(*(uint2 *)res = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4 *)res = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;

  surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode);

  return tmp;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf2Dread<T>(surf, x, y, mode);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) signed char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap);

  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap);

  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap);

  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap);

  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);

  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);

  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) long long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned long long int surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap);

  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap);
}
# 734 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float1 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap).x));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float2 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap);

  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float4 surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap);

  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}
# 769 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) uchar1 __surf3Dreadc1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar2 __surf3Dreadc2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar4 __surf3Dreadc4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort1 __surf3Dreads1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort2 __surf3Dreads2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort4 __surf3Dreads4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint1 __surf3Dreadu1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint2 __surf3Dreadu2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint4 __surf3Dreadu4(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong1 __surf3Dreadl1(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong2 __surf3Dreadl2(surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
# 795 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s == 1) ? (void)(*(uchar1 *)res = __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(*(ushort1*)res = __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(*(uint1 *)res = __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(*(uint2 *)res = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4 *)res = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;

  surf3Dread(&tmp, surf, x, y, z, (int)sizeof(T), mode);

  return tmp;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf3Dread<T>(surf, x, y, z, mode);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) signed char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap);

  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap);

  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap);

  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap);

  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap);

  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap);

  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) long long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned long long int surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap);

  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap);
}
# 1082 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float1 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap).x));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float2 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap);

  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float4 surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap);

  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}
# 1117 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) uchar1 __surf1DLayeredreadc1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar2 __surf1DLayeredreadc2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar4 __surf1DLayeredreadc4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort1 __surf1DLayeredreads1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort2 __surf1DLayeredreads2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort4 __surf1DLayeredreads4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint1 __surf1DLayeredreadu1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint2 __surf1DLayeredreadu2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint4 __surf1DLayeredreadu4(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong1 __surf1DLayeredreadl1(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong2 __surf1DLayeredreadl2(surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
# 1143 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s == 1) ? (void)(*(uchar1 *)res = __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(*(ushort1*)res = __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(*(uint1 *)res = __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(*(uint2 *)res = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4 *)res = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;

  surf1DLayeredread(&tmp, surf, x, layer, (int)sizeof(T), mode);

  return tmp;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf1DLayeredread<T>(surf, x, layer, mode);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) signed char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap);

  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap);

  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap);

  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap);

  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap);

  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap);

  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) long long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned long long int surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap);

  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap);
}
# 1430 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float1 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap).x));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float2 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap);

  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float4 surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap);

  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}
# 1465 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) uchar1 __surf2DLayeredreadc1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar2 __surf2DLayeredreadc2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar4 __surf2DLayeredreadc4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort1 __surf2DLayeredreads1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort2 __surf2DLayeredreads2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort4 __surf2DLayeredreads4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint1 __surf2DLayeredreadu1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint2 __surf2DLayeredreadu2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint4 __surf2DLayeredreadu4(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong1 __surf2DLayeredreadl1(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong2 __surf2DLayeredreadl2(surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
# 1491 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s == 1) ? (void)(*(uchar1 *)res = __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(*(ushort1*)res = __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(*(uint1 *)res = __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(*(uint2 *)res = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4 *)res = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;

  surf2DLayeredread(&tmp, surf, x, y, layer, (int)sizeof(T), mode);

  return tmp;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surf2DLayeredread<T>(surf, x, y, layer, mode);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) signed char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) long long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned long long int surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap);
}
# 1778 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float1 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap).x));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float2 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float4 surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap);

  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}
# 1813 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) uchar1 __surfCubemapreadc1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar2 __surfCubemapreadc2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar4 __surfCubemapreadc4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort1 __surfCubemapreads1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort2 __surfCubemapreads2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort4 __surfCubemapreads4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint1 __surfCubemapreadu1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint2 __surfCubemapreadu2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint4 __surfCubemapreadu4(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong1 __surfCubemapreadl1(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong2 __surfCubemapreadl2(surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
# 1839 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s == 1) ? (void)(*(uchar1 *)res = __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(*(ushort1*)res = __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(*(uint1 *)res = __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(*(uint2 *)res = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4 *)res = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;

  surfCubemapread(&tmp, surf, x, y, face, (int)sizeof(T), mode);

  return tmp;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surfCubemapread<T>(surf, x, y, face, mode);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) signed char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadc1(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap);

  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadc2(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap);

  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadc4(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreads1(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap);

  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreads2(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap);

  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreads4(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap);

  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap);

  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) long long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned long long int surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadl1(surf, x, y, face, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap);

  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapreadl2(surf, x, y, face, cudaBoundaryModeTrap);
}
# 2126 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float1 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surfCubemapreadu1(surf, x, y, face, cudaBoundaryModeTrap).x));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float2 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapreadu2(surf, x, y, face, cudaBoundaryModeTrap);

  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float4 surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapreadu4(surf, x, y, face, cudaBoundaryModeTrap);

  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}
# 2161 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) uchar1 __surfCubemapLayeredreadc1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar2 __surfCubemapLayeredreadc2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uchar4 __surfCubemapLayeredreadc4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort1 __surfCubemapLayeredreads1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort2 __surfCubemapLayeredreads2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ushort4 __surfCubemapLayeredreads4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint1 __surfCubemapLayeredreadu1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint2 __surfCubemapLayeredreadu2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) uint4 __surfCubemapLayeredreadu4(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong1 __surfCubemapLayeredreadl1(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) ulonglong2 __surfCubemapLayeredreadl2(surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
# 2188 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  (s == 1) ? (void)(*(uchar1 *)res = __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(*(ushort1*)res = __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(*(uint1 *)res = __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(*(uint2 *)res = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(*(uint4 *)res = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  T tmp;

  surfCubemapLayeredread(&tmp, surf, x, y, layerFace, (int)sizeof(T), mode);

  return tmp;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  *res = surfCubemapLayeredread<T>(surf, x, y, layerFace, mode);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (char)__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) signed char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (signed char)__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_char1((signed char)__surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uchar2 tmp = __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_char2((signed char)tmp.x, (signed char)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) char4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uchar4 tmp = __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_char4((signed char)tmp.x, (signed char)tmp.y, (signed char)tmp.z, (signed char)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (short)__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_short1((signed short)__surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ushort2 tmp = __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_short2((signed short)tmp.x, (signed short)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) short4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ushort4 tmp = __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_short4((signed short)tmp.x, (signed short)tmp.y, (signed short)tmp.z, (signed short)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_int1((signed int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_int2((int)tmp.x, (int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) int4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_int4((int)tmp.x, (int)tmp.y, (int)tmp.z, (int)tmp.w);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) uint4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) long long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return (long long int)__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) unsigned long long int surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x;
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_longlong1((long long int)__surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) longlong2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  ulonglong2 tmp = __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_longlong2((long long int)tmp.x, (long long int)tmp.y);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) ulonglong2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __surfCubemapLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap);
}
# 2475 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return __int_as_float((int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x);
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float1 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  return make_float1(__int_as_float((int)__surfCubemapLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap).x));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float2 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint2 tmp = __surfCubemapLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_float2(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y));
}

template<>
__inline__ __attribute__((always_inline)) __attribute__((device)) float4 surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode)
{
  uint4 tmp = __surfCubemapLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap);

  return make_float4(__int_as_float((int)tmp.x), __int_as_float((int)tmp.y), __int_as_float((int)tmp.z), __int_as_float((int)tmp.w));
}
# 2511 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwritec1( uchar1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwritec2( uchar2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwritec4( uchar4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwrites1( ushort1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwrites2( ushort2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwrites4( ushort4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwriteu1( uint1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwriteu2( uint2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwriteu4( uint4 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwritel1(ulonglong1 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1Dwritel2(ulonglong2 val, surface<void, 0x01> t, int x, enum cudaSurfaceBoundaryMode mode);
# 2537 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T val;
    uchar1 c1;
    ushort1 s1;
    uint1 u1;
    uint2 u2;
    uint4 u4;
  } tmp;

  tmp.val = val;

  (s == 1) ? (void)(__surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(__surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(__surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(__surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf1Dwrite(val, surf, x, (int)sizeof(T), mode);
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(signed char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(unsigned char val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(char1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(make_uchar1((unsigned char)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uchar1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(char2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uchar2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(char4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uchar4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(short val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(unsigned short val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(short1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(make_ushort1((unsigned short)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ushort1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(short2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ushort2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(short4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ushort4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(unsigned int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(int1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uint1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(int2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uint2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(int4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uint4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(long long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(unsigned long long int val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(longlong1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ulonglong1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(longlong2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ulonglong2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap);
}
# 2765 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(float val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(float1 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(float2 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(float4 val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap);
}
# 2793 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwritec1( uchar1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwritec2( uchar2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwritec4( uchar4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwrites1( ushort1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwrites2( ushort2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwrites4( ushort4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwriteu1( uint1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwriteu2( uint2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwriteu4( uint4 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwritel1(ulonglong1 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2Dwritel2(ulonglong2 val, surface<void, 0x02> t, int x, int y, enum cudaSurfaceBoundaryMode mode);
# 2819 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T val;
    uchar1 c1;
    ushort1 s1;
    uint1 u1;
    uint2 u2;
    uint4 u4;
  } tmp;

  tmp.val = val;

  (s == 1) ? (void)(__surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(__surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(__surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(__surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode);
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(signed char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(unsigned char val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(char1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uchar1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(char2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uchar2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(char4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uchar4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(short val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(unsigned short val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(short1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ushort1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(short2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ushort2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(short4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ushort4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(unsigned int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(int1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uint1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(int2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uint2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(int4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uint4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(long long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(unsigned long long int val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(longlong1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ulonglong1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(longlong2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ulonglong2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap);
}
# 3047 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(float val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(float1 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(float2 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(float4 val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap);
}
# 3075 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwritec1( uchar1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwritec2( uchar2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwritec4( uchar4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwrites1( ushort1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwrites2( ushort2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwrites4( ushort4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwriteu1( uint1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwriteu2( uint2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwriteu4( uint4 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwritel1(ulonglong1 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf3Dwritel2(ulonglong2 val, surface<void, 0x03> t, int x, int y, int z, enum cudaSurfaceBoundaryMode mode);
# 3101 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T val;
    uchar1 c1;
    ushort1 s1;
    uint1 u1;
    uint2 u2;
    uint4 u4;
  } tmp;

  tmp.val = val;

  (s == 1) ? (void)(__surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(__surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(__surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(__surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf3Dwrite(val, surf, x, y, z, (int)sizeof(T), mode);
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(signed char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(unsigned char val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(char1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(make_uchar1((unsigned char)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uchar1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(char2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uchar2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(char4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uchar4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(short val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(unsigned short val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(short1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites1(make_ushort1((unsigned short)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ushort1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(short2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ushort2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(short4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ushort4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(unsigned int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(int1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uint1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(int2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uint2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(int4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uint4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(long long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(unsigned long long int val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(longlong1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ulonglong1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(longlong2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ulonglong2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeTrap);
}
# 3329 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(float val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(float1 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(float2 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, z, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(float4 val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf3Dwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeTrap);
}
# 3357 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwritec1( uchar1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwritec2( uchar2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwritec4( uchar4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwrites1( ushort1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwrites2( ushort2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwrites4( ushort4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwriteu1( uint1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwriteu2( uint2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwriteu4( uint4 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwritel1(ulonglong1 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf1DLayeredwritel2(ulonglong2 val, surface<void, 0xF1> t, int x, int layer, enum cudaSurfaceBoundaryMode mode);
# 3383 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T val;
    uchar1 c1;
    ushort1 s1;
    uint1 u1;
    uint2 u2;
    uint4 u4;
  } tmp;

  tmp.val = val;

  (s == 1) ? (void)(__surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(__surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(__surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(__surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf1DLayeredwrite(val, surf, x, layer, (int)sizeof(T), mode);
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(signed char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(unsigned char val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(char1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uchar1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(char2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uchar2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(char4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uchar4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(short val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(unsigned short val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(short1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ushort1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(short2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ushort2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(short4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ushort4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(unsigned int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(int1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uint1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(int2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uint2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(int4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uint4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(long long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(unsigned long long int val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(longlong1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ulonglong1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(longlong2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ulonglong2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeTrap);
}
# 3611 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(float val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(float1 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(float2 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(float4 val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf1DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeTrap);
}
# 3639 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwritec1( uchar1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwritec2( uchar2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwritec4( uchar4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwrites1( ushort1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwrites2( ushort2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwrites4( ushort4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwriteu1( uint1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwriteu2( uint2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwriteu4( uint4 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwritel1(ulonglong1 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surf2DLayeredwritel2(ulonglong2 val, surface<void, 0xF2> t, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode);
# 3665 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T val;
    uchar1 c1;
    ushort1 s1;
    uint1 u1;
    uint2 u2;
    uint4 u4;
  } tmp;

  tmp.val = val;

  (s == 1) ? (void)(__surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(__surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surf2DLayeredwrite(val, surf, x, y, layer, (int)sizeof(T), mode);
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(signed char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(unsigned char val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(char1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uchar1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(char2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uchar2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(char4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uchar4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(short val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(unsigned short val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(short1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ushort1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(short2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ushort2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(short4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ushort4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(unsigned int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(int1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uint1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(int2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uint2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(int4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uint4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(long long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(unsigned long long int val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(longlong1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ulonglong1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(longlong2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ulonglong2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeTrap);
}
# 3893 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(float val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(float1 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(float2 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layer, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(float4 val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surf2DLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeTrap);
}
# 3920 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwritec1( uchar1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwritec2( uchar2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwritec4( uchar4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwrites1( ushort1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwrites2( ushort2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwrites4( ushort4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwriteu1( uint1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwriteu2( uint2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwriteu4( uint4 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwritel1(ulonglong1 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapwritel2(ulonglong2 val, surface<void, 0x0C> t, int x, int y, int face, enum cudaSurfaceBoundaryMode mode);
# 3947 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T val;
    uchar1 c1;
    ushort1 s1;
    uint1 u1;
    uint2 u2;
    uint4 u4;
  } tmp;

  tmp.val = val;

  (s == 1) ? (void)(__surfCubemapwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(__surfCubemapwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(__surfCubemapwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(__surfCubemapwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surfCubemapwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surfCubemapwrite(val, surf, x, y, face, (int)sizeof(T), mode);
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(signed char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(unsigned char val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(char1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(make_uchar1((unsigned char)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uchar1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec1(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(char2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uchar2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec2(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(char4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uchar4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritec4(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(short val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(unsigned short val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(short1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites1(make_ushort1((unsigned short)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ushort1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites1(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(short2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ushort2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites2(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(short4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ushort4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwrites4(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(unsigned int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(int1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uint1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(int2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uint2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu2(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(int4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uint4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu4(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(long long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(unsigned long long int val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(longlong1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ulonglong1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel1(val, surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(longlong2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ulonglong2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwritel2(val, surf, x, y, face, cudaBoundaryModeTrap);
}
# 4175 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(float val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(float1 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(float2 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, face, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(float4 val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeTrap);
}
# 4202 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwritec1( uchar1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwritec2( uchar2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwritec4( uchar4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwrites1( ushort1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwrites2( ushort2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwrites4( ushort4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwriteu1( uint1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwriteu2( uint2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwriteu4( uint4 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwritel1(ulonglong1 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
extern __attribute__((device)) __attribute__((device_builtin)) void __surfCubemapLayeredwritel2(ulonglong2 val, surface<void, 0xFC> t, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode);
# 4229 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  union {
    T val;
    uchar1 c1;
    ushort1 s1;
    uint1 u1;
    uint2 u2;
    uint4 u4;
  } tmp;

  tmp.val = val;

  (s == 1) ? (void)(__surfCubemapLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 2) ? (void)(__surfCubemapLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 4) ? (void)(__surfCubemapLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 8) ? (void)(__surfCubemapLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
  (s == 16) ? (void)(__surfCubemapLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeTrap)) :
              (void)0;
}

template<class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{;
  surfCubemapLayeredwrite(val, surf, x, y, layerFace, (int)sizeof(T), mode);
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(signed char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(unsigned char val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(char1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(make_uchar1((unsigned char)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uchar1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(char2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec2(make_uchar2((unsigned char)val.x, (unsigned char)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uchar2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(char4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec4(make_uchar4((unsigned char)val.x, (unsigned char)val.y, (unsigned char)val.z, (unsigned char)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uchar4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(short val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(unsigned short val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(short1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites1(make_ushort1((unsigned short)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ushort1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(short2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites2(make_ushort2((unsigned short)val.x, (unsigned short)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ushort2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(short4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites4(make_ushort4((unsigned short)val.x, (unsigned short)val.y, (unsigned short)val.z, (unsigned short)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ushort4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(unsigned int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(int1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uint1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(int2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu2(make_uint2((unsigned int)val.x, (unsigned int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uint2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(int4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu4(make_uint4((unsigned int)val.x, (unsigned int)val.y, (unsigned int)val.z, (unsigned int)val.w), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uint4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(long long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(unsigned long long int val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(longlong1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel1(make_ulonglong1((unsigned long long int)val.x), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ulonglong1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(longlong2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel2(make_ulonglong2((unsigned long long int)val.x, (unsigned long long int)val.y), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ulonglong2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeTrap);
}
# 4457 "/usr/local/cuda-6.5/bin/..//include/surface_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(float val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(float1 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu1(make_uint1((unsigned int)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(float2 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu2(make_uint2((unsigned int)__float_as_int(val.x), __float_as_int((unsigned int)val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(float4 val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{
  __surfCubemapLayeredwriteu4(make_uint4((unsigned int)__float_as_int(val.x), (unsigned int)__float_as_int(val.y), (unsigned int)__float_as_int(val.z), (unsigned int)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap);
}
# 9416 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h" 1
# 61 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 62 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h" 2
# 74 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
template<class T, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchi(texture<T, 0x01, readMode> t, int4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetch(texture<T, texType, readMode> t, float4 i, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchc(texture<T, texType, readMode> t, float4 i);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchl(texture<T, texType, readMode> t, float4 i, int l, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchlc(texture<T, texType, readMode> t, float4 i, int l);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchlc(texture<T, texType, readMode> t, float4 i, int l);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchlc(texture<T, texType, readMode> t, float4 i, int l);







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex1Dfetch(texture<char, 0x01, cudaReadModeElementType> t, int x)
{



  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex1Dfetch(texture<signed char, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex1Dfetch(texture<unsigned char, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex1Dfetch(texture<char1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex1Dfetch(texture<uchar1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex1Dfetch(texture<char2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex1Dfetch(texture<uchar2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex1Dfetch(texture<char4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex1Dfetch(texture<uchar4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex1Dfetch(texture<short, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex1Dfetch(texture<unsigned short, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex1Dfetch(texture<short1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex1Dfetch(texture<ushort1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex1Dfetch(texture<short2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex1Dfetch(texture<ushort2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex1Dfetch(texture<short4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex1Dfetch(texture<ushort4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex1Dfetch(texture<int, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex1Dfetch(texture<unsigned int, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex1Dfetch(texture<int1, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex1Dfetch(texture<uint1, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex1Dfetch(texture<int2, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex1Dfetch(texture<uint2, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex1Dfetch(texture<int4, 0x01, cudaReadModeElementType> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex1Dfetch(texture<uint4, 0x01, cudaReadModeElementType> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 359 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1Dfetch(texture<float, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1Dfetch(texture<float1, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1Dfetch(texture<float2, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1Dfetch(texture<float4, 0x01, cudaReadModeElementType> t, int x)
{
  float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1Dfetch(texture<char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{



  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1Dfetch(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1Dfetch(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1Dfetch(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1Dfetch(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1Dfetch(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1Dfetch(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1Dfetch(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1Dfetch(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1Dfetch(texture<short, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1Dfetch(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1Dfetch(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1Dfetch(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1Dfetch(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1Dfetch(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1Dfetch(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1Dfetch(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, int x)
{
  uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex1D(texture<char, 0x01, cudaReadModeElementType> t, float x)
{



  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex1D(texture<signed char, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex1D(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex1D(texture<char1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex1D(texture<uchar1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex1D(texture<char2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex1D(texture<uchar2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex1D(texture<char4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex1D(texture<uchar4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex1D(texture<short, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex1D(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex1D(texture<short1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex1D(texture<ushort1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex1D(texture<short2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex1D(texture<ushort2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex1D(texture<short4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex1D(texture<ushort4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex1D(texture<int, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex1D(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex1D(texture<int1, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex1D(texture<uint1, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex1D(texture<int2, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex1D(texture<uint2, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex1D(texture<int4, 0x01, cudaReadModeElementType> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex1D(texture<uint4, 0x01, cudaReadModeElementType> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 814 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1D(texture<float, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1D(texture<float1, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1D(texture<float2, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1D(texture<float4, 0x01, cudaReadModeElementType> t, float x)
{
  float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1D(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{



  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1D(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1D(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1D(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1D(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1D(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1D(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1D(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1D(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1D(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1D(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1D(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1D(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1D(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1D(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1D(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  int4 v = __itexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1D(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x)
{
  uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex2D(texture<char, 0x02, cudaReadModeElementType> t, float x, float y)
{



  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex2D(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex2D(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex2D(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex2D(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex2D(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex2D(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2D(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2D(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex2D(texture<short, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex2D(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex2D(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex2D(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex2D(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex2D(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2D(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2D(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex2D(texture<int, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex2D(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex2D(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex2D(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex2D(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex2D(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2D(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2D(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 1263 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2D(texture<float, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2D(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2D(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2D(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y)
{
  float4 v = __ftexfetch(t, make_float4(x, y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2D(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{



  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2D(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2D(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2D(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2D(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2D(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2D(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2D(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2D(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2D(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2D(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2D(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2D(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2D(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2D(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2D(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  int4 v = __itexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2D(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{
  uint4 v = __utexfetch(t, make_float4(x, y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex1DLayered(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{



  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex1DLayered(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex1DLayered(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex1DLayered(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex1DLayered(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex1DLayered(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex1DLayered(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex1DLayered(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex1DLayered(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex1DLayered(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex1DLayered(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex1DLayered(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex1DLayered(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex1DLayered(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex1DLayered(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex1DLayered(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex1DLayered(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex1DLayered(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex1DLayered(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex1DLayered(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex1DLayered(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex1DLayered(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex1DLayered(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex1DLayered(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex1DLayered(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 1712 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayered(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayered(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayered(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayered(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayered(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{



  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayered(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayered(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayered(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayered(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayered(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayered(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayered(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayered(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayered(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayered(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayered(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayered(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayered(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayered(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayered(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayered(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex2DLayered(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{



  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex2DLayered(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex2DLayered(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex2DLayered(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex2DLayered(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex2DLayered(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex2DLayered(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2DLayered(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2DLayered(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex2DLayered(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex2DLayered(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex2DLayered(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex2DLayered(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex2DLayered(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex2DLayered(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2DLayered(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2DLayered(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex2DLayered(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex2DLayered(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex2DLayered(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex2DLayered(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex2DLayered(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex2DLayered(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2DLayered(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2DLayered(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 2161 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayered(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayered(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayered(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayered(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{
  float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayered(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{



  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayered(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayered(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayered(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayered(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayered(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayered(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayered(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayered(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayered(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayered(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayered(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayered(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayered(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayered(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayered(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayered(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{
  uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex3D(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{



  int4 v = __itexfetch(t, make_float4(x, y, z, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex3D(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex3D(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex3D(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex3D(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex3D(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex3D(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex3D(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex3D(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex3D(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex3D(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex3D(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex3D(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex3D(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex3D(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex3D(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex3D(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex3D(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex3D(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex3D(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex3D(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex3D(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex3D(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex3D(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex3D(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 2610 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3D(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3D(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3D(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3D(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetch(t, make_float4(x, y, z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3D(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{



  int4 v = __itexfetch(t, make_float4(x, y, z, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3D(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3D(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3D(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3D(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3D(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3D(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3D(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3D(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3D(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3D(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3D(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3D(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3D(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3D(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3D(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3D(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetch(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char texCubemap(texture<char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{



  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char texCubemap(texture<signed char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char texCubemap(texture<unsigned char, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 texCubemap(texture<char1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 texCubemap(texture<uchar1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 texCubemap(texture<char2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 texCubemap(texture<uchar2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 texCubemap(texture<char4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 texCubemap(texture<uchar4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short texCubemap(texture<short, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short texCubemap(texture<unsigned short, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 texCubemap(texture<short1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 texCubemap(texture<ushort1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 texCubemap(texture<short2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 texCubemap(texture<ushort2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 texCubemap(texture<short4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 texCubemap(texture<ushort4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int texCubemap(texture<int, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int texCubemap(texture<unsigned int, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 texCubemap(texture<int1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 texCubemap(texture<uint1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 texCubemap(texture<int2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 texCubemap(texture<uint2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 texCubemap(texture<int4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 texCubemap(texture<uint4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 3059 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemap(texture<float, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemap(texture<float1, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemap(texture<float2, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemap(texture<float4, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{
  float4 v = __ftexfetchc(t, make_float4(x, y, z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemap(texture<char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{



  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemap(texture<signed char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemap(texture<unsigned char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemap(texture<char1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemap(texture<uchar1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemap(texture<char2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemap(texture<uchar2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemap(texture<char4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemap(texture<uchar4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemap(texture<short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemap(texture<unsigned short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemap(texture<short1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemap(texture<ushort1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemap(texture<short2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemap(texture<ushort2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemap(texture<short4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  int4 v = __itexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemap(texture<ushort4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{
  uint4 v = __utexfetchc(t, make_float4(x, y, z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char texCubemapLayered(texture<char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{



  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char texCubemapLayered(texture<signed char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char texCubemapLayered(texture<unsigned char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 texCubemapLayered(texture<char1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 texCubemapLayered(texture<uchar1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 texCubemapLayered(texture<char2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 texCubemapLayered(texture<uchar2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 texCubemapLayered(texture<char4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 texCubemapLayered(texture<uchar4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short texCubemapLayered(texture<short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short texCubemapLayered(texture<unsigned short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 texCubemapLayered(texture<short1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 texCubemapLayered(texture<ushort1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 texCubemapLayered(texture<short2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 texCubemapLayered(texture<ushort2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 texCubemapLayered(texture<short4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 texCubemapLayered(texture<ushort4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int texCubemapLayered(texture<int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int texCubemapLayered(texture<unsigned int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 texCubemapLayered(texture<int1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 texCubemapLayered(texture<uint1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 texCubemapLayered(texture<int2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 texCubemapLayered(texture<uint2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 texCubemapLayered(texture<int4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 texCubemapLayered(texture<uint4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 3508 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayered(texture<float, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayered(texture<float1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayered(texture<float2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayered(texture<float4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{
  float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayered(texture<char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{



  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayered(texture<signed char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayered(texture<unsigned char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayered(texture<char1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayered(texture<uchar1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayered(texture<char2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayered(texture<uchar2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayered(texture<char4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayered(texture<uchar4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayered(texture<short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayered(texture<unsigned short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayered(texture<short1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayered(texture<ushort1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayered(texture<short2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayered(texture<ushort2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayered(texture<short4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayered(texture<ushort4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{
  uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}
# 3785 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
template<int comp, class T, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);
template<int comp, class T, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);
template<int comp, class T, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftex2Dgather(texture<T, 0x02, readMode> t, float2 i, int c = comp);
# 3807 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2Dgather(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2Dgather(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2Dgather(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2Dgather(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2Dgather(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2Dgather(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2Dgather(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2Dgather(texture<char3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2Dgather(texture<uchar3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2Dgather(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2Dgather(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2Dgather(texture<signed short, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2Dgather(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2Dgather(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2Dgather(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2Dgather(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2Dgather(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2Dgather(texture<short3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2Dgather(texture<ushort3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2Dgather(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2Dgather(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2Dgather(texture<signed int, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2Dgather(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2Dgather(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2Dgather(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2Dgather(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2Dgather(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2Dgather(texture<int3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2Dgather(texture<uint3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2Dgather(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2Dgather(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<float3, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 2) { float4 v = __ftex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, int comp = 0)
{
  if (comp == 3) { float4 v = __ftex2Dgather<3>(t, make_float2(x, y)); return v; } else if (comp == 2) { float4 v = __ftex2Dgather<2>(t, make_float2(x, y)); return v; } else if (comp == 1) { float4 v = __ftex2Dgather<1>(t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather<0>(t, make_float2(x, y)); return v; };
}
# 3994 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<char3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<uchar3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<signed short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<short3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<ushort3, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { int4 v = __itex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { int4 v = __itex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { int4 v = __itex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2Dgather(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{
  if (comp == 3) { uint4 v = __utex2Dgather<3>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 2) { uint4 v = __utex2Dgather<2>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else if (comp == 1) { uint4 v = __utex2Dgather<1>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather<0>(t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); };
}







template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchlod(texture<T, texType, readMode> t, float4 i, float level, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchlodc(texture<T, texType, readMode> t, float4 i, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchlodl(texture<T, texType, readMode> t, float4 i, int l, float level, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchlodlc(texture<T, texType, readMode> t, float4 i, int l, float level);







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex1DLod(texture<char, 0x01, cudaReadModeElementType> t, float x, float level)
{



  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex1DLod(texture<signed char, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex1DLod(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex1DLod(texture<char1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex1DLod(texture<uchar1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex1DLod(texture<char2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex1DLod(texture<uchar2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex1DLod(texture<char4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex1DLod(texture<uchar4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex1DLod(texture<short, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex1DLod(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex1DLod(texture<short1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex1DLod(texture<ushort1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex1DLod(texture<short2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex1DLod(texture<ushort2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex1DLod(texture<short4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex1DLod(texture<ushort4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex1DLod(texture<int, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex1DLod(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex1DLod(texture<int1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex1DLod(texture<uint1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex1DLod(texture<int2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex1DLod(texture<uint2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex1DLod(texture<int4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex1DLod(texture<uint4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 4393 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLod(texture<float, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLod(texture<float1, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLod(texture<float2, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLod(texture<float4, 0x01, cudaReadModeElementType> t, float x, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLod(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{



  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLod(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLod(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLod(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLod(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLod(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLod(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLod(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLod(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLod(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLod(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLod(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLod(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLod(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLod(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLod(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLod(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex2DLod(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{



  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex2DLod(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex2DLod(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex2DLod(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex2DLod(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex2DLod(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex2DLod(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2DLod(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2DLod(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex2DLod(texture<short, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex2DLod(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex2DLod(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex2DLod(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex2DLod(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex2DLod(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2DLod(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2DLod(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex2DLod(texture<int, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex2DLod(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex2DLod(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex2DLod(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex2DLod(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex2DLod(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2DLod(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2DLod(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 4842 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLod(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLod(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLod(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLod(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLod(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{



  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLod(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLod(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLod(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLod(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLod(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLod(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLod(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLod(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLod(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLod(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLod(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLod(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLod(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLod(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLod(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLod(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex1DLayeredLod(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{



  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex1DLayeredLod(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex1DLayeredLod(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex1DLayeredLod(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex1DLayeredLod(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex1DLayeredLod(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex1DLayeredLod(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex1DLayeredLod(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex1DLayeredLod(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex1DLayeredLod(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex1DLayeredLod(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex1DLayeredLod(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex1DLayeredLod(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex1DLayeredLod(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex1DLayeredLod(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex1DLayeredLod(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex1DLayeredLod(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex1DLayeredLod(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex1DLayeredLod(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex1DLayeredLod(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex1DLayeredLod(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex1DLayeredLod(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex1DLayeredLod(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex1DLayeredLod(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex1DLayeredLod(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 5291 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredLod(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredLod(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredLod(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredLod(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredLod(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{



  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredLod(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredLod(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredLod(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredLod(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredLod(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredLod(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredLod(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredLod(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredLod(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredLod(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredLod(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredLod(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredLod(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredLod(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredLod(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredLod(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex2DLayeredLod(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{



  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex2DLayeredLod(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex2DLayeredLod(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex2DLayeredLod(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex2DLayeredLod(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex2DLayeredLod(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex2DLayeredLod(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2DLayeredLod(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2DLayeredLod(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex2DLayeredLod(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex2DLayeredLod(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex2DLayeredLod(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex2DLayeredLod(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex2DLayeredLod(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex2DLayeredLod(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2DLayeredLod(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2DLayeredLod(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex2DLayeredLod(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex2DLayeredLod(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex2DLayeredLod(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex2DLayeredLod(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex2DLayeredLod(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex2DLayeredLod(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2DLayeredLod(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2DLayeredLod(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 5740 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredLod(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredLod(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredLod(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredLod(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{
  float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredLod(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{



  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredLod(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredLod(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredLod(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredLod(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredLod(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredLod(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredLod(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredLod(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredLod(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredLod(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredLod(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredLod(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredLod(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredLod(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredLod(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredLod(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{
  uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex3DLod(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{



  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex3DLod(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex3DLod(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex3DLod(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex3DLod(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex3DLod(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex3DLod(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex3DLod(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex3DLod(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex3DLod(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex3DLod(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex3DLod(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex3DLod(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex3DLod(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex3DLod(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex3DLod(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex3DLod(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex3DLod(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex3DLod(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex3DLod(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex3DLod(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex3DLod(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex3DLod(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex3DLod(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex3DLod(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 6189 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DLod(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DLod(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DLod(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DLod(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DLod(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{



  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DLod(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DLod(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DLod(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DLod(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DLod(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DLod(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DLod(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DLod(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DLod(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DLod(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DLod(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DLod(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DLod(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DLod(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DLod(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DLod(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char texCubemapLod(texture<char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{



  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char texCubemapLod(texture<signed char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char texCubemapLod(texture<unsigned char, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 texCubemapLod(texture<char1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 texCubemapLod(texture<uchar1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 texCubemapLod(texture<char2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 texCubemapLod(texture<uchar2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 texCubemapLod(texture<char4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 texCubemapLod(texture<uchar4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short texCubemapLod(texture<short, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short texCubemapLod(texture<unsigned short, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 texCubemapLod(texture<short1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 texCubemapLod(texture<ushort1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 texCubemapLod(texture<short2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 texCubemapLod(texture<ushort2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 texCubemapLod(texture<short4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 texCubemapLod(texture<ushort4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int texCubemapLod(texture<int, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int texCubemapLod(texture<unsigned int, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 texCubemapLod(texture<int1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 texCubemapLod(texture<uint1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 texCubemapLod(texture<int2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 texCubemapLod(texture<uint2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 texCubemapLod(texture<int4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 texCubemapLod(texture<uint4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 6638 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLod(texture<float, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLod(texture<float1, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLod(texture<float2, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLod(texture<float4, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{
  float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLod(texture<char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{



  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLod(texture<signed char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLod(texture<unsigned char, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLod(texture<char1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLod(texture<uchar1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLod(texture<char2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLod(texture<uchar2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLod(texture<char4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLod(texture<uchar4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLod(texture<short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLod(texture<unsigned short, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLod(texture<short1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLod(texture<ushort1, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLod(texture<short2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLod(texture<ushort2, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLod(texture<short4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLod(texture<ushort4, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{
  uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char texCubemapLayeredLod(texture<char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{



  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char texCubemapLayeredLod(texture<signed char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char texCubemapLayeredLod(texture<unsigned char, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 texCubemapLayeredLod(texture<char1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 texCubemapLayeredLod(texture<uchar1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 texCubemapLayeredLod(texture<char2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 texCubemapLayeredLod(texture<uchar2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 texCubemapLayeredLod(texture<char4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 texCubemapLayeredLod(texture<uchar4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short texCubemapLayeredLod(texture<short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short texCubemapLayeredLod(texture<unsigned short, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 texCubemapLayeredLod(texture<short1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 texCubemapLayeredLod(texture<ushort1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 texCubemapLayeredLod(texture<short2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 texCubemapLayeredLod(texture<ushort2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 texCubemapLayeredLod(texture<short4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 texCubemapLayeredLod(texture<ushort4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int texCubemapLayeredLod(texture<int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int texCubemapLayeredLod(texture<unsigned int, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 texCubemapLayeredLod(texture<int1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 texCubemapLayeredLod(texture<uint1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 texCubemapLayeredLod(texture<int2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 texCubemapLayeredLod(texture<uint2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 texCubemapLayeredLod(texture<int4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 texCubemapLayeredLod(texture<uint4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 7087 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayeredLod(texture<float, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayeredLod(texture<float1, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayeredLod(texture<float2, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayeredLod(texture<float4, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{
  float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayeredLod(texture<char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{



  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayeredLod(texture<signed char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayeredLod(texture<unsigned char, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayeredLod(texture<char1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayeredLod(texture<uchar1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayeredLod(texture<char2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayeredLod(texture<uchar2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayeredLod(texture<char4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayeredLod(texture<uchar4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayeredLod(texture<short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float texCubemapLayeredLod(texture<unsigned short, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayeredLod(texture<short1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 texCubemapLayeredLod(texture<ushort1, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayeredLod(texture<short2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 texCubemapLayeredLod(texture<ushort2, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayeredLod(texture<short4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 texCubemapLayeredLod(texture<ushort4, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{
  uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level);
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}


template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchgrad(texture<T, texType, readMode> t, float4 i, float4 dPdx, float4 dPdy, int d = texType);
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) uint4 __utexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) int4 __itexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));
template<class T, int texType, enum cudaTextureReadMode readMode> extern __attribute__((device)) __attribute__((device_builtin)) float4 __ftexfetchgradl(texture<T, texType, readMode> t, float4 i, int l, float4 dPdx, float4 dPdy, int d = (texType & 0xF));







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex1DGrad(texture<char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{



  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex1DGrad(texture<signed char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex1DGrad(texture<unsigned char, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex1DGrad(texture<char1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex1DGrad(texture<uchar1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex1DGrad(texture<char2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex1DGrad(texture<uchar2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex1DGrad(texture<char4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex1DGrad(texture<uchar4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex1DGrad(texture<short, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex1DGrad(texture<unsigned short, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex1DGrad(texture<short1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex1DGrad(texture<ushort1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex1DGrad(texture<short2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex1DGrad(texture<ushort2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex1DGrad(texture<short4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex1DGrad(texture<ushort4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex1DGrad(texture<int, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex1DGrad(texture<unsigned int, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex1DGrad(texture<int1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex1DGrad(texture<uint1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex1DGrad(texture<int2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex1DGrad(texture<uint2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex1DGrad(texture<int4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex1DGrad(texture<uint4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 7550 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DGrad(texture<float, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DGrad(texture<float1, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DGrad(texture<float2, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DGrad(texture<float4, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DGrad(texture<char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{



  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DGrad(texture<signed char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DGrad(texture<unsigned char, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DGrad(texture<char1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DGrad(texture<uchar1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DGrad(texture<char2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DGrad(texture<uchar2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DGrad(texture<char4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DGrad(texture<uchar4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DGrad(texture<short, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DGrad(texture<unsigned short, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DGrad(texture<short1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DGrad(texture<ushort1, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DGrad(texture<short2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DGrad(texture<ushort2, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DGrad(texture<short4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DGrad(texture<ushort4, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex2DGrad(texture<char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{



  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex2DGrad(texture<signed char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex2DGrad(texture<unsigned char, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex2DGrad(texture<char1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex2DGrad(texture<uchar1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex2DGrad(texture<char2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex2DGrad(texture<uchar2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2DGrad(texture<char4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2DGrad(texture<uchar4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex2DGrad(texture<short, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex2DGrad(texture<unsigned short, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex2DGrad(texture<short1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex2DGrad(texture<ushort1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex2DGrad(texture<short2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex2DGrad(texture<ushort2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2DGrad(texture<short4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2DGrad(texture<ushort4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex2DGrad(texture<int, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex2DGrad(texture<unsigned int, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex2DGrad(texture<int1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex2DGrad(texture<uint1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex2DGrad(texture<int2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex2DGrad(texture<uint2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2DGrad(texture<int4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2DGrad(texture<uint4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 7999 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DGrad(texture<float, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DGrad(texture<float1, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DGrad(texture<float2, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DGrad(texture<float4, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DGrad(texture<char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{



  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DGrad(texture<signed char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DGrad(texture<unsigned char, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DGrad(texture<char1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DGrad(texture<uchar1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DGrad(texture<char2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DGrad(texture<uchar2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DGrad(texture<char4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DGrad(texture<uchar4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DGrad(texture<short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DGrad(texture<unsigned short, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DGrad(texture<short1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DGrad(texture<ushort1, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DGrad(texture<short2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DGrad(texture<ushort2, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DGrad(texture<short4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DGrad(texture<ushort4, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex1DLayeredGrad(texture<char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{



  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex1DLayeredGrad(texture<signed char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex1DLayeredGrad(texture<unsigned char, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex1DLayeredGrad(texture<char1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex1DLayeredGrad(texture<uchar1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex1DLayeredGrad(texture<char2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex1DLayeredGrad(texture<uchar2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex1DLayeredGrad(texture<char4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex1DLayeredGrad(texture<uchar4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex1DLayeredGrad(texture<short, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex1DLayeredGrad(texture<unsigned short, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex1DLayeredGrad(texture<short1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex1DLayeredGrad(texture<ushort1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex1DLayeredGrad(texture<short2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex1DLayeredGrad(texture<ushort2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex1DLayeredGrad(texture<short4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex1DLayeredGrad(texture<ushort4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex1DLayeredGrad(texture<int, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex1DLayeredGrad(texture<unsigned int, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex1DLayeredGrad(texture<int1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex1DLayeredGrad(texture<uint1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex1DLayeredGrad(texture<int2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex1DLayeredGrad(texture<uint2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex1DLayeredGrad(texture<int4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex1DLayeredGrad(texture<uint4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 8448 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredGrad(texture<float, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredGrad(texture<float1, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredGrad(texture<float2, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredGrad(texture<float4, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredGrad(texture<char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{



  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredGrad(texture<signed char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredGrad(texture<unsigned char, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredGrad(texture<char1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredGrad(texture<uchar1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredGrad(texture<char2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredGrad(texture<uchar2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredGrad(texture<char4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredGrad(texture<uchar4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredGrad(texture<short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex1DLayeredGrad(texture<unsigned short, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredGrad(texture<short1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex1DLayeredGrad(texture<ushort1, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredGrad(texture<short2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex1DLayeredGrad(texture<ushort2, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredGrad(texture<short4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex1DLayeredGrad(texture<ushort4, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex2DLayeredGrad(texture<char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{



  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex2DLayeredGrad(texture<signed char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex2DLayeredGrad(texture<unsigned char, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex2DLayeredGrad(texture<char1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex2DLayeredGrad(texture<uchar1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex2DLayeredGrad(texture<char2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex2DLayeredGrad(texture<uchar2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex2DLayeredGrad(texture<char4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex2DLayeredGrad(texture<uchar4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex2DLayeredGrad(texture<short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex2DLayeredGrad(texture<unsigned short, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex2DLayeredGrad(texture<short1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex2DLayeredGrad(texture<ushort1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex2DLayeredGrad(texture<short2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex2DLayeredGrad(texture<ushort2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex2DLayeredGrad(texture<short4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex2DLayeredGrad(texture<ushort4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex2DLayeredGrad(texture<int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex2DLayeredGrad(texture<unsigned int, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex2DLayeredGrad(texture<int1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex2DLayeredGrad(texture<uint1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex2DLayeredGrad(texture<int2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex2DLayeredGrad(texture<uint2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex2DLayeredGrad(texture<int4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex2DLayeredGrad(texture<uint4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 8897 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredGrad(texture<float, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredGrad(texture<float1, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredGrad(texture<float2, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredGrad(texture<float4, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredGrad(texture<char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{



  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredGrad(texture<signed char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredGrad(texture<unsigned char, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredGrad(texture<char1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredGrad(texture<uchar1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredGrad(texture<char2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredGrad(texture<uchar2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredGrad(texture<char4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredGrad(texture<uchar4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredGrad(texture<short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex2DLayeredGrad(texture<unsigned short, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredGrad(texture<short1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex2DLayeredGrad(texture<ushort1, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredGrad(texture<short2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex2DLayeredGrad(texture<ushort2, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredGrad(texture<short4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex2DLayeredGrad(texture<ushort4, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
  uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) char tex3DGrad(texture<char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{



  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));


  return (char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) signed char tex3DGrad(texture<signed char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (signed char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned char tex3DGrad(texture<unsigned char, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned char)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char1 tex3DGrad(texture<char1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar1 tex3DGrad(texture<uchar1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char2 tex3DGrad(texture<char2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar2 tex3DGrad(texture<uchar2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char4 tex3DGrad(texture<char4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_char4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uchar4 tex3DGrad(texture<uchar4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uchar4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) short tex3DGrad(texture<short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned short tex3DGrad(texture<unsigned short, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned short)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short1 tex3DGrad(texture<short1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort1 tex3DGrad(texture<ushort1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short2 tex3DGrad(texture<short2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort2 tex3DGrad(texture<ushort2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) short4 tex3DGrad(texture<short4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_short4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) ushort4 tex3DGrad(texture<ushort4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_ushort4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) int tex3DGrad(texture<int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int tex3DGrad(texture<unsigned int, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return (unsigned int)v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int1 tex3DGrad(texture<int1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint1 tex3DGrad(texture<uint1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int2 tex3DGrad(texture<int2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint2 tex3DGrad(texture<uint2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int4 tex3DGrad(texture<int4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_int4(v.x, v.y, v.z, v.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 tex3DGrad(texture<uint4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_uint4(v.x, v.y, v.z, v.w);
}
# 9346 "/usr/local/cuda-6.5/bin/..//include/texture_fetch_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DGrad(texture<float, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return v.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DGrad(texture<float1, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float1(v.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DGrad(texture<float2, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float2(v.x, v.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DGrad(texture<float4, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  return make_float4(v.x, v.y, v.z, v.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DGrad(texture<char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{



  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));

  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DGrad(texture<signed char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DGrad(texture<unsigned char, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DGrad(texture<char1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DGrad(texture<uchar1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DGrad(texture<char2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DGrad(texture<uchar2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DGrad(texture<char4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DGrad(texture<uchar4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DGrad(texture<short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float tex3DGrad(texture<unsigned short, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return w.x;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DGrad(texture<short1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float1 tex3DGrad(texture<ushort1, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float1(w.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DGrad(texture<short2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 tex3DGrad(texture<ushort2, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float2(w.x, w.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DGrad(texture<short4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 tex3DGrad(texture<ushort4, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{
  uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0));
  float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w));

  return make_float4(w.x, w.y, w.z, w.w);
}
# 9417 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h" 1
# 59 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 60 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h" 2
# 70 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(char *retVal, cudaTextureObject_t texObject, int x)
{




    int4 tmp;
    asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(signed char *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(char1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(char2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(char4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(unsigned char *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(uchar1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(uchar2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(uchar4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(short *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(short1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(short2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(short4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(unsigned short *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(ushort1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(ushort2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(ushort4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(int *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(int1 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(int2 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(int4 *retVal, cudaTextureObject_t texObject, int x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(unsigned int *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(uint1 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(uint2 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(uint4 *retVal, cudaTextureObject_t texObject, int x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 334 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(float *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(float1 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(float2 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1Dfetch(float4 *retVal, cudaTextureObject_t texObject, int x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.s32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex1Dfetch(cudaTextureObject_t texObject, int x)
{
   T ret;
   tex1Dfetch(&ret, texObject, x);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(char *retVal, cudaTextureObject_t texObject, float x)
{




    int4 tmp;
    asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(signed char *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(char1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(char2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(char4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(unsigned char *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(uchar1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(uchar2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(uchar4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(short *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(short1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(short2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(short4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(unsigned short *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(ushort1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(ushort2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(ushort4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(int *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(int1 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(int2 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(int4 *retVal, cudaTextureObject_t texObject, float x)
{
   int4 tmp;
   asm volatile ("tex.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(unsigned int *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(uint1 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(uint2 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(uint4 *retVal, cudaTextureObject_t texObject, float x)
{
   uint4 tmp;
   asm volatile ("tex.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 646 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(float *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(float1 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(float2 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1D(float4 *retVal, cudaTextureObject_t texObject, float x)
{
   float4 tmp;
   asm volatile ("tex.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex1D(cudaTextureObject_t texObject, float x)
{
   T ret;
   tex1D(&ret, texObject, x);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(char *retVal, cudaTextureObject_t texObject, float x, float y)
{




    int4 tmp;
    asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(signed char *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(char1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(char2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(char4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(short *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(short1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(short2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(short4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(int *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(int1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(int2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(int4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   int4 tmp;
   asm volatile ("tex.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   uint4 tmp;
   asm volatile ("tex.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 958 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(float *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(float1 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(float2 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2D(float4 *retVal, cudaTextureObject_t texObject, float x, float y)
{
   float4 tmp;
   asm volatile ("tex.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex2D(cudaTextureObject_t texObject, float x, float y)
{
   T ret;
   tex2D(&ret, texObject, x, y);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{




    int4 tmp;
    asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 1270 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(float *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3D(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex3D(cudaTextureObject_t texObject, float x, float y, float z)
{
   T ret;
   tex3D(&ret, texObject, x, y, z);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(char *retVal, cudaTextureObject_t texObject, float x, int layer)
{




    int4 tmp;
    asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(short *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(int *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   int4 tmp;
   asm volatile ("tex.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 1582 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(float *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, int layer)
{
   float4 tmp;
   asm volatile ("tex.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex1DLayered(cudaTextureObject_t texObject, float x, int layer)
{
   T ret;
   tex1DLayered(&ret, texObject, x, layer);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{




    int4 tmp;
    asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   int4 tmp;
   asm volatile ("tex.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   uint4 tmp;
   asm volatile ("tex.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 1894 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer)
{
   float4 tmp;
   asm volatile ("tex.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer)
{
   T ret;
   tex2DLayered(&ret, texObject, x, y, layer);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{




    int4 tmp;
    asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   int4 tmp;
   asm volatile ("tex.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   uint4 tmp;
   asm volatile ("tex.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 2206 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(float *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemap(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z)
{
   float4 tmp;
   asm volatile ("tex.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T texCubemap(cudaTextureObject_t texObject, float x, float y, float z)
{
   T ret;
   texCubemap(&ret, texObject, x, y, z);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{




    int4 tmp;
    asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   int4 tmp;
   asm volatile ("tex.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   uint4 tmp;
   asm volatile ("tex.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 2518 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   float4 tmp;
   asm volatile ("tex.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer)
{
   T ret;
   texCubemapLayered(&ret, texObject, x, y, z, layer);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (long)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   int4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_long4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (unsigned long)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   uint4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(float *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2Dgather(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0)
{
   float4 tmp;
   if (comp == 0) {
       asm volatile ("tld4.r.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 1) {
       asm volatile ("tld4.g.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 2) {
       asm volatile ("tld4.b.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   else if (comp == 3) {
       asm volatile ("tld4.a.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0)
{
   T ret;
   tex2Dgather(&ret, to, x, y, comp);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(char *retVal, cudaTextureObject_t texObject, float x, float level)
{




    int4 tmp;
    asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(short *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(int *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   int4 tmp;
   asm volatile ("tex.level.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 3540 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(float *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float level)
{
   float4 tmp;
   asm volatile ("tex.level.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], %6;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex1DLod(cudaTextureObject_t texObject, float x, float level)
{
   T ret;
   tex1DLod(&ret, texObject, x, level);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{




    int4 tmp;
    asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   int4 tmp;
   asm volatile ("tex.level.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 3852 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float level)
{
   float4 tmp;
   asm volatile ("tex.level.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level)
{
   T ret;
   tex2DLod(&ret, texObject, x, y, level);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{




    int4 tmp;
    asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 4164 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   T ret;
   tex3DLod(&ret, texObject, x, y, z, level);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{




    int4 tmp;
    asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 4476 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], %7;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level)
{
   T ret;
   tex1DLayeredLod(&ret, texObject, x, layer, level);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{




    int4 tmp;
    asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 4788 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level)
{
   T ret;
   tex2DLayeredLod(&ret, texObject, x, y, layer, level);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{




    int4 tmp;
    asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   int4 tmp;
   asm volatile ("tex.level.cube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.cube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 5100 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   float4 tmp;
   asm volatile ("tex.level.cube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], %8;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{
   T ret;
   texCubemapLod(&ret, texObject, x, y, z, level);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{




    int4 tmp;
    asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   int4 tmp;
   asm volatile ("tex.level.acube.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   uint4 tmp;
   asm volatile ("tex.level.acube.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 5412 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void texCubemapLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   float4 tmp;
   asm volatile ("tex.level.acube.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %8}], %9;" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(z), "f"(level));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{
   T ret;
   texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{




    int4 tmp;
    asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 5724 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(float *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{
   T ret;
   tex1DGrad(&ret, texObject, x, dPdx, dPdy);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{




    int4 tmp;
    asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 6036 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7, %8}, {%9, %10};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{
   T ret;
   tex2DGrad(&ret, texObject, x, y, dPdx, dPdy);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{




    int4 tmp;
    asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.3d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.3d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 6348 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex3DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.3d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9, %10, %10}, {%11, %12, %13, %13};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "f"(x), "f"(y), "f"(z), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdx.z), "f"(dPdy.x), "f"(dPdy.y), "f"(dPdy.z));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{
   T ret;
   tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{




    int4 tmp;
    asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a1d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 6660 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex1DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a1d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6}], {%7}, {%8};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(dPdx), "f"(dPdy));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{
   T ret;
   tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{




    int4 tmp;
    asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));

    *retVal = (char)tmp.x;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (signed char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned char)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned short)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   int4 tmp;
   asm volatile ("tex.grad.a2d.v4.s32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(unsigned int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (unsigned int)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   uint4 tmp;
   asm volatile ("tex.grad.a2d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}
# 6972 "/usr/local/cuda-6.5/bin/..//include/texture_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = (float)(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void tex2DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   float4 tmp;
   asm volatile ("tex.grad.a2d.v4.f32.f32 {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}], {%8, %9}, {%10, %11};" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(texObject), "r"(layer), "f"(x), "f"(y), "f"(dPdx.x), "f"(dPdx.y), "f"(dPdy.x), "f"(dPdy.y));
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{
   T ret;
   tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy);
   return ret;
}
# 9418 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/surface_indirect_functions.h" 1
# 59 "/usr/local/cuda-6.5/bin/..//include/surface_indirect_functions.h"
# 1 "/usr/local/cuda-6.5/bin/..//include/builtin_types.h" 1
# 60 "/usr/local/cuda-6.5/bin/..//include/surface_indirect_functions.h" 2
# 70 "/usr/local/cuda-6.5/bin/..//include/surface_indirect_functions.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (signed char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b8.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b8.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b8.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b16.trap  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b16.clamp {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b16.zero  {%0}, [%1, {%2}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_longlong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (unsigned long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b64.trap  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b64.clamp {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b64.zero  {%0}, [%1, {%2}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=f"(tmp) : "l"(surfObject), "r"(x));
   }
   *retVal = (float)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.b32.trap  {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.b32.clamp {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.b32.zero  {%0}, [%1, {%2}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float1(tmp.x);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b8.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b8.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b8.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b16.trap  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b16.clamp {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b16.zero  {%0, %1}, [%2, {%3}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b64.trap  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b64.clamp {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b64.zero  {%0, %1}, [%2, {%3}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v2.b32.trap  {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v2.b32.clamp {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v2.b32.zero  {%0, %1}, [%2, {%3}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf1Dread(&ret, surfObject, x, boundaryMode);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf2Dread(&ret, surfObject, x, y, boundaryMode);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (signed char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_longlong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (unsigned long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = (float)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float1(tmp.x);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.3d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.3d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.3d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(x), "r"(y), "r"(z));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf3Dread(&ret, surfObject, x, y, z, boundaryMode);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (signed char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b8.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b8.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b8.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b16.trap  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b16.clamp {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b16.zero  {%0}, [%1, {%2, %3}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_longlong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (unsigned long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b64.trap  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b64.clamp {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b64.zero  {%0}, [%1, {%2, %3}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = (float)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.b32.trap  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.b32.clamp {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.b32.zero  {%0}, [%1, {%2, %3}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float1(tmp.x);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b8.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b8.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b8.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b16.trap  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b16.clamp {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b16.zero  {%0, %1}, [%2, {%3, %4}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b64.trap  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b64.clamp {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b64.zero  {%0, %1}, [%2, {%3, %4}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v2.b32.trap  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v2.b32.clamp {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v2.b32.zero  {%0, %1}, [%2, {%3, %4}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a1d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a1d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a1d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layer), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(face), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surfCubemapread(&ret, surfObject, face, x, y, boundaryMode);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (signed char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned char)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b8.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b8.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b8.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned short tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned short)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b16.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b16.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b16.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=h"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(unsigned int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned int tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned int)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=r"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_longlong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(unsigned long long *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   unsigned long long tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (unsigned long long)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b64.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b64.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b64.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=l"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong1(tmp.x);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = (float)(tmp);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float1 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.b32.trap  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.b32.clamp {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.b32.zero  {%0}, [%1, {%2, %3, %4, %4}];" : "=f"(tmp.x) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float1(tmp.x);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b8.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b8.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b8.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b16.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b16.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b16.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=h"(tmp.x), "=h"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=r"(tmp.x), "=r"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   longlong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_longlong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ulonglong2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b64.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b64.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b64.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=l"(tmp.x), "=l"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ulonglong2(tmp.x, tmp.y);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float2 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v2.b32.trap  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v2.b32.clamp {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v2.b32.zero  {%0, %1}, [%2, {%3, %4, %5, %5}];" : "=f"(tmp.x), "=f"(tmp.y) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float2(tmp.x, tmp.y);
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_char4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b8.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b8.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b8.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   short4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_short4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   ushort4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b16.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b16.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b16.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=h"(tmp.x), "=h"(tmp.y), "=h"(tmp.z), "=h"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   int4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_int4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   uint4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   float4 tmp;
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("suld.b.a2d.v4.b32.trap  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("suld.b.a2d.v4.b32.clamp {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("suld.b.a2d.v4.b32.zero  {%0, %1, %2, %3}, [%4, {%5, %6, %7, %7}];" : "=f"(tmp.x), "=f"(tmp.y), "=f"(tmp.z), "=f"(tmp.w) : "l"(surfObject), "r"(layerface), "r"(x), "r"(y));
   }
   *retVal = make_float4(tmp.x, tmp.y, tmp.z, tmp.w);
}







template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   T ret;
   surfCubemapLayeredread(&ret, surfObject, x, y, z, layerface, boundaryMode);
   return ret;
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b8.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b8.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b8.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b16.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b16.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b16.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b64.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b64.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b64.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.b32.trap  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.b32.clamp [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.b32.zero  [%0, {%1}], {%2};" : : "l"(surfObject), "r"(x), "f"(data.x));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b8.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b8.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b8.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b16.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b16.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b16.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b64.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b64.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b64.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v2.b32.trap  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v2.b32.clamp [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v2.b32.zero  [%0, {%1}], {%2, %3};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b8.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b8.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b8.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b16.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b16.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b16.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.1d.v4.b32.trap  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.1d.v4.b32.clamp [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.1d.v4.b32.zero  [%0, {%1}], {%2, %3, %4, %5};" : : "l"(surfObject), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.2d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.2d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.2d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.3d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.3d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.3d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(x), "r"(y), "r"(z), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b8.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b8.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b8.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b16.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b16.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b16.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b64.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b64.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b64.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.b32.trap  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.b32.clamp [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.b32.zero  [%0, {%1, %2}], {%3};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b8.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b8.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b8.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b16.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b16.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b16.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b64.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b64.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b64.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v2.b32.trap  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v2.b32.clamp [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v2.b32.zero  [%0, {%1, %2}], {%3, %4};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b8.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b8.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b8.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b16.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b16.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b16.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a1d.v4.b32.trap  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a1d.v4.b32.clamp [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a1d.v4.b32.zero  [%0, {%1, %2}], {%3, %4, %5, %6};" : : "l"(surfObject), "r"(layer), "r"(x), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layer), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(face), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b8.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b8.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b8.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b16.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b16.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b16.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(unsigned int data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(unsigned long long data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b64.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b64.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b64.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.b32.trap  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.b32.clamp [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.b32.zero  [%0, {%1, %2, %3, %3}], {%4};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b64.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b64.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b64.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "l"(data.x), "l"(data.y));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v2.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v2.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v2.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y));
   }
}







static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((int)data.x), "r"((int)data.y), "r"((int)data.z), "r"((int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b8.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b8.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b8.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"((unsigned int)data.x), "r"((unsigned int)data.y), "r"((unsigned int)data.z), "r"((unsigned int)data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b16.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b16.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b16.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "h"(data.x), "h"(data.y), "h"(data.z), "h"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "r"(data.x), "r"(data.y), "r"(data.z), "r"(data.w));
   }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
   if (boundaryMode == cudaBoundaryModeTrap) {
       asm volatile ("sust.b.a2d.v4.b32.trap  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeClamp) {
       asm volatile ("sust.b.a2d.v4.b32.clamp [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
   else if (boundaryMode == cudaBoundaryModeZero) {
       asm volatile ("sust.b.a2d.v4.b32.zero  [%0, {%1, %2, %3, %3}], {%4, %5, %6, %7};" : : "l"(surfObject), "r"(layerface), "r"(x), "r"(y), "f"(data.x), "f"(data.y), "f"(data.z), "f"(data.w));
   }
}
# 9419 "/usr/local/cuda-6.5/bin/..//include/device_functions.h" 2
# 80 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2
# 1 "/usr/local/cuda-6.5/bin/..//include/device_launch_parameters.h" 1
# 63 "/usr/local/cuda-6.5/bin/..//include/device_launch_parameters.h"
extern "C" {


uint3 __attribute__((device_builtin)) extern const threadIdx;
uint3 __attribute__((device_builtin)) extern const blockIdx;
dim3 __attribute__((device_builtin)) extern const blockDim;
dim3 __attribute__((device_builtin)) extern const gridDim;
int __attribute__((device_builtin)) extern const warpSize;




}
# 81 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h" 2
# 92 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
namespace
{
# 123 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaSetupArgument(
  T arg,
  size_t offset
)
{
  return ::cudaSetupArgument((const void*)&arg, sizeof(T), offset);
}
# 162 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
static __inline__ __attribute__((host)) cudaError_t cudaEventCreate(
  cudaEvent_t *event,
  unsigned int flags
)
{
  return ::cudaEventCreateWithFlags(event, flags);
}
# 225 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
__inline__ __attribute__((host)) cudaError_t cudaMallocHost(
  void **ptr,
  size_t size,
  unsigned int flags
)
{
  return ::cudaHostAlloc(ptr, size, flags);
}

template<class T>
__inline__ __attribute__((host)) cudaError_t cudaHostAlloc(
  T **ptr,
  size_t size,
  unsigned int flags
)
{
  return ::cudaHostAlloc((void**)(void*)ptr, size, flags);
}

template<class T>
__inline__ __attribute__((host)) cudaError_t cudaHostGetDevicePointer(
  T **pDevice,
  void *pHost,
  unsigned int flags
)
{
  return ::cudaHostGetDevicePointer((void**)(void*)pDevice, pHost, flags);
}
# 323 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaMallocManaged(
  T **devPtr,
  size_t size,
  unsigned int flags = 0x01
)
{
  return ::cudaMallocManaged((void**)(void*)devPtr, size, flags);
}
# 399 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaStreamAttachMemAsync(
  cudaStream_t stream,
  T *devPtr,
  size_t length = 0,
  unsigned int flags = 0x04
)
{
  return ::cudaStreamAttachMemAsync(stream, (void*)devPtr, length, flags);
}

template<class T>
__inline__ __attribute__((host)) cudaError_t cudaMalloc(
  T **devPtr,
  size_t size
)
{
  return ::cudaMalloc((void**)(void*)devPtr, size);
}

template<class T>
__inline__ __attribute__((host)) cudaError_t cudaMallocHost(
  T **ptr,
  size_t size,
  unsigned int flags = 0
)
{
  return cudaMallocHost((void**)(void*)ptr, size, flags);
}

template<class T>
__inline__ __attribute__((host)) cudaError_t cudaMallocPitch(
  T **devPtr,
  size_t *pitch,
  size_t width,
  size_t height
)
{
  return ::cudaMallocPitch((void**)(void*)devPtr, pitch, width, height);
}
# 475 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaMemcpyToSymbol(
  const T &symbol,
  const void *src,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyHostToDevice
)
{
  return ::cudaMemcpyToSymbol((const void*)&symbol, src, count, offset, kind);
}
# 527 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaMemcpyToSymbolAsync(
  const T &symbol,
  const void *src,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyHostToDevice,
        cudaStream_t stream = 0
)
{
  return ::cudaMemcpyToSymbolAsync((const void*)&symbol, src, count, offset, kind, stream);
}
# 573 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaMemcpyFromSymbol(
        void *dst,
  const T &symbol,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost
)
{
  return ::cudaMemcpyFromSymbol(dst, (const void*)&symbol, count, offset, kind);
}
# 625 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaMemcpyFromSymbolAsync(
        void *dst,
  const T &symbol,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost,
        cudaStream_t stream = 0
)
{
  return ::cudaMemcpyFromSymbolAsync(dst, (const void*)&symbol, count, offset, kind, stream);
}
# 658 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaGetSymbolAddress(
        void **devPtr,
  const T &symbol
)
{
  return ::cudaGetSymbolAddress(devPtr, (const void*)&symbol);
}
# 687 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaGetSymbolSize(
        size_t *size,
  const T &symbol
)
{
  return ::cudaGetSymbolSize(size, (const void*)&symbol);
}
# 730 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaBindTexture(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  const struct cudaChannelFormatDesc &desc,
        size_t size = (2147483647 * 2U + 1U)
)
{
  return ::cudaBindTexture(offset, &tex, devPtr, &desc, size);
}
# 775 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaBindTexture(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
        size_t size = (2147483647 * 2U + 1U)
)
{
  return cudaBindTexture(offset, tex, devPtr, tex.channelDesc, size);
}
# 831 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaBindTexture2D(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  const struct cudaChannelFormatDesc &desc,
  size_t width,
  size_t height,
  size_t pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch);
}
# 889 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaBindTexture2D(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  size_t width,
  size_t height,
  size_t pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &tex.channelDesc, width, height, pitch);
}
# 931 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindTextureToArray(&tex, array, &desc);
}
# 969 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindTextureToArray(tex, array, desc) : err;
}
# 1010 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t mipmappedArray,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc);
}
# 1048 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t mipmappedArray
)
{
  struct cudaChannelFormatDesc desc;
  cudaArray_t levelArray;
  cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0);

  if (err != cudaSuccess) {
      return err;
  }
  err = ::cudaGetChannelDesc(&desc, levelArray);

  return err == cudaSuccess ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err;
}
# 1087 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaUnbindTexture(
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaUnbindTexture(&tex);
}
# 1121 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
__inline__ __attribute__((host)) cudaError_t cudaGetTextureAlignmentOffset(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaGetTextureAlignmentOffset(offset, &tex);
}
# 1174 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaFuncSetCacheConfig(
  T *func,
  enum cudaFuncCache cacheConfig
)
{
  return ::cudaFuncSetCacheConfig((const void*)func, cacheConfig);
}

template<class T>
__inline__ __attribute__((host)) cudaError_t cudaFuncSetSharedMemConfig(
  T *func,
  enum cudaSharedMemConfig config
)
{
  return ::cudaFuncSetSharedMemConfig((const void*)func, config);
}
# 1216 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(
    int *numBlocks,
    T func,
    int blockSize,
    size_t dynamicSMemSize)
{
  return ::cudaOccupancyMaxActiveBlocksPerMultiprocessor(numBlocks, (const void*)func, blockSize, dynamicSMemSize);
}




class __cudaOccupancyB2DHelper {
  size_t n;
public:
  inline __attribute__((host)) __attribute__((device)) __cudaOccupancyB2DHelper(size_t n) : n(n) {}
  inline __attribute__((host)) __attribute__((device)) size_t operator()(int)
  {
      return n;
  }
};
# 1270 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSize(
    int *minGridSize,
    int *blockSize,
    T func,
    size_t dynamicSMemSize = 0,
    int blockSizeLimit = 0)
{
  return cudaOccupancyMaxPotentialBlockSizeVariableSMem(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit);
}
# 1309 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<typename UnaryFunction, class T>
__inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMem(
    int *minGridSize,
    int *blockSize,
    T func,
    UnaryFunction blockSizeToDynamicSMemSize,
    int blockSizeLimit = 0)
{
    cudaError_t status;


    int device;
    struct cudaFuncAttributes attr;


    int maxThreadsPerMultiProcessor;
    int warpSize;
    int devMaxThreadsPerBlock;
    int multiProcessorCount;
    int funcMaxThreadsPerBlock;
    int occupancyLimit;
    int granularity;


    int maxBlockSize = 0;
    int numBlocks = 0;
    int maxOccupancy = 0;


    int blockSizeToTryAligned;
    int blockSizeToTry;
    int blockSizeLimitAligned;
    int occupancyInBlocks;
    int occupancyInThreads;
    int dynamicSMemSize;





    if (!minGridSize || !blockSize || !func) {
        return cudaErrorInvalidValue;
    }





    status = ::cudaGetDevice(&device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &maxThreadsPerMultiProcessor,
        cudaDevAttrMaxThreadsPerMultiProcessor,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &warpSize,
        cudaDevAttrWarpSize,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &devMaxThreadsPerBlock,
        cudaDevAttrMaxThreadsPerBlock,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &multiProcessorCount,
        cudaDevAttrMultiProcessorCount,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaFuncGetAttributes(&attr, func);
    if (status != cudaSuccess) {
        return status;
    }

    funcMaxThreadsPerBlock = attr.maxThreadsPerBlock;





    occupancyLimit = maxThreadsPerMultiProcessor;
    granularity = warpSize;

    if (blockSizeLimit == 0) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (devMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (funcMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = funcMaxThreadsPerBlock;
    }

    blockSizeLimitAligned = ((blockSizeLimit + (granularity - 1)) / granularity) * granularity;

    for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) {



        if (blockSizeLimit < blockSizeToTryAligned) {
            blockSizeToTry = blockSizeLimit;
        } else {
            blockSizeToTry = blockSizeToTryAligned;
        }

        dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry);

        status = cudaOccupancyMaxActiveBlocksPerMultiprocessor(
            &occupancyInBlocks,
            func,
            blockSizeToTry,
            dynamicSMemSize);

        if (status != cudaSuccess) {
            return status;
        }

        occupancyInThreads = blockSizeToTry * occupancyInBlocks;

        if (occupancyInThreads > maxOccupancy) {
            maxBlockSize = blockSizeToTry;
            numBlocks = occupancyInBlocks;
            maxOccupancy = occupancyInThreads;
        }



        if (occupancyLimit == maxOccupancy) {
            break;
        }
    }







    *minGridSize = numBlocks * multiProcessorCount;
    *blockSize = maxBlockSize;

    return status;
}
# 1505 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaLaunch(
  T *func
)
{
  return ::cudaLaunch((const void*)func);
}
# 1543 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T>
__inline__ __attribute__((host)) cudaError_t cudaFuncGetAttributes(
  struct cudaFuncAttributes *attr,
  T *entry
)
{
  return ::cudaFuncGetAttributes(attr, (const void*)entry);
}
# 1572 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim>
__inline__ __attribute__((host)) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindSurfaceToArray(&surf, array, &desc);
}
# 1601 "/usr/local/cuda-6.5/bin/..//include/cuda_runtime.h"
template<class T, int dim>
__inline__ __attribute__((host)) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindSurfaceToArray(surf, array, desc) : err;
}





}
# 1 "<command-line>" 2
# 1 "../src/Vec2.cu"
# 14 "../src/Vec2.cu"
# 1 "../src/Vec2.hpp" 1
# 24 "../src/Vec2.hpp"
# 1 "../src/CImg.h" 1
# 73 "../src/CImg.h"
# 1 "/usr/include/c++/4.8/cstdio" 1 3
# 39 "/usr/include/c++/4.8/cstdio" 3
       
# 40 "/usr/include/c++/4.8/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 526 "/usr/include/libio.h" 3 4
}
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 943 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/include/c++/4.8/cstdio" 2 3
# 94 "/usr/include/c++/4.8/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 150 "/usr/include/c++/4.8/cstdio" 3
namespace __gnu_cxx
{
# 168 "/usr/include/c++/4.8/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 74 "../src/CImg.h" 2
# 1 "/usr/include/c++/4.8/cstdlib" 1 3
# 39 "/usr/include/c++/4.8/cstdlib" 3
       
# 40 "/usr/include/c++/4.8/cstdlib" 3
# 75 "../src/CImg.h" 2
# 1 "/usr/include/c++/4.8/cstdarg" 1 3
# 39 "/usr/include/c++/4.8/cstdarg" 3
       
# 40 "/usr/include/c++/4.8/cstdarg" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 43 "/usr/include/c++/4.8/cstdarg" 2 3
# 52 "/usr/include/c++/4.8/cstdarg" 3
namespace std
{
  using ::va_list;
}
# 76 "../src/CImg.h" 2
# 1 "/usr/include/c++/4.8/cstring" 1 3
# 39 "/usr/include/c++/4.8/cstring" 3
       
# 40 "/usr/include/c++/4.8/cstring" 3
# 71 "/usr/include/c++/4.8/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 120 "/usr/include/c++/4.8/cstring" 3

}
# 77 "../src/CImg.h" 2
# 1 "/usr/include/c++/4.8/cmath" 1 3
# 39 "/usr/include/c++/4.8/cmath" 3
       
# 40 "/usr/include/c++/4.8/cmath" 3
# 78 "../src/CImg.h" 2
# 1 "/usr/include/c++/4.8/ctime" 1 3
# 39 "/usr/include/c++/4.8/ctime" 3
       
# 40 "/usr/include/c++/4.8/ctime" 3
# 58 "/usr/include/c++/4.8/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 79 "../src/CImg.h" 2
# 1 "/usr/include/c++/4.8/exception" 1 3
# 33 "/usr/include/c++/4.8/exception" 3
       
# 34 "/usr/include/c++/4.8/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/include/c++/4.8/exception" 2 3

extern "C++" {

namespace std
{
# 60 "/usr/include/c++/4.8/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 117 "/usr/include/c++/4.8/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 142 "/usr/include/c++/4.8/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
# 80 "../src/CImg.h" 2
# 123 "../src/CImg.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 55 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 189 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 124 "../src/CImg.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 103 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 106 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 209 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) throw () __attribute__ ((__nonnull__ (2)));
# 228 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 253 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
# 276 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) throw ();
# 399 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));
# 432 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
}
# 125 "../src/CImg.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 48 "/usr/include/getopt.h" 3 4
extern "C" {
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 185 "/usr/include/getopt.h" 3 4
}
# 872 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 993 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1005 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1016 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1026 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1081 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1091 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1112 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1151 "/usr/include/unistd.h" 3 4
}
# 126 "../src/CImg.h" 2
# 208 "../src/CImg.h"
# 1 "/usr/include/X11/Xlib.h" 1 3 4
# 44 "/usr/include/X11/Xlib.h" 3 4
# 1 "/usr/include/X11/X.h" 1 3 4
# 66 "/usr/include/X11/X.h" 3 4
typedef unsigned long XID;



typedef unsigned long Mask;



typedef unsigned long Atom;

typedef unsigned long VisualID;
typedef unsigned long Time;
# 96 "/usr/include/X11/X.h" 3 4
typedef XID Window;
typedef XID Drawable;


typedef XID Font;

typedef XID Pixmap;
typedef XID Cursor;
typedef XID Colormap;
typedef XID GContext;
typedef XID KeySym;

typedef unsigned char KeyCode;
# 45 "/usr/include/X11/Xlib.h" 2 3 4


# 1 "/usr/include/X11/Xfuncproto.h" 1 3 4
# 48 "/usr/include/X11/Xlib.h" 2 3 4
# 1 "/usr/include/X11/Xosdefs.h" 1 3 4
# 49 "/usr/include/X11/Xlib.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 52 "/usr/include/X11/Xlib.h" 2 3 4
# 69 "/usr/include/X11/Xlib.h" 3 4
extern int
_Xmblen(




    char *str,
    int len

    );
# 92 "/usr/include/X11/Xlib.h" 3 4
typedef char *XPointer;
# 160 "/usr/include/X11/Xlib.h" 3 4
typedef struct _XExtData {
 int number;
 struct _XExtData *next;
 int (*free_private)(
 struct _XExtData *extension
 );
 XPointer private_data;
} XExtData;




typedef struct {
 int extension;
 int major_opcode;
 int first_event;
 int first_error;
} XExtCodes;





typedef struct {
    int depth;
    int bits_per_pixel;
    int scanline_pad;
} XPixmapFormatValues;





typedef struct {
 int function;
 unsigned long plane_mask;
 unsigned long foreground;
 unsigned long background;
 int line_width;
 int line_style;
 int cap_style;

 int join_style;
 int fill_style;

 int fill_rule;
 int arc_mode;
 Pixmap tile;
 Pixmap stipple;
 int ts_x_origin;
 int ts_y_origin;
        Font font;
 int subwindow_mode;
 int graphics_exposures;
 int clip_x_origin;
 int clip_y_origin;
 Pixmap clip_mask;
 int dash_offset;
 char dashes;
} XGCValues;






typedef struct _XGC







*GC;




typedef struct {
 XExtData *ext_data;
 VisualID visualid;

 int c_class;



 unsigned long red_mask, green_mask, blue_mask;
 int bits_per_rgb;
 int map_entries;
} Visual;




typedef struct {
 int depth;
 int nvisuals;
 Visual *visuals;
} Depth;







struct _XDisplay;

typedef struct {
 XExtData *ext_data;
 struct _XDisplay *display;
 Window root;
 int width, height;
 int mwidth, mheight;
 int ndepths;
 Depth *depths;
 int root_depth;
 Visual *root_visual;
 GC default_gc;
 Colormap cmap;
 unsigned long white_pixel;
 unsigned long black_pixel;
 int max_maps, min_maps;
 int backing_store;
 int save_unders;
 long root_input_mask;
} Screen;




typedef struct {
 XExtData *ext_data;
 int depth;
 int bits_per_pixel;
 int scanline_pad;
} ScreenFormat;




typedef struct {
    Pixmap background_pixmap;
    unsigned long background_pixel;
    Pixmap border_pixmap;
    unsigned long border_pixel;
    int bit_gravity;
    int win_gravity;
    int backing_store;
    unsigned long backing_planes;
    unsigned long backing_pixel;
    int save_under;
    long event_mask;
    long do_not_propagate_mask;
    int override_redirect;
    Colormap colormap;
    Cursor cursor;
} XSetWindowAttributes;

typedef struct {
    int x, y;
    int width, height;
    int border_width;
    int depth;
    Visual *visual;
    Window root;

    int c_class;



    int bit_gravity;
    int win_gravity;
    int backing_store;
    unsigned long backing_planes;
    unsigned long backing_pixel;
    int save_under;
    Colormap colormap;
    int map_installed;
    int map_state;
    long all_event_masks;
    long your_event_mask;
    long do_not_propagate_mask;
    int override_redirect;
    Screen *screen;
} XWindowAttributes;






typedef struct {
 int family;
 int length;
 char *address;
} XHostAddress;




typedef struct {
 int typelength;
 int valuelength;
 char *type;
 char *value;
} XServerInterpretedAddress;




typedef struct _XImage {
    int width, height;
    int xoffset;
    int format;
    char *data;
    int byte_order;
    int bitmap_unit;
    int bitmap_bit_order;
    int bitmap_pad;
    int depth;
    int bytes_per_line;
    int bits_per_pixel;
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    XPointer obdata;
    struct funcs {
 struct _XImage *(*create_image)(
  struct _XDisplay* ,
  Visual* ,
  unsigned int ,
  int ,
  int ,
  char* ,
  unsigned int ,
  unsigned int ,
  int ,
  int );
 int (*destroy_image) (struct _XImage *);
 unsigned long (*get_pixel) (struct _XImage *, int, int);
 int (*put_pixel) (struct _XImage *, int, int, unsigned long);
 struct _XImage *(*sub_image)(struct _XImage *, int, int, unsigned int, unsigned int);
 int (*add_pixel) (struct _XImage *, long);
 } f;
} XImage;




typedef struct {
    int x, y;
    int width, height;
    int border_width;
    Window sibling;
    int stack_mode;
} XWindowChanges;




typedef struct {
 unsigned long pixel;
 unsigned short red, green, blue;
 char flags;
 char pad;
} XColor;






typedef struct {
    short x1, y1, x2, y2;
} XSegment;

typedef struct {
    short x, y;
} XPoint;

typedef struct {
    short x, y;
    unsigned short width, height;
} XRectangle;

typedef struct {
    short x, y;
    unsigned short width, height;
    short angle1, angle2;
} XArc;




typedef struct {
        int key_click_percent;
        int bell_percent;
        int bell_pitch;
        int bell_duration;
        int led;
        int led_mode;
        int key;
        int auto_repeat_mode;
} XKeyboardControl;



typedef struct {
        int key_click_percent;
 int bell_percent;
 unsigned int bell_pitch, bell_duration;
 unsigned long led_mask;
 int global_auto_repeat;
 char auto_repeats[32];
} XKeyboardState;



typedef struct {
        Time time;
 short x, y;
} XTimeCoord;



typedef struct {
  int max_keypermod;
  KeyCode *modifiermap;
} XModifierKeymap;
# 499 "/usr/include/X11/Xlib.h" 3 4
typedef struct _XDisplay Display;


struct _XPrivate;
struct _XrmHashBucketRec;

typedef struct



{
 XExtData *ext_data;
 struct _XPrivate *private1;
 int fd;
 int private2;
 int proto_major_version;
 int proto_minor_version;
 char *vendor;
        XID private3;
 XID private4;
 XID private5;
 int private6;
 XID (*resource_alloc)(
  struct _XDisplay*
 );
 int byte_order;
 int bitmap_unit;
 int bitmap_pad;
 int bitmap_bit_order;
 int nformats;
 ScreenFormat *pixmap_format;
 int private8;
 int release;
 struct _XPrivate *private9, *private10;
 int qlen;
 unsigned long last_request_read;
 unsigned long request;
 XPointer private11;
 XPointer private12;
 XPointer private13;
 XPointer private14;
 unsigned max_request_size;
 struct _XrmHashBucketRec *db;
 int (*private15)(
  struct _XDisplay*
  );
 char *display_name;
 int default_screen;
 int nscreens;
 Screen *screens;
 unsigned long motion_buffer;
 unsigned long private16;
 int min_keycode;
 int max_keycode;
 XPointer private17;
 XPointer private18;
 int private19;
 char *xdefaults;

}



*_XPrivDisplay;






typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Window root;
 Window subwindow;
 Time time;
 int x, y;
 int x_root, y_root;
 unsigned int state;
 unsigned int keycode;
 int same_screen;
} XKeyEvent;
typedef XKeyEvent XKeyPressedEvent;
typedef XKeyEvent XKeyReleasedEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Window root;
 Window subwindow;
 Time time;
 int x, y;
 int x_root, y_root;
 unsigned int state;
 unsigned int button;
 int same_screen;
} XButtonEvent;
typedef XButtonEvent XButtonPressedEvent;
typedef XButtonEvent XButtonReleasedEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Window root;
 Window subwindow;
 Time time;
 int x, y;
 int x_root, y_root;
 unsigned int state;
 char is_hint;
 int same_screen;
} XMotionEvent;
typedef XMotionEvent XPointerMovedEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Window root;
 Window subwindow;
 Time time;
 int x, y;
 int x_root, y_root;
 int mode;
 int detail;




 int same_screen;
 int focus;
 unsigned int state;
} XCrossingEvent;
typedef XCrossingEvent XEnterWindowEvent;
typedef XCrossingEvent XLeaveWindowEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int mode;

 int detail;





} XFocusChangeEvent;
typedef XFocusChangeEvent XFocusInEvent;
typedef XFocusChangeEvent XFocusOutEvent;


typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 char key_vector[32];
} XKeymapEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int x, y;
 int width, height;
 int count;
} XExposeEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Drawable drawable;
 int x, y;
 int width, height;
 int count;
 int major_code;
 int minor_code;
} XGraphicsExposeEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Drawable drawable;
 int major_code;
 int minor_code;
} XNoExposeEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int state;
} XVisibilityEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window parent;
 Window window;
 int x, y;
 int width, height;
 int border_width;
 int override_redirect;
} XCreateWindowEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
} XDestroyWindowEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int from_configure;
} XUnmapEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int override_redirect;
} XMapEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window parent;
 Window window;
} XMapRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 Window parent;
 int x, y;
 int override_redirect;
} XReparentEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int x, y;
 int width, height;
 int border_width;
 Window above;
 int override_redirect;
} XConfigureEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int x, y;
} XGravityEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int width, height;
} XResizeRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window parent;
 Window window;
 int x, y;
 int width, height;
 int border_width;
 Window above;
 int detail;
 unsigned long value_mask;
} XConfigureRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int place;
} XCirculateEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window parent;
 Window window;
 int place;
} XCirculateRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Atom atom;
 Time time;
 int state;
} XPropertyEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Atom selection;
 Time time;
} XSelectionClearEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window owner;
 Window requestor;
 Atom selection;
 Atom target;
 Atom property;
 Time time;
} XSelectionRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window requestor;
 Atom selection;
 Atom target;
 Atom property;
 Time time;
} XSelectionEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Colormap colormap;

 int c_new;



 int state;
} XColormapEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Atom message_type;
 int format;
 union {
  char b[20];
  short s[10];
  long l[5];
  } data;
} XClientMessageEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int request;

 int first_keycode;
 int count;
} XMappingEvent;

typedef struct {
 int type;
 Display *display;
 XID resourceid;
 unsigned long serial;
 unsigned char error_code;
 unsigned char request_code;
 unsigned char minor_code;
} XErrorEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
} XAnyEvent;







typedef struct
    {
    int type;
    unsigned long serial;
    int send_event;
    Display *display;
    int extension;
    int evtype;
    } XGenericEvent;

typedef struct {
    int type;
    unsigned long serial;
    int send_event;
    Display *display;
    int extension;
    int evtype;
    unsigned int cookie;
    void *data;
} XGenericEventCookie;





typedef union _XEvent {
        int type;
 XAnyEvent xany;
 XKeyEvent xkey;
 XButtonEvent xbutton;
 XMotionEvent xmotion;
 XCrossingEvent xcrossing;
 XFocusChangeEvent xfocus;
 XExposeEvent xexpose;
 XGraphicsExposeEvent xgraphicsexpose;
 XNoExposeEvent xnoexpose;
 XVisibilityEvent xvisibility;
 XCreateWindowEvent xcreatewindow;
 XDestroyWindowEvent xdestroywindow;
 XUnmapEvent xunmap;
 XMapEvent xmap;
 XMapRequestEvent xmaprequest;
 XReparentEvent xreparent;
 XConfigureEvent xconfigure;
 XGravityEvent xgravity;
 XResizeRequestEvent xresizerequest;
 XConfigureRequestEvent xconfigurerequest;
 XCirculateEvent xcirculate;
 XCirculateRequestEvent xcirculaterequest;
 XPropertyEvent xproperty;
 XSelectionClearEvent xselectionclear;
 XSelectionRequestEvent xselectionrequest;
 XSelectionEvent xselection;
 XColormapEvent xcolormap;
 XClientMessageEvent xclient;
 XMappingEvent xmapping;
 XErrorEvent xerror;
 XKeymapEvent xkeymap;
 XGenericEvent xgeneric;
 XGenericEventCookie xcookie;
 long pad[24];
} XEvent;







typedef struct {
    short lbearing;
    short rbearing;
    short width;
    short ascent;
    short descent;
    unsigned short attributes;
} XCharStruct;





typedef struct {
    Atom name;
    unsigned long card32;
} XFontProp;

typedef struct {
    XExtData *ext_data;
    Font fid;
    unsigned direction;
    unsigned min_char_or_byte2;
    unsigned max_char_or_byte2;
    unsigned min_byte1;
    unsigned max_byte1;
    int all_chars_exist;
    unsigned default_char;
    int n_properties;
    XFontProp *properties;
    XCharStruct min_bounds;
    XCharStruct max_bounds;
    XCharStruct *per_char;
    int ascent;
    int descent;
} XFontStruct;




typedef struct {
    char *chars;
    int nchars;
    int delta;
    Font font;
} XTextItem;

typedef struct {
    unsigned char byte1;
    unsigned char byte2;
} XChar2b;

typedef struct {
    XChar2b *chars;
    int nchars;
    int delta;
    Font font;
} XTextItem16;


typedef union { Display *display;
  GC gc;
  Visual *visual;
  Screen *screen;
  ScreenFormat *pixmap_format;
  XFontStruct *font; } XEDataObject;

typedef struct {
    XRectangle max_ink_extent;
    XRectangle max_logical_extent;
} XFontSetExtents;





typedef struct _XOM *XOM;
typedef struct _XOC *XOC, *XFontSet;

typedef struct {
    char *chars;
    int nchars;
    int delta;
    XFontSet font_set;
} XmbTextItem;

typedef struct {
    wchar_t *chars;
    int nchars;
    int delta;
    XFontSet font_set;
} XwcTextItem;
# 1133 "/usr/include/X11/Xlib.h" 3 4
typedef struct {
    int charset_count;
    char **charset_list;
} XOMCharSetList;

typedef enum {
    XOMOrientation_LTR_TTB,
    XOMOrientation_RTL_TTB,
    XOMOrientation_TTB_LTR,
    XOMOrientation_TTB_RTL,
    XOMOrientation_Context
} XOrientation;

typedef struct {
    int num_orientation;
    XOrientation *orientation;
} XOMOrientation;

typedef struct {
    int num_font;
    XFontStruct **font_struct_list;
    char **font_name_list;
} XOMFontInfo;

typedef struct _XIM *XIM;
typedef struct _XIC *XIC;

typedef void (*XIMProc)(
    XIM,
    XPointer,
    XPointer
);

typedef int (*XICProc)(
    XIC,
    XPointer,
    XPointer
);

typedef void (*XIDProc)(
    Display*,
    XPointer,
    XPointer
);

typedef unsigned long XIMStyle;

typedef struct {
    unsigned short count_styles;
    XIMStyle *supported_styles;
} XIMStyles;
# 1245 "/usr/include/X11/Xlib.h" 3 4
typedef void *XVaNestedList;

typedef struct {
    XPointer client_data;
    XIMProc callback;
} XIMCallback;

typedef struct {
    XPointer client_data;
    XICProc callback;
} XICCallback;

typedef unsigned long XIMFeedback;
# 1269 "/usr/include/X11/Xlib.h" 3 4
typedef struct _XIMText {
    unsigned short length;
    XIMFeedback *feedback;
    int encoding_is_wchar;
    union {
 char *multi_byte;
 wchar_t *wide_char;
    } string;
} XIMText;

typedef unsigned long XIMPreeditState;





typedef struct _XIMPreeditStateNotifyCallbackStruct {
    XIMPreeditState state;
} XIMPreeditStateNotifyCallbackStruct;

typedef unsigned long XIMResetState;




typedef unsigned long XIMStringConversionFeedback;
# 1303 "/usr/include/X11/Xlib.h" 3 4
typedef struct _XIMStringConversionText {
    unsigned short length;
    XIMStringConversionFeedback *feedback;
    int encoding_is_wchar;
    union {
 char *mbs;
 wchar_t *wcs;
    } string;
} XIMStringConversionText;

typedef unsigned short XIMStringConversionPosition;

typedef unsigned short XIMStringConversionType;






typedef unsigned short XIMStringConversionOperation;




typedef enum {
    XIMForwardChar, XIMBackwardChar,
    XIMForwardWord, XIMBackwardWord,
    XIMCaretUp, XIMCaretDown,
    XIMNextLine, XIMPreviousLine,
    XIMLineStart, XIMLineEnd,
    XIMAbsolutePosition,
    XIMDontChange
} XIMCaretDirection;

typedef struct _XIMStringConversionCallbackStruct {
    XIMStringConversionPosition position;
    XIMCaretDirection direction;
    XIMStringConversionOperation operation;
    unsigned short factor;
    XIMStringConversionText *text;
} XIMStringConversionCallbackStruct;

typedef struct _XIMPreeditDrawCallbackStruct {
    int caret;
    int chg_first;
    int chg_length;
    XIMText *text;
} XIMPreeditDrawCallbackStruct;

typedef enum {
    XIMIsInvisible,
    XIMIsPrimary,
    XIMIsSecondary
} XIMCaretStyle;

typedef struct _XIMPreeditCaretCallbackStruct {
    int position;
    XIMCaretDirection direction;
    XIMCaretStyle style;
} XIMPreeditCaretCallbackStruct;

typedef enum {
    XIMTextType,
    XIMBitmapType
} XIMStatusDataType;

typedef struct _XIMStatusDrawCallbackStruct {
    XIMStatusDataType type;
    union {
 XIMText *text;
 Pixmap bitmap;
    } data;
} XIMStatusDrawCallbackStruct;

typedef struct _XIMHotKeyTrigger {
    KeySym keysym;
    int modifier;
    int modifier_mask;
} XIMHotKeyTrigger;

typedef struct _XIMHotKeyTriggers {
    int num_hot_key;
    XIMHotKeyTrigger *key;
} XIMHotKeyTriggers;

typedef unsigned long XIMHotKeyState;




typedef struct {
    unsigned short count_values;
    char **supported_values;
} XIMValuesList;

extern "C" {





extern int _Xdebug;

extern XFontStruct *XLoadQueryFont(
    Display* ,
    const char*
);

extern XFontStruct *XQueryFont(
    Display* ,
    XID
);


extern XTimeCoord *XGetMotionEvents(
    Display* ,
    Window ,
    Time ,
    Time ,
    int*
);

extern XModifierKeymap *XDeleteModifiermapEntry(
    XModifierKeymap* ,



    KeyCode ,

    int
);

extern XModifierKeymap *XGetModifierMapping(
    Display*
);

extern XModifierKeymap *XInsertModifiermapEntry(
    XModifierKeymap* ,



    KeyCode ,

    int
);

extern XModifierKeymap *XNewModifiermap(
    int
);

extern XImage *XCreateImage(
    Display* ,
    Visual* ,
    unsigned int ,
    int ,
    int ,
    char* ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);
extern int XInitImage(
    XImage*
);
extern XImage *XGetImage(
    Display* ,
    Drawable ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    int
);
extern XImage *XGetSubImage(
    Display* ,
    Drawable ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    int ,
    XImage* ,
    int ,
    int
);




extern Display *XOpenDisplay(
    const char*
);

extern void XrmInitialize(
    void
);

extern char *XFetchBytes(
    Display* ,
    int*
);
extern char *XFetchBuffer(
    Display* ,
    int* ,
    int
);
extern char *XGetAtomName(
    Display* ,
    Atom
);
extern int XGetAtomNames(
    Display* ,
    Atom* ,
    int ,
    char**
);
extern char *XGetDefault(
    Display* ,
    const char* ,
    const char*
);
extern char *XDisplayName(
    const char*
);
extern char *XKeysymToString(
    KeySym
);

extern int (*XSynchronize(
    Display* ,
    int
))(
    Display*
);
extern int (*XSetAfterFunction(
    Display* ,
    int (*) (
      Display*
            )
))(
    Display*
);
extern Atom XInternAtom(
    Display* ,
    const char* ,
    int
);
extern int XInternAtoms(
    Display* ,
    char** ,
    int ,
    int ,
    Atom*
);
extern Colormap XCopyColormapAndFree(
    Display* ,
    Colormap
);
extern Colormap XCreateColormap(
    Display* ,
    Window ,
    Visual* ,
    int
);
extern Cursor XCreatePixmapCursor(
    Display* ,
    Pixmap ,
    Pixmap ,
    XColor* ,
    XColor* ,
    unsigned int ,
    unsigned int
);
extern Cursor XCreateGlyphCursor(
    Display* ,
    Font ,
    Font ,
    unsigned int ,
    unsigned int ,
    XColor const * ,
    XColor const *
);
extern Cursor XCreateFontCursor(
    Display* ,
    unsigned int
);
extern Font XLoadFont(
    Display* ,
    const char*
);
extern GC XCreateGC(
    Display* ,
    Drawable ,
    unsigned long ,
    XGCValues*
);
extern GContext XGContextFromGC(
    GC
);
extern void XFlushGC(
    Display* ,
    GC
);
extern Pixmap XCreatePixmap(
    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int
);
extern Pixmap XCreateBitmapFromData(
    Display* ,
    Drawable ,
    const char* ,
    unsigned int ,
    unsigned int
);
extern Pixmap XCreatePixmapFromBitmapData(
    Display* ,
    Drawable ,
    char* ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    unsigned long ,
    unsigned int
);
extern Window XCreateSimpleWindow(
    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    unsigned long
);
extern Window XGetSelectionOwner(
    Display* ,
    Atom
);
extern Window XCreateWindow(
    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    int ,
    unsigned int ,
    Visual* ,
    unsigned long ,
    XSetWindowAttributes*
);
extern Colormap *XListInstalledColormaps(
    Display* ,
    Window ,
    int*
);
extern char **XListFonts(
    Display* ,
    const char* ,
    int ,
    int*
);
extern char **XListFontsWithInfo(
    Display* ,
    const char* ,
    int ,
    int* ,
    XFontStruct**
);
extern char **XGetFontPath(
    Display* ,
    int*
);
extern char **XListExtensions(
    Display* ,
    int*
);
extern Atom *XListProperties(
    Display* ,
    Window ,
    int*
);
extern XHostAddress *XListHosts(
    Display* ,
    int* ,
    int*
);
__attribute__((deprecated))
extern KeySym XKeycodeToKeysym(
    Display* ,



    KeyCode ,

    int
);
extern KeySym XLookupKeysym(
    XKeyEvent* ,
    int
);
extern KeySym *XGetKeyboardMapping(
    Display* ,



    KeyCode ,

    int ,
    int*
);
extern KeySym XStringToKeysym(
    const char*
);
extern long XMaxRequestSize(
    Display*
);
extern long XExtendedMaxRequestSize(
    Display*
);
extern char *XResourceManagerString(
    Display*
);
extern char *XScreenResourceString(
 Screen*
);
extern unsigned long XDisplayMotionBufferSize(
    Display*
);
extern VisualID XVisualIDFromVisual(
    Visual*
);



extern int XInitThreads(
    void
);

extern void XLockDisplay(
    Display*
);

extern void XUnlockDisplay(
    Display*
);



extern XExtCodes *XInitExtension(
    Display* ,
    const char*
);

extern XExtCodes *XAddExtension(
    Display*
);
extern XExtData *XFindOnExtensionList(
    XExtData** ,
    int
);
extern XExtData **XEHeadOfExtensionList(
    XEDataObject
);


extern Window XRootWindow(
    Display* ,
    int
);
extern Window XDefaultRootWindow(
    Display*
);
extern Window XRootWindowOfScreen(
    Screen*
);
extern Visual *XDefaultVisual(
    Display* ,
    int
);
extern Visual *XDefaultVisualOfScreen(
    Screen*
);
extern GC XDefaultGC(
    Display* ,
    int
);
extern GC XDefaultGCOfScreen(
    Screen*
);
extern unsigned long XBlackPixel(
    Display* ,
    int
);
extern unsigned long XWhitePixel(
    Display* ,
    int
);
extern unsigned long XAllPlanes(
    void
);
extern unsigned long XBlackPixelOfScreen(
    Screen*
);
extern unsigned long XWhitePixelOfScreen(
    Screen*
);
extern unsigned long XNextRequest(
    Display*
);
extern unsigned long XLastKnownRequestProcessed(
    Display*
);
extern char *XServerVendor(
    Display*
);
extern char *XDisplayString(
    Display*
);
extern Colormap XDefaultColormap(
    Display* ,
    int
);
extern Colormap XDefaultColormapOfScreen(
    Screen*
);
extern Display *XDisplayOfScreen(
    Screen*
);
extern Screen *XScreenOfDisplay(
    Display* ,
    int
);
extern Screen *XDefaultScreenOfDisplay(
    Display*
);
extern long XEventMaskOfScreen(
    Screen*
);

extern int XScreenNumberOfScreen(
    Screen*
);

typedef int (*XErrorHandler) (
    Display* ,
    XErrorEvent*
);

extern XErrorHandler XSetErrorHandler (
    XErrorHandler
);


typedef int (*XIOErrorHandler) (
    Display*
);

extern XIOErrorHandler XSetIOErrorHandler (
    XIOErrorHandler
);


extern XPixmapFormatValues *XListPixmapFormats(
    Display* ,
    int*
);
extern int *XListDepths(
    Display* ,
    int ,
    int*
);



extern int XReconfigureWMWindow(
    Display* ,
    Window ,
    int ,
    unsigned int ,
    XWindowChanges*
);

extern int XGetWMProtocols(
    Display* ,
    Window ,
    Atom** ,
    int*
);
extern int XSetWMProtocols(
    Display* ,
    Window ,
    Atom* ,
    int
);
extern int XIconifyWindow(
    Display* ,
    Window ,
    int
);
extern int XWithdrawWindow(
    Display* ,
    Window ,
    int
);
extern int XGetCommand(
    Display* ,
    Window ,
    char*** ,
    int*
);
extern int XGetWMColormapWindows(
    Display* ,
    Window ,
    Window** ,
    int*
);
extern int XSetWMColormapWindows(
    Display* ,
    Window ,
    Window* ,
    int
);
extern void XFreeStringList(
    char**
);
extern int XSetTransientForHint(
    Display* ,
    Window ,
    Window
);



extern int XActivateScreenSaver(
    Display*
);

extern int XAddHost(
    Display* ,
    XHostAddress*
);

extern int XAddHosts(
    Display* ,
    XHostAddress* ,
    int
);

extern int XAddToExtensionList(
    struct _XExtData** ,
    XExtData*
);

extern int XAddToSaveSet(
    Display* ,
    Window
);

extern int XAllocColor(
    Display* ,
    Colormap ,
    XColor*
);

extern int XAllocColorCells(
    Display* ,
    Colormap ,
    int ,
    unsigned long* ,
    unsigned int ,
    unsigned long* ,
    unsigned int
);

extern int XAllocColorPlanes(
    Display* ,
    Colormap ,
    int ,
    unsigned long* ,
    int ,
    int ,
    int ,
    int ,
    unsigned long* ,
    unsigned long* ,
    unsigned long*
);

extern int XAllocNamedColor(
    Display* ,
    Colormap ,
    const char* ,
    XColor* ,
    XColor*
);

extern int XAllowEvents(
    Display* ,
    int ,
    Time
);

extern int XAutoRepeatOff(
    Display*
);

extern int XAutoRepeatOn(
    Display*
);

extern int XBell(
    Display* ,
    int
);

extern int XBitmapBitOrder(
    Display*
);

extern int XBitmapPad(
    Display*
);

extern int XBitmapUnit(
    Display*
);

extern int XCellsOfScreen(
    Screen*
);

extern int XChangeActivePointerGrab(
    Display* ,
    unsigned int ,
    Cursor ,
    Time
);

extern int XChangeGC(
    Display* ,
    GC ,
    unsigned long ,
    XGCValues*
);

extern int XChangeKeyboardControl(
    Display* ,
    unsigned long ,
    XKeyboardControl*
);

extern int XChangeKeyboardMapping(
    Display* ,
    int ,
    int ,
    KeySym* ,
    int
);

extern int XChangePointerControl(
    Display* ,
    int ,
    int ,
    int ,
    int ,
    int
);

extern int XChangeProperty(
    Display* ,
    Window ,
    Atom ,
    Atom ,
    int ,
    int ,
    const unsigned char* ,
    int
);

extern int XChangeSaveSet(
    Display* ,
    Window ,
    int
);

extern int XChangeWindowAttributes(
    Display* ,
    Window ,
    unsigned long ,
    XSetWindowAttributes*
);

extern int XCheckIfEvent(
    Display* ,
    XEvent* ,
    int (*) (
        Display* ,
               XEvent* ,
               XPointer
             ) ,
    XPointer
);

extern int XCheckMaskEvent(
    Display* ,
    long ,
    XEvent*
);

extern int XCheckTypedEvent(
    Display* ,
    int ,
    XEvent*
);

extern int XCheckTypedWindowEvent(
    Display* ,
    Window ,
    int ,
    XEvent*
);

extern int XCheckWindowEvent(
    Display* ,
    Window ,
    long ,
    XEvent*
);

extern int XCirculateSubwindows(
    Display* ,
    Window ,
    int
);

extern int XCirculateSubwindowsDown(
    Display* ,
    Window
);

extern int XCirculateSubwindowsUp(
    Display* ,
    Window
);

extern int XClearArea(
    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int
);

extern int XClearWindow(
    Display* ,
    Window
);

extern int XCloseDisplay(
    Display*
);

extern int XConfigureWindow(
    Display* ,
    Window ,
    unsigned int ,
    XWindowChanges*
);

extern int XConnectionNumber(
    Display*
);

extern int XConvertSelection(
    Display* ,
    Atom ,
    Atom ,
    Atom ,
    Window ,
    Time
);

extern int XCopyArea(
    Display* ,
    Drawable ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XCopyGC(
    Display* ,
    GC ,
    unsigned long ,
    GC
);

extern int XCopyPlane(
    Display* ,
    Drawable ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int ,
    unsigned long
);

extern int XDefaultDepth(
    Display* ,
    int
);

extern int XDefaultDepthOfScreen(
    Screen*
);

extern int XDefaultScreen(
    Display*
);

extern int XDefineCursor(
    Display* ,
    Window ,
    Cursor
);

extern int XDeleteProperty(
    Display* ,
    Window ,
    Atom
);

extern int XDestroyWindow(
    Display* ,
    Window
);

extern int XDestroySubwindows(
    Display* ,
    Window
);

extern int XDoesBackingStore(
    Screen*
);

extern int XDoesSaveUnders(
    Screen*
);

extern int XDisableAccessControl(
    Display*
);


extern int XDisplayCells(
    Display* ,
    int
);

extern int XDisplayHeight(
    Display* ,
    int
);

extern int XDisplayHeightMM(
    Display* ,
    int
);

extern int XDisplayKeycodes(
    Display* ,
    int* ,
    int*
);

extern int XDisplayPlanes(
    Display* ,
    int
);

extern int XDisplayWidth(
    Display* ,
    int
);

extern int XDisplayWidthMM(
    Display* ,
    int
);

extern int XDrawArc(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XDrawArcs(
    Display* ,
    Drawable ,
    GC ,
    XArc* ,
    int
);

extern int XDrawImageString(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern int XDrawImageString16(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const XChar2b* ,
    int
);

extern int XDrawLine(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    int ,
    int
);

extern int XDrawLines(
    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int
);

extern int XDrawPoint(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int
);

extern int XDrawPoints(
    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int
);

extern int XDrawRectangle(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XDrawRectangles(
    Display* ,
    Drawable ,
    GC ,
    XRectangle* ,
    int
);

extern int XDrawSegments(
    Display* ,
    Drawable ,
    GC ,
    XSegment* ,
    int
);

extern int XDrawString(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern int XDrawString16(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const XChar2b* ,
    int
);

extern int XDrawText(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XTextItem* ,
    int
);

extern int XDrawText16(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XTextItem16* ,
    int
);

extern int XEnableAccessControl(
    Display*
);

extern int XEventsQueued(
    Display* ,
    int
);

extern int XFetchName(
    Display* ,
    Window ,
    char**
);

extern int XFillArc(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XFillArcs(
    Display* ,
    Drawable ,
    GC ,
    XArc* ,
    int
);

extern int XFillPolygon(
    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int ,
    int
);

extern int XFillRectangle(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XFillRectangles(
    Display* ,
    Drawable ,
    GC ,
    XRectangle* ,
    int
);

extern int XFlush(
    Display*
);

extern int XForceScreenSaver(
    Display* ,
    int
);

extern int XFree(
    void*
);

extern int XFreeColormap(
    Display* ,
    Colormap
);

extern int XFreeColors(
    Display* ,
    Colormap ,
    unsigned long* ,
    int ,
    unsigned long
);

extern int XFreeCursor(
    Display* ,
    Cursor
);

extern int XFreeExtensionList(
    char**
);

extern int XFreeFont(
    Display* ,
    XFontStruct*
);

extern int XFreeFontInfo(
    char** ,
    XFontStruct* ,
    int
);

extern int XFreeFontNames(
    char**
);

extern int XFreeFontPath(
    char**
);

extern int XFreeGC(
    Display* ,
    GC
);

extern int XFreeModifiermap(
    XModifierKeymap*
);

extern int XFreePixmap(
    Display* ,
    Pixmap
);

extern int XGeometry(
    Display* ,
    int ,
    const char* ,
    const char* ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    int ,
    int ,
    int* ,
    int* ,
    int* ,
    int*
);

extern int XGetErrorDatabaseText(
    Display* ,
    const char* ,
    const char* ,
    const char* ,
    char* ,
    int
);

extern int XGetErrorText(
    Display* ,
    int ,
    char* ,
    int
);

extern int XGetFontProperty(
    XFontStruct* ,
    Atom ,
    unsigned long*
);

extern int XGetGCValues(
    Display* ,
    GC ,
    unsigned long ,
    XGCValues*
);

extern int XGetGeometry(
    Display* ,
    Drawable ,
    Window* ,
    int* ,
    int* ,
    unsigned int* ,
    unsigned int* ,
    unsigned int* ,
    unsigned int*
);

extern int XGetIconName(
    Display* ,
    Window ,
    char**
);

extern int XGetInputFocus(
    Display* ,
    Window* ,
    int*
);

extern int XGetKeyboardControl(
    Display* ,
    XKeyboardState*
);

extern int XGetPointerControl(
    Display* ,
    int* ,
    int* ,
    int*
);

extern int XGetPointerMapping(
    Display* ,
    unsigned char* ,
    int
);

extern int XGetScreenSaver(
    Display* ,
    int* ,
    int* ,
    int* ,
    int*
);

extern int XGetTransientForHint(
    Display* ,
    Window ,
    Window*
);

extern int XGetWindowProperty(
    Display* ,
    Window ,
    Atom ,
    long ,
    long ,
    int ,
    Atom ,
    Atom* ,
    int* ,
    unsigned long* ,
    unsigned long* ,
    unsigned char**
);

extern int XGetWindowAttributes(
    Display* ,
    Window ,
    XWindowAttributes*
);

extern int XGrabButton(
    Display* ,
    unsigned int ,
    unsigned int ,
    Window ,
    int ,
    unsigned int ,
    int ,
    int ,
    Window ,
    Cursor
);

extern int XGrabKey(
    Display* ,
    int ,
    unsigned int ,
    Window ,
    int ,
    int ,
    int
);

extern int XGrabKeyboard(
    Display* ,
    Window ,
    int ,
    int ,
    int ,
    Time
);

extern int XGrabPointer(
    Display* ,
    Window ,
    int ,
    unsigned int ,
    int ,
    int ,
    Window ,
    Cursor ,
    Time
);

extern int XGrabServer(
    Display*
);

extern int XHeightMMOfScreen(
    Screen*
);

extern int XHeightOfScreen(
    Screen*
);

extern int XIfEvent(
    Display* ,
    XEvent* ,
    int (*) (
        Display* ,
               XEvent* ,
               XPointer
             ) ,
    XPointer
);

extern int XImageByteOrder(
    Display*
);

extern int XInstallColormap(
    Display* ,
    Colormap
);

extern KeyCode XKeysymToKeycode(
    Display* ,
    KeySym
);

extern int XKillClient(
    Display* ,
    XID
);

extern int XLookupColor(
    Display* ,
    Colormap ,
    const char* ,
    XColor* ,
    XColor*
);

extern int XLowerWindow(
    Display* ,
    Window
);

extern int XMapRaised(
    Display* ,
    Window
);

extern int XMapSubwindows(
    Display* ,
    Window
);

extern int XMapWindow(
    Display* ,
    Window
);

extern int XMaskEvent(
    Display* ,
    long ,
    XEvent*
);

extern int XMaxCmapsOfScreen(
    Screen*
);

extern int XMinCmapsOfScreen(
    Screen*
);

extern int XMoveResizeWindow(
    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XMoveWindow(
    Display* ,
    Window ,
    int ,
    int
);

extern int XNextEvent(
    Display* ,
    XEvent*
);

extern int XNoOp(
    Display*
);

extern int XParseColor(
    Display* ,
    Colormap ,
    const char* ,
    XColor*
);

extern int XParseGeometry(
    const char* ,
    int* ,
    int* ,
    unsigned int* ,
    unsigned int*
);

extern int XPeekEvent(
    Display* ,
    XEvent*
);

extern int XPeekIfEvent(
    Display* ,
    XEvent* ,
    int (*) (
        Display* ,
               XEvent* ,
               XPointer
             ) ,
    XPointer
);

extern int XPending(
    Display*
);

extern int XPlanesOfScreen(
    Screen*
);

extern int XProtocolRevision(
    Display*
);

extern int XProtocolVersion(
    Display*
);


extern int XPutBackEvent(
    Display* ,
    XEvent*
);

extern int XPutImage(
    Display* ,
    Drawable ,
    GC ,
    XImage* ,
    int ,
    int ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XQLength(
    Display*
);

extern int XQueryBestCursor(
    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*
);

extern int XQueryBestSize(
    Display* ,
    int ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*
);

extern int XQueryBestStipple(
    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*
);

extern int XQueryBestTile(
    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*
);

extern int XQueryColor(
    Display* ,
    Colormap ,
    XColor*
);

extern int XQueryColors(
    Display* ,
    Colormap ,
    XColor* ,
    int
);

extern int XQueryExtension(
    Display* ,
    const char* ,
    int* ,
    int* ,
    int*
);

extern int XQueryKeymap(
    Display* ,
    char [32]
);

extern int XQueryPointer(
    Display* ,
    Window ,
    Window* ,
    Window* ,
    int* ,
    int* ,
    int* ,
    int* ,
    unsigned int*
);

extern int XQueryTextExtents(
    Display* ,
    XID ,
    const char* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*
);

extern int XQueryTextExtents16(
    Display* ,
    XID ,
    const XChar2b* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*
);

extern int XQueryTree(
    Display* ,
    Window ,
    Window* ,
    Window* ,
    Window** ,
    unsigned int*
);

extern int XRaiseWindow(
    Display* ,
    Window
);

extern int XReadBitmapFile(
    Display* ,
    Drawable ,
    const char* ,
    unsigned int* ,
    unsigned int* ,
    Pixmap* ,
    int* ,
    int*
);

extern int XReadBitmapFileData(
    const char* ,
    unsigned int* ,
    unsigned int* ,
    unsigned char** ,
    int* ,
    int*
);

extern int XRebindKeysym(
    Display* ,
    KeySym ,
    KeySym* ,
    int ,
    const unsigned char* ,
    int
);

extern int XRecolorCursor(
    Display* ,
    Cursor ,
    XColor* ,
    XColor*
);

extern int XRefreshKeyboardMapping(
    XMappingEvent*
);

extern int XRemoveFromSaveSet(
    Display* ,
    Window
);

extern int XRemoveHost(
    Display* ,
    XHostAddress*
);

extern int XRemoveHosts(
    Display* ,
    XHostAddress* ,
    int
);

extern int XReparentWindow(
    Display* ,
    Window ,
    Window ,
    int ,
    int
);

extern int XResetScreenSaver(
    Display*
);

extern int XResizeWindow(
    Display* ,
    Window ,
    unsigned int ,
    unsigned int
);

extern int XRestackWindows(
    Display* ,
    Window* ,
    int
);

extern int XRotateBuffers(
    Display* ,
    int
);

extern int XRotateWindowProperties(
    Display* ,
    Window ,
    Atom* ,
    int ,
    int
);

extern int XScreenCount(
    Display*
);

extern int XSelectInput(
    Display* ,
    Window ,
    long
);

extern int XSendEvent(
    Display* ,
    Window ,
    int ,
    long ,
    XEvent*
);

extern int XSetAccessControl(
    Display* ,
    int
);

extern int XSetArcMode(
    Display* ,
    GC ,
    int
);

extern int XSetBackground(
    Display* ,
    GC ,
    unsigned long
);

extern int XSetClipMask(
    Display* ,
    GC ,
    Pixmap
);

extern int XSetClipOrigin(
    Display* ,
    GC ,
    int ,
    int
);

extern int XSetClipRectangles(
    Display* ,
    GC ,
    int ,
    int ,
    XRectangle* ,
    int ,
    int
);

extern int XSetCloseDownMode(
    Display* ,
    int
);

extern int XSetCommand(
    Display* ,
    Window ,
    char** ,
    int
);

extern int XSetDashes(
    Display* ,
    GC ,
    int ,
    const char* ,
    int
);

extern int XSetFillRule(
    Display* ,
    GC ,
    int
);

extern int XSetFillStyle(
    Display* ,
    GC ,
    int
);

extern int XSetFont(
    Display* ,
    GC ,
    Font
);

extern int XSetFontPath(
    Display* ,
    char** ,
    int
);

extern int XSetForeground(
    Display* ,
    GC ,
    unsigned long
);

extern int XSetFunction(
    Display* ,
    GC ,
    int
);

extern int XSetGraphicsExposures(
    Display* ,
    GC ,
    int
);

extern int XSetIconName(
    Display* ,
    Window ,
    const char*
);

extern int XSetInputFocus(
    Display* ,
    Window ,
    int ,
    Time
);

extern int XSetLineAttributes(
    Display* ,
    GC ,
    unsigned int ,
    int ,
    int ,
    int
);

extern int XSetModifierMapping(
    Display* ,
    XModifierKeymap*
);

extern int XSetPlaneMask(
    Display* ,
    GC ,
    unsigned long
);

extern int XSetPointerMapping(
    Display* ,
    const unsigned char* ,
    int
);

extern int XSetScreenSaver(
    Display* ,
    int ,
    int ,
    int ,
    int
);

extern int XSetSelectionOwner(
    Display* ,
    Atom ,
    Window ,
    Time
);

extern int XSetState(
    Display* ,
    GC ,
    unsigned long ,
    unsigned long ,
    int ,
    unsigned long
);

extern int XSetStipple(
    Display* ,
    GC ,
    Pixmap
);

extern int XSetSubwindowMode(
    Display* ,
    GC ,
    int
);

extern int XSetTSOrigin(
    Display* ,
    GC ,
    int ,
    int
);

extern int XSetTile(
    Display* ,
    GC ,
    Pixmap
);

extern int XSetWindowBackground(
    Display* ,
    Window ,
    unsigned long
);

extern int XSetWindowBackgroundPixmap(
    Display* ,
    Window ,
    Pixmap
);

extern int XSetWindowBorder(
    Display* ,
    Window ,
    unsigned long
);

extern int XSetWindowBorderPixmap(
    Display* ,
    Window ,
    Pixmap
);

extern int XSetWindowBorderWidth(
    Display* ,
    Window ,
    unsigned int
);

extern int XSetWindowColormap(
    Display* ,
    Window ,
    Colormap
);

extern int XStoreBuffer(
    Display* ,
    const char* ,
    int ,
    int
);

extern int XStoreBytes(
    Display* ,
    const char* ,
    int
);

extern int XStoreColor(
    Display* ,
    Colormap ,
    XColor*
);

extern int XStoreColors(
    Display* ,
    Colormap ,
    XColor* ,
    int
);

extern int XStoreName(
    Display* ,
    Window ,
    const char*
);

extern int XStoreNamedColor(
    Display* ,
    Colormap ,
    const char* ,
    unsigned long ,
    int
);

extern int XSync(
    Display* ,
    int
);

extern int XTextExtents(
    XFontStruct* ,
    const char* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*
);

extern int XTextExtents16(
    XFontStruct* ,
    const XChar2b* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*
);

extern int XTextWidth(
    XFontStruct* ,
    const char* ,
    int
);

extern int XTextWidth16(
    XFontStruct* ,
    const XChar2b* ,
    int
);

extern int XTranslateCoordinates(
    Display* ,
    Window ,
    Window ,
    int ,
    int ,
    int* ,
    int* ,
    Window*
);

extern int XUndefineCursor(
    Display* ,
    Window
);

extern int XUngrabButton(
    Display* ,
    unsigned int ,
    unsigned int ,
    Window
);

extern int XUngrabKey(
    Display* ,
    int ,
    unsigned int ,
    Window
);

extern int XUngrabKeyboard(
    Display* ,
    Time
);

extern int XUngrabPointer(
    Display* ,
    Time
);

extern int XUngrabServer(
    Display*
);

extern int XUninstallColormap(
    Display* ,
    Colormap
);

extern int XUnloadFont(
    Display* ,
    Font
);

extern int XUnmapSubwindows(
    Display* ,
    Window
);

extern int XUnmapWindow(
    Display* ,
    Window
);

extern int XVendorRelease(
    Display*
);

extern int XWarpPointer(
    Display* ,
    Window ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XWidthMMOfScreen(
    Screen*
);

extern int XWidthOfScreen(
    Screen*
);

extern int XWindowEvent(
    Display* ,
    Window ,
    long ,
    XEvent*
);

extern int XWriteBitmapFile(
    Display* ,
    const char* ,
    Pixmap ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XSupportsLocale (void);

extern char *XSetLocaleModifiers(
    const char*
);

extern XOM XOpenOM(
    Display* ,
    struct _XrmHashBucketRec* ,
    const char* ,
    const char*
);

extern int XCloseOM(
    XOM
);

extern char *XSetOMValues(
    XOM ,
    ...
) __attribute__ ((__sentinel__(0)));

extern char *XGetOMValues(
    XOM ,
    ...
) __attribute__ ((__sentinel__(0)));

extern Display *XDisplayOfOM(
    XOM
);

extern char *XLocaleOfOM(
    XOM
);

extern XOC XCreateOC(
    XOM ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XDestroyOC(
    XOC
);

extern XOM XOMOfOC(
    XOC
);

extern char *XSetOCValues(
    XOC ,
    ...
) __attribute__ ((__sentinel__(0)));

extern char *XGetOCValues(
    XOC ,
    ...
) __attribute__ ((__sentinel__(0)));

extern XFontSet XCreateFontSet(
    Display* ,
    const char* ,
    char*** ,
    int* ,
    char**
);

extern void XFreeFontSet(
    Display* ,
    XFontSet
);

extern int XFontsOfFontSet(
    XFontSet ,
    XFontStruct*** ,
    char***
);

extern char *XBaseFontNameListOfFontSet(
    XFontSet
);

extern char *XLocaleOfFontSet(
    XFontSet
);

extern int XContextDependentDrawing(
    XFontSet
);

extern int XDirectionalDependentDrawing(
    XFontSet
);

extern int XContextualDrawing(
    XFontSet
);

extern XFontSetExtents *XExtentsOfFontSet(
    XFontSet
);

extern int XmbTextEscapement(
    XFontSet ,
    const char* ,
    int
);

extern int XwcTextEscapement(
    XFontSet ,
    const wchar_t* ,
    int
);

extern int Xutf8TextEscapement(
    XFontSet ,
    const char* ,
    int
);

extern int XmbTextExtents(
    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle*
);

extern int XwcTextExtents(
    XFontSet ,
    const wchar_t* ,
    int ,
    XRectangle* ,
    XRectangle*
);

extern int Xutf8TextExtents(
    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle*
);

extern int XmbTextPerCharExtents(
    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*
);

extern int XwcTextPerCharExtents(
    XFontSet ,
    const wchar_t* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*
);

extern int Xutf8TextPerCharExtents(
    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*
);

extern void XmbDrawText(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XmbTextItem* ,
    int
);

extern void XwcDrawText(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XwcTextItem* ,
    int
);

extern void Xutf8DrawText(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XmbTextItem* ,
    int
);

extern void XmbDrawString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern void XwcDrawString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const wchar_t* ,
    int
);

extern void Xutf8DrawString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern void XmbDrawImageString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern void XwcDrawImageString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const wchar_t* ,
    int
);

extern void Xutf8DrawImageString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern XIM XOpenIM(
    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char*
);

extern int XCloseIM(
    XIM
);

extern char *XGetIMValues(
    XIM , ...
) __attribute__ ((__sentinel__(0)));

extern char *XSetIMValues(
    XIM , ...
) __attribute__ ((__sentinel__(0)));

extern Display *XDisplayOfIM(
    XIM
);

extern char *XLocaleOfIM(
    XIM
);

extern XIC XCreateIC(
    XIM , ...
) __attribute__ ((__sentinel__(0)));

extern void XDestroyIC(
    XIC
);

extern void XSetICFocus(
    XIC
);

extern void XUnsetICFocus(
    XIC
);

extern wchar_t *XwcResetIC(
    XIC
);

extern char *XmbResetIC(
    XIC
);

extern char *Xutf8ResetIC(
    XIC
);

extern char *XSetICValues(
    XIC , ...
) __attribute__ ((__sentinel__(0)));

extern char *XGetICValues(
    XIC , ...
) __attribute__ ((__sentinel__(0)));

extern XIM XIMOfIC(
    XIC
);

extern int XFilterEvent(
    XEvent* ,
    Window
);

extern int XmbLookupString(
    XIC ,
    XKeyPressedEvent* ,
    char* ,
    int ,
    KeySym* ,
    int*
);

extern int XwcLookupString(
    XIC ,
    XKeyPressedEvent* ,
    wchar_t* ,
    int ,
    KeySym* ,
    int*
);

extern int Xutf8LookupString(
    XIC ,
    XKeyPressedEvent* ,
    char* ,
    int ,
    KeySym* ,
    int*
);

extern XVaNestedList XVaCreateNestedList(
    int , ...
) __attribute__ ((__sentinel__(0)));



extern int XRegisterIMInstantiateCallback(
    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char* ,
    XIDProc ,
    XPointer
);

extern int XUnregisterIMInstantiateCallback(
    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char* ,
    XIDProc ,
    XPointer
);

typedef void (*XConnectionWatchProc)(
    Display* ,
    XPointer ,
    int ,
    int ,
    XPointer*
);


extern int XInternalConnectionNumbers(
    Display* ,
    int** ,
    int*
);

extern void XProcessInternalConnection(
    Display* ,
    int
);

extern int XAddConnectionWatch(
    Display* ,
    XConnectionWatchProc ,
    XPointer
);

extern void XRemoveConnectionWatch(
    Display* ,
    XConnectionWatchProc ,
    XPointer
);

extern void XSetAuthorization(
    char * ,
    int ,
    char * ,
    int
);

extern int _Xmbtowc(
    wchar_t * ,




    char * ,
    int

);

extern int _Xwctomb(
    char * ,
    wchar_t
);

extern int XGetEventData(
    Display* ,
    XGenericEventCookie*
);

extern void XFreeEventData(
    Display* ,
    XGenericEventCookie*
);





}
# 209 "../src/CImg.h" 2
# 1 "/usr/include/X11/Xutil.h" 1 3 4
# 54 "/usr/include/X11/Xutil.h" 3 4
# 1 "/usr/include/X11/keysym.h" 1 3 4
# 73 "/usr/include/X11/keysym.h" 3 4
# 1 "/usr/include/X11/keysymdef.h" 1 3 4
# 74 "/usr/include/X11/keysym.h" 2 3 4
# 55 "/usr/include/X11/Xutil.h" 2 3 4
# 81 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
     long flags;
 int x, y;
 int width, height;
 int min_width, min_height;
 int max_width, max_height;
     int width_inc, height_inc;
 struct {
  int x;
  int y;
 } min_aspect, max_aspect;
 int base_width, base_height;
 int win_gravity;
} XSizeHints;
# 119 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
 long flags;
 int input;

 int initial_state;
 Pixmap icon_pixmap;
 Window icon_window;
 int icon_x, icon_y;
 Pixmap icon_mask;
 XID window_group;

} XWMHints;
# 163 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
    unsigned char *value;
    Atom encoding;
    int format;
    unsigned long nitems;
} XTextProperty;





typedef enum {
    XStringStyle,
    XCompoundTextStyle,
    XTextStyle,
    XStdICCTextStyle,

    XUTF8StringStyle
} XICCEncodingStyle;

typedef struct {
 int min_width, min_height;
 int max_width, max_height;
 int width_inc, height_inc;
} XIconSize;

typedef struct {
 char *res_name;
 char *res_class;
} XClassHint;
# 231 "/usr/include/X11/Xutil.h" 3 4
typedef struct _XComposeStatus {
    XPointer compose_ptr;
    int chars_matched;
} XComposeStatus;
# 273 "/usr/include/X11/Xutil.h" 3 4
typedef struct _XRegion *Region;
# 287 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
  Visual *visual;
  VisualID visualid;
  int screen;
  int depth;

  int c_class;



  unsigned long red_mask;
  unsigned long green_mask;
  unsigned long blue_mask;
  int colormap_size;
  int bits_per_rgb;
} XVisualInfo;
# 320 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
 Colormap colormap;
 unsigned long red_max;
 unsigned long red_mult;
 unsigned long green_max;
 unsigned long green_mult;
 unsigned long blue_max;
 unsigned long blue_mult;
 unsigned long base_pixel;
 VisualID visualid;
 XID killid;
} XStandardColormap;
# 357 "/usr/include/X11/Xutil.h" 3 4
typedef int XContext;




extern "C" {



extern XClassHint *XAllocClassHint (
    void
);

extern XIconSize *XAllocIconSize (
    void
);

extern XSizeHints *XAllocSizeHints (
    void
);

extern XStandardColormap *XAllocStandardColormap (
    void
);

extern XWMHints *XAllocWMHints (
    void
);

extern int XClipBox(
    Region ,
    XRectangle*
);

extern Region XCreateRegion(
    void
);

extern const char *XDefaultString (void);

extern int XDeleteContext(
    Display* ,
    XID ,
    XContext
);

extern int XDestroyRegion(
    Region
);

extern int XEmptyRegion(
    Region
);

extern int XEqualRegion(
    Region ,
    Region
);

extern int XFindContext(
    Display* ,
    XID ,
    XContext ,
    XPointer*
);

extern int XGetClassHint(
    Display* ,
    Window ,
    XClassHint*
);

extern int XGetIconSizes(
    Display* ,
    Window ,
    XIconSize** ,
    int*
);

extern int XGetNormalHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern int XGetRGBColormaps(
    Display* ,
    Window ,
    XStandardColormap** ,
    int* ,
    Atom
);

extern int XGetSizeHints(
    Display* ,
    Window ,
    XSizeHints* ,
    Atom
);

extern int XGetStandardColormap(
    Display* ,
    Window ,
    XStandardColormap* ,
    Atom
);

extern int XGetTextProperty(
    Display* ,
    Window ,
    XTextProperty* ,
    Atom
);

extern XVisualInfo *XGetVisualInfo(
    Display* ,
    long ,
    XVisualInfo* ,
    int*
);

extern int XGetWMClientMachine(
    Display* ,
    Window ,
    XTextProperty*
);

extern XWMHints *XGetWMHints(
    Display* ,
    Window
);

extern int XGetWMIconName(
    Display* ,
    Window ,
    XTextProperty*
);

extern int XGetWMName(
    Display* ,
    Window ,
    XTextProperty*
);

extern int XGetWMNormalHints(
    Display* ,
    Window ,
    XSizeHints* ,
    long*
);

extern int XGetWMSizeHints(
    Display* ,
    Window ,
    XSizeHints* ,
    long* ,
    Atom
);

extern int XGetZoomHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern int XIntersectRegion(
    Region ,
    Region ,
    Region
);

extern void XConvertCase(
    KeySym ,
    KeySym* ,
    KeySym*
);

extern int XLookupString(
    XKeyEvent* ,
    char* ,
    int ,
    KeySym* ,
    XComposeStatus*
);

extern int XMatchVisualInfo(
    Display* ,
    int ,
    int ,
    int ,
    XVisualInfo*
);

extern int XOffsetRegion(
    Region ,
    int ,
    int
);

extern int XPointInRegion(
    Region ,
    int ,
    int
);

extern Region XPolygonRegion(
    XPoint* ,
    int ,
    int
);

extern int XRectInRegion(
    Region ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XSaveContext(
    Display* ,
    XID ,
    XContext ,
    const char*
);

extern int XSetClassHint(
    Display* ,
    Window ,
    XClassHint*
);

extern int XSetIconSizes(
    Display* ,
    Window ,
    XIconSize* ,
    int
);

extern int XSetNormalHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern void XSetRGBColormaps(
    Display* ,
    Window ,
    XStandardColormap* ,
    int ,
    Atom
);

extern int XSetSizeHints(
    Display* ,
    Window ,
    XSizeHints* ,
    Atom
);

extern int XSetStandardProperties(
    Display* ,
    Window ,
    const char* ,
    const char* ,
    Pixmap ,
    char** ,
    int ,
    XSizeHints*
);

extern void XSetTextProperty(
    Display* ,
    Window ,
    XTextProperty* ,
    Atom
);

extern void XSetWMClientMachine(
    Display* ,
    Window ,
    XTextProperty*
);

extern int XSetWMHints(
    Display* ,
    Window ,
    XWMHints*
);

extern void XSetWMIconName(
    Display* ,
    Window ,
    XTextProperty*
);

extern void XSetWMName(
    Display* ,
    Window ,
    XTextProperty*
);

extern void XSetWMNormalHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern void XSetWMProperties(
    Display* ,
    Window ,
    XTextProperty* ,
    XTextProperty* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*
);

extern void XmbSetWMProperties(
    Display* ,
    Window ,
    const char* ,
    const char* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*
);

extern void Xutf8SetWMProperties(
    Display* ,
    Window ,
    const char* ,
    const char* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*
);

extern void XSetWMSizeHints(
    Display* ,
    Window ,
    XSizeHints* ,
    Atom
);

extern int XSetRegion(
    Display* ,
    GC ,
    Region
);

extern void XSetStandardColormap(
    Display* ,
    Window ,
    XStandardColormap* ,
    Atom
);

extern int XSetZoomHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern int XShrinkRegion(
    Region ,
    int ,
    int
);

extern int XStringListToTextProperty(
    char** ,
    int ,
    XTextProperty*
);

extern int XSubtractRegion(
    Region ,
    Region ,
    Region
);

extern int XmbTextListToTextProperty(
    Display* display,
    char** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern int XwcTextListToTextProperty(
    Display* display,
    wchar_t** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern int Xutf8TextListToTextProperty(
    Display* display,
    char** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern void XwcFreeStringList(
    wchar_t** list
);

extern int XTextPropertyToStringList(
    XTextProperty* ,
    char*** ,
    int*
);

extern int XmbTextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    char*** list_return,
    int* count_return
);

extern int XwcTextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    wchar_t*** list_return,
    int* count_return
);

extern int Xutf8TextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    char*** list_return,
    int* count_return
);

extern int XUnionRectWithRegion(
    XRectangle* ,
    Region ,
    Region
);

extern int XUnionRegion(
    Region ,
    Region ,
    Region
);

extern int XWMGeometry(
    Display* ,
    int ,
    const char* ,
    const char* ,
    unsigned int ,
    XSizeHints* ,
    int* ,
    int* ,
    int* ,
    int* ,
    int*
);

extern int XXorRegion(
    Region ,
    Region ,
    Region
);





}
# 210 "../src/CImg.h" 2
# 1 "/usr/include/X11/keysym.h" 1 3 4
# 73 "/usr/include/X11/keysym.h" 3 4
# 1 "/usr/include/X11/keysymdef.h" 1 3 4
# 74 "/usr/include/X11/keysym.h" 2 3 4
# 211 "../src/CImg.h" 2
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 28 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 29 "/usr/include/sched.h" 2 3 4
# 41 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 72 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 118 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 201 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 42 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 116 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 125 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 166 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 201 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 239 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 505 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 517 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 551 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 753 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 899 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1011 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1055 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1122 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1156 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1170 "/usr/include/pthread.h" 3 4
}
# 212 "../src/CImg.h" 2
# 2061 "../src/CImg.h"
namespace cimg_library {


  template<typename T=float> struct CImg;
  template<typename T=float> struct CImgList;
  struct CImgDisplay;
  struct CImgException;





  namespace cimg {
# 2089 "../src/CImg.h"
    const char t_normal[] = { 0 };
    const char *const t_black = cimg::t_normal,
      *const t_red = cimg::t_normal,
      *const t_green = cimg::t_normal,
      *const t_yellow = cimg::t_normal,
      *const t_blue = cimg::t_normal,
      *const t_magenta = cimg::t_normal,
      *const t_cyan = cimg::t_normal,
      *const t_white = cimg::t_normal,
      *const t_bold = cimg::t_normal,
      *const t_underscore = cimg::t_normal;


    inline std::FILE* output(std::FILE *file=0);
    inline void info();


    template<typename T>
    inline void unused(const T&, ...) {}




    inline int mutex(const unsigned int n, const int lock_mode=1);

    inline unsigned int& _exception_mode(const unsigned int value, const bool is_set) {
      static unsigned int mode = 2;
      cimg::mutex(0);
      if (is_set) mode = value;
      cimg::mutex(0,0);
      return mode;
    }
# 2132 "../src/CImg.h"
    inline unsigned int& exception_mode(const unsigned int mode) {
      return _exception_mode(mode,true);
    }





    inline unsigned int& exception_mode() {
      return _exception_mode(0,false);
    }

    inline int dialog(const char *const title, const char *const msg, const char *const button1_label="OK",
                      const char *const button2_label=0, const char *const button3_label=0,
                      const char *const button4_label=0, const char *const button5_label=0,
                      const char *const button6_label=0, const bool centering=false);

    inline double eval(const char *const expression,
                       const double x=0, const double y=0, const double z=0, const double c=0);
  }
# 2220 "../src/CImg.h"
  struct CImgException : public std::exception {
# 2230 "../src/CImg.h"
    char _message[16384];
    CImgException() { *_message = 0; }
    CImgException(const char *const format, ...) { std::va_list ap; __builtin_va_start(ap,format); vsnprintf(_message,sizeof(_message),format,ap); __builtin_va_end(ap); if (cimg::exception_mode()) { std::fprintf(cimg::output(),"\n%s[CImg] *** %s ***%s %s\n",cimg::t_red,"CImgException",cimg::t_normal,_message); if (1 && true && !(cimg::exception_mode()%2)) try { cimg::dialog("CImgException",_message,"Abort"); } catch (CImgException&) {} if (cimg::exception_mode()>=3) cimg_library::cimg::info(); }; }

    const char *what() const throw() { return _message; }
  };



  struct CImgInstanceException : public CImgException {
    CImgInstanceException(const char *const format, ...) { std::va_list ap; __builtin_va_start(ap,format); vsnprintf(_message,sizeof(_message),format,ap); __builtin_va_end(ap); if (cimg::exception_mode()) { std::fprintf(cimg::output(),"\n%s[CImg] *** %s ***%s %s\n",cimg::t_red,"CImgInstanceException",cimg::t_normal,_message); if (1 && true && !(cimg::exception_mode()%2)) try { cimg::dialog("CImgInstanceException",_message,"Abort"); } catch (CImgException&) {} if (cimg::exception_mode()>=3) cimg_library::cimg::info(); }; }
  };



  struct CImgArgumentException : public CImgException {
    CImgArgumentException(const char *const format, ...) { std::va_list ap; __builtin_va_start(ap,format); vsnprintf(_message,sizeof(_message),format,ap); __builtin_va_end(ap); if (cimg::exception_mode()) { std::fprintf(cimg::output(),"\n%s[CImg] *** %s ***%s %s\n",cimg::t_red,"CImgArgumentException",cimg::t_normal,_message); if (1 && true && !(cimg::exception_mode()%2)) try { cimg::dialog("CImgArgumentException",_message,"Abort"); } catch (CImgException&) {} if (cimg::exception_mode()>=3) cimg_library::cimg::info(); }; }
  };



  struct CImgIOException : public CImgException {
    CImgIOException(const char *const format, ...) { std::va_list ap; __builtin_va_start(ap,format); vsnprintf(_message,sizeof(_message),format,ap); __builtin_va_end(ap); if (cimg::exception_mode()) { std::fprintf(cimg::output(),"\n%s[CImg] *** %s ***%s %s\n",cimg::t_red,"CImgIOException",cimg::t_normal,_message); if (1 && true && !(cimg::exception_mode()%2)) try { cimg::dialog("CImgIOException",_message,"Abort"); } catch (CImgException&) {} if (cimg::exception_mode()>=3) cimg_library::cimg::info(); }; }
  };



  struct CImgDisplayException : public CImgException {
    CImgDisplayException(const char *const format, ...) { std::va_list ap; __builtin_va_start(ap,format); vsnprintf(_message,sizeof(_message),format,ap); __builtin_va_end(ap); if (cimg::exception_mode()) { std::fprintf(cimg::output(),"\n%s[CImg] *** %s ***%s %s\n",cimg::t_red,"CImgDisplayException",cimg::t_normal,_message); if (1 && false && !(cimg::exception_mode()%2)) try { cimg::dialog("CImgDisplayException",_message,"Abort"); } catch (CImgException&) {} if (cimg::exception_mode()>=3) cimg_library::cimg::info(); }; }
  };



  struct CImgWarningException : public CImgException {
    CImgWarningException(const char *const format, ...) { std::va_list ap; __builtin_va_start(ap,format); vsnprintf(_message,sizeof(_message),format,ap); __builtin_va_end(ap); if (cimg::exception_mode()) { std::fprintf(cimg::output(),"\n%s[CImg] *** %s ***%s %s\n",cimg::t_red,"CImgWarningException",cimg::t_normal,_message); if (1 && false && !(cimg::exception_mode()%2)) try { cimg::dialog("CImgWarningException",_message,"Abort"); } catch (CImgException&) {} if (cimg::exception_mode()>=3) cimg_library::cimg::info(); }; }
  };
# 2280 "../src/CImg.h"
  namespace cimg {



    template<typename T> struct type {
      static const char* string() {
        static const char* s[] = { "unknown", "unknown8", "unknown16", "unknown24",
                                   "unknown32", "unknown40", "unknown48", "unknown56",
                                   "unknown64", "unknown72", "unknown80", "unknown88",
                                   "unknown96", "unknown104", "unknown112", "unknown120",
                                   "unknown128" };
        return s[(sizeof(T)<17)?sizeof(T):0];
      }
      static bool is_float() { return false; }
      static bool is_inf(const T) { return false; }
      static bool is_nan(const T) { return false; }
      static T min() { return (T)-1>0?(T)0:(T)-1<<(8*sizeof(T)-1); }
      static T max() { return (T)-1>0?(T)-1:~((T)-1<<(8*sizeof(T)-1)); }
      static T inf() { return max(); }
      static T cut(const double val) { return val<(double)min()?min():val>(double)max()?max():(T)val; }
      static const char* format() { return "%s"; }
      static const char* format(const T val) { static const char *const s = "unknown"; cimg::unused(val); return s; }
    };

    template<> struct type<bool> {
      static const char* string() { static const char *const s = "bool"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const bool) { return false; }
      static bool is_nan(const bool) { return false; }
      static bool min() { return false; }
      static bool max() { return true; }
      static bool inf() { return max(); }
      static bool is_inf() { return false; }
      static bool cut(const double val) { return val<(double)min()?min():val>(double)max()?max():(bool)val; }
      static const char* format() { return "%s"; }
      static const char* format(const bool val) { static const char* s[] = { "false", "true" }; return s[val?1:0]; }
    };

    template<> struct type<unsigned char> {
      static const char* string() { static const char *const s = "unsigned char"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const unsigned char) { return false; }
      static bool is_nan(const unsigned char) { return false; }
      static unsigned char min() { return 0; }
      static unsigned char max() { return (unsigned char)~0U; }
      static unsigned char inf() { return max(); }
      static unsigned char cut(const double val) {
        return val<(double)min()?min():val>(double)max()?max():(unsigned char)val; }
      static const char* format() { return "%u"; }
      static unsigned int format(const unsigned char val) { return (unsigned int)val; }
    };

    template<> struct type<char> {
      static const char* string() { static const char *const s = "char"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const char) { return false; }
      static bool is_nan(const char) { return false; }
      static char min() { return (char)(-1L<<(8*sizeof(char)-1)); }
      static char max() { return (char)~((char)(-1L<<(8*sizeof(char)-1))); }
      static char inf() { return max(); }
      static char cut(const double val) { return val<(double)min()?min():val>(double)max()?max():(char)val; }
      static const char* format() { return "%d"; }
      static int format(const char val) { return (int)val; }
    };

    template<> struct type<signed char> {
      static const char* string() { static const char *const s = "signed char"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const signed char) { return false; }
      static bool is_nan(const signed char) { return false; }
      static signed char min() { return (signed char)(-1L<<(8*sizeof(signed char)-1)); }
      static signed char max() { return ~((signed char)(-1L<<(8*sizeof(signed char)-1))); }
      static signed char inf() { return max(); }
      static signed char cut(const double val) {
        return val<(double)min()?min():val>(double)max()?max():(signed char)val; }
      static const char* format() { return "%d"; }
      static unsigned int format(const signed char val) { return (int)val; }
    };

    template<> struct type<unsigned short> {
      static const char* string() { static const char *const s = "unsigned short"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const unsigned short) { return false; }
      static bool is_nan(const unsigned short) { return false; }
      static unsigned short min() { return 0; }
      static unsigned short max() { return (unsigned short)~0U; }
      static unsigned short inf() { return max(); }
      static unsigned short cut(const double val) {
        return val<(double)min()?min():val>(double)max()?max():(unsigned short)val; }
      static const char* format() { return "%u"; }
      static unsigned int format(const unsigned short val) { return (unsigned int)val; }
    };

    template<> struct type<short> {
      static const char* string() { static const char *const s = "short"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const short) { return false; }
      static bool is_nan(const short) { return false; }
      static short min() { return (short)(-1L<<(8*sizeof(short)-1)); }
      static short max() { return ~((short)(-1L<<(8*sizeof(short)-1))); }
      static short inf() { return max(); }
      static short cut(const double val) { return val<(double)min()?min():val>(double)max()?max():(short)val; }
      static const char* format() { return "%d"; }
      static int format(const short val) { return (int)val; }
    };

    template<> struct type<unsigned int> {
      static const char* string() { static const char *const s = "unsigned int"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const unsigned int) { return false; }
      static bool is_nan(const unsigned int) { return false; }
      static unsigned int min() { return 0; }
      static unsigned int max() { return (unsigned int)~0U; }
      static unsigned int inf() { return max(); }
      static unsigned int cut(const double val) {
        return val<(double)min()?min():val>(double)max()?max():(unsigned int)val; }
      static const char* format() { return "%u"; }
      static unsigned int format(const unsigned int val) { return val; }
    };

    template<> struct type<int> {
      static const char* string() { static const char *const s = "int"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const int) { return false; }
      static bool is_nan(const int) { return false; }
      static int min() { return (int)(-1L<<(8*sizeof(int)-1)); }
      static int max() { return ~((int)(-1L<<(8*sizeof(int)-1))); }
      static int inf() { return max(); }
      static int cut(const double val) { return val<(double)min()?min():val>(double)max()?max():(int)val; }
      static const char* format() { return "%d"; }
      static int format(const int val) { return val; }
    };

    template<> struct type<unsigned long> {
      static const char* string() { static const char *const s = "unsigned long"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const unsigned long) { return false; }
      static bool is_nan(const unsigned long) { return false; }
      static unsigned long min() { return 0; }
      static unsigned long max() { return (unsigned long)~0UL; }
      static unsigned long inf() { return max(); }
      static unsigned long cut(const double val) {
        return val<(double)min()?min():val>(double)max()?max():(unsigned long)val; }
      static const char* format() { return "%lu"; }
      static unsigned long format(const unsigned long val) { return val; }
    };

    template<> struct type<long> {
      static const char* string() { static const char *const s = "long"; return s; }
      static bool is_float() { return false; }
      static bool is_inf(const long) { return false; }
      static bool is_nan(const long) { return false; }
      static long min() { return (long)(-1L<<(8*sizeof(long)-1)); }
      static long max() { return ~((long)(-1L<<(8*sizeof(long)-1))); }
      static long inf() { return max(); }
      static long cut(const double val) { return val<(double)min()?min():val>(double)max()?max():(long)val; }
      static const char* format() { return "%ld"; }
      static long format(const long val) { return val; }
    };

    template<> struct type<double> {
      static const char* string() { static const char *const s = "double"; return s; }
      static bool is_float() { return true; }
      static bool is_inf(const double val) {



        return !is_nan(val) && (val<cimg::type<double>::min() || val>cimg::type<double>::max());

      }
      static bool is_nan(const double val) {



        return !(val==val);

      }
      static double min() { return -1.7E308; }
      static double max() { return 1.7E308; }
      static double inf() { return max()*max(); }
      static double nan() { static const double val_nan = -std::sqrt(-1.0); return val_nan; }
      static double cut(const double val) { return val<min()?min():val>max()?max():val; }
      static const char* format() { return "%.16g"; }
      static double format(const double val) { return val; }
    };

    template<> struct type<float> {
      static const char* string() { static const char *const s = "float"; return s; }
      static bool is_float() { return true; }
      static bool is_inf(const float val) {



        return !is_nan(val) && (val<cimg::type<float>::min() || val>cimg::type<float>::max());

      }
      static bool is_nan(const float val) {



        return !(val==val);

      }
      static float min() { return -3.4E38f; }
      static float max() { return 3.4E38f; }
      static float inf() { return (float)cimg::type<double>::inf(); }
      static float nan() { return (float)cimg::type<double>::nan(); }
      static float cut(const double val) { return val<(double)min()?min():val>(double)max()?max():(float)val; }
      static const char* format() { return "%.16g"; }
      static double format(const float val) { return (double)val; }
    };

    template<typename T, typename t> struct superset { typedef T type; };
    template<> struct superset<bool,unsigned char> { typedef unsigned char type; };
    template<> struct superset<bool,char> { typedef char type; };
    template<> struct superset<bool,signed char> { typedef signed char type; };
    template<> struct superset<bool,unsigned short> { typedef unsigned short type; };
    template<> struct superset<bool,short> { typedef short type; };
    template<> struct superset<bool,unsigned int> { typedef unsigned int type; };
    template<> struct superset<bool,int> { typedef int type; };
    template<> struct superset<bool,unsigned long> { typedef unsigned long type; };
    template<> struct superset<bool,long> { typedef long type; };
    template<> struct superset<bool,float> { typedef float type; };
    template<> struct superset<bool,double> { typedef double type; };
    template<> struct superset<unsigned char,char> { typedef short type; };
    template<> struct superset<unsigned char,signed char> { typedef short type; };
    template<> struct superset<unsigned char,unsigned short> { typedef unsigned short type; };
    template<> struct superset<unsigned char,short> { typedef short type; };
    template<> struct superset<unsigned char,unsigned int> { typedef unsigned int type; };
    template<> struct superset<unsigned char,int> { typedef int type; };
    template<> struct superset<unsigned char,unsigned long> { typedef unsigned long type; };
    template<> struct superset<unsigned char,long> { typedef long type; };
    template<> struct superset<unsigned char,float> { typedef float type; };
    template<> struct superset<unsigned char,double> { typedef double type; };
    template<> struct superset<signed char,unsigned char> { typedef short type; };
    template<> struct superset<signed char,char> { typedef short type; };
    template<> struct superset<signed char,unsigned short> { typedef int type; };
    template<> struct superset<signed char,short> { typedef short type; };
    template<> struct superset<signed char,unsigned int> { typedef long type; };
    template<> struct superset<signed char,int> { typedef int type; };
    template<> struct superset<signed char,unsigned long> { typedef long type; };
    template<> struct superset<signed char,long> { typedef long type; };
    template<> struct superset<signed char,float> { typedef float type; };
    template<> struct superset<signed char,double> { typedef double type; };
    template<> struct superset<char,unsigned char> { typedef short type; };
    template<> struct superset<char,signed char> { typedef short type; };
    template<> struct superset<char,unsigned short> { typedef int type; };
    template<> struct superset<char,short> { typedef short type; };
    template<> struct superset<char,unsigned int> { typedef long type; };
    template<> struct superset<char,int> { typedef int type; };
    template<> struct superset<char,unsigned long> { typedef long type; };
    template<> struct superset<char,long> { typedef long type; };
    template<> struct superset<char,float> { typedef float type; };
    template<> struct superset<char,double> { typedef double type; };
    template<> struct superset<unsigned short,char> { typedef int type; };
    template<> struct superset<unsigned short,signed char> { typedef int type; };
    template<> struct superset<unsigned short,short> { typedef int type; };
    template<> struct superset<unsigned short,unsigned int> { typedef unsigned int type; };
    template<> struct superset<unsigned short,int> { typedef int type; };
    template<> struct superset<unsigned short,unsigned long> { typedef unsigned long type; };
    template<> struct superset<unsigned short,long> { typedef long type; };
    template<> struct superset<unsigned short,float> { typedef float type; };
    template<> struct superset<unsigned short,double> { typedef double type; };
    template<> struct superset<short,unsigned short> { typedef int type; };
    template<> struct superset<short,unsigned int> { typedef long type; };
    template<> struct superset<short,int> { typedef int type; };
    template<> struct superset<short,unsigned long> { typedef long type; };
    template<> struct superset<short,long> { typedef long type; };
    template<> struct superset<short,float> { typedef float type; };
    template<> struct superset<short,double> { typedef double type; };
    template<> struct superset<unsigned int,char> { typedef long type; };
    template<> struct superset<unsigned int,signed char> { typedef long type; };
    template<> struct superset<unsigned int,short> { typedef long type; };
    template<> struct superset<unsigned int,int> { typedef long type; };
    template<> struct superset<unsigned int,unsigned long> { typedef unsigned long type; };
    template<> struct superset<unsigned int,long> { typedef long type; };
    template<> struct superset<unsigned int,float> { typedef float type; };
    template<> struct superset<unsigned int,double> { typedef double type; };
    template<> struct superset<int,unsigned int> { typedef long type; };
    template<> struct superset<int,unsigned long> { typedef long type; };
    template<> struct superset<int,long> { typedef long type; };
    template<> struct superset<int,float> { typedef float type; };
    template<> struct superset<int,double> { typedef double type; };
    template<> struct superset<unsigned long,char> { typedef long type; };
    template<> struct superset<unsigned long,signed char> { typedef long type; };
    template<> struct superset<unsigned long,short> { typedef long type; };
    template<> struct superset<unsigned long,int> { typedef long type; };
    template<> struct superset<unsigned long,long> { typedef long type; };
    template<> struct superset<unsigned long,float> { typedef double type; };
    template<> struct superset<unsigned long,double> { typedef double type; };
    template<> struct superset<long,float> { typedef double type; };
    template<> struct superset<long,double> { typedef double type; };
    template<> struct superset<float,double> { typedef double type; };

    template<typename t1, typename t2, typename t3> struct superset2 {
      typedef typename superset<t1, typename superset<t2,t3>::type>::type type;
    };

    template<typename t1, typename t2, typename t3, typename t4> struct superset3 {
      typedef typename superset<t1, typename superset2<t2,t3,t4>::type>::type type;
    };

    template<typename t1, typename t2> struct last { typedef t2 type; };
# 2591 "../src/CImg.h"
    struct X11_info {
      volatile unsigned int nb_wins;
      pthread_t* events_thread;
      pthread_cond_t wait_event;
      pthread_mutex_t wait_event_mutex;
      CImgDisplay* wins[1024];
      Display* display;
      unsigned int nb_bits;
      bool is_blue_first;
      bool is_shm_enabled;
      bool byte_order;






      X11_info():nb_wins(0),events_thread(0),display(0),
                 nb_bits(0),is_blue_first(false),is_shm_enabled(false),byte_order(false) {
        XInitThreads();
        pthread_mutex_init(&wait_event_mutex,0);
        pthread_cond_init(&wait_event,0);





      }

      ~X11_info() {
        if (events_thread) {
          pthread_cancel(*events_thread);
          delete events_thread;
        }
        if (display) {}
        pthread_cond_destroy(&wait_event);
        pthread_mutex_unlock(&wait_event_mutex);
        pthread_mutex_destroy(&wait_event_mutex);
      }
    };





    inline X11_info& X11_attr() { static X11_info val; return val; }
# 2653 "../src/CImg.h"
    struct Mutex_info {







      pthread_mutex_t mutex[32];
      Mutex_info() { for (unsigned int i = 0; i<32; ++i) pthread_mutex_init(&mutex[i],0); }
      void lock(const unsigned int n) { pthread_mutex_lock(&mutex[n]); }
      void unlock(const unsigned int n) { pthread_mutex_unlock(&mutex[n]); }
      int trylock(const unsigned int n) { return pthread_mutex_trylock(&mutex[n]); }






    };





    inline Mutex_info& Mutex_attr() { static Mutex_info val; return val; }
# 2691 "../src/CImg.h"
    const unsigned int keyESC = 0xff1b;
    const unsigned int keyF1 = 0xffbe;
    const unsigned int keyF2 = 0xffbf;
    const unsigned int keyF3 = 0xffc0;
    const unsigned int keyF4 = 0xffc1;
    const unsigned int keyF5 = 0xffc2;
    const unsigned int keyF6 = 0xffc3;
    const unsigned int keyF7 = 0xffc4;
    const unsigned int keyF8 = 0xffc5;
    const unsigned int keyF9 = 0xffc6;
    const unsigned int keyF10 = 0xffc7;
    const unsigned int keyF11 = 0xffc8;
    const unsigned int keyF12 = 0xffc9;
    const unsigned int keyPAUSE = 0xff13;
    const unsigned int key1 = 0x0031;
    const unsigned int key2 = 0x0032;
    const unsigned int key3 = 0x0033;
    const unsigned int key4 = 0x0034;
    const unsigned int key5 = 0x0035;
    const unsigned int key6 = 0x0036;
    const unsigned int key7 = 0x0037;
    const unsigned int key8 = 0x0038;
    const unsigned int key9 = 0x0039;
    const unsigned int key0 = 0x0030;
    const unsigned int keyBACKSPACE = 0xff08;
    const unsigned int keyINSERT = 0xff63;
    const unsigned int keyHOME = 0xff50;
    const unsigned int keyPAGEUP = 0xff55;
    const unsigned int keyTAB = 0xff09;
    const unsigned int keyQ = 0x0071;
    const unsigned int keyW = 0x0077;
    const unsigned int keyE = 0x0065;
    const unsigned int keyR = 0x0072;
    const unsigned int keyT = 0x0074;
    const unsigned int keyY = 0x0079;
    const unsigned int keyU = 0x0075;
    const unsigned int keyI = 0x0069;
    const unsigned int keyO = 0x006f;
    const unsigned int keyP = 0x0070;
    const unsigned int keyDELETE = 0xffff;
    const unsigned int keyEND = 0xff57;
    const unsigned int keyPAGEDOWN = 0xff56;
    const unsigned int keyCAPSLOCK = 0xffe5;
    const unsigned int keyA = 0x0061;
    const unsigned int keyS = 0x0073;
    const unsigned int keyD = 0x0064;
    const unsigned int keyF = 0x0066;
    const unsigned int keyG = 0x0067;
    const unsigned int keyH = 0x0068;
    const unsigned int keyJ = 0x006a;
    const unsigned int keyK = 0x006b;
    const unsigned int keyL = 0x006c;
    const unsigned int keyENTER = 0xff0d;
    const unsigned int keySHIFTLEFT = 0xffe1;
    const unsigned int keyZ = 0x007a;
    const unsigned int keyX = 0x0078;
    const unsigned int keyC = 0x0063;
    const unsigned int keyV = 0x0076;
    const unsigned int keyB = 0x0062;
    const unsigned int keyN = 0x006e;
    const unsigned int keyM = 0x006d;
    const unsigned int keySHIFTRIGHT = 0xffe2;
    const unsigned int keyARROWUP = 0xff52;
    const unsigned int keyCTRLLEFT = 0xffe3;
    const unsigned int keyAPPLEFT = 0xffeb;
    const unsigned int keyALT = 0xffe9;
    const unsigned int keySPACE = 0x0020;
    const unsigned int keyALTGR = 0xffea;
    const unsigned int keyAPPRIGHT = 0xffec;
    const unsigned int keyMENU = 0xff67;
    const unsigned int keyCTRLRIGHT = 0xffe4;
    const unsigned int keyARROWLEFT = 0xff51;
    const unsigned int keyARROWDOWN = 0xff54;
    const unsigned int keyARROWRIGHT = 0xff53;
    const unsigned int keyPAD0 = 0xffb0;
    const unsigned int keyPAD1 = 0xffb1;
    const unsigned int keyPAD2 = 0xffb2;
    const unsigned int keyPAD3 = 0xffb3;
    const unsigned int keyPAD4 = 0xffb4;
    const unsigned int keyPAD5 = 0xffb5;
    const unsigned int keyPAD6 = 0xffb6;
    const unsigned int keyPAD7 = 0xffb7;
    const unsigned int keyPAD8 = 0xffb8;
    const unsigned int keyPAD9 = 0xffb9;
    const unsigned int keyPADADD = 0xffab;
    const unsigned int keyPADSUB = 0xffad;
    const unsigned int keyPADMUL = 0xffaa;
    const unsigned int keyPADDIV = 0xffaf;
# 2964 "../src/CImg.h"
    const double PI = 3.14159265358979323846;


    const char *const data_font12x13 =
"                          .wjwlwmyuw>wjwkwbwjwkwRxuwmwjwkwmyuwJwjwlx`w      Fw                         mwlwlwuwnwuynwuwmyTwlwkwuwmwuwnwlwkwuwmwuw_wuxl"
"wlwkwuwnwuynwuwTwlwlwtwnwtwnw my     Qw   +wlw   b{ \\w  Wx`xTw_w[wbxawSwkw  nynwky<x1w `y    ,w  Xwuw   CxlwiwlwmyuwbwuwUwiwlwbwiwrwqw^wuwmxuwnwiwlwmy"
"uwJwiwlw^wnwEymymymymy1w^wkxnxtxnw<| gybwkwuwjwtwowmxswnxnwkxlxkw:wlymxlymykwn{myo{nymy2ykwqwqwm{myozn{o{mzpwrwpwkwkwswowkwqwqxswnyozlyozmzp}pwrwqwqwq"
"wswswsxsxqwqwp}qwlwiwjybw`w[wcw_wkwkwkwkw mw\"wlwiw=wtw`xIw awuwlwm{o{mylwn|pwtwtwoy`w_w_wbwiwkxcwqwpwkznwuwjzpyGzqymyaxlylw_zWxkxaxrwqxrwqyswowkwkwkwk"
"wkwkwk}qyo{o{o{o{owkwkwkwkznxswnymymymymyayuwqwrwpwrwpwrwpwrwqwqwpwkwtwlwkwlwuwnwuynwuwmyTwkwlwuwmwuwnwkwlwuwmwuwkxlwuxmwkwlwuwnwuynwuwTwkwlwuwmwuwlwm"
"wkwtwUwuwuwowswowswowswowsw;wqwtw_ymzp~py>w bwswcwkwuwjwuwozpwtwuwnwtwowkwjwmwuwuwkwIxmxuxowuwmwswowswmxnwjwhwowswowsw0wmwowswuwnwrwowswpwswowkwjwrwqw"
"rwpwkwkwtwnwkxsxqxswowswpwswnwswpwswowrwnwmwrwqwqwqwswswrwswowswjwpwlxjwkxuxLw[wcw_wSwkw mw\"wlwiw=wtwmxlwFw cwswnwuwnwkwjwswo{pwrwpwtwtwpwswby`w`yUwlw"
"twpwqwpwswowlw\\wrwrxuwHwrwfwuwjwlwlwTyuwVwlwtwawswowswowswcwuwmwuwmwuwmwuwmwuwlwkwuwnwswpwkwkwkwkwkwkwkwkwswoxswowswowswowswowswowswowrwpwswpwrwpwrwpw"
"rwpwrwpwswoznwtw  Ww (wGwtwtwqwqwqwuwuwuwqwswuwqwqw=wqxtw`{nzp~q{ozowrwnxmwtwow bzawkwuwl}rwuwnwtwuwnwtwowkwjwlyjwIwlwswmwiwkwnwuwnwkwhwnwswowswowkwew"
"ewixnwsytwswuwnwrwpwkwrwpwkwkwkwrwpwkwkwuwmwkxsxqwuwtwpwqwqwswowqwqwswowiwmwrwpwswowtwtwpwuwmwuwjwowkwjwlxsxXynzmymznyozlzoznwkwkwtwnwkzuyrzmynzmzowux"
"myozmwswpwrwowtwtwrwrwpwrwp{mwlwiwHyuwpwtwkwmxlynzoxswmwmwswnwswowtxq|owtwtwpym{p{owswnwuwmwlwkwqwqxuwuxqwrwpwtwtwqwqwowlwuwuwkwmwlwtwowuwuwdwjznwl{nw"
"uwnwkx_wtxtwswtwlwtwWwuytwgyjwmwjwawswoyuwVwlwtwnwtwmwtwnwtwmwuwmwlwuwmwuwmwuwmwuwmwuwmwuwmxuwowkwkwkwkwkwkwkwkwkwrwpwuwtwpwqwqwqwqwqwqwqwqwqwowtwpwsw"
"uwqwrwpwrwpwrwpwrwowuwnwswowuwlymymymymymymyuyqymymymymynwkwkwkwjynzmymymymymykwmzowswowswowswowswpwrwozowrwW}q}qwtwtwqwtwtwqwtwtwA}rwuw_{p~r~r}pwtwow"
"rwnxmwtwow aw_w]wtwpwuwmxuwmybwjwlyjwIwlwswmwiwnynwtwnznzkwmynwswTyp}pylwmwtwtwtwswuwn{owkwrwp{o{owk|pwkwkxlwkwuwuwuwqwuwtwpwqwqwswowqwqwswoykwmwrwpws"
"wowuwuwuwowkwjwnwkwjwDwowswowkwswowswowkwswowswowkwkwuwmwkwswswswswowswowswowswoxlwswowkwswpwrwowtwtwqwtwowrwlwoxkwhxVxuxpwtypwuwjwnwtwnwkwswowtxnxmws"
"wowqwqwtwuxqwtwnwtwtwqwswowswmwm{nwuwlxnwkwqwqwtwtwqwrwpwtwtwqwuyuwpwiwhwnwmwrwnwbwkwuwlwlwswoxuxowlwtw`wuwrwszmwtwo}dwuwtwuw[}qymx`wswoyuwow_ylxlwtwo"
"yuwoyuwoyuwmwlwuwmwuwmwuwmwuwmwuwmwuwmwt{swk{o{o{o{owkwkwkwlztwpwuwtwpwqwqwqwqwqwqwqwqwqwnxowtwtwqwrwpwrwpwrwpwrwnwmwswowuwiwkwkwkwkwkwkwswswkwswowswo"
"wswowswowkwkwkwkwswowswowswowswowswowswowswcwtxowswowswowswowswpwrwowswpwrwWwtwtwqwqwqwuwuwuwqwuwswqwqw>wowuw`}q~q|q}qwrwpwrwowtwnwtwo~ izaw]wtwoykwux"
"qwtwswfwjwmwuwuwn}eyaxlwswmwjwjwpwswjwowswmwmwswnzWy]ypwlwtwtwuwswswowrwpwkwrwpwkwkwsyqwrwpwkwkwuwmwkwuwuwuwqwtwuwpwqwqznwqwqzkynwmwrwowuwnwuwuwuwowkw"
"jwnwkxkwGzowswowkwswo{owkwswowswowkwkxlwkwswswswswowswowswowswowjxmwkwswowtwnwuwuwuwpxmwtwlwlwlwiwlytwewtwtwqwswowtxoznwswnxmwswnwuwmwuwnwswowtwtwqwtw"
"twqwtwnwtwtwqwswowswmwmwswowswmwmwkwqwqwtwtwqwrwowuwuwpwuyuwq~own~own~owbwkwuwmznwswmwbwswawuwrwgwtwhwdwuytwXwJwswnxuw=wtwmwswowtxowswqxmwswowswowswow"
"swowswowswnwtwowkwkwkwkwkwkwkwkwkwrwpwtwuwpwqwqwqwqwqwqwqwqwqwnxowtwtwqwrwpwrwpwrwpwrwnwmwswowtwmznznznznznzn~swk{o{o{o{owkwkwkwkwswowswowswowswowswow"
"swowswo}qwuwuwowswowswowswowswowtwnwswowtwUwuwuwowswowswowswowsw@}qx`}q~pzo{pwrwpwrwowtwnwtwow aw_w_}owuwmwuwtwrwswuwewjwkwiwJwkwswmwkwiwp|kwowswmwmws"
"wkwWym}mypwlwszr{owrwpwkwrwpwkwkwqwqwrwpwkwkwtwnwkwtwtwqwtwuwpwqwqwkwqwqwtwiwnwmwrwowuwnwuwuwuwpwuwlwkwmwjwkwHwswowswowkwswowkwkwswowswowkwkwuwmwkwsws"
"wswswowswowswowswowhwnwkwswowtwnwuwuwuwpxmwtwmwkwlwiwmwtydwtwtwqwswowswowtwnwswowkwswnwuwnwtwnwswowtwtwqwtwtwqwtwnwtwtwqwswowswmwmwswowswnwlwkwqwqxuwu"
"xqwrwnyowqwpwiwhwpwuwuwowrwpwuwuwdwkwuwlwlwswo{owkxuwawtxtwszmwtwiwdwuwtwuwXwJwswmwuwKzmwtwlwtxowrwpwtxrxl{o{o{o{o{o{o{owkwkwkwkwkwkwkwkwkwrwpwtwuwpwq"
"wqwqwqwqwqwqwqwqwowtwpwuwswqwrwpwrwpwrwpwrwnwmznwswowswowswowswowswowswowswowswowkwkwkwkwkwkwkwkwkwswowswowswowswowswowswowswcwuwuwowswowswowswowswowt"
"wnwswowtwTymymymymy=wmw^wuwuwmxlxmyowrwowtwnwtwmxmw bwswIwuwmwuwmwuwtwrxswdwjw]wJwkxuxmwlwlwswlwjwowswmwmwswlwSycyawlwswowrwowswpwswowkwjwrwqwrwpwkwkw"
"swowkwqwqwsxowswpwjwswpwswowrwnwmxtxnwlwswpwswmwlwlwjwkwHwswowswowkwswowswowkwswowswowkwkwtwnwkwswswswswowswowswowswowkwswowkwswnxlwswpwtwmxmwjwlwiwTx"
"uxpwtxowswowtwnwswowkwswnynwtwnwswowtwtwqxuwuxqwtwnwtwtwqwswowswmwlwuwnwswowkwjwswo{pwrwmwmwswnwjwiwnymwtwnycwkwuwlwl{mwmwiw_wrwdwtwVwrw*wswmwuw?wtwlw"
"tzqwrwpwtzswkwswowswowswowswowswowswowswnwswpwkwkwkwkwkwkwkwkwswowsxowswowswowswowswowswowrwpwswpxtxpxtxpxtxpxtxnwmwkwswowswowswowswowswowswowswowtxow"
"kwswowswowswowswowkwkwkwkwswowswowswowswowswowswowswlwnxtwowswowswowswowswnxmwswnx >wlw\\wkx`wnwrwoznwtwmxl| gybw^wtwozmwsxpzuxfxlx]wnw_wlxjyn{o{nykwnz"
"mymwkynymwkwewewjwjwrwswqwp{myozn{owizpwrwpwkwkwrwp{owqwqwsxnyowiyowrwozmwlzmwlwswqxsxnwm}qwjxlwGzozmymznynwjzowswowkwkwswowkwswswswswnynzmzowjymxlznx"
"lwswqwrwnwm{mwlwiwHxuxpzmxlymynwswmwnwrwozmxuxo{pwtxn{pzmykwmyo}p{owkyuynwnwrwmwly`w_w_wbwjzo{pwqwnwmwhw_z>zY}M|nwuw2wqwqwryrwqwqyowqwqwqwqwqwqwqwqwqw"
"qwqwqwr{qyo{o{o{o{owkwkwkwkznwsxnymymymymycwuynznznznzmwmwkwuynznznznznznznyuzrymymymymynwkwkwkwjynwswnymymymymybzmznznznznwlzmw     hwHwlwSwTw <w8z ]"
"x tx Zxjwmx RwWw/wgw pw_ynwky=wCwmwaw\\w_wnw  1wIwlz 'wiwuwaw  mw    Pw   swlwjw     hw        f| pyWx/wgw rxSw/wCwmwaw\\w_wnw  1w  AwRx  nw    Pw   txk"
"wlxm";


    const char *const data_font20x23 =
"                                                9q\\q^r_rnp`qnq`plp7q\\q^q_qmqbq\\q^q_qmqHqmp_q\\q^r_rnp`qnq7q\\q^q_qmq_q \"r                               "
"                        Mq^q^qnq`pnr`qnq`plp6q^q^pmp`qmqaq^q^pmp`qmqIpmq]q^q^qnq`pnr`qnq6q^q^pmp`qmq`q \"plp         'q     5qmq               Vq      "
"               Xq    [plp      3qYq_p^rnpLplp8qYq_qNqYq_q4rmpaqYq_q_rmp%qYq^pGq  Irc|!pKp]raqjq`p   HtNq_qmq\\plqbp_shpdscq[q^q[p [q]s_r`uau]rbv`tcxbua"
"t LsZucrav_udwcxdw`udqiqeq]q]qjreq]sksgrjqbtcv_tcvaud{eqiqgqfqgqjsjqlrjrhrirfzfs`q[sZqMqJqCqNsLq]q]q]q]q   .scq]s \\sKt%r  [s^raxdxat_qazgqlqlqctJqIqIq"
"LqHsOqiqOtaqmq\\uft nufu`sLs`t\\qKv<r\\rLrepirepitgpeq]r^r^r^r^r^r^{gudxdxdxdxdq]q]q]q]wcrjqbt`t`t`t`tLtlpgqiqeqiqeqiqeqiqgrireq[s_q[q_pnp_pnr`qnq`plp7q["
"q_s`qmqcq[q_s`qmq]pkpbpmr`q[q_s`pmraqmq8q[q^pnp_qnq^qaq\\qnq !pnqd{!pJp^tdunucr _y  dvOq_qmq\\plpap_pmpipdudq[p\\p_plplp _q^ubtawcw^rbvavdxcwcw Ou]yerawb"
"xeyexdwbxeqiqeq]q]qkrdq]sksgrjqdxewbxewcwe{eqiqfqhqfqjsjqkqjqfqiqezfs`q[s[sMpJqCqOtLq]q]q]q]q  q 1tcq]t ^vaq_w&r  \\u_raxdxcxcuczgqlqlqexMsJqJsMq[p^uPq"
"iqdq]uaqmq]qkqcq!qkqguaqmqNpkp\\p]pKtmp:p]plpKpfpfpfpcpipdq]r^r^r^r^r^r^{ixexdxdxdxdq]q]q]q]yerjqdxdxdxdxdxPwnpfqiqeqiqeqiqeqiqfqiqdq\\u_p[p^pnpKqnq_r5p"
"[p^pmp`qmqbp[p^pmp`qmq]tKp[p^pmpLqmq7p[p]pnp_qnq^p`q\\qnq5uauauauaucq`qhq4p]pKr_ueunucr `q  \\rkpOq_qmq\\plpctbqmqkqerlpdq\\q\\q_qnpnq\\q%q^qkqcqnqapjrdpjr`"
"sbq]rkp^qcrkrerkq Oplr`sirgtbqkrdripeqjsfq]q]ripeqiqeq]q]qlrcq]sksgskqerjrfqkrdrjrfqkrerjp`q`qiqfqhqeqkskqiqlqdqkq\\qeq]qZq\\qmqNqKqCqOqIq5q]q  q 1q`qZq"
" _rlqbtaqjp$q  ^qkqatbr^q]rjrewdqhqgqlqlqfrjrOuKqKu8p_rlpOqkqcq]qFpgpcp\"pgpTpkp\\q^p\\p^qLump:p^pjpLpgpepgpbpjpPt`t`t`t`t`qnq_qnqcripeq]q]q]q]q]q]q]q]qj"
"sfskqerjrfrjrfrjrfrjrfrjrRrjrfqiqeqiqeqiqeqiqeqkqcvbrlq`q]q_plp Iq]q_qmqNq]q_qmqKtIq]q_qmq ^q]q^plpKq`q mqkqcqkqcqkqcqkqcqkqdq`qhq5q^qLt`ueunudtasbqip"
"`q`pipcq  [qIq_qmq`{gvcqmqkpdq_q\\q\\q]rZq%q_rkraqZq]qaqnqbq]qXqcqiqeqiq1pSpXq`qfrhqnqbqjqdq]qhqfq]q]q]qiqeq]q]qmrbq]qnqmqnqgskqeqhqfqjqdqhqfqjqeqYq`qiq"
"frjreqkskqirnrdrmr]qdq]qZq]qkq)qCqOqIq5q]q  q 1q`qZq _qkq_qaq mq  ^qkqaqnqar_q]qhqfrnqnreqhqgqlqlqfqhqPwLqLw9p_q_phqdqkqcq]qGplslpiu#pmtlpUpkp\\q_q_r8u"
"mp:p^pjpLpgpepgperipcq^qnq`qnq`qnq`qnq`qnq`qnq`qmqcq]q]q]q]q]q]q]q]q]qhqfskqeqhqfqhqfqhqfqhqfqhqdphpfqirfqiqeqiqeqiqeqiqermrcwcqkq    [q 3qZp Oq nqmqm"
"qeqiqeqiqeqiqeqiqeq_piq4q^pLvatd|evdvcqipasaqkqdq  [qHq_qmq`{hrnpmpcqmqlpcq_q\\pZp]rZq%q_qiqaqZq]qapmqbq^qWqcqiqeqiqdq]qUsSs[qaqdqhqnqbqjqeq\\qgqgq]q^q\\"
"qiqeq]q]qnraq]qnqmqnqgqnqlqfqfqgqjqeqfqgqjqeqYq`qiqeqjqdqlqmqlqhqnqbqmq]rdq]qZq^pgp=taqns`s`snqatdv_snqcqnsbq]q]qkqcq]qnsmshqns`saqnsasnqcqnr`tbvaqjqe"
"qiqdqkqkqjrkreqiqdw`q`qZq#tnreqkq^qatauaqnsdqiq`raqjqdqiqdpmrcxdqmqmqatbxfyeqiqbqnq`r`q^qfqhrmqmrfqhqgqlqlqgqfqep[pnqnp[p`q`pipbpnqnpNq]taq^qnqnqbqmqb"
"q\\qIqmpkpmqkqkp$qmpkpmqVqmq\\q`q[pLqjqeump:p^pjpLphpdphpapkpbq^qnq`qnq`qnq`qnq`qnq`qnq`qmqdq\\q]q]q]q]q]q]q]q]qgqgqnqlqfqfqhqfqhqfqhqfqhqfqfrjrhqiqnqgqi"
"qeqiqeqiqeqiqdqmqbqkrdqmsbt`t`t`t`t`t`tlsfs_t`t`t`tbq]q]q]q[tbqns`s_s_s_s_s\\q`smpdqjqdqjqdqjqdqjqeqiqdqnscqiq;qlqlqgqgqgqnqmqnqgqjqnqgqgqfq_qjq<{fpjpL"
"vatd|fxeqkqdqipasaqkqdp  \\yNqGplqeqmp`qmqmqcrLqZq`qnpnq\\q%q_qiqaqZq^rbqmqbubqms^qaqkqdqiqdq]qXuf{fu_q`qlrnqlqjqlqcqkreq\\qgqgq]q^q\\qiqeq]q]t`q]qnqmqnqg"
"qnqlqfqfqgqkreqfqgqkres[q`qiqeqjqdqlqmqlqhs`s]rcq]qZq#vbwcvbwcwev`wcwcq]q]qlqbq]vnthwcwcwcwcubwcvaqjqdqkqcqkqkqiqkqdqiqdw`q`qZq7smsfxdqlr^qavdvawdqkq_"
"raqjqdpgpeqntdxdqmqmqcwdyfyeqiqcqlq`raq^qfqhqlqlqfqhqgqlqlqgqfqfrZqZraqarkraqLq^vbq^wbqmqbq]tKpmpfpkpjp_plp9plpkplpUs[qaqZpLqjqeump:p^pjpaplp_piqdpiqa"
"plqbq_qlqbqlqbqlqbqlqbqlqbqlqbrmqdq\\q]q]q]q]q]q]q]q]qgqgqnqlqfqfqhqfqhqfqhqfqhqfqerlrgqjqmqgqiqeqiqeqiqeqiqcsaqjqdqnq`vbvbvbvbvbvbvnuivbwcwcwcwcq]q]q]"
"q]wcwcwcwcwcwcwOwcqjqdqjqdqjqdqjqeqiqdwdqiq;pkqkpgpepgpmumpgpjrmpgpepfq_qkq;{hrkpLxdxf|fxepipdqipas`pkpcp  ZqHqGplpdt_pmplpmshsMqZqaplplp]q&q^qiqaq[qa"
"t`plqbvcx_q`ucrkr:uc{cucq`qlvlqjqlqcwdq\\qgqgxdvcqjtfyeq]q]s_q]qmsmqgqmqmqfqfqgwdqfqgwcv_q`qiqdqlqbqmqmqmqfr`s]qbq\\q[q#pjqcrlrdqkpcrlrcqkrdq^rlrcrlrdq]"
"q]qmqaq]rlrlqirlrdqkqcrlrerlrcr_qjpbq]qjqdqkqcqlslqhqmqbqkq^q_q`qZq_tjpSqmsmpgrlsdqnsaqmqbqkqdq\\rlrdqlq_raqjqeqgqgrnqnrdqlqcqmqmqcqkqerkq`qaycqlq_rbq^"
"qfqhqlqlqfqhqgqlqlqgqnvnqgrYqYrbqbrirbqLq_rnpmpdwaqmqcydq^qlqLpmpfpkpkq`plpa{RpltkpB{gpXpLqjqdtmpcqHp]plp_plp`pipjpipipmsfplpjphr_qlqbqlqbqlqbqlqbqlqb"
"qlqbqlxkq\\xdxdxdxdq]q]q]q_vjqgqmqmqfqfqhqfqhqfqhqfqhqfqdrnrfqkqlqgqiqeqiqeqiqeqiqcsaqjqdqnq`pjqcpjqcpjqcpjqcpjqcpjqcpjrlrjqkpbqkrdqkrdqkrdqkrdq]q]q]q]"
"qkrdrlrdqkqcqkqcqkqcqkqcqkqOqkqcqjqdqjqdqjqdqjqdqkqcrlrdqkq:pnwnpgpnwnpgplslpgpkrlpgpkqkpfq^qlq6qaqlpMzfzfzfzgqipdqipbqmp`qmqc|  fqHqHqlpcuasmplpmpiul"
"qSqZq]p^{+q^qiqaq\\q`ubqlqbpkrdrkrarawcx<tEteq`qlqlqlqjqlqcwdq\\qgqgxdvcqjtfyeq]q]t`q]qmsmqgqmqmqfqfqgvcqfqgv_t`q`qiqdqlqbqmqmqmqgs_q]qaq\\q[q\"vcqjqeq]qj"
"qdqiqdq^qjqcqjqdq]q]qnq`q]qkqkqiqjqeqiqdqjqeqjqcq^s^q]qjqdqkqbqmsmqgqmqbqkq_qas_qYsc{Spkqkphqkrcqntcvcqiqeq\\qjqdqmr`tbqjqeqgqgqmqmqdqlqcqmqmqdqiqfqiqa"
"qaycqlq_qaq^qfqhqlqlqfqhqfqmqmqfqnvnqh}cqc}cqc}cqLq_qmpawbqkqasaq^qkqMpmpfpjsnpaplp`{RplpmqkpB{huatKqjqbrmpcqJt^r]plpctlpjqktlpmpkpltlpjqhq^qlqbqlqbql"
"qbqlqbqlqcrlrcqlxkq\\xdxdxdxdq]q]q]q_vjqgqmqmqfqfqhqfqhqfqhqfqhqfqcteqlqkqgqiqeqiqeqiqeqiqbq`qkrdqmravbvbvbvbvbvbvjqkq]qiqeqiqeqiqeqiqdq]q]q]q^qiqdqjqe"
"qiqeqiqeqiqeqiqeqiqd{hqkpnqdqjqdqjqdqjqdqjqdqkqcqjqdqkq:pnwnpgpnwnpgplslpgplrkpgpkqkpfq^qlq6qaqmqMzg|fxdxfqipdqipbqmqaqmqcp  \\wLqK{dt]qmqmqkrmrnrSqZqK"
"{TtKq^qiqaq]r\\rdqkq\\qdqiqaqarkrcsmq<tEtfq_qlqlqlqkqjqdqjqeq\\qgqgq]q^qgqfqiqeq]q]qnraq]qmsmqgqlqnqfqfqgq^qfqgqkq]raq`qiqdqlqbqnqkqnqgt`q^raq\\q[q#wcqjqe"
"q]qjqdydq^qjqcqjqdq]q]s_q]qkqkqiqjqeqiqdqjqeqjqcq]uaq]qjqcqmqaqmpmpmqfs`qmq_ras_qYscpjtRpkqkphqkrcqkreqlrcqiqcr_qjqdqmq_qnqbqjqeqlqlqgqmqmqdqlqcqmqmqd"
"qiqfqiqaqaqiqdqjqaq`q^qfqhqlqlqfqhqfrnqnrfqfqh}cqc}cqc}cqLq_qmp_q^qkq`qMrlqMpmpfpWplpUqRplplqlp=q&qjq`pmp _plp]qkpnpdqhpeqkpnpiq^qjqdqjqdqjqdqjqdqjqdq"
"jqdqkqdq\\q]q]q]q]q]q]q]q]qgqgqlqnqfqfqhqfqhqfqhqfqhqfqbrdqmqjqgqiqeqiqeqiqeqiqbq`wcqlrcwcwcwcwcwcwc~kq]yeyeyeydq]q]q]q^qiqdqjqeqiqeqiqeqiqeqiqeqiqd{hq"
"lpmqdqjqdqjqdqjqdqjqcqmqbqjqcqmq9pkqkpgpepgpmumpgpmrjpgpepfq]pmq:{epmpLzg|evbveqipdqipbqmqaqmpbq  [qHqK{cpmq^plqmqkqktRqZqFqOtKq^qiqaq^rZqdy^qdqiqaqaq"
"iq]q:uc{cudq_qlqlqmqjxdqiqfq\\qgqgq]q^qgqfqiqeq]q]qmrbq]qlqlqgqlqnqfqfqgq^qfqgqkr]qaq`qiqcqnqaqnqkqnqhrnq`q_r`q\\q[q$qjqcqjqeq]qjqdydq^qjqcqjqdq]q]s_q]q"
"kqkqiqjqeqiqdqjqeqjqcqZsbq]qjqcqmqaqnqmqnqfs`qmq`r^r`qZr9pkqkphqkrcqjqeqkqcqiqet_qjqcqnq`rnqbqjqeqlqlqgqmqmqdqlqcqmqmqdqiqfqiqaqaqiqdqjqbr`q]qhqgrmqmr"
"fqhqeweqfqgrYqYrdpnqnpdrirdpnqnpNq_qmp_q]qmqcyPrmqMqmpkpmqkvaplpVqRqmpkpmq=q&qjq`pmp(v_plp\\pkpmpdphqepkpmpjq]xdxdxdxdxdxdwdq\\q]q]q]q]q]q]q]q]qgqgqlqnq"
"fqfqhqfqhqfqhqfqhqfqcteqnqiqgqiqeqiqeqiqeqiqbq`vbqjqeqjqdqjqdqjqdqjqdqjqdqjqdqjxkq]yeyeyeydq]q]q]q^qiqdqjqeqiqeqiqeqiqeqiqeqiqQqmplqdqjqdqjqdqjqdqjqcq"
"mqbqjqcqmq9qlqlqgqgqgqnqmqnqgqnqjqgqgqfq]qnq:{eqnpLzg|dt`tdqipcpipbpkp`sbq  Zq plq`pmq_pkqmqkqjrQqZqFq'q]rkraq_rYqdy^qdqiqbq`qiq^q6uf{fuaq_qlyjzeqiqeq"
"]qhqfq]q]qhqfqiqeq]q]qlrcq]qlqlqgqkseqhqfq]qhqfqjq]qaq`qiqcqnq`skshrmraq_q_q[q\\q$qjqcqjqeq]qjqdq\\q^qjqcqjqdq]q]qnq`q]qkqkqiqjqeqiqdqjqeqjqcqXqbq]qjqcq"
"mqaqnqmqnqgqmq`s_q\\q`qZq7pmpnqmpgqkrcqjqeqkpbqiqeq\\qjqcs_qlqcqjqeqlqlqgqmqmqdqlqcqmqmqdqiqfqiqaq`qkqdrjrdr_q]riqfrnqnreqhqducqhqerZqZrdwdrkrdwOq_qmp_q"
"^w`q`q[sKplslpTplpWqQpmpkqnp<q&qjq`pmp aplp\\pkplpephqepkplpjq^zfzfzfzfzfzfxcq]q]q]q]q]q]q]q]q]qhqfqkseqhqfqhqfqhqfqhqfqhqcrnreriqfqiqeqiqeqiqeqiqbq`q]"
"qjqeqjqdqjqdqjqdqjqdqjqdqjqdqjqdq]q]q]q]q\\q]q]q]q^qiqdqjqeqiqeqiqeqiqeqiqeqiqQqnpkqdqjqdqjqdqjqdqjqbsaqjqbs7qmqmqeqiqeqiqeqiqeqiqeq]qnp7q]rJrnpnresnpn"
"sct_rcqipcqkqcqkqasaq  [rkp&plpcplpnr`qkqmqkrltRqZqFq'q\\qkq`q`r_pjr^qcpjrcqkrbq`rkrdpkr3sSsLrlrnrhqhqeqjreripeqjsfq]q]riqfqiqeq]q]qkrdq]qgqgqkserjrfq]"
"rjrfqjrfpiraq_qkqbt`skshqkqaq`q^q[q\\q$qkrcrlrdqkpcrlrcqipdq^rlrcqjqdq]q]qmqaq]qkqkqiqjqdqkqcrlrerlrcq^pjqbq]rlrbs_rkrfqmq`s`r\\q`qZq6qlrfrmscrlrepkqbrk"
"qdqkpaqjqcs`rlqcrlrernsnrgrnqnrdqlqcrnqnrdrkqdqkraq`qkqdqhqer^q\\rkqdwdqhqbqarjrdpYqYpbubpipbuNq_rnpmpbq^qnqnq`q`qZqIpgpRplp7pgp;q&rlr`pmp bplp[pkufpiq"
"dpkukrlpcqhqfqhqfqhqfqhqfqhqfqhqfqjqcripeq]q]q]q]q]q]q]q]qjsfqkserjrfrjrfrjrfrjrfrjrdrlrfrjreqkqcqkqcqkqcqkqaq`q]qnplqeqkrdqkrdqkrdqkrdqkrdqkrdqksjpjq"
"kpbqipdqipdqipdqipdq]q]q]q]qkqcqjqdqkqcqkqcqkqcqkqcqkq^qbqkqcrlrdrlrdrlrdrlrbsarlrbs6qkqcqkqcqkqcqkqcqkqdq\\r7q\\qFp\\p]r^rcqipcvbqkqas`r  \\vOqIqlpcw_pip"
"mpivnrRpZpEqbqIq^q[ubwdxdw]qcwbwaq_wcvbq]qRpSp[q^q^qhqexcxeyexdq\\xeqiqeq]q]qjrexdqgqgqjrdxeq\\xeqiqfx`q_war_ririqiqbqazfq[q\\q$xcwcvbwcxdq]wcqjqdq]q]qlq"
"bq]qkqkqiqjqdwcwcwcq^wbu`wbs_rkrgqkq`q`w`q`qZq$yewdqmq`wdvaqjqbr`qkqcyeyewcqlsdwcxdw`sauczexdq^umteucqhqbq`xLqJsKsMq^vdxdpgpaq`qYqIqkq bqkq?{+yapmp Jp"
"fpfpipcpfpiucqhqfqhqfqhqfqhqfqhqfqhqfqjxixexdxdxdxdq]q]q]q]yeqjrdxdxdxdxdxdrjrgpnwdwcwcwcwaq`q]qnuexdxdxdxdxdxdvnwjvbxdxdxdxdq]q]q]q]wcqjqdwcwcwcwcw^q"
"bwbwcwcwcwaq`w`q4uauauauaucq\\r7p[qFp\\p\\p\\pbqipasapip`q^y  ctNqIqmqbu_phsgslrSq\\qEqbqIq^qZsawdxcu\\qbt^taq]uataq]q q]qgpiqfqfw`udwcxdqZudqiqeq]q]qirfxdq"
"gqgqjrbtcqZtcqirfv_q]s_r_rirjrircqazfq[q\\q#tnqcqns`s`snqaucq\\snqcqjqdq]q]qkqcq]qkqkqiqjqbsaqnsasnqcq]t_t_snqaq^rkrhrkraq`w`q`qZq#smrevbs^t`s`qjqbq`qiq"
"dqnrmqdrmrcubqkrcubqntat^r`sc|fxdq^umtcqaqhqbq^tJqIqIqLq]tcxLq`qYqHu `u>{+qnrmqapmp Kpepgpiuhpephscqfqhqfqhqfqhqfqhqfqhqfqhqixgudxdxdxdxdq]q]q]q]wcqjr"
"bt`t`t`t`taphpgplt`s_s_s_s_q`q]qmsctnqctnqctnqctnqctnqctnqbsktgs_uauauaucq]q]q]q[saqjqbs_s_s_s_sNpms_snqbsnqbsnqbsnqaq`qns_q !p Zp      jp#q\\q6q7q   l"
"q [sjq  Qq -q  OqZq]q  Cq;q HqWq $rIq`qZq _q iqbqKqFqIq`q     hp$q]u   JqYpmpLp   .p        jp    ]p Xr`q[r !p       Tp\"p\\p6q6q   mq Yx  Qr -r  Ps\\q_s"
"  Ipkq:q HqWq $qHq`qZq _q iqbqKqFqIq`q     hp$q]t   IqYpmpLq   /q        kq     Fq_q[q #s       Tp\"q^q6p   1p Vu  Rs    YsJsMy &v<s HqWq &sHtcq]t _q i"
"qbqKqFqIq`q     hp$q   2q2q   /q        kq     Hs_q]s \"q                (r     Xy %t;r GqWq &rFscq]s ^q iqbqKqFqIq`q         ,q4r   0r        lr     G"
"r^q                               *q                                                                                   kr               i";


    const char *const data_font47x53 =
"                                                                                                                                                      "
"        9])]2_2]T\\8^U^3]  E])]2`4^U^>])]2_4^U^ 6^T\\5])]1_2]T\\8^U^  K])]2`4^V^3]                                                                       "
"                                                                                                                    U]*\\2a4`V\\8^U^5a  F]*\\1\\X\\4^U^=]*\\"
"2a5^U^ 7aV\\4]*\\1a4`V\\8^U^  J]*\\1\\X\\4^V^3\\                                                                                                             "
"                                                                              S],\\1\\W\\5g8^U^6c  F],\\1\\V\\5^U^<],\\2]W]6^U^ 8h3],\\0\\W\\5g8^U^  I],\\1\\V\\5^V"
"^4\\      ;]                                                                                                                                           "
"                                         :\\-]2\\U\\6\\V`7^U^7]U]  F\\-]2\\T\\6^U^;\\-]3]U]7^U^ 8\\Va1\\-]1\\U\\6\\V`7^U^  H\\-]2\\T\\6^V^5]      =a                  "
"              J]                                                                                                                                      "
"              N\\/]2\\S\\7\\T]6^U^7\\S\\  E\\/]2\\R\\7^U^:\\/]3]S]8^U^ 8\\T^/\\/]1\\S\\7\\T]6^U^  G\\/]2\\R\\7^V^6]      =c                                L^           "
"                                                         *^                            U`                                         O^             )\\S\\ "
"                    !^$^3\\  E]U\\  K^$^4^ G^$^4]   J^$^3\\   #^$^3\\ 4^            B[                                                                    "
"&^                            Xe                                         S^             (\\S\\               )Z      Q^&^3^2]S\\ A\\S\\  K^&^3^ F^&^4_  >]S"
"\\9^&^3^2]S\\   W^&^3^ 6^        Q]    M[               ?`   ![1^H]?` =]4](\\    %` >b4c  Bb ?`2a    .a   Ib   Pb      Aa <a @b      Fb =b  F^ :] '] Da A"
"].].].].]            <_:]._    Xh ?c   W^       @`   La   Pa        Sa   Va5^U^ @`   \"f4_ >`0`*^   $^.` <^F]F^F]G`G]     F\\S\\ ;b        %a2a2a2a2a <bR"
"\\     D`4^(^3`4`U\\8^V^6\\S\\  J^(^3`4^U^@^(^3_4^U^/^/`U\\8^(^3`4`U\\8^V^  K^(^3`4^V^1^9]+^V^      ?`    O\\  D\\6]M]            We D]1]T] 9[3bJ\\@e<])]2])\\  "
"  T]0d3_7h9i/_;k5f?n:f7e    3g :_8i3h@h9n?l5iB]H]C].].]J^B].`I`H_J]<g?g1g?g4hAuB]H]G]C]F]K_K]S^J^F^G^CrBb7]*b'_ D] :] '] Fc A].].].].]            >a:]"
".a   !^T_ Bg   `       Dd2_8n?m7g3]:rD]P]P]@g <] 8] 8] B] 3e J^K^ If7^U^+b@d   Fb@f5a Ad4e-] :f  Ra0d AaF\\HaF\\HeJ\\?]._0_0_0_0_2\\U\\0tHh@n?n?n?n?].].].]"
"-h:_J]<g8g8g8g8g BhV]G]H]C]H]C]H]C]H]G^G^B]*d5](]2\\X\\4aW]8^V^6\\S\\  I](]3]X]5^U^?](]3\\W\\5^U^.^R[9aW]7](]2\\X\\4aW]8^V^  J](]2\\X\\4^V^1]8]+^V^      ?a>w   "
"P[ 9[/a:aQa7[    Wl      \"h E]1]T]+\\R\\;[4dL]Ag=])]2])\\    U^1f8c8k;j1`;k7h?n;h9g    5i*b:_8k6kBl=n?l7mD]H]C].].]L_A].`I`H`K]>kAj6kAj9kBuB]H]F]E]E^L_L^"
"R^L^D^I^BrBb7^+b(a D] ;] '] Gd A].].].].]      ;]     (b:].b   #^Q] Dj  !a       Ff3_8n?m8i4]:rD]P]P]Bk ?_ 9] 9_ C]&[0f I]K]=]0g7^U^-fC\\S]   IfBf6c B["
"S]5[S].] <i  R\\W\\1]T] B\\W\\G]H\\W\\G]H[S]K]?]._0_0_0_0_2c1uIkBn?n?n?n?].].].]-l>`K]>k<k<k<k<k EoF]H]C]H]C]H]C]H]F^I^A],h6]*]2\\V\\6]Wa7^V^6\\S\\  H]*]2\\V]6^U"
"^>]*]3]W]6^U^._V_;]Wa5]*]2\\V\\6]Wa7^V^  I]*]2\\V\\5^V^2]7]+^V^      @]W\\=v   P[ 9\\1c<cSd:]   \"o      #_S^ F]1]T],]S];[5^V^N]A_T]=]*]0]*\\    U]1^T^;e8`S_<"
"^R_2`;k8^R]?n<_T_;^S^    6^S_.i>_8m:`R`Cn?n?l9`QaE]H]C].].]M_@].aKaH`K]?`S`Bk8`S`Bk;_R_BuB]H]F]E]D]MaM]P]L]B^K^ArB]1]&])c D] <] '] G] :].].].].]      "
";]     (^6]*^   #]P^ E^P\\   V^       H^T^4_8n?m:`S`6]:rD]P]P]C`S` Aa :] :a D]&[1^S\\ I^M^=]0^R[7^U^/^R^EZO\\   L^R^ N]U] :],\\0] <j  M\\2]R] >\\H]B\\H]=\\M]>"
"]._0_0_0_0_0_/uK`R`Cn?n?n?n?].].].]-n@`K]?`S`>`S`>`S`>`S`>`S` H`ScE]H]C]H]C]H]C]H]E^K^@],^T^5],]1\\V\\6\\U`7^V^6]U\\  F],]2\\T\\6^U^=],]2\\U\\6^U^-e9\\U`4],]1\\"
"V\\6\\U`7^V^  H],]1\\V\\5^V^3]6]+^V^  B`1`1`1`1`6]W]>u   P[ 9]2e>eUf;^   %q      $^O\\ F]1]T],]S];[5]T]N\\@]P[=]*]0]2ZR\\RZ   $]2]P]<_W]8]N]<ZL^4a;]+]MZ/]<^P"
"^=^Q^    7\\O]1nAa9]N_<_M]C]NaA].]+_L^E]H]C].].]N_?].aKaHaL]@^M^C]P_:^M^C]P_=^M\\6]6]H]F^G^D]MaM]P^N^B^K^-^B]1]&]*e D] =] '] H] 9].].].].]      ;]     )"
"^5])^   %^O]8^3]LZ   U]       I^R^6a9_0]+^M^7]:]H]D]P]P]D^M^ Cc ;] ;c E]&[2^PZ H]M]<]1^-^U^1]L];[   N]L] Q]S] :\\,\\1] <dU\\  M\\2\\P\\ >\\H\\A\\H\\<\\M\\=]/a2a2a"
"2a2a1_/]V];_M]C].].].].].].].]-]ObBaL]@^M^@^M^@^M^@^M^@^M^ J^N`D]H]C]H]C]H]C]H]E^K^@]-^Q]5].]1\\T\\7\\S]6^V^5c  E].]2]S\\7^U^<].]2\\S\\7^U^,a6\\S]2].]1\\T\\7\\S"
"]6^V^  G].]1\\T\\6^V^4]5]+^V^  De6e6e6e6e9\\U\\>u   P[ :_3f@gVf<_   &r      $]M[ F]1]T],\\R]>d<^T^P]A^OZ=]+].]4]T\\T]   &^3^P^=[S]8[K].]4\\X];],]!]<]N]>^O^  "
"  8ZM^3`P`Ba9]M^=^J\\C]K_B].],^H\\E]H]C].].]O_>].aKaHaL]A^K^D]N^<^K^D]N^>]JZ6]6]H]E]G]C]MaM]O^P^@^M^-^A]1]&]+_W_ D] >] '] H] 9]  B].]      ;]     )]4](]"
"   %]N]:c6]   G]       J^P^7a8_1],^K^;c=]H]D]P]P]E^K^ Ee <] <e F]&[2] =^O^<]1] 0\\H\\<\\   P\\H\\ R\\Q\\+]3\\,\\2] <eU\\  M\\3]P\\ >\\I]A\\I]<\\N]=]/a2a2a2a2a2a1]U]<"
"^J\\C].].].].].].].]-]K_CaL]A^K^B^K^B^K^B^K^B^K^ K]K^D]H]C]H]C]H]C]H]D^M^?]-]P]4]0]1\\R\\  Ha  C]0]2]R] E]0]2\\Q\\ 9c 9]0]1\\R\\   !]0]1\\R\\ ?]4]   Di:i:i:i:i"
";\\6]G]   P\\ :`5g@gWh>a   (_       J]KZ F]1]T],\\R\\?h>]R]P\\@]1]+].]3^V\\V^.]   T]2]N]5]8ZJ]-]6]X];]-]!^=]L]?]M]    *]5_J_Ec:]L^>]H[C]I^C].],]F[E]H]C].].]"
"P_=].]X]M]X]HbM]A]I]D]M]<]I]D]M]?]%]6]H]E]G]C^NaN^N]Q^>^O^-^@]0]'],_U_  &] '] H] 9]  B].]      ;]     )]4](]   %]N]:d7]   F]       K]N]8c8^1],]I]>i@]H"
"]D]P]P]E]I] Fg =] =g G]&[2] <]O];]1] 1\\F\\=\\   Q\\F\\ S\\Q\\+]3\\.]  IeU\\  M\\3\\N\\ ?\\I\\@\\I\\=]M\\<]0c4c4c4c4c3a1]U]<]H[C].].].].].].].]-]J_DbM]A]I]B]I]B]I]B]I]"
"B]I] L]J_E]H]C]H]C]H]C]H]C^O^>].]N]    .]        '`X_           I]   FbWa=bWa=bWa=bWa=bWa<\\6^I^  ?Z2[ :a5gAiXh?c   *^       H] 7]1]T]-]S]Aj>]R]Q]@]1],"
"],\\1^X\\X^,]   T]3]L]6]'].]7]W];]-]!]<]L]?]M^    +]6^F^F]W]:]K]?]FZC]H^D].]-]DZE]H]C].].]Q_<].]X]M]X]H]X]M]B]G]E]M^>]G]E]M^@]%]6]H]E^I^B]O^X]O]M^R^=]O^"
"-^@]0]']-_S_  '] '] H] 9]  B].]      ;]     )]4](]   %]N]:e8_   H]       L]M]8]W]7^2]-]G]AmB]H]D]P]P]F]G] Hi >] >i  J[3] ;^Q^;]1] 2\\RbT\\Ge   R\\VdR\\ T\\"
"Q\\+]4\\2a  IfU\\  M\\3\\N\\ ?\\J\\?\\J\\AaM\\ G]W]4]W]4]W]4]W]4]W]4c3^U]=]FZC].].].].].].].]-]H]D]X]M]B]G]D]G]D]G]D]G]D]G]A[H[B]J`E]H]C]H]C]H]C]H]B]O^>g8]N]    "
"         1]T_      3[    9]   G_O^?_O^?_O^?_O^?_O^=\\5]I^  @\\3[ ;c6gAy?d7`8]L]7^7]L]>^       H] 6]1]T]-]S]B_W[U]>]R]R]?]1],],]0d*]   T]3]L]6]'].]7\\V];]"
".] ]<]L]@]K]  7Z PZ X]7^D^G]W]:]K]?]/]G]D].]-]/]H]C].].]R_;].]X^O^X]H]X^N]B]G]E]L]>]G]E]L]@]%]6]H]D]I]A]O]W]O]L^T^<^Q^-^?]0]'].^O^  Sb7]U`2b4`U]8a8])`"
"7]T_  M].]%_O_@_2`0`3`/_3c9]     )]4](]   N_6]N]3^7a/c0_ <^  D[U^  Ga  N]L]9]W]6^3]-]G]B`W]W`C]H]D]P]P]F]G] I_X]X_ ?] ?_X]X_  Nb7]2ZFZ=]Q]:]0] 3[SfU[I"
"g   R[UfS[ T\\Q\\+]5]2a  IfU\\  M\\3\\N\\ ?\\K]?\\K]AaN] G]W]4]W]4]W]4]W]4]W]4]W]3]T]=]/].].].].].].].]-]G]E]X^N]B]G]D]G]D]G]D]G]D]G]B]J]C]KbF]H]C]H]C]H]C]H]B"
"^Q^=j;]P_9b3b3b3b3b3b3bN`Bb3a2a2a2a    V_2_2`1`1`1`1` ;aU]    :]U`   S^T]U^A^L^A^L^A^L^A^L^?]5]I]  @^5\\ <e7gAy@f;e:]L]8`8^N^?^       G] 6]1]T]-\\R\\A]U["
"RZ>]R]R\\>]1],],].`(]   U^3]L]6]'].]8]V];].]!^<]L]@]K]  :] P]#^8^A]I^W^;]K]@].]G^E].].].]H]C].].]S_:].]W]O]W]H]W]N]C]E]F]L]?]E]F]L]@]%]6]H]D]J^A]O]W]O]"
"L^U^:^S^-^>]0^(]/^M^  Wh:]Wd6f8dW]:e>h2dW]?]Vd<].].]O_>].]WdScK]Vd8f;]Wd7dW]?]Wa6h>h6]L]B]I]A]P`P]K^L^B^K^@l4]4](]   PdU]A]N]2^8e5g;]Vd?^J^8]6]L] E]V`"
">pA]S]S]:e6kDo>]L]:^W^6^4].]E]D_U]U_D]H]D]P]P]G]E] K_W]W_ @] @_W]W_  Qf9]3\\H\\>^S^:]0_ 6[ThT[K]Q\\   S[T\\R]S[ U]S]+]6],] ?]L]@fU\\  M\\3\\N\\ ?\\K\\>\\K\\;]O\\ G"
"^W^6^W^6^W^6^W^6^W^5]W]4^T]>].].].].].].].].]-]G^F]W]N]C]E]F]E]F]E]F]E]F]E]D_L_E]K]W]F]H]C]H]C]H]C]H]A^S^<k<]Ra<h9h9h9h9h9h9hTeFf7e6e6e6e;].].].]\"^;]V"
"d8f7f7f7f7f/^6eX]@]L]?]L]?]L]?]L]B^K^?]Wd>^K^  O]S]S]B]I]B]I]B]I]B]I]@]5^K^  @]4[ ;f8gAyAg<h<]L]8`7]N]>]       F] 6]1]T]-\\R\\B]T[6]R]S]>^2]-]*\\.`(]   U"
"]2]L]6]'].]9]U];].]!];]L]@]K]  =` P`'^7]?\\I]U];]K]@].]F]E].].].]H]C].].]T_9].]W]O]W]H]W^O]C]E]F]L]?]E]F]L]@]%]6]H]C]K]@^P]W]P^K^V^9]S]-^=]/](]0^K^  Xi"
";]Xf9h9fX]<h?h3fX]?]Xg=].].]P_=].]XfVfL]Xg:h<]Xf9fX]?]Xb7i>h6]L]A]K]@^Q`Q^J^N^@]K]?l4]4](]   QfW^A]O^1]6f9h;]Xg@_K]7]6]L]=]G]C^Wc@pA]S]S]<h9mDo>]L]:]U"
"]5^5].]E]E^S]S^E]H]D]P]P]G]E]@Z+]V]V^-Z4]5ZKZ:]V]V^  Sh9]4^J^>]S]9]._ 8[U_Q[T[L]P\\   S[T\\Q]T[ T]U]*]7]*] @]L]@fU\\  M\\3\\N\\ ?\\L]>\\L]:]Q]:]1]U]6]U]6]U]6]"
"U]6]U]6^W^5]S]>].].].].].].].].]-]F]F]W^O]C]E]F]E]F]E]F]E]F]E]C_N_D]L^W]F]H]C]H]C]H]C]H]@]S];]P_=]S^8i:i:i:i:i:i:iVgIh9h9h9h9h<].].].]'d<]Xg:h9h9h9h9h"
"0^8k?]L]?]L]?]L]?]L]A]K]>]Xf>]K]  O]R]R]D]G]D]VZOZV]D]KZV]D]G]A]4]K]  @]3[ <g7fAyBi>j=]L]8`7]N]?]       F^ 6]1]T]5uI]T[6]R]S\\<^3]-]*]1d*]   U]3]J]7]']"
".]9\\T];].\\Ua-^;]L]@]K^?].] Uc Pc+_8]>]J]U];]K]@].]F]E].].].]H]C].].]U_8].]W^Q^W]H]V]O]C]E]F]L]?]E]F]L]@^&]6]H]C]K]?]Q^V]Q]I^X^8^U^.^<]/](]1^I^  ]R_<aT"
"_;_R\\:^Tb=_S^@h4_Ub?bT^=].].]Q_<].aT_X]T^LbT^;_T_=aT_;^Tb?aTZ8_R]>h6]L]A]K]?]Q`Q]H^P^?]K]?l4]4](]   R^U^W]@]O]0^7g;_S];bT^@`L]8_7]L]>]E]E^W]V]@pA]S]S]"
"=_T_<oDo?]K^;]U]5_6].\\D]E]R]R]E]H]D]P]P]G]E]A\\+[U]U\\,\\6]6\\L\\;[U]U\\  S_W[V\\9]3^V`V^=^U^9]/a :[T]G[M\\O\\1ZQZ  M[S\\P\\S[ Ud)]8](\\ @]L]@fU\\  M\\3\\N\\9ZQZ0\\L\\="
"\\L\\8\\Q\\9]1]U]6]U]6]U]6]U]6]U]6]U]5]S]>].].].].].].].].]-]F]F]V]O]C]E]F]E]F]E]F]E]F]E]B_P_C]L]V^G]H]C]H]C]H]C]H]@^U^;]N^>]T]6]R_;]R_;]R_;]R_;]R_;]R_;]R"
"_X_T^K_R\\:_S^;_S^;_S^;_S^=].].].]*h=bT^;_T_;_T_;_T_;_T_;_T_1^9_T`>]L]?]L]?]L]?]L]A]K]>aT_?]K]  P]Q]R]E]F]E]V\\Q\\W]E]K\\W]E]F]A]4^L]  A^@ZN\\ =i8e@yCk?^R^"
"=]L]9b8]O^?]       Im B]1]T]5uI]T[6]S^T]<^3]-]*]3^X\\X^,]   V^3]J]7](^/]9]T];e7]We/]9]N]?]K^?].] Wd Nd._8]O`U\\T\\K]S]<]L^A]-]F^F].]/]-]H]C].].]V_7].]V]Q"
"]V]H]V^P]D]C]G]L]@]C]G]L]?^']6]H]C^M^?]Q]U]Q]Ic6^W^._<]/^)]2^G^ !ZM^=`Q^=^NZ;^Q`>^P^=].^Q`?`Q^>].].]R_;].`R^X\\R^M`Q^=^P^>`Q^=^Q`?`1]MZ;].]L]A^M^?]Q`Q]"
"G^R^>^M^1^4]4](]  D]P^A]R^X]@]P^/]9^Vb=^NZ;`Q^AaN^8_7]L]>]E]F^V]U]>]P]>]S]S]>^P^>`T`7]6]J]<]S]5^6]/]C]G]Q]Q]F]H]D]P]P]H]C]C^&]TZ,^7]7^N^6]TZ H]/^U[TZ9"
"]2n;]U]8]0d <[U]F[M\\P]2[R[  M[S\\P\\S[ Tb(]9]'\\ @]L]@fU\\  M\\3]P]9[R[1\\M\\<\\M\\7\\R\\8]2]S]8]S]8]S]8]S]8]S]7]U]6]R]?]-].].].].].].].]-]F]F]V^P]D]C]H]C]H]C]H]"
"C]H]C]B_R_C]L]T]G]H]C]H]C]H]C]H]?^W^:]M]>]U^6ZM^<ZM^<ZM^<ZM^<ZM^<ZM^<ZMbP]M^NZ;^P^=^P^=^P^=^P^>].].].]+i=`Q^=^P^=^P^=^P^=^P^=^P^2^:^P^>]L]?]L]?]L]?]L]"
"A^M^>`Q^@^M^  P]Q]Q]F]E]F]W^S^W]F]L^W]F]E]B]3]M^  B^B^O[ =k8d?xClA^P^>]L]9]X]8^P]>\\       Hl A] 9uI]T[5]T]T]:^ =]*]5^V\\V^.]   V]2]J]7](]/^:]S];h:]Xg0]"
"9^P^?]K^?].]!e Je2_7\\PdW\\S\\L]S]<]M^@]-]E]F].]/]-]H]C].].]X_5].]V]Q]V]H]U^Q]D]C]G]L]@]C]G]M^?`)]6]H]B]M]>]Q]U]Q]Hb5c-^;].])]   B]=_O]=].]O_>]N^>].]O_?_"
"O]>].].]S_:]._P`P]M_O]=]N]>_O]=]O_?_1]-].]L]@]M]>]RbR]G^R^=]M]1^3]4](]  FaSaD^Qa?]R_.]9]R`>]._O]>^N]8`7]L]>]E]G^U]U^?]P]>]S]S]>]N]>^P^7]6]J]<]S]4^7]/]"
"C]G]Q]Q]F]H]D]P]P]H]C]D_&]&_8]8_N_7] B]/]T[3]1l:^W^8]1]W` >\\U\\E\\N\\P]3\\S\\  N\\S\\P\\S\\ S_']:]&\\ @]L]@fU\\  M\\2\\P\\8\\S\\2\\N]<\\N]7\\S]8]2]S]8]S]8]S]8]S]8]S]8]S]"
"7]R]?]-].].].].].].].]-]E]G]U^Q]D]C]H]C]H]C]H]C]H]C]A_T_B]M]S]G]H]C]H]C]H]C]H]>c9]M^?]U]'].].].].].].`O^N].]N^>]N^>]N^>]N^?].].].],_R^>_O]=]N]=]N]=]N]"
"=]N]=]N]2^:]O_?]L]?]L]?]L]?]L]@]M]=_O]?]M]  O\\P]Q]F\\D]F\\U^U^V]F\\L^V]F\\D]B]3]M]  RuJ`O[ >m9c>wCmA]N]>]L]9]X]7]P]?]       Im A] 2\\R\\A]T[5^V^T\\:` ?](\\6]T"
"\\T]/]   V]2]J]7])^1_9]S];i;bS^2^8^S_>]K^?].]$e@u@e6_7]QfX\\S\\M^S^=]N^?]-]E]F].]/]-]H]C].].c4].]U]S]U]H]T]Q]D]C]G]M^@]C]G]M]=c-]6]H]B]M]>^R]U]R^G`4c.^:]"
".])]   B]=^M]?^/]M^?]L]>]/]M^?^N^?].].]T_9].^O_O^N^N^?]M^?^M]?]M^?^0]-].]L]@]M]>^S]X]S^F^T^<^O^2_3]4](]  GcUcE]Pa?]Vb-]:]O_?].^N^>]O^8a8]L]?]C]H]T]T]?"
"]P]>]S]S]?]L]@^N^8]6]J]=^S^4^8]/]C]H^Q]Q^G]H]D]P]P]H]C]E_%]%_9]9_L_8] B]0^T[3]0_T_>cWc=]1]U_ ?[U\\C[N]R^4]T]  N[R\\Q]R[ 'uG]&] @]L]?eU\\  M\\2]R]8]T]3\\N\\;"
"\\N\\7]S\\7]3^S^:^S^:^S^:^S^:^S^9]S]8^R]?]-].].].].].].].]-]E]G]T]Q]D]C]H]C]H]C]H]C]H]C]@_V_A]N]R]G]H]C]H]C]H]C]H]>c9]L]?]U]'].].].].].]._M]O^/]L]?]L]?]L"
"]?]L]?].].].]-^O]>^N^?]M^?]M^?]M^?]M^?]M^ I]O`?]L]?]L]?]L]?]L]@^O^=^M]@^O^  P]P]P\\G]C\\G]T^W^T\\G]M^T\\G]C\\B]3^O^  RuJ[X]P[ >o=\\XaX]BwDoC]L\\>]L]:^X^8]P]?"
"]       E] 5] 3]S]A^U[4dT];b @](]6ZR\\RZ.]   V]2]J]7]*^7d8]R];]R_<aQ^3]5f<^M_?].]'e=u=e:_6\\Q^S`S]N]Q]=l>]-]E]Fm>k=]-rC].].b3].]U]S]U]H]T^R]D]C]G]M]?]C]"
"G]N^<f1]6]H]B^O^=]S^U^S]F_2a.^9].])]   A]>^M]?].]M^?]L]>]/]M^?^M]?].].]U_8].^N^N]N^M]?]L]?^M]?]M^?^0]-].]L]@^O^=]S]X]S]D^V^:]O]2_2]4](]  H\\U^W]U\\E]Pa?"
"]Vb-];]M^?].^M]>^P]7a8]L]?]C]H]T]T]?]P]>]S]S]?]L]@]L]8]6p=]Q]3^9]/]C]H]P]P]G]H]C]Q]Q]G]ViV]F_$]$_:]:_J_9] B]0]S[3]0]P]>o=]2]S_ @[U\\C[M]T_5^U^;u O[R\\R]"
"Q[ 'uH]/ZQ] ?]L]?eU\\  M\\1]T]7^U^4\\O]O]I\\O]T`MZQ]S]O]E]3]Q]:]Q]:]Q]:]Q]:]Q]:^S^9]QmO]-m>m>m>m>].].].]1hL]G]T^R]D]C]H]C]H]C]H]C]H]C]?_X_@]O]Q]G]H]C]H]C]"
"H]C]H]=a8]L]?]U]&].].].].].].^M]O].]L]?]L]?]L]?]L]?].].].].^M]?^M]?]L]?]L]?]L]?]L]?]L] I]Pa?]L]?]L]?]L]?]L]?]O]<^M]?]O]  O]P]P\\G]C\\G]ScS\\G]N^S\\G]P]P\\B"
"]2]O]  QuF]Q[ >oAqDuDqD]L]?]L]:^X^8^R^?\\       D] 5] 3]S]@`X[3bS\\R^G]W^N] P](].\\&]   W]1]J]7]*^7c8]Q];ZM^=`O^4]4d:]M_?].])d:u:d=_5\\R]O^R\\N]Q]=j<]-]E]F"
"m>k=]-rC].].a2].]U^U^U]H]S]R]D]C]G]N^?]C]G]P_:g3]6]H]A]O]<]S]S]S]E^1_.^8]-]*]   A]>^M]?]/^M^?]K]?]0^M^?]L]?].].]V_7].]M]M]N]L]@^L]?^M]@^M^?]/]-].]L]?]"
"O]<]S]X]S]C^X^9]O]2^1]4](]0_IZ O[R\\X]S\\G^O_>]Vd9_U];]L]?].]L]=]P]8]X^9]L]?]C]I^T]S]@]P]>]S]S]?]L]@]L^9]6p=]Q]3^9]/]C]H]P]P]G]H]C]Q]Q]G]ViV]G_#]#_;];_H"
"_:] B]0]S[3]0\\N\\>o=]2]Q^ A[U\\C[LcX\\6]T]9u O[RfP[ 'uIf7e >]L]>dU\\<] :f5d4]T]:fT\\O^NfT\\UdOeR\\O^F^3]Q]:]Q]:]Q]:]Q]:]Q]:]Q]:^QmO]-m>m>m>m>].].].]1hL]G]S]R"
"]D]C]H]C]H]C]H]C]H]C]>d?]P^Q]G]H]C]H]C]H]C]H]<_7]L]?]U^'].].].].].].^L]P].]K]@]K]@]K]@]K]@].].].].]L]?]L]@^L]@^L]@^L]@^L]@^L] I]Q]X^@]L]?]L]?]L]?]L]?]"
"O]<^M]?]O]  O\\WmX]H\\WmX]H\\QaR]H\\N^R]H\\O]P]C]2]O]  QuF]R\\ ?qCsDtDrE]L]?]L]:]V]7]R]>x      '] 5] 3\\R\\?e3^R\\SbJ^V^O] P](].\\&]   W]1]J]7]+^6e:]Q]-^>_M]5^6"
"h<^O`  Qe8u8e@^5]R\\M]R\\O^Q^>m?]-]E]Fm>k=]KdFrC].].b3].]T]U]T]H]S^S]D]C]G]P_>]C]Gk6f5]6]H]A^Q^<]S]S]S]F_1_/_8]-]*]   A]>]K]A].]K]@]J]?]0]K]?]L]?].].]W_"
"6].]M]M]N]L]@]J]@]K]A]K]?]/^.].]L]?]O]<]T^W]T]C^X^9^Q^3^1]3]']3dN\\ P\\R`Q[G]N_>]Q`;bW];\\K^?]/]L]=]Q^8]W]9]L]?]C]I]S]S]@]P]>]S]S]@]J]B^L^9]6p>^Q^4^9]/]C"
"]H]P]P]G]H]C]Q]Q]G]ViV]H_\"]\"_<]<_F_;] B]1]R[3]1]N]8a6]2]P^ B[U\\C[K`V\\7]T]8u O[RdN[ 'uIf5a <]L]=cU\\<] :f3`1]T];fU\\N^NfU\\T[S]NaQ\\N^G^3^Q^<^Q^<^Q^<^Q^<^Q"
"^;]Q]:]PmO]-m>m>m>m>].].].]1hL]G]S^S]D]C]H]C]H]C]H]C]H]C]=b>]P]P]G]H]C]H]C]H]C]H]<_7]L]?]U_(].].].].].].]K]Q].]J]A]J]A]J]A]J]@].].].].]L]?]L]@]J]A]J]A"
"]J]A]J]A]J] K]P\\V]@]L]?]L]?]L]?]L]?^Q^<]K]@^Q^  O\\WmX]H\\WmX]H\\P_Q]H\\O^Q]H\\O]P]C]2^Q^  D^<]R[ >qDuEsCqD]L]?]L]:]V]7]R]>x      '] 5] 3\\R\\=f+]TdL^T^P] P]"
"(].\\2u  *]1]J]7],^-_=]P],]>_M]5]7_R^<^Qa  Sd .dC^4\\R]M]R\\O]O]>]N_@]-]E]F].]/]KdF]H]C].].]X^4].]T]U]T]H]R]S]D]C]Gk=]C]Gj1c6]6]H]@]Q];^T]S]T^Ga1].^7]-]*"
"]   Lh>]K]A].]K]@]J]?]0]K]?]L]?].].]X_5].]M]M]N]L]@]J]@]K]A]K]?]._0].]L]>]Q];^U]V]U^Bb7]Q]3^1^3]'^6iS^ P[P^P[G]N_>]N^=dX]<]J]>^1]L]=^R]8^W]9]L]@]A]J]S"
"]S]@]P]>]S]S]@]J]B]J]9]6]J]>]O]5^8]/]C]H]P]P]G]H]B]R]R]F]C]Iz<]<z=]=z<] B]1]R[7j:\\L\\7_5]2]P^ B[U\\C[ V]T]7u O[R\\U^O[  T]   ]L];aU\\<]   I]T],]O[X\\>]K]@]"
"O[X\\I`3]O]<]O]<]O]<]O]<]O]<]O];]P]?]-].].].].].].].]-]E]G]R]S]D]C]H]C]H]C]H]C]H]C]<`=]Q]O]G]H]C]H]C]H]C]H];]6]L]?]T_4h9h9h9h9h9h9hK]Q].]J]A]J]A]J]A]J]"
"@].].].]/]J]@]L]@]J]A]J]A]J]A]J]A]J]?tG]Q\\U]@]L]?]L]?]L]?]L]>]Q];]K]?]Q]  N\\WmX]H\\WmX]H\\P_Q]H\\P^P]H\\O]P]C]1]Q]  C]:]S[ ?sEvEqAoC]L]?]L];^V^8^T^>x     "
" '] 5] 4]S]<g-\\T^V^M]S_Q\\ O](].\\2u Se =^1]J]7]-^*^?]O],^?^K]7^7]N]<^Sb  Sa (aC]3\\R\\K\\R\\P^O^?]L^A]-]E]F].]/]KdF]H]C].].]W^5].]T^W^T]H]R^T]D]C]Gj<]C]Gj-"
"`7]6]H]@]Q]:]U^S^U]Fb2]/^6]-^+]   Nj>]K]A].]K]@p?]0]K]?]L]?].].b3].]M]M]N]L]@]J]@]K]A]K]?].c4].]L]>]Q]:]U]V]U]@`6^S^4^5b2]&b<u P[O]P\\H]N^=]M]>^Ua<]J]="
"c7]L]<]S^8]V^:]L]@]A]J]S]S]@]P]>]S]S]@]J]B]J]9]6]J]?^O^7^7]/]C]H]P]P]G]H]B]R]R]F]C]Iz<]<z=]=z<] B]1]R[7j:\\L\\7_ C^P] B[U\\C[ W]T] W] O[R\\T^P[  T]   ]L]7"
"]U\\<]   H]T]-\\O\\X\\>\\I\\@\\O\\X\\J`3^O^>^O^>^O^>^O^>^O^=]O]<^P]?]-].].].].].].].]-]E]G]R^T]D]C]H]C]H]C]H]C]H]C];^<]R]N]G]H]C]H]C]H]C]H];]6]L]?]S`8j;j;j;j;j"
";j;|Q].pApApAp@].].].]/]J]@]L]@]J]A]J]A]J]A]J]A]J]?tG]R]U]@]L]?]L]?]L]?]L]>^S^;]K]?^S^  N\\WmX]H\\WmX]H\\QaR]H\\Q^O]H\\O]P]C]1^S^  D]9]T\\ ?sFwDo?nC]L]?]L];"
"]T]7]T]=]       Hj ?] 4]S]8d/]T]T]N^R_R\\ O](] =u Se =]0]J]7].^(]?]O]+]?^K]7]7]L]<gX]  Sa (aC]3\\R\\K\\R\\P]M]?]K]A]-]E]F].]/]D]F]H]C].].]V^6].]S]W]S]H]Q]T"
"]D]C]Gg9]C]G]Q_,^7]6]H]@^S^:]U]Q]U]G^X]2]0^5],]+]   Pl>]K]A].]K]@p?]0]K]?]L]?].].a2].]M]M]N]L]@]J]@]K]A]K]?]-f8].]L]>^S^:]U]V]U]?^4]S]4^4`0]$`<^Si O[O"
"\\O\\H]N^=]M^@^S`<]J]=c7]L]<]S]8^U]:]L]@]O]O]J]S]S]@]P]>]S]S]@]J]B]J]9]6]J]?]M]7]6]/^E^H]P]P]G]H]A]S]S]E]C]Iz<]<z=]=z<] B]1]R[7j:\\L\\6] A^Q] B[U\\C[Ni:]T]"
" V] O[R\\S]P[  T]   ]L]6\\U\\<]  Dh2]T]/]P\\W\\?]I\\A]P\\W\\K`2]M]>]M]>]M]>]M]>]M]>^O^=]O]?]-].].].].].].].]-]E]G]Q]T]D]C]H]C]H]C]H]C]H]C]<`=]S]M]G]H]C]H]C]H]"
"C]H];]6]M^?]R`;l=l=l=l=l=l=~Q].pApApAp@].].].]/]J]@]L]@]J]A]J]A]J]A]J]A]J]?tG]S]T]@]L]?]L]?]L]?]L]=]S]:]K]>]S]  M]P]P\\G]C\\G]ScS\\G]S^N\\G]P]P\\B]0]S]  D]"
"7\\T[ >sFwCn?mB]L]?]L];]T]7]T]=]       Hi >] 4]S]7[Xa1]T^T^O]P_T] O](] =u Se =]0]J]7]/^'^A]N]+]?^K]7]8^L^<eW]  Sd .dC]3\\R\\K\\R\\P]M]?]K]A]-]E]F].]/]D]F]H"
"]C].].]U^7].]ScS]H]Q^U]D]C]G]/]C]G]O^,^8]6]H]?]S]9]U]Q]U]H^W^3]1^4],]+]   Q`P]>]K]A].]K]@p?]0]K]?]L]?].].b3].]M]M]N]L]@]J]@]K]A]K]?]+e9].]L]=]S]9]V]T]"
"V]@_4]S]5_4b2]&b<\\Nd M[O]P\\H]N^=]L]@]Q_<]J]?e7]L];]T]8]T]:]L]@]O]O]J]S]S]@]P]>]S]S]@]J]B]J]9]6]J]?]M]8^6].]E]G]P]Q^G]H]A^T]T^E]C]Iz<]<z=]=z<] B]1]R[3]"
"1\\L\\6] A_R] B\\U\\E\\Ni:]T] V] O\\S\\R]R\\  T]   ]L]6\\U\\<]  Dh2]T]/\\O[V\\?\\H\\A\\O[V\\L`1]M]>]M]>]M]>]M]>]M]>]M]>^O]?]-].].].].].].].]-]E]G]Q^U]D]C]H]C]H]C]H]C]"
"H]C]=b>]T]L]G]H]C]H]C]H]C]H];]6]M]>]Qa>`P]>`P]>`P]>`P]>`P]>`P]>`PoQ].pApApAp@].].].]/]J]@]L]@]J]A]J]A]J]A]J]A]J]?tG]T]S]@]L]?]L]?]L]?]L]=]S]:]K]>]S]  "
"L\\P]P\\F\\C\\F\\T^W^T\\F\\T^M\\F\\C\\B]0]S]  E^7]U[ >sFwBl=kA]L]?]L]<^T^8^V^=]       Ij >] <u=[U^1\\S]R]O]O_U\\ N](] 1] Ge =]0]J]7]0_&]A]N]+]?^K]8^8]J]:aU\\  Pe 4"
"eA]3\\R\\K\\R\\Qo@]J]A].]F^F].].]E]F]H]C].].]T^8].]RaR]H]P]U]C]E]F].]E]F]N^,]8]6]H]?]S]9^V]Q]V^H^V^4]2_4],]+]   Q]M]>]K]A].]K]@],]0]K]?]L]?].].c4].]M]M]N]"
"L]@]J]@]K]A]K]?](d;].]L]=]S]9^W]T]W^@`5^U^5^/_3]'_8ZJ` K[O]P\\H]N^=]L]@]P];]J]@_0]L];]U^9^T^;]L]@]O]O]J]S]S]@]P]>]S]S]@]J]B]J]9]6]J]@^M^:^5].]E]F]Q]Q]F"
"]H]@^U]U^C]E]G_\"]\"_BZT]TZB_F_;] B]1]R[3]1\\L\\?o I_S] A[U]F[ V]T] W] N[S\\R]R[  S]   ]L]6\\U\\   ']T]/\\O\\V\\@\\H\\A\\O\\V\\M_0o@o@o@o@o?m>l>].].].].].].].].]-]F^"
"G]P]U]C]E]F]E]F]E]F]E]F]E]=d?^V]L]F]H]C]H]C]H]C]H];]6]N^>]O`?]M]>]M]>]M]>]M]>]M]>]M]>]M]?].].].].]-].].].]/]J]@]L]@]J]A]J]A]J]A]J]A]J] K]U]R]@]L]?]L]?"
"]L]?]L]=^U^:]K]>^U^  L\\P]Q]F\\D]F\\U^U^V]F\\U^M]F\\D]B\\/^U^  OuD]V[ =sFwBk;i@]L]?]L]<]R]7]V];]       F^   Nu=[T^3]S]R]O]N_V\\ N](] 1]   ].]L]6]1_%]Aq0]>]K]"
"8]7]J]/]  Md:u:d>]3\\R\\K\\S\\Po@]J]A].]F]E].].]E]F]H]C].].]S^9].]RaR]H]P^V]C]E]F].]E]F]M],]8]6]H]>]U^8]W^Q^W]H^U^4]2^3]+],]   R^M]>]K]A].]K]@],]0]K]?]L]?"
"].].]X_5].]M]M]N]L]@]J]@]K]A]K]?]$`;].]L]=^U^8]W]T]W]@b5]U]5^,]3]']  J\\Q_Q[G]N^=]L]A]O];]J]@].]L];]U]8]R];]L]@]O]O]J]S]S]@]P]>]S]S]@]J]B]J]9]5]L]?]K];"
"^4].^G^F]Q]Q]F]H]?_W]W_B]E]F_#]#_B\\U]U\\B_H_A\\U]U[ H]1]R[3]1]N]?o H`V] @[T]G[ U]T] X] N[S\\Q]S[  S]   ]L]6\\U\\   (]T]/]P\\U\\A]I]B]P\\U\\M^/o@o@o@o@o@o@m>].]"
".].].].].].].]-]F]F]P^V]C]E]F]E]F]E]F]E]F]E]>_X_?]W^L]F]H]C]H]C]H]C]H];]6]P_=]M^@^M]?^M]?^M]?^M]?^M]?^M]?^M]?].].].].]-].].].]/]J]@]L]@]J]A]J]A]J]A]J]"
"A]J] K]U\\Q]@]L]?]L]?]L]?]L]<]U]9]K]=]U]  K]Q]Q]F]E]F]W^S^W]F]W^L]F]E]B\\.]U]  NuC\\V[ =eXZXdFgXhAi9h@]L]?]L]<]R]7]V];]       E]   Nu=[S]3\\R]R]O]M_X\\ M]("
"] 1]   ].]L]6]2_$]Aq0]>]K]8]7]J]/]  Ke=u=e<]3\\R\\K\\S\\Po@]J]A].]F]E].].]E]F]H]C].].]R^:].]RaR]H]O^W]C]E]F].]E]F]M^-]8]6]H]>]U]7]W]O]W]I^S^5]3^2]+],]   R"
"]L]>]K]A].]K]@],]0]K]?]L]?].].]W_6].]M]M]N]L]@]J]@]K]A]K]?]\"_<].]L]<]U]7]W]T]W]Ac5^W^6^+^4](]  H[R\\X]S\\G]N^=]L]A]O];]J]A^.]L]:]W^9^R];]L]@]O]O]J]S]S]@"
"]P]>]S]S]@]J]B]J]9]5]L]?]K];^4]-]G]D]R]R]E]H]>kA]E]E_$]$_B^V]V^B_J_A^V]V] I]1]R[3]0\\N\\>o G`X] ?\\U_Q[T\\ T]T] ] N\\T\\Q]T\\  S]   ]L]6\\U\\   )]T].\\P\\T\\A\\I]A"
"\\P\\T\\N^.o@o@o@o@o@o@m>].].].].].].].].]-]F]F]O^W]C]E]F]E]F]E]F]E]F]E]?_V_@]W]K]F]H]C]H]C]H]C]H];]6k<]L^A]L]?]L]?]L]?]L]?]L]?]L]?]L]?].].].].]-].].].]/"
"]J]@]L]@]J]A]J]A]J]A]J]A]J] K]V\\P]@]L]?]L]?]L]?]L]<^W^9]K]=^W^  J]R]R]D]G]D]W\\Q\\W]D]W\\L]D]G]A\\.^V]  NuC]W[ <cWZXdEfXh@g8g?]L]?]L]=^R^8^X^:]       F]  "
" G\\R\\5[S]4]R]R]O]Lb M](\\ 0]   ].]L]6]3_#]Aq0]>]K]9]6]J]/]  He@u@e H\\R]M]T]Q^J]A]J]@]/]G^E].]-]F]F]H]C].].]Q^;].]Q_Q]H]N]W]B]G]E]-]G^F]L]-]8]6]I^>^W^7]"
"W]O]W]I^R^6]4^1]+],]   R]M^>^M^@]/^M^?]-]0^M^?]L]?].].]V_7].]M]M]N]L]@^L]?^M^A^M^?] ]<].]L]<]U]7]X]R]X]B^W^5]W]6^)]4](]  H\\T]W]U\\F]O_=]L]A]P^;^L^A]-]L"
"]:]W]8]P]<]L]@]O]O]J^T]T]?]P]>]S]S]@^L]A^L]8]5]L]@^J]=^3]-^I^D^S]S^E]H]<g>]G]C_%]%_A_W]W_A_L_@_W]W_ J]0]S[3]0]P]5]4],b =[ThT[ R]T]!] M[T\\P]U[  R]   ]L"
"]6\\U\\   *]T].]P[S\\B]J]A]P[S\\N].^J]B^J]B^J]B^J]B^J]B^K^A]M]=]/].].].].].].].]-]G^F]N]W]B]G]D]G]D]G]D]G]D]G]?_T_AbK]E]I^C]I^C]I^C]I^;]6j;]K]A]M^?]M^?]M^"
"?]M^?]M^?]M^?]M_?].].].].].].].].]/]J]@]L]@^L]@^L]@^L]@^L]@^L] J^X]Q]?]L]?]L]?]L]?]L];]W]8^M^<]W]  I]R]S]C]H]C]VZOZW]C]VZL]C]H]@\\-]W]  MuC]X[ ;cWZWbDe"
"WZXe>e6e>]L]?]L]=]P]8^X^:]       F^   H\\R\\5[S]5]Q]R]O^L` K]*] 0]  !^.]L]6]4_\"]2],^>^M]8]6]J]0]  DeCuCe E]R\\M]T\\P]I]A]J]@]/]G]D].]-]F]F]H]C].].]P^<].]Q"
"_Q]H]N^X]B]G]E]-]G]E]L^.]8]5]J]<]W]6^X]O]X^J^Q^6]5^0]+^-]   R]M^>^M]?].]M^?]-]/]M^?]L]?].].]U_8].]M]M]N]L]?]L]?^M]?]M^?] ]<].]M^<^W^6aRbB^V^6]W]7^(]4]"
"(]  GcUcE]P_=]L]A]P]9]L]@]-]L]:^X]9^P]<]M^@]P^O]I]T]T]?]P]>]S]S]@^L]@]L]8]5]M]?]I]>^2],]I]B_U]U_D]H]:c<]G]B_&]&_?_X]X_?_N_>_X]X_ I]0]S[3]0_T_5]4]+` ;["
"SfU[ P^U^#] L[U\\P]V[  Q]   ]M^6\\U\\   ,^U^-\\P\\S\\B\\J]@\\P\\S\\N].]I]B]I]B]I]B]I]B]I]B]I]B^M]=]/].].].].].].].]-]G]E]N^X]B]G]D]G]D]G]D]G]D]G]@_R_A`J]D]J]A]J"
"]A]J]A]J]:]6g8]K]A]M^?]M^?]M^?]M^?]M^?]M^?]M_?].].].].].].].].].]L]?]L]?]L]?]L]?]L]?]L]?]L]3^;aP]?]M^?]M^?]M^?]M^;]W]8^M];]W]  H]S]T^B]J^B]J^B]J^B]J^@"
"\\-]W]  G^1_ :aW[V`BcW[Wc<d5c=]L]>]N]<]P]7]X]8]       F]KZ   X]S]5[S]5\\P]R]N]K_ K]*] 0]  !],]N]5]5_\"]1],]<]M]9^6^L^0]  Ad Nd A\\R]O^U\\P^I^B]K^?]H[C]H^D]"
".],]G]F]H]C].].]O^=].]P^Q]H]M]X]A]I]D],]I^E]K]AZH^8]5]J]<]W]5bObJ^O^7]6_0]*]-]   R]M^>^M]?^/]M^?^.]/]M^?]L]?].].]T_9].]M]M]N]L]?]L]?^M]?]M^?] ]<].]M^;"
"]W]5aRaB^U^6c8_(]4](]  FaSaD]P_=]M]@]P]9]L]@]-]L]9b9]O^=^N^?\\P_Q]H]T]T]?]P]=]T]T]?^L]@]L]8]4]N]@^I^?]1],^K^A`W]W`C]H]7]8]I]@^&]&^=i=^N^<i H]0^T[3]1l6]"
"4])_ <\\RbT\\ O]T]#] L\\V\\O]X\\     M^N^6\\U\\   ,]T]-\\OhF\\J]@\\OhQ]/^I^D^I^D^I^D^I^D^I^C]I]B]L]<]H[C].].].].].].].]-]H]D]M]X]A]I]B]I]B]I]B]I]B]I]@_P_B_J]C]J"
"]A]J]A]J]A]J]:]6].]K]A]M^?]M^?]M^?]M^?]M^?]M^?]M_?^/^/^/^/^/].].].].]L]?]L]?]L]?]L]?]L]?]L]?]L]3^;`O]?]M^?]M^?]M^?]M^;c8^M];c  G^U]U^@^M^@^M^@^M^@^M^?"
"\\-c  H^0_ 9^U[U^@aV[Va:b3a<]L]>^P^=^P]7]X]8_       H^M[ F] 6]S]>ZQ[T^6]P]S^N^K^ K]*] 0]:] 8]0],]O^5]6_2ZI]1]-^<^O^9]4]L]0]<].] Uc Pc1]2\\Q^S`W^P]G]B]K]"
">^J\\C]I^C].],^H]F]H]C].].]N^>].]C]H]MbA^K^D],^K^D]K^B[I]7]5^L^<c5aMaJ^N]7]6^/]*]-]   R^O_>_O]=].]O_>].].]O_?]L]?].].]S_:].]M]M]N]L]>]N]>_O]=]O_?] ]<]-"
"]O_;]X^5aRaC^S^6a8_']4](]  D]P^B^Ra>^N]@]Q]7]N]?^.]L]9a8]N]=^N^?]Q_Q]G]U]U]>]P]=]T]T]?_N]>]N]7]4^P^@]G]@^1]+^M^?mB]H]7]8^K^?\\%]%\\;g;\\L\\:g G]/]T[3]2n7]"
"4]'^ <\\F\\ M\\S\\  J\\F\\     L^N^6\\U\\   ,\\S\\-]OhG]K]@]OhQ]LZ=]G]D]G]D]G]D]G]D]G]D]G]D^L]<^J\\C].].].].].].].]-]J_D]MbA^K^B^K^B^K^B^K^B^K^A_N_B^K]B^L^A^L^A^"
"L^A^L^:]6].]K]A^O_?^O_?^O_?^O_?^O_?^O_?^Oa?].].].].]/].].].]-]N]>]L]>]N]=]N]=]N]=]N]=]N]2^;_O]=]O_>]O_>]O_>]O_:a7_O]9a  E^P_>^P_>^P_>^P_>^P_>\\,a  H^.]"
" /[5]T[S\\8a1`<]L]=^R^<]O^8b7_       H^O\\ F] 6\\R\\=[R[U^5\\N]T]L^M` L]*] 0]:] 8]1^+]P]4]7_1[L_1]<ZL^:^Q^8]4^N^>ZM];].] R` P`.]2]QfXaN]G]B]L^=^L]C]K_B].]+"
"_J]F]H]C].].]M^?].]C]H]La@^M^C]+^M^C]J]B]L^7]4^N^:a4aMaK^M^8]7^.]*^.]   Q]P`>`Q^=^NZ;^Q`>_LZ>].^Q`?]L]?].].]Q^;].]M]M]N]L]>^P^>`Q^=^Q`?]/ZL];]-^Q`:a4`"
"P`D^Q^7a8^&]4](]   S]Sb>_P^@]R^7^P^>^MZ<]L]9a9]M]=_P`XZB]Q_Q]G^V]V^>]P]=^U]U^?`P^>^P^6]4]Q^?]G]A^0]*^O^<i@]H]7]7^M^=Z$]%Z8e9ZKZ7e F]/^U[TZ9]3^V`V^8]4]"
"&^ <\\H\\ K[R[  I\\H\\     K_P`XZ9\\U\\   ,[R[,\\E\\D\\K]?\\E\\M]O\\=]G]D]G]D]G]D]G]D]G]D]G]D]K];^L]C].].].].].].].]-]K_C]La@^M^@^M^@^M^@^M^@^M^A_L_C`N^A^N^?^N^?^"
"N^?^N^9]6].]L]?]P`>]P`>]P`>]P`>]P`>]P`>]P]X^LZN^NZ;_LZ>_LZ>_LZ>_LZ?].].].]-^P^>]L]>^P^=^P^=^P^=^P^=^P^2^:^P^=^Q`>^Q`>^Q`>^Q`:a7`Q^9a  Dk<k<k<k<k>],a  "
"H]-] /[,[._0_;]L]=j<]N]7`5a       J_S^ F] 6\\R\\=^U[W_5]N^V^K_Rd L],] /]:] 8]1])^T^3]8_0^Q`0]<]Q_8^S^8^3_R_=]R^:].] O] P]+]1\\PdW`N^G^C]N_;`R`C]NaA].]*`O"
"`F]H]C].].]L^@].]C]H]La?`S`B]*`S`B]J]B`Q_6]3_R_9a4aMaL^K^9]8^-])].]   Q_Tb>aS^;_R\\:^Sa=`Q]>]-^Sa?]L]?].].]P^<].]M]M]N]L]=_T_=aS^;^Sa?]/^R_:]-^Sa:a3_P_"
"C^P^7_8^%]4](]   S_V^X^?aS^>]T^5_T_=`R]<]L]8_8]M^>`SdA]SaS]E^W]W^=]P^=_W]W_>]X]T_<_T_5^4^T^?^G^C^/])^Q^8c=]H]7]6`S` ?] ;c >c E]._W[V\\9]4^J^9]4]%] ;]L]"
" IZQZ  H]L] !u  ,`Sd9\\U\\   ,ZQZ,]E\\E]L]?]E\\M_S^>^G^F^G^F^G^F^G^F^G^F^G^F^K]:`R`C].].].].].].].]-]ObB]La?`S`>`S`>`S`>`S`>`S`?]J]CcS`?_R_=_R_=_R_=_R_8]6"
"].]V[R^?_Tb>_Tb>_Tb>_Tb>_Tb>_Tb>_T^V_Q]M_R\\:`Q]=`Q]=`Q]=`Q]?].].].],_T_=]L]=_T_;_T_;_T_;_T_;_T_1^:`T_;^Sa=^Sa=^Sa=^Sa9_6aS^7_  Bi:i:i:i:i=]+`  I],] /["
",[-].]:]L]<h;]N]7`3q      \"h E] 7]S]=k5]LdIjW^ M],] /]:] 8]1](f9k?n?l/]<j6g7]1j<h9].] LZ PZ(]1]O`U]K]E]Cm8kBn?n?](nE]H]C].].]K^Am>]C]H]K`>kA])kA]J^Cm5"
"]2j7_2`M`K^J]9]8tC])].]   PgX]>]Xf9h9fX]<k>],fX]?]L]?].].]O^=].]M]M]N]L]<h<]Xf9fX]?]/j9d4gX]:a3_P_D^O^7_8m4]4](]   RfXaBk=^V^3h;j<]L]8_9^L]>qA^U]W]U^D"
"i<]O`?k=]Xg:h3a7f>uCn?]/eSe;]:]H]7]5k >] :a <a D]-h>n?\\H\\8]4]%] 9^R^   *^R^  Xu  ,q9\\U\\    /]D\\F]LfH]D\\Li>]E]F]E]F]E]F]E]F]E]F]E]F]JnIkBn?n?n?n?].].]."
"]-n@]K`>k<k<k<k<k=[H[Co<j;j;j;j7]6].]Vf=gX]=gX]=gX]=gX]=gX]=gX]=gTjLh9k<k<k<k?].].].]+h<]L]<h9h9h9h9h Fk:gX]=gX]=gX]=gX]9_6]Xf6_  @e6e6e6e6e;]+_  G\\+["
" /].]-[,[9]L];e:^N^8`2p       e D] 7]S]<i4\\JbGgT^ M\\,\\ .]:] 8]1]'d8k?n>i-]<i4e6]0h;g8].]   I]0]3]E]Cl6h@l=n?]&jC]H]C].].]J^Bm>]C]H]K`<g?]'g?]I]Bj3]1h6"
"_2_K_L^I^:]8tC])].]   OdV]>]Wd6f8dW]:i>]+dW]?]L]?].].]N^>].]M]M]N]L];f;]Wd7dW]?]/i7c3dV]9_2_P_E^M^8_8m4]4](]   QdV`B]Xe;d1f8h<]L]8_9]K]>]XdW_@eWeBg;]O"
"`=g;]Vd8f1`6d=uCn?]/eSe;]:]H]7]3g <] 9_ :_ C]+f>n>ZFZ7]4]%] 7f   &f  Vu  ,]XdW_9\\U\\    /\\C\\F\\KfH\\C\\Kg=]E]F]E]F]E]F]E]F]E]F]E]F]JnHh@n?n?n?n?].].].]-l>"
"]K`<g8g8g8g8g J]Vh:h9h9h9h6]6].]Ve;dV]<dV]<dV]<dV]<dV]<dV]<eRiJf7i:i:i:i?].].].]*f;]L];f7f7f7f7f F]Xe7dV]<dV]<dV]<dV]9_6]Wd5_  <\\-\\-\\-\\-\\6]+_  FZ*[ /]"
".],Z+Z9]L]8`8]L]7^.m       W` A] 7\\R\\7b2]H^BaP_ O].] .]:\\ 7]2^%`6k?n:b*]9c/a5],b6b5].\\   H]/\\4]C]Di0b=h9n?]#c?]H]C].].]I_Dm>]C]H]J_9a<]$d?]I^?c0].b3_2"
"_K_M^G^;]8tC](]/]   M`T]>]U`2b4`U]7c;])`U]?]L]?].].]M^?].]M]M]N]L]8`8]U`3`U]?],c2a0_T]9_2^N^F^K^8]7m4]4](]   O`R^B]Va8b-`3d:]L]7]9^J]?]V`T]>cUc?c9]N_:"
"a8]T`3`-_4`<wDn?]/eSe;]:]H]7]0a 9] 8] 8] B])b<n @]4]&^ 5b   \"b  Tu  ,]V`T]8\\U\\    0].].]0b;]C]H]C]H]C]H]C]H]C]H^E^H^JnEb=n?n?n?n?].].].]-h:]J_9a2a2a2a"
"2a G\\Rb4b3b3b3b3]6].]Vc7`T]:`T]:`T]:`T]:`T]:`T]:aMcEb2c4c4c4c<].].].]'`8]L]8`1`1`1`1` D]Ua2_T]9_T]9_T]9_T]8]5]U`2]      =]                       &[   "
"O].]  E]  E]         ']    S]        R]      ^       (](]/]        C]  S]    '] V]      F^ 7]4](]   %])[  4]7] @])_Q_:] 9]6]                6[   S]0[R"
"^           H]%\\U\\ A\\            @\\             /Z            <\\             ,[    M^5](^      =]                       &[   N]0]  D\\  D]         '\\  "
"  Q^DZ       1]      _       )](]/]        D^  S]    '] V]      F] 6]4](]   %]   ;]7] @] /] 9]6]                6[   S]0g           H]%\\U\\ @\\         "
"   @\\                          J\\                  X]4](]      <]                       &[   N]0]  D\\  E^         '\\    P^G]       2]      X^       )]"
"(^0]        D]  R]    '] V]      G^ 6]4](]   %]   ;]7] @] /] 9]6]                6[   S]0e           F]%\\U\\ ?[            ?[                          "
"I[                  ^4])^      @ZV]                       &[   M]2]  D]  E]         ']    O_K_       3]      V^       *b,]5b        E^  R]    '] V]   "
"   G^ 6^5])^   %]   ;]7] @] /] 9]6]                6[   S].a           D]%\\U\\ ?\\            @\\                          J\\                 !^4])^     "
" B\\V]                       &[   M]2]  D\\            G\\    L`P`       2]      U^       +b =b        RZN^  R^    '] V]      H^ 4^6]*^   $]   ;]7] @] /]"
" 9]6]                6[   S]            J]  :\\            @\\                          J\\                 \"^3]*^      A\\V\\                       %[   L"
"]4]                   Vm       2^      S^       ,b =b        R\\Q_  R]    &] V]      I^ 3b:].b   $]   ;]7] @] /] 9]6]                6[   S]           "
" J]  @ZU]            FZU]                          PZU]                 #^2]+^      @b                       %[                       Si       4b     "
"                  %i  Ua    &] V]      Mb 2a:].a   #]   ;]7] @] /] 9]6]                   .]            J]  @b            Fb                          "
"Pb                 'b2]       E`                                               Qb       1a                       $g  S`    %] V]      Ma /_:]._   !]  "
" ;]7] @] /] 9]6]                   .]            J]  @a            Ea                          Oa                 &a1]       D^                       "
"                                X^                 Ip      Fc  Q^    #] V]      M_  A]    )]   ;]7] @] /] 9]6]                                T]  @`  "
"          D`                          N`                 %_/]       BZ                                                                        Ap      "
"                 6]                                                                                                                                   "
"                                                        p                       6]                                                                    "
"                                                                                                                                                      "
"                                                F]']2]    +]']2^ D]']3_   E]']1]   \"]']2^ 8]                             H";


    const char *const _data_font90x103[] = {

"                                                                                                                                                      "
"                                                                                                                                                      "
"                                                                        HX     4V         >X       IX           *W             FW                     "
"                                                                                                                                                      "
"                                                                                                                                                      "
"                                                                                                                     HX  W 4Z 3VCT   <Z     >X  W 4Z  "
" HX  W 4Z     'VCT ;X  W 3Y 2UCT       KX  W 3Y   0W                                                                                                  "
"                                                                                                                                                      "
"                                                                                                                                                      "
"                                    @W !W 4\\ 5YET ?XHX 8]     >W !W 4\\ 7XGX KW !W 4\\ 7XHX   +YET :W !W 3[ 5ZFT ?XGX     EW !W 3[ 7XGX 5W              "
"                                                                                                                                                      "
"                                                                                                                                                      "
"                                                                                                                        >W \"V 3\\ 7]HU ?XHX 9`     ?W \""
"V 3\\ 7XGX JW \"V 3\\ 7XHX   -]HU 9W \"V 3] 7]HT ?XGX     DW \"V 3] 8XGX 5V                                                                                "
"                                                                                                                                                      "
"                                                                                                                                                      "
"                                                      <W $V 3VNV 8_KV ?XHX 9`     >W $V 3VNV 8XGX IW $V 3VNV 8XHX   -_KV 8W $V 2] 7_KU ?XGX     CW $V "
"2] 8XGX 6V                                                                                                                                            "
"                                                                                                                                                      "
"                                                                                                                                                :W &W "
"4VLV :j >XHX :VJV     >W &W 4VLV 9XGX HW &W 4VLV 9XHX   .j 6W &W 3VMV 9i >XGX     BW &W 3VMV 9XGX 7W               MW                                 "
"                                                                                                                                                      "
"                                                                                                                                                      "
"                                                                                      CV 'W 4VJV ;j >XHX ;UGV     >V 'W 4VJV :XGX GV 'W 4VJV :XHX   .j"
" 5V 'W 3VKV :i >XGX     AV 'W 3VKV :XGX 8W               N[                                                                                           "
"                                                                                                                                                      "
"                                                                                                                                                      "
"                            DV )W 4VHU <VK_ =XHX ;TEU     =V )W 4VHU :XGX FV )W 4VHU :XHX   /VK_ 3V )W 3VIV <UK_ =XGX     @V )W 3VIV ;XGX 9W          "
"     N]                                                                                                                                               "
"                                                                                                                                                      "
"                                                                                                                              DV *V 3UFU =UH\\ <XHX <UD"
"T     <V *V 3UFU ;XGX EV *V 3UFU ;XHX   /UH\\ 1V *V 2UGU <TH] =XGX     ?V *V 2UGU ;XGX 9V               a                                              "
"                                                                                                                                                      "
"                                                                                                                                                      "
"                                                                         EV ,V 3UDU >TEY ;XHX <TBT     <V ,V 3UDU <XGX DV ,V 3UDU <XHX   /TEY /V ,V 2U"
"EU =TFZ <XGX     >V ,V 2UEU <XGX :V               Na                                                                                                  "
"                                                                                                                                                      "
"                                                                                                                                                      "
"                     DU -V 3VDV ?TCV :XHX <TBT     ;U -V 3VDV =XGX CU -V 3VDV =XHX   /TCV -U -V 2UCU >TCU :XGX     =U -V 2UCU =XGX ;V               NV"
"IV                                                                          \"W                                                                        "
"                                                                                                                                                      "
"                                                                                                                          JU /V 3VBV     ETBT     :U /"
"V 3VBV   FU /V 3VBV       (U /V 2UAU         DU /V 2UAU   @V               NVGV                                                                       "
"   $X                                                                                                                                                 "
"              *X                                                                                                                                      "
"                           JX                                GTBT                                                   MX  GX 7V     :UEU     DX  GX 7V  "
" JX  GX 7W       4X  GX 6V         GX  GX 5V   (X                            &X                                                                       "
"                                                                                        )X                                                     8V     "
"                                                                                                      ;X                                FTBT          "
"                                         LX  IX 7X     <UCU     DX  IX 7X   JX  IX 6W       3X  IX 6X         GX  IX 5X   *X                          "
"  &Y                                                                                                                                                  "
"             (X                                                     9V                                                                                "
"                           <X                                ETBT                                                   KX  KX 6X 1TBT   BTAT     CX  KX 6"
"Y   JX  KX 6Y     (TBT BX  KX 5X 1TBT       LX  KX 4X   +X                            %T                                                    #W 9W     "
"                                                                                          3a   :a     <W   2W    >W   E\\   AW ,W ,W ,W ,W             "
"                HY GV +Y         4Z           NX                 @X                                                                  %W               "
"                 DUDU                                                 =Y 7W  KW 6Z 4XDT   BTAT     BW  KW 6Z   IW  KW 6[   ,Y )XDT AW  KW 5Z 4XDT     "
"  KW  KW 4Z   ,W BW                 8V         (S                                             <S       9V 7V                                          "
"                                                     3a   :a     ;W   3W    >W   H_   AW ,W ,W ,W ,W                             L] GV +]         ;a  "
"        #[                 F^                                           8XGX                      +W                                BTEU              "
"                      *R            9a :W  MW 6\\ 6ZET ?XHX <TAT     AW  MW 6\\ 7XGX LW  MW 5[ 7XGX .Y +ZET @W  MW 5\\ 6ZET ?XHX     DW  MW 4\\ 7XHX 0W AW"
" &XHX               MZ         +T                                   $Y         BS 1W,V MY   8W 7W  T           9X   5Z /[     0Z   8Z /Y           GY "
"      .\\       <\\               [   4[   :\\              -a   :a     :W   4W    >W   Ja   AW ,W ,W ,W ,W                             N_ GV +_         "
"?e   8]       J]                 Jb       8[       <[                  $Y       FY 7XGX   =Z         Di 5W   8Z .Y !W         FW *Y   4W)V*W)V-Y(V    "
"        <UFU   3\\                    +[ 0[ 0[ 0[ 0[   4[=T            <e ;W  W 5\\ 7\\FT ?XHX <TAT     @W  W 6^ 8XGX KW  W 5] 8XGX .Z@R ?\\FT ?W  W 4\\ 7\\"
"FT ?XHX     CW  W 3\\ 7XHX 1W @W &XHX               N\\         ,T     :U :U5U                            `   EX 2VFV   .S 4]0W\"b DV  V 5V  T         7W"
" .` 3[ 7c 8d )Z Dq 8b Hy Bb 7`           Na   /Z @k .d Kj ?x Mt 7f MX/X'X -X -X2Z&X -]0]0[3X Dc Ii -c Ij 4f N~W$X/X.X&X.X4Y4XDY/Y/Y,Y'~S%a >W $a  MY  "
" EW   5W    >W   Kb   AW ,W ,W ,W ,W                            !a GV +a         Ch   =f       ^                 Mf 2Z @x Mx <c 3X C~Q)X?X?X Kc   2T  "
" .V   .T   CX   $a  !W.W   N` ;XGX ![ Lb       &Z Mi 7[   >a 5a &W   0g    #\\ -_   <\\*V.\\*V0a-V\"X )Z /Z /Z /Z /Z 4WJV 1~U+d Kx Mx Mx Mx MX -X -X -X ,j"
" @[3X Dc 8c 8c 8c 8c   <cBV.X/X'X/X'X/X'X/X/Y,Y$X &h ;W \"W 5VNV 8]HU ?XHX <TAT     ?W \"W 5VNV 8XGX JW \"W 5VMV 9XGX -ZDV @]HU >W \"W 4VNV 8]HU ?XHX     "
"BW \"W 3VNV 8XHX 2W ?W &XHX               ^ K~\\       >S   3Q +[ @[;[ ;Q                          ;e   HX 2VFV #VBV FS 6`1V#g GV !V 3V !T         7W 0d"
" :` ;j ?k -[ Dq :g Ky Df ;d          $f   1Z @o 5j Np Ex Mt :m\"X/X'X -X -X3Z%X -]0]0\\4X Gi Lm 4i Ln ;m#~W$X/X-X(X-X4Y4XCY1Y-Y.Y&~S%a >W $a  N[   EV   "
"5W    >W   Lc   AW ,W ,W ,W ,W                            \"b GV +a         Dk   Aj      \"_                 h 3Z @x Mx ?i 6X C~Q)X?X?X Ni   6V   /V   /"
"V   DX   &f  #W0W   e >XGX %c#e       +b\"i 9_   Be 9d 'V   3k    %^ /c   @^*V0^*V2d.V\"X )Z /Z /Z /Z /Z 3b 1~U.j Nx Mx Mx Mx MX -X -X -X ,p F\\4X Gi >i "
">i >i >i   BiEV.X/X'X/X'X/X'X/X.Y.Y#X 'j ;V \"V 5VLV :_IT >XHX <TAT     >V \"V 5VLV 9XGX IV \"V 4VMV 9XGX ,ZHY A_IT <V \"V 4VLV :_IT >XHX     AV \"V 3VLV 9"
"XHX 2V >W &XHX              !_ K~[       >T   4R -_ D_?_ >S         =t                Fh   IX 2VFV #VBV FS 7c4V#i HV \"W 3V !T         7V 0f @e >o Co 0"
"\\ Dq <j Ly Fj ?h          (i  \\ ?Z @r :o\"s Hx Mt <q$X/X'X -X -X4Z$X -]0]0\\4X Im Np 9m Np ?q%~W$X/X-X(X,W5[6XAX1X+X.X%~S%a =V $a  ]   EV   6W    >W   M"
"d   AW ,W ,W ,W ,W               HW             1b GV +b         Fm   Dm      #`                \"j 4Z @x Mx Am 8X C~Q)X?X?X!m   9X   0V   0X   EX   'h"
"  $W0W  \"h ?XGX 'g%g       0h%i :a   Cf :f *V   4m    %^ 0e   A^+V/^+V1f1V!X )Z /Z /Z /Z /Z 2` 1~V0o\"x Mx Mx Mx MX -X -X -X ,t J\\4X Im Bm Bm Bm Bm   F"
"mHV-X/X'X/X'X/X'X/X-X.X\"X (l ;V $V 4UJU :ULXLU >XHX <UCU     =V $V 5VJV :XGX HV $V 4VKV :XGX +ZL\\ AULXLU ;V $V 3UJU :ULXLU >XHX     @V $V 2UJU 9XHX 3V"
" =W &XHX              !` K~Z       >T   4S /a FaAa @T         @w                Hl   KX 2VFV $WCV ES 8e5V$j HV \"V 1V \"T         7V 2j Eh ?q Dp 1\\ Dq >"
"l Ly Hn Bj          +l %e E\\ At >s$v Kx Mt >u&X/X'X -X -X5Z#X -^2^0]5X Jo q ;o r Br%~W$X/X-X(X,X6[6XAY3Y+Y0Y%~S%W 3V  IW !_   FW   7W    >W   Md   AW "
",W ,W ,W ,W               HW             2[ ?V #[         Hn   En      #`                #l 6\\ Ax Mx Cp 9X C~Q)X?X?X\"o   ;Z   1V   1Z   FX  KS 0i  #W2"
"W LV ,i ?XGX *l'h       3l'i ;c   Dg ;g ,W   6o    %^ 1g   B^,V.^,V0g3V X *\\ 1\\ 1\\ 1\\ 1\\ 2^ 0~V2s$x Mx Mx Mx MX -X -X -X ,v L]5X Jo Do Do Do Do   HpKW"
"-X/X'X/X'X/X'X/X-Y0Y\"X )n <W &W 5VJV ;TI_ >XHX ;UEU     <W &W 5VIV ;XGX HW &W 5VIV ;XGX *g ?TI_ ;W &W 4VJV ;TI_ >XHX     @W &W 3VJV :XHX 4W =W &XHX   "
"  1\\ 1\\ 1\\ 1\\ 1\\ =XMV K~Y       =S   4U 1c IdCc AU         Dz                In   LX 2VFV $VBV ES 9g7V$k HV #W 1W #T         8W 3l Fh ?r Eq 3] Dq ?m L"
"y Ip Em          -n )k H\\ Au Av%x Mx Mt ?x(X/X'X -X -X6Z\"X -^2^0]5X Ls\"s ?s\"s Et%~W$X/X,X*X+X6[6X@Y5Y)Y2Y$~S%W 3W  JW \"a   FW   8W    >W   NZ   6W ,W "
",W ,W ,W               HW             2X <V  X         H[G[   Go       KZ                %[H[ 7\\ Ax Mx Ds ;X C~Q)X?X?X$s   >\\   2V   2\\   GX  KS 1j  #"
"W2W LV -j ?XGX +ZEZ)VGY       5ZDZ)i <e   EUFY <UFX -W   7q    %VMU 2YIY   CVMU,V.VMU,V0UFX3V X *\\ 1\\ 1\\ 1\\ 1\\ 1\\ 0~W4v%x Mx Mx Mx MX -X -X -X ,x N]5X"
" Ls Hs Hs Hs Hs   LsMW,X/X'X/X'X/X'X/X,Y2Y!X *\\G[ <W (W 4UHU <UH] =XHX ;VGV     ;W (W 5VHV ;XGX GW (W 4UGU ;XGX )c =UH] 9W (W 3UHU <UH] =XHX     ?W (W"
" 2UHU :XHX 5W <W &XHX     5c 8c 8c 8c 8c @WKU J~X       >T   5V 2e KfEe CW         G|                Jp   MX 2VFV $VBV ES 9XIX8V$l HV #V /V #T        "
" 8V 3n Gh ?s Fr 5^ Dq @n Lx Ir Go          .o -q L^ Bv Cx&z x Mt A{)X/X'X -X -X7Z!X -^2^0^6X Mu#t Au#t Gu%~W$X/X,X*X+X6[6X?X5X'X2X#~S%W 2V  JW #c   FW"
"   9W    >W   NX   4W ,W ,W ,W ,W               HW             2W ;V  NW         IZCY   Hp       JY                &ZDZ 9^ Bx Mx Eu <X C~Q)X?X?X%u   @"
"^   3V   3^   HX  KS 2k  \"W4W KV -ZGW ?XGX -X=X+R@W       8X<X  .XIX   FQ@W <Q@W /W   7dGU    %QHU 3XEX   DQHU-V-QHU-V/Q@W5V NX +^ 3^ 3^ 3^ 3^ 2\\ 0~W5"
"x&x Mx Mx Mx MX -X -X -X ,z!^6X Mu Ju Ju Ju Ju   N}+X/X'X/X'X/X'X/X+X2X X +ZBY ;W *W 4UFU =TF\\ =XHX :VIV     9W *W 5VFV <XGX FW *W 4VGV <XGX (_ :TF\\ 8"
"W *W 3UFU =TF\\ =XHX     >W *W 2UFU ;XHX 6W ;W &XHX     7h =h =h =h =h DWJV K~X       >T   5W 4g MgFg EY         J~                K]FZ   MX 2VFV $VBV "
"ES :XGX9V%\\GX HV $W /W 3PATAP         GV 3[H[ Gh ?]F] GZE^ 6^ Dq A]FX Lx I\\F\\ G\\G[          /[H] 0u N^ Bw E_D^&{!x Mt B`C_)X/X'X -X -X8Z X -_4_0_7X N^"
"E^$u C^E^$u H^E\\%~W$X/X,Y,Y*W7]8X>Y7Y'Y4Y#~S%W 2V  JW $e   FV   9W    >W   NW   3W ,W ,W ,W ,W               HW             2W ;V  NW         IY@X >X "
"4[AV       IX                &X@X 9^ Bx Mx F^E^ =X C~Q)X?X?X&^E^   B`   4V   4`   IX  KS 3\\GW  \"W4W KV .YBT ?XGX .V7V,P=W       :W8W  /VEV   3V +V /V "
"  7eGU     KU 3WCW   ;U-V$U-V LV5V NX +^ 3^ 3^ 3^ 3^ 3^ 1~W6_D^&x Mx Mx Mx MX -X -X -X ,{\"_7X N^E^ L^E^ L^E^ L^E^ L^E^  !^Ed*X/X'X/X'X/X'X/X+Y4Y X +Y?"
"X ;V *V 4UDU >TEZ <XHX 9a     7V *V 4UDV =XGX EV *V 4VEV =XGX )] 7TEZ 6V *V 3UDU >TEZ <XHX     =V *V 2UDU <XHX 6V :W &XHX     9k @k @k @k @k EWJV K~W "
"      >T   5Y 5g MhHi G[         M~Q                L\\AW   MX 2VFV $VCV DS :WEW:V%ZAU HV $V -V 3RCTCR         HW 4ZDZ H\\LX ?Y?[ HV>\\ 8_ DX )[?T -Y J[B"
"[ I[CZ          0WAZ 2x ^ BX>^ G]=Z&X=b#X -X '];[)X/X'X -X -X:[ NX -_4_0_7X \\?\\%X@^ E\\?\\%X?] J[=X =X <X/X+X,X)X8]8X=Y9Y%Y6Y )Y$W 2W  KW %ZMZ   FV   :W"
"    >W   X   3W     4W ,W               HW             3X ;V  NX         KY?X Ca 9Y:R       HX                (X>X :VNV BZ /X '\\?\\ A^ FX0X)X?X?X'\\?\\  "
" Db   5V   5b   JX  KS 3ZBT  !W6W JV .X?R   4V4U HV       ;V4V  1VCV   4V *U 0V   7fGU     KU 4WAW   <U.V#U.V JU6V MX +^ 3^ 3^ 3^ 3^ 3^ 2XIX F]=Z&X -X"
" -X -X -X -X -X -X ,X=b$_7X \\?\\ N\\?\\ N\\?\\ N\\?\\ N\\?\\  #\\?`)X/X'X/X'X/X'X/X*Y6Y NX ,Y=W :V ,V 3UDU >TDX   ;a     6V ,V 4UBU   GV ,V 3UCU   0` 6TDX 4V ,V"
" 2UDU >TDX       >V ,V 1UDU   :V 9W       (o Do Do Do Do GWIU J~V       >T   6Z 6i jIj I\\         N~R                M[=U   MX 2VFV %VBV H] AWCW;V%Y=R"
" HV %W -V 4UETEU         IV 4ZBZ IWGX ?V;[ IS9Z 9VNX DX *Z;R -X JZ>Y JZ?Y          1U>Z 5`C_#` CX;[ H[7W&X9_$X -X (\\6X)X/X'X -X -X;[ MX -_4_0`8X![;[&X"
"=[ F[;[&X<[ LZ8U =X <X/X+X,X)X8]8X<X9X#X6X )Z$W 1V  KW &ZKZ   FV   ;W    >W   W   2W     4W ,W               HW             3W :V  MW         KX=W Cc "
";X7P       HX                (W<W ;WNW BY /X ([;[ Gg JX0X)X?X?X([;[   Fd   6V   6d   KX  KS 4Y>R  !X8X JV /X<P   6V1U IV       <U0U  2UAU   3U *U 1V  "
" 6fGU     KU 4V?V   <U/V\"U/V IU7V LX ,` 5` 5` 5` 5` 5` 3XIX G[7W&X -X -X -X -X -X -X -X ,X9_%`8X![;[![;[![;[![;[![;[  %[;](X/X'X/X'X/X'X/X)X6X MX ,X;W"
" :V .V 3UBU ?TBT   7]     3V .V 4VAU   GV .V 3UAU   4d 7TBT 1V .V 2UBU ?TBT       ;V .V 1UBU   <V 8W       )r Gr Gr Gr Gr IVHR GX+W       =S   5[ 7i!k"
"Jk I]        !^                )Y:T   MX 2VFV %VBV Le EVAV<V$X:P HV %W -W 6WFTFV         IV 4X?Y IRBX ?T7Y IP5Z :VNX DX +Z8P .Y JY<Y KY=X          1S;"
"Y 6];\\$WNW CX9Z J[4U&X6]%X -X )[2V)X/X'X -X -X<[ LX -XNV6VNX0`8X\"Z7Z'X;Z HZ7Z'X;Z LY4R =X <X/X*X.X(X8]8X<Y;Y#Y8Y *Z#W 1V  KW 'ZIZ   FV   <W    >W   W "
"  2W     4W ,W               HW             3W :V  MW         KW<X Dd <W       -W                )W;X <WNW AY 0X )Z7Z Jl MX0X)X?X?X)Z7Z   Hf   7V   7f"
"   LX  KS 4X;P   W8W IV /W   \"V.U JV       >U.U  4VAV &V 5U *U 2V   6gGU     KU 5W?W   =U/V\"U/V IU7V LX ,WNW 5WNW 5WNW 5WNW 5WNW 5WNW 4XHX H[4U&X -X -"
"X -X -X -X -X -X ,X6]&`8X\"Z7Z#Z7Z#Z7Z#Z7Z#Z7Z  'Z8['X/X'X/X'X/X'X/X)Y8Y MX ,W:W 9V 0V 3U@U     ?[     1V 0V 3U@V   GV 0V 3U?U   8h   1V 0V 2U@U       "
"  CV 0V 1U@U   >V 7W       *`L` I`L` I`L` I`L` I`L` JV =X,X       >T   6] 9k\"lKl K_        #\\                'Y8S   MX 2VFV %VBV Nk IVAV=V$X 1V %V +V "
"6YHTHY -V       EW 5Y>Y :X ?R5Z .Y ;VMX DX +Y  DX IY<Y LY;X          2Q8Y 8[5[&WNW CX8Y KZ1T&X4\\&X -X *Z.T)X/X'X -X -X=[ KX -XNV6VNX0a9X#Z5Z(X:Y IZ5Z("
"X:Z NY1P =X <X/X*X.X'W9WNV:X:Y=Y!Y:Y *Z\"W 1W  LW (ZGZ      -W    >W   W   2W     4W ,W               HW             3W :V  MW         KW;W De =W      "
" -X                *W:W <VLV @Y 1X *Z5Z Mp X0X)X?X?X*Z5Z   Jh   8V   8h   MX  KS 5Y   :X:X IV /W   #U+T JV       ?U+T  5U?U &V 5U +V     AgGU     KU 5"
"V=V   =U0V!U0V IV8V KX ,WNW 5WNW 5WNW 5WNW 5WNW 5WNW 4XHX IZ1T&X -X -X -X -X -X -X -X ,X4\\'a9X#Z5Z%Z5Z%Z5Z%Z5Z%Z5Z  )Z5Z(X/X'X/X'X/X'X/X(Y:Y LX -X:W  "
"        !W                    2\\LZ                          EW       +[@[ K[@[ K[@[ K[@[ K[@[ KV <X-X     /P 0T   7^ 9k\"lLm La        %Z              "
"  %Z6Q   MX 2VFV %VCV n KWAW>V$X 1V &W +W 5XITIX +V       EV 4X<X :X ?P2Y -X <WMX DX ,Y  CX JY:Y MX9W          2P7Y :Z0Z(WLW DX7X KY.R&X2Z&X -X *Y+R)X"
"/X'X -X -X>[ JX -XNW8WNX0a9X#Y3Y(X9Y JY3Y(X9Y NX  LX <X/X*X.X'X:VMV:X9X=X NX:X *Z!W 0V  LW )ZEZ      .W    >W   W   2W     4W ,W               HW     "
"        3W :V  MW         LX;W Df >W       ,W                +W8W >WLW @Y 2X +Z3Z!t\"X0X)X?X?X*Y3Y   Kj   9V   9j     AS 5X   8W:W HV /W   #T)T KV     "
"  @T(T  6U?U &V 5T +V     AhGU     KU 5V=V   =U0V!U0V JV7V   WLW 7WLW 7WLW 7WLW 7WLW 7XNX 6XGX IY.R&X -X -X -X -X -X -X -X ,X2Z'a9X#Y3Y%Y3Y%Y3Y%Y3Y%Y3"
"Y  )Y3Z)X/X'X/X'X/X'X/X'X:X Ki >W8V                               *XHZ                          FW       ,Z<Z MZ<Z MZ<Z MZ<Z MZ<Z LV <X.X     .R 2S   "
"7` :k#nMm Mb        &Z                $Y4P   MX 2VFV &VBV!o KV?V?V#W 0V &V )V 3XKTKX )V       EV 5X:X ;X  X -Y =VLX DX -Y  CY JY:Y NY9X           HX ;"
"Z-Y)WLW DX7Y MY,Q&X1Z'X -X +Y)Q)X/X'X -X -X?[ IX -XMV8VMX0XNX:X$Y1Y)X9Y KY1Y)X8X NX  LX <X/X)X0X&X:VMV:X9Y?Y NY<Y *Y W 0V  LW *ZCZ      /W    >W   W  "
" 2W     4W ,W               HW             3W :V  MW         LW:W Dg ?W       ,X                ,W8W >WLW ?Y 3X +Y1Y\"v#X0X)X?X?X+Y1Y   MYNVNY   :V   :"
"YNVNY     BS 5X   8X<X HV /W   $T?ZBT*c       AT&T  7U?U &V 6U -W     @hGU     KU 6V;V   >U1V U1V KW7V   NWLW 7WLW 7WLW 7WLW 7WLW 7WLW 6XGX JY,Q&X -X "
"-X -X -X -X -X -X ,X1Z(XNX:X$Y1Y'Y1Y'Y1Y'Y1Y'Y1Y P)P$Y3[)X/X'X/X'X/X'X/X'Y<Y Km BW8W                               +UDZ               7P          1W  "
"     -Y8Y Y8Y Y8Y Y8Y Y8Y MV ;W.X     /T 4T   7a ;k#nMn Nc 6P :W4W ?Z ?X6X KY                #Y   0X 2VFV &VBV\"p KV?V?V#W 0V 'W )W 2XMTMX 'V       FW "
"5X:X ;X  Y -X >VKX DX -X  BX IX8X NX7W      KP  1P  =X <Y)X+XLX EX6X NY*P&X0Z(X -X ,Y'P)X/X'X -X -X@Z GX -XMV8VMX0XNX:X%Y/Y*X8X LY/Y*X8Y!X  KX <X/X)X0"
"X&X:VMV:X8YAY LY>Y *Z W 0W  MW +ZAZ      0W    >W   W   2W     4W ,W               HW             3W :V  MW         LW:W DSF[ @X       -X             "
"   -X8W ?WJW ?Y 4X ,Y/Y%z%X0X)X?X?X,Y/Y   YMVMY   ;V   ;YMVMY     CS 5X 5P*Q JW<W GV /W   %TBbET/g       BTGb?T  8U?U &V 7U 5_     ?hGU     KU 6V;V   "
">U2V NU2V$_7V   NXLX 9XLX 9XLX 9XLX 9XLX 8WLW 6XGX KY*P&X -X -X -X -X -X -X -X ,X0Z)XNX:X%Y/Y)Y/Y)Y/Y)Y/Y)Y/Y\"R+R&Y3]*X/X'X/X'X/X'X/X&Y>Y Jp EW:Y     "
"                          +R@Y               7Q          2W       .XEVFY\"X5Y\"X5Y\"X5Y\"X5Y NV ;X/X     0V 5T   8c <k#nNo e >^ AW4W ?Z >W6W KY           "
"     \"Y   0X 2VFV &VCW#[LSKZ KV?V@V\"W 0V 'W )W 1XNTNX &V       FW 6Y:Y <X  NX -X ?WKX DX .Y  CY IX8X NX7W      NS  1S  @X =X&X,WJW EX6X NY /X/Y(X -X ,"
"Y /X/X'X -X -XAZ FX -XMW:WMX0XMX;X%Y/Y*X8Y MY/Y*X8Y!X  KX <X/X)Y1X%W;WMW;W6XAX JX>X *Z NW 0W  MW ,Z?Z      1W    >W   W   2W     4W ,W               H"
"W             3W :V  MW         LW:W DPAY ?Y       .W                -W6W @WJW >Y 5X ,X-X&_MXM_&X0X)X?X?X,Y/Y  !YLVLY   <V   <YLVLY     DS 6Y 6R,R JX>"
"W FV /X   'TCfFT2i       CUGfBT  9U?U &V 7U 5]     >iGU     KU 6V;V   >U2V NU2V$]5V   NWJW 9WJW 9WJW 9WJW 9WJW 9WJW 8XFX KY /X -X -X -X -X -X -X -X ,X"
"/Y)XMX;X%Y/Y)Y/Y)Y/Y)Y/Y)Y/Y#T-T'Y3]*X/X'X/X'X/X'X/X%X>X Ir GW=\\                                GY               9S          3W       /XDVDX$X2X$X2X$X"
"2X$X2X V ;X0X     0X 7T   8d <k#~`!g Bd DW4W ?[ ?X7W LY                !X   /X 2VFV &VCV#ZJSGV KV?VAV!W 0V 'V 'V /d $V       FV 5X8X <X  NX -X ?VJX DX"
" .X  BX HX8X Y7X     #V  1V  CX >X$X-WJW EX6X Y .X.Y)X -X -Y .X/X'X -X -XBZ EX -XLV:VLX0XMX;X&Y-Y+X7X NY-Y+X7X!X  KX <X/X(X2X$X<VKV<X6YCY JY@Y +Z MW /"
"V  MW -Y;Y    \"Z ;WDX 0Z 2XDW >Z <W !X :WDY     IW ,W  HX8X MY 3Z *X 3X &X 7] <W             3W :V  MW       ;X :W:W 4Y @[ )\\ (Y   6X     8QEV     :[ "
"    JW6W @VIW =Y 6X -Y-Y(]JXJ]'X0X)X?X?X-Y-Y  #YKVKY   =V   =YKVKY     IZ 9X 6T.T JW>W FV .X   (TDgFT3j       CTFhDT  9U?U &V 8U 4\\     =iGU     KU 6V"
";V   >U3V MU3V#\\5V   MWJW 9WJW 9WJW 9WJW 9WJW 9WJW 8XFX LY .X -X -X -X -X -X -X -X ,X.Y*XMX;X&Y-Y+Y-Y+Y-Y+Y-Y+Y-Y%V/V)Y3_+X/X'X/X'X/X'X/X%Y@Y Is HW?^ "
"?Z /Z /Z /Z /Z /Z /Z6Y NZ 0Z /Z /Z /Z         8Y 1Y 3Z /Z /Z /Z /Z   3ZCV          5WDX       DXCVCW%X0W%X0W%X0W%X0W V :X1X     0X 7T   9f =k#~`\"h Cf "
"EW4W @\\ ?X8X LX                !Y   /X 2VFV 'VBV#XHSET KV?VAV!W 0V (W 'W .` \"V       GW 5X8X <X  NX -X @VIX DX .X  BX HX8X X5W     &Y  1Y  FX >W\"W.XJX"
" FX6X X -X.Y)X -X -X -X/X'X -X -XCZ DX -XLV:VLX0XLX<X&X+X+X7X NX+X+X7X!X  KX <X/X(X2X$X<VKV<X5YEY HYBY +Z LW /W  NW .Y9Y    'b ?WG^ 7b 9^GW A` Gl 2_GW"
" MWG_ DW ,W ,W8Y MW ,WG^>^4WG_ 9` @WG^ 9^GW MWG\\ ;f Gm <W6W#X2X#W;X;W5Y7Y#W1X\"u 6W :V  MW       >^BV\"W:W 3X ?^ 0e AWG_ KV.X ?X <W6W   HTG[ K}!WCWCW Ca"
" 7p&{ NW6W AWHW >Z 7X -X+X)\\HXH\\(X0X)X?X?X-X+X  $YJVJY   >V   >YJVJY     Ma =X 7V0V JW@W EV .Y   *TEiET5k       DTEiDT  :VAV &V 9U 3_   ;W6W NiGU     "
"KU 6V;V   >U3V MU3V#_8V   NXJX ;XJX ;XJX ;XJX ;XJX ;XJX :XEX LX -X -X -X -X -X -X -X -X ,X.Y*XLX<X&X+X+X+X+X+X+X+X+X+X&X1X*X3`+X/X'X/X'X/X'X/X$YBY Ht "
"IW@_ Cb 7b 7b 7b 7b 7b 7b>a'b 7` 5` 5` 5` AW ,W ,W ,W  DY EWG_ 9` 5` 5` 5` 5` (Z <`GV W6W MW6W MW6W MW6W#W1X NWG^ HW1X     NWBVBW&W.W&WJP:PJW&W4PJW&W."
"W!V :X2X     0X 6S   8g >k#~`#j Fj GW4W @\\ >W8W LX                 X   .X 2VFV 'VBV$XGSCR KV?VBV X 1V (W 'W ,\\  V       GW 5X8X <X  NX -X AWIX DX /X  "
"BY HX8X X5W     ([  1[  HX ?W W/WHW FX6X!Y -X-Y*X -X .Y -X/X'X -X -XDZ CX -XLW<WLX0XKW<X'Y+X+X7X Y+X+X7X!X  KX <X/X'X4X#X<VKV<X4XFY FXBX *Y KW /W  NW "
"/Y7Y    +g AWIb ;f =bIW De Il 3bIW MWIc FW ,W ,W9Y LW ,WIbBb6WIc >f CWIb =bIW MWI^ =j Im <W6W\"W2W\"W<Z<W4X7X!W2W!u 6W :V  MW       @bEW\"W:W 2X @c 8j CW"
"Ic MX0W =W <W6W IW/W\"VI^ L}!WCWCW Ee =t&{ W4W BWHW =Y 7X .X*Y*ZFXFZ(X0X)X?X?X.Y+X  #WIVIW   =V   =WIVIW     f ?X 8X2X KW@W EV .Z   +SE[GVDS6ZDV       "
"DSDVDXDS  9UAU %V :U 2`   <W6W NiGU     KU 6V;V   >U4V LU4V\"`:V GX /WHW ;WHW ;WHW ;WHW ;WHW ;WHW :XEX MY -X -X -X -X -X -X -X -X ,X-Y+XKW<X'Y+X,Y+X,Y+"
"X,Y+X,Y+X'Z3Z,Y4WNY,X/X'X/X'X/X'X/X#XBX Gu JWB\\ Ag <g <g <g <g <g <gBe+f <e :e :e :e CW ,W ,W ,W  Mc FWIc >f ;f ;f ;f ;f +Z >eJU NW6W MW6W MW6W MW6W\"W"
"2W MWIb IW2W     NWAVAW(W,W(WJR<RJW(W4RJW(W,W\"V 9W2X     1X 6T   9i ?k#~`#k Hl HW4W @] ?X9W LW                 NX   .X 2VFV 'VCW$WFSAP KV?VBV NW 1V (V"
" &W *X  MV       GV 5X6X =X  NX -X AVHX DX /X  BX GX8X X5X     ,^  1^  LX ?W MW0WHW FX6X!X ,X-Y*X -X .X ,X/X'X -X -XEZ BX -XKV<VKX0XKX=X'Y+Y,X7X Y+Y,X"
"7X!X  KX <X/X'X4X\"W=WKV<W3YGY FYDY +Z KW .V  NW 0Y5Y    /l CWJe ?j AeJW Eh Kl 5eJW MWJe GW ,W ,W:Y KW ,WJdDd7WJe @h DWJe AeJW MWJ_ ?l Im <W6W\"W2W!W=Z="
"W2X9X W2W!u 6W :V  MW       BeFV!W;X 1W ?f =k CWJe NY2X =X =W6W JW-W$WI` N}!WCWCW Gi Av&{ W4W BVGW <Y 8X .X)X+ZEXEZ)X0X)X?X?X.Y+Y  #UHVHU   <V   <UHVH"
"U    !j AX 9Z4Z KWBW DV -Z   -TFY@RDT8XAV       ETDVBWET  :VCV %V ;V )X   =W6W NiGU     KU 6V;V   >U5V KU5V GX<V FX /WHW ;WHW ;WHW ;WHW ;WHW ;WHW :WDX"
" MX ,X -X -X -X -X -X -X -X ,X-Y+XKX=X'Y+Y-Y+Y-Y+Y-Y+Y-Y+Y'Z5Z+Y5WMY,X/X'X/X'X/X'X/X#YDY GX@^ KWCZ Al Al Al Al Al Al AlFh.j ?h =h =h =h EW ,W ,W ,W !g"
" GWJe @h =h =h =h =h ,Z @hLV NW6W MW6W MW6W MW6W\"W2W MWJe KW2W     W@VAW)W+W)WJT>TKW)W4TKW)W+W\"V 9X3X     2X 5T   :k ?i\"~`$m Jn IW4W A^ ?X:X MW       "
"          NY   .X 2VFV 7~X2XFS <V?VCV MX 2V )W %W +X  MV       GV 5X6X =X  NX -X BVGX DX /X  BX GX8X X5X LX -X  7a  1a  X @W KW2XHX GX6X!X ,X,X*X -X ."
"X ,X/X'X -X -XFZ AX -XKV<VKX0XJW=X'X)X,X7X X)X,X7X!X  KX <X/X'X4X\"X>VIV>X2YIY DYFY +Z JW .V  NW 1Y3Y    1n DWLh Bm ChLW Gk Ll 6hLW MWKg HW ,W ,W;Y JW "
",WKfGg8WKg Cl FWLh ChLW MWK` @m Im <W6W\"X4X!W=Z=W1X;X NW3X!u 6W :V  MW       CgGV!W;W 0X ?g Am CWKg [4X >Y =W6W JW-W&YJb }!WCWCW Hk Dx&{ W4W CWFW <Y 9"
"X /Y)X,ZDXDZ*X0X)X?X?X.X)X P #SGVGS %P 7V 9P0P CSGVGS    !l BX 8ZGWFZ JWCX DV ,Z   .SEW<PCS8V?V .P>P     JSCVAVDS  :WEV $V <V &W   >W6W NiGU     KU 6V"
";V BP>P /U5V KU5V EW=V FX 0XHX =XHX =XHX =XHX =XHX =XHX <XDX MX ,X -X -X -X -X -X -X -X ,X,X+XJW=X'X)X-X)X-X)X-X)X-X)X&Z7Z*X5WKX,X/X'X/X'X/X'X/X\"YFY F"
"X=[ KWDY @n Cn Cn Cn Cn Cn CnHj1m Bk @k @k @k FW ,W ,W ,W $j GWKg Cl Al Al Al Al .Z Bs MW6W MW6W MW6W MW6W\"W3X MWLh LW3X     V?V@W*V)W*VJV@VKW*V4VKW*V"
")W#V 9X4X     2X 4S   :l ?i\"~`%o Lp JW4W A^ >W:X MW                 NX   -X 2VFV 7~X2WES <V?VDV LX 2V )W %W -\\  V       HW 5X6X =X  NX .X BWGX DX 0X  "
"BY FX:X NX5X LX -X  :d  1d $Y @V IV2WFW GX6X\"Y ,X,Y+X -X /Y ,X/X'X -X -XH[ @X -XKW>WKX0XJX>X(Y)X,X7X!Y)X,X7X!Y  LX <X/X&X6X!X>VIV>X1YKY BXFX +Z IW .W "
" W 2Y1Y    2o EWMj Dn DjMW Hn Nl 7jMW MWLi IW ,W ,W<Y IW ,WLhIi9WLi En GWMj EjMW MWLa An Im <W6W!W4W W=Z=W1Y=Y MW4W u 6W :V  MW       DiIV W;W /W =g C"
"m CWLi![4W =Y =W6W KW+W(ZKd!}!WCWCW Im Fy&{ W4W CWFW ;Y :X /X'X-YCXCY*X0X)X?X?X/Y)X!R #QFVFQ $R 9V :R1R DQFVFQ    \"n BX 7ZJ\\JZ HWDW CV +[   1TFW.T:W?V"
" /Q?Q     KTCVAWET  :XIX $V =V #U   >W6W NiGU     KU 6V;V BQ?Q 0U6V JU6V BU>V EX 0WFW =WFW =WFW =WFW =WFW =WFW <XDX NY ,X -X -X -X -X -X -X -X ,X,Y,XJ"
"X>X(Y)X.Y)X.Y)X.Y)X.Y)X%Z9Z*Y6WJX,X/X'X/X'X/X'X/X!XFX EX;Z LWDX ?o Do Do Do Do Do DoKn4n Cn Cn Cn Cn HW ,W ,W ,W %l HWLi En Cn Cn Cn Cn /Z Cs LW6W MW6"
"W MW6W MW6W!W4W LWMj LW4W     W?V?V+W(V+WKXBXKV+W5XKV+W(V$W 8W4X     2X 5T   ;n ?g!~_%p LZDZ JW4W A^ >W:W MW                 MX   -X 2VFV 7~X2WES <WAW"
"DV KX 3V )W %W /` \"V       HV 4X6X =X  Y .X BVFX DX 0X  BX EX:X NX5X LX -X  <e  /e 'Y @V GV4XFX HX7X!X +X+X+X -X /X +X/X'X -X -XI[ ?X -XJV>VJX0XIW>X(X"
"'X-X7X!X'X-X7X!Y  LX <X/X&X6X!X>VIV>X1YKY AXHX +Z HW -V  W 3Y/Y    3p FWMk Fo EkMW Io Nl 8kMW MWMk JW ,W ,W=Y HW ,WMjJj:WMk Gp HWMk GkMW MWMb Bo Im <W"
"6W!W4W W>\\>W0X=X LW5X u 6W :V  MW       EkJV W<X /W >j Fn CWMk\"\\6X =Z >W6W KW+W)[Ke\"}!WCWCW Jo Hz&{ W4W DWDW ;Y ;X /X'X.YBXBY+X0X)X?X?X/X'X#T  HV  IT "
":V ;T3T :V   CV +o BX 6ZM`MZ GXFX CV *\\   3SFW,S:V>V 0R@R     KSBV@VDS  9e #V ?W \"V   ?W6W NiGU     KU 6V;V BR@R 1U6V JU6V BV?V EX 1XFX ?XFX ?XFX ?XFX"
" ?XFX ?XFW =XCX NX +X -X -X -X -X -X -X -X ,X+X,XIW>X(X'X/X'X/X'X/X'X/X'X%Z;Z)X5VHX-X/X'X/X'X/X'X/X XHX DX:Y LWEX >p Ep Ep Ep Ep Ep EpMp6o Do Do Do Do"
" HW ,W ,W ,W 'o IWMk Gp Ep Ep Ep Ep 0Z Ds KW6W MW6W MW6W MW6W!W5X LWMk MW5X     V>V?W,V'W,VKZDYKW,V5YKW,V'W%W 8X5W     2X 4T   ;o @g ~^%q NY@Y KW4W B`"
" ?X<X MV                 LX   -X 2VFV 7~X2WES ;VAVDV JY 4V )V $W 1d $V       HV 4X6X =X  X .Y CWFX DXLY =XEX 'Y EY<X MX5X LX -X  ?e  )e +Y ?V:X6V4WDW "
"HX7X!X +X+X+X -X /X +X/X'X -X -XJ[ >X -XJW@WJX0XIX?X(X'X-X7X!X'X-X8Y Y  MX <X/X%W6X W?WIV>W/YMY @YJY +Y GW -V  W 4X+X    4YE\\ FWNXG\\ H]EX F\\GXNW J\\F[ "
"GW ,\\GXNW MWNXG[ JW ,W ,W?Z GW ,WNXH[KXH[:WNXG[ H]H] IWNXG\\ I\\GXNW MWNXFQ C\\CW CW ,W6W!X6X NW?\\?W.X?X JW6W 1X 6W :V  MW     9X=X\"[IZKW W=Y /W @m H]DV "
"CWNXG[\"\\6W =[ >W6W LW)W*ZJWKY\"}!WCWCW K\\H] J{&{ V3W DWDW :Y <X /X'X.XAXAX+X0X)X?X?X/X'X$V  IV  JV ;V <V5V ;V   CV ,^MSKW BX 5x EWFW BV ,_   5TFW,S:V?W"
" 1SAS     LTBV@VDS  9d \"V @W  U   ?W6W NiGU     KU 5V=V ASAS 2U7V IU7V @U@V DX 1WDW ?WDW ?WDW ?WDW ?WDW ?XFX >XCX NX +X -X -X -X -X -X -X -X ,X+X,XIX?"
"X(X'X/X'X/X'X/X'X/X'X$Z=Z(X6WHX-X/X'X/X'X/X'X/X YJY DX9Y MWEW =YE\\ EYE\\ EYE\\ EYE\\ EYE\\ EYE\\ EYE]N\\G[7]EX E\\F[ F\\F[ F\\F[ F\\F[ IW ,W ,W ,W (p IWNXG[ H]H"
"] G]H] G]H] G]H] G]H] 1Z E]H^ JW6W MW6W MW6W MW6W W6W KWNXG\\ MW6W     NV>V>V,V&V,VJZFYIV,V6YIV,V&V%W 7W6X     3X LR:T   ;q @e N~^&s!Y>Y LW4W B` >W<X N"
"W                $x   FX 2VFV 7~X2WES ;VAVEW IY 5V *W #W 4XNTNX &V       IW 5X5X =X  X .X CWEX Di AXH_ +X CX<X MX5X LX -X  Be  #e /Z @V<^IUDV5WDW HX8Y"
"!X +X+X+X -X /X +X/X'X -X -XK[ =X -XIV@VIX0XHW?X(X'X-X7X!X'X-X8X NZ  NX <X/X%X8X NX@VGV@X.c >XJX +Z GW -W !W 5X)X    5U>Z G_CZ I[>T FZC_ KZAZ HW -ZB_ "
"M^BZ KW ,W ,W@Z FW ,^CZMVCZ;^BZ IZBZ I_CZ IZC_ M^ 5Y<S CW ,W6W W6W MW?\\?W.YAY JW6W 2Y 6W :V  MW     ;\\A\\%YDYLV NW>Y .W AXJa IZ<Q C^BZ MX8X =\\ ?W6W LW)"
"W+YIXJY LW=W JWCWCW LZBZ K]F] ;W >W2W EWDW 9Y =X /X'X/YAXAY,X0X)X?X?X/X'X%X  JV  KX <V =X7X <V   CV -\\JSHT BX 4v DXHX BV -b   7SEV*S;V?W 2TBT     LSAV"
"@VCS  9b !V AV  MU   ?W6W MhGU     KU 5V=V ATBT 3U8V HU8V ?UAV CX 1WDW ?WDW ?WDW ?WDW ?WDW ?WDW ?XBX NX +X -X -X -X -X -X -X -X ,X+X,XHW?X(X'X/X'X/X'X"
"/X'X/X'X#Z?Z'X7WGX-X/X'X/X'X/X'X/X NXJX CX9Y MWFW <U>Z FU>Z FU>Z FU>Z FU>Z FU>Z FU>eBZ9[>T FZAZ HZAZ HZAZ HZAZ JW ,W ,W ,W )r J^BZ IZBZ GZBZ GZBZ GZBZ"
" GZBZ 1Z EZB[ JW6W MW6W MW6W MW6W W6W K_CZ MW6W     V=V>V-V%V-VHZHYHV-V6YHV-V%V%W 7X7X     4X NU:T   <s Ae N~^'u\"X<X LW4W BWNW >W<W MW                "
"$w   EX   2~X2WES ;WCWEV GY   9W #W 5XMTMX 'V       IV 4X4X >X !Y 0Y BVDX Dk CXJc -X BX>X LX5Y MX -X  Ee   Le 3Z ?U=bKUCU6XDX IX9Y X +X+X+X -X /X +X/X"
"'X -X -XL[ <X -XIV@VIX0XHX@X(X'X-X8Y!X'X-X8X N[  X <X/X%X8X NX@VGV@X.c =XLX +Z FW ,V !W       AR9Y H]?Y KZ:R GY?] LY=Y IW -Y?] M]@Y KW ,W ,WAY DW ,]@X"
"NV@X;]@Y JY>Y J]?Y KY?] M] 4X8P CW ,W6W X8X MW?\\?W-XAX IW7X 3Y 5W :V  MW     =_C_(YBXLV NW?Z -W CXC\\ KY ,]@Y LW8X >] ?W6W LW)W,YHWHY MW=W JWCWCW MY>Y "
"L[B[ ;W >W2W FWBW 9Y >X 0X%X0X@X@X,X0X)X?X?X/X'X&Y  JV  KY =V >Y7Y =V   CV .[HSFR BX 3t BWHW AV .WN\\   9SFV)S;V?W 3UCU     LSAV@VCS  7_  V BV  LU   ?W"
"6W MhGU     KU 5W?W AUCU 4U8V HU8V ?UAV CX 2XDX AXDX AXDX AXDX AXDX AXDX @XBX NX +X -X -X -X -X -X -X -X ,X+X,XHX@X(X'X/X'X/X'X/X'X/X'X\"ZAZ&X8WFX-X/X'"
"X/X'X/X'X/X MXLX BX8X MWFW <R9Y GR9Y GR9Y GR9Y GR9Y GR9Y GR9a>Y;Z:R GY=Y JY=Y JY=Y JY=Y KW ,W ,W ,W *]E[ J]@Y JY>Y IY>Y IY>Y IY>Y IY>Y 2Z FY>Y JW6W MW"
"6W MW6W MW6W W7X K]?Y NW7X     V=V=U-V$U-VGZJYFU-V7YFU-V$U%W 7X8X    &~X/X:T   =t @c L~\\'v\"W:W LW4W CXNX ?X>X MV                $x   EX   2~X2WES :VDW"
"EV FZ   :W #W 7XKTKX )V       IV 4X4X >X !X 0Y BWDX Dm FXKf /Y AYBY KX5Y MX -X  Gd ~X d 5Y ?V>dLUCU6WBW IX;Z Y +X+Y,X -X 0Y +X/X'X -X -XM[ ;X -XIWBWIX"
"0XGW@X)Y'Y.X8X!Y'Y.X9Y M] #X <X/X$X:X MX@VGV@X-a <YNY ,Z EW ,V !W       AP6X H\\=Y LY7P HY=\\ LX;X IW .Y=\\ M[=X KW ,W ,WBY CW ,[=]=W;[=X KY<Y K\\=Y MY=\\ "
"M\\ 4X *W ,W6W NW8X MW@VNV@W,XCX GW8W 3Y 4W :V  MW     >aEa)X@XNW NWA[ ,W DW?[ LX +[=X KW:X =] ?W6W MW'W-XGWGX MW=W JWCWCW MX<Y NZ>Z <W >W2W FWBW 9Z ?X"
" 0X%X0X@X@X,X0X(X@X@X/Y'Y(Y  IV  JY >V ?Y5Y >V   CV .YFSDP BX 2q @XJX AV /WK[   :SFV)S;V@X 4VDV     LSAV@VCS  6\\  MV CV  KU   ?W6W MhGU     KU 4V?V @V"
"DV 5U9V GU9V >UBV BX 2WBW AWBW AWBW AWBW AWBW AXDX @XBX Y +X -X -X -X -X -X -X -X ,X+Y-XGW@X)Y'Y1Y'Y1Y'Y1Y'Y1Y'Y\"ZCZ&Y9WEY.X/X'X/X'X/X'X/X MYNY BX8Y N"
"WFW <P6X GP6X GP6X GP6X GP6X GP6X GP6_<X;Y7P GX;X JX;X JX;X JX;X KW ,W ,W ,W *Z?Y K[=X KY<Y KY<Y KY<Y KY<Y KY<Y 3Z GY<Y KW6W MW6W MW6W MW6W NW8W J\\=Y "
"NW8W     NV=V=V.V$V.VFZLYEV.V8YEV.V$V&W 6W8X    &~X2\\<T   =v Ab K~\\(x$W8W MW4W CXNX ?X>X NW                $w   DX   $VBV#XFS :WFXEV H]   ;W #W 9XITIX"
" +V       JW 4X4X >X \"Y 3[ BWCX Dn GXLi 1X ?ZFZ JY7Z MX -X  Je M~X Me 9Y >U?gMUCV7WBW IX>\\ NX *X*X,X -X 0X *X/X'X -X -XNZ 9X -XHVBVHX0XGXAX)X%X.X9Y!X%"
"X.X:Y La 'X <X/X$X:X LWAWGV@W+_ :XNX ,Z DW ,W \"W       &W H[;X MY .X;[ MX9X JW .X;[ M[<X LW ,W ,WCY BW ,Z<\\<X<[<X LX:X K[;X MX;[ M[ 3W )W ,W6W NW8W KW"
"AVNVAW*XEX FW9X 4Y 3W :V  MW     ?cGc+Y?WNV MWD] +W DV=Z LX +Z;X LW:X >_ @W6W MW'W.YGWFX NW=W JWCWCW NX:X NY<Y <W >W2W FWBW 8Z @X 0X%X0X@X@X,X0X(X@X@X"
"/X%X)Y  HV  IY ?V @Y3Y ?V   CV /YES 6X 1\\H[ JcJc LV 0WI\\   =TFV)S;WAX 5WEW     MTAVAWCS  3W 4~W.W  KV   ?W6W LgGU     KU 4WAW @WEW 6U9V GU9V ?VBV BX 2"
"WBW AWBW AWBW AWBW AWBW AWBW AXAX X *X -X -X -X -X -X -X -X ,X*X-XGXAX)X%X1X%X1X%X1X%X1X%X!ZEZ%X9WCX.X/X'X/X'X/X'X/X LXNX AX7X NWFW !W ,W ,W ,W ,W ,W "
",]:X=Y .X9X LX9X LX9X LX9X LW ,W ,W ,W +Z=X K[<X LX:X KX:X KX:X KX:X KX:X 3Z GX<Z KW6W MW6W MW6W MW6W NW9X J[;X NW9X     NU<V=V.U#V.UDZNYDV.U8YDV.U#V&"
"V 5X9W    %~X3]<T   >x A` J~\\(y%W8W MW4W CXMW >W>W MV                $x   DX   $VCV\"XFS 9XIXEV H_   <W #W ;YHTHY -V       JV 3X4X >X #Y ?g AVBX Do HXM"
"k 3Y >l HX7Z MX -X  Me J~X Je =Y >V?hNUBU8XBX Ju MX *X*X,w Lq IX *~R'X -X -c 8X -XHVBVHX0XFWAX)X%X.X9Y!X%X.X;Z Ke ,X <X/X$X:X LXBVEVBX+_ 9` +Y CW +V \""
"W       %W IZ9X NX .X9Z MW7W JW /X9Z MZ;X LW ,W ,WDY AW ,Z;[;W<Z;X MY:Y LZ9X X9Z MZ 2W )W ,W6W NX:X KWAVNVAW*YGY EW:W 4Z 3W :V  MW     ?XMYIe,X>WNV MW"
"Ib +W EW;Y MW *Z;X KV:W =_ @W6W NW%W/XFWFX NW=W JWCWCW NW8X!Y:Y =W >| GW@W 8Y @X 0X%X1Y@X@Y-X0X(X@X@X/XImIX*Y  GV  HY @V AY1Y @V   CV /XDS 6X 0YDY JdL"
"d LV 1WF[   >SFV'S<WBY 6XFX     MS@VAVAS    @~W/W  JU   >W6W LgGU     KU 3WCW ?XFX 7U:V FU:V >UBV AX 3XBX CXBX CXBX CXBX CXBX CXBX BXAw?X *w Lw Lw Lw "
"LX -X -X -X ,X*X-XFWAX)X%X1X%X1X%X1X%X1X%X ZGZ$X:WBX.X/X'X/X'X/X'X/X K` @X7X NWFW  W ,W ,W ,W ,W ,W ,[8W=X -W7W LW7W LW7W LW7W LW ,W ,W ,W ,Y:X LZ;X M"
"Y:Y MY:Y MY:Y MY:Y MY:Y  \"Y=\\ LW6W MW6W MW6W MW6W MW:W IZ9X NW:W     NV<V=V/V#V/VCcCV/V9YCV/V=X>V&V 4W:X    %~X2TNV<S   =y KWM^LW$~Z({&W7V MW4W CWLX ?"
"X?W MV                 KX   ,X   %VBV!XGS 9gFV Ha   >W \"W ;WFTFW -V       JV 3X4X >X #Y ?f AWBX Dp IXNm 4X <j GX7Z MX -X !e G~X Ge AY =U?ZH^BU8W@W Jt "
"LX *X*X,w Lq IX *~R'X -X -b 7X -XHWDWHX0XFXBX)X%X.X:Y X%X.X<Z Ih 0X <X/X#X<X KXBVEVBX*] 8` ,Z CW +V \"W       %W IZ9X X -X9Z NX7X KW /X9Z MY9W LW ,W ,W"
"EY @W ,Y:Z:W<Y9W MX8X LZ9X X9Z MY 1W )W ,W6W MW:W JWAVNVAW)XGX DW:W 4Y 3X :V  MW     @VHXKWGV,W<^ MWIa *W FW9Y NW *Y9W KW<X >` @W6W NW%W/WEWEW NW=W JW"
"CWCW X8X!X8X =W >| GW@W 7Y AX 0X%X1X?X?X-X0X(X@X@X/XImIX+Y  FV  GY AV BY/Y AV   DX 1XCS 6X 0W@X KdLd LV 1VCZ   ?SFV'S;WE[ 7XFX G~X  .S@VBWAS    @~W0W "
".P>W   >W6W KfGU     KU 3XEX >XFX 8U;V:W3U;VCZ9P>WCV:W/Y 3W@W CW@W CW@W CW@W CW@W CXBX CX@w?X *w Lw Lw Lw LX -X -X -X 5p9X-XFXBX)X%X1X%X1X%X1X%X1X%X N"
"ZIZ#X:VAX.X/X'X/X'X/X'X/X K` @X7X NWFW  W ,W ,W ,W ,W ,W ,[8X?X -X7X NX7X NX7X NX7X MW ,W ,W ,W ,X9X LY9W MX8X MX8X MX8X MX8X MX8X  \"X=] LW6W MW6W MW6"
"W MW6W MW:W IZ9X NW:W     NVLuKU/VLuKU/VBaAU/V:YAU/V=X=U&V 4X;X    %~X2RLW>T   >{!z'~Z)}(W6W NW4W DXLX ?X@X MV                 KX   ,X   %VBV!YHS 8eEV"
" Ic   ?W !W ;UETEU ,V       KW 3X4X >X $Y >c ?WAX DWD^ JbG] 5X 9d DY9[ MX -X #d D~X Dd DY <U@YD\\BU9X@X Kq IX *X*X,w Lq IX *~R'X -X -a 6X -XGVDVGX0XEWB"
"X)X%X.X;Z X%X.X?\\ Gk 4X <X/X#X<X KXBVEVBX)[ 6^ ,Z BW +W #W       %W IY7W X -W7Y NW5W KW 0X7Y MY9W LW ,W ,WFY ?W ,Y:Z:W<Y9W MW6W LY7W W7Y MY 1W )W ,W6W"
" MW:W JWBVLVBW(XIX CW;X 5Y 2X :V  MX     BUDVKVDU.X<] LWI_ :WEW FV7X NW *Y9W JV<X >a AW6W NW%W0XEWEX W=W JWCWCW W6W!X8X =W >| HX@X 7Y BX 0X%X1X?X?X-X0"
"X(X@X@X/XImIX,Y  EV  FY BV CY-Y BV   DX 1XCS 6X 1W>W KeNe LV 1VB[   ASFV'S;YI] 9YGY F~X  .S@VDX@S    @~W1V ,TEZ   >W6W JeGU IX   +U 2YIY <YGY :U;V:W3U"
";VGa<TEZCV:W/X 3X@X EX@X EX@X EX@X EX@X EX@X DX@w?X *w Lw Lw Lw LX -X -X -X 5p9X-XEWBX)X%X1X%X1X%X1X%X1X%X MZKZ\"X;WAX.X/X'X/X'X/X'X/X J^ ?X7X NWFX !W "
",W ,W ,W ,W ,W ,Z6W?X -W5W NW5W NW5W NW5W MW ,W ,W ,W -X7W LY9W MW6W MW6W MW6W MW6W MW6W  \"W=^ LW6W MW6W MW6W MW6W MW;X IY7W NW;X     NVLuKU/VLuKU/VA_"
"@U/V;Y@U/V=X=U&V 4X<X    $~X,W>T   ?|\"}(~X)~(W6W NW4W DXKW >W@X MV                 KX   ,X   %VBV!ZIS 7cEV IYNZ8W  0W !W :RCTCR +V       KW 3X4X >X %Y"
" =b >V@X DS=\\ K`C[ 6Y 8b BX9[     Nd A~X Ad HY <VAX@ZBV:X?W Kq IX *X*X,w Lq IX *~R'X -X -a 6X -XGVDVGX0XEXCX)X%X.X=[ NX%X.u Fl 6X <X/X\"W<W IWCWEVBW([ "
"5\\ ,Z AW +W #W       $V IY7X\"X -X7Y NW5W KW 0X7Y MX8X MW ,W ,WHZ >W ,X8X8W=X8X X6X MY7X\"X7Y MX 0W )W ,W6W MX<X IWCVLVCW&XKX AW<W 5Y 1W 9V  LW  4P  /TB"
"VMVBT.X;\\ LWI` =\\HW GW7X NW *X8X KV=X >XMW AW6W NW%W0XEWDW W=W JWCWCW!X6X#X6X >W >| HW>W 6Y CX 0X%X1X?X?X-X0X'XAXAX.XImIX-Y  DV  EY CV DY+Y CV   DX 2X"
"BS 6X 1V<V KeNe LV 2V?Y   ASFV'S:dNV :XFY E~X  .S@i?S    @~W2i >h   =W6W JeGU IX   4g :g :YFX DgEV:X<gEVHe>hCV:X/X 3X?W EX?W EX?W EX?W EX?W EX@X EX?w?"
"X *w Lw Lw Lw LX -X -X -X 5p9X-XEXCX)X%X1X%X1X%X1X%X1X%X LZMZ!X<W@X.X/X'X/X'X/X'X/X I\\ >X7X NWFY !V +V +V +V +V +V +Y6W@X ,W5W NW5W NW5W NW5W MW ,W ,W"
" ,W -X7X MX8X X6X X6X X6X X6X X6X  $X=_ MW6W MW6W MW6W MW6W LW<W HY7X NW<W     MVLuKU/VLuKU/V@]?U/V<Y?U/V=X=U&V 3W<X    $~X+V>S   >}%~R)~V(~P)W6W NW4W"
" DWJX ?XAW L~^               $X   ,X   %VCV N\\LS 6aDVAW0XLZ9W  0W !W :PATAP +V       KV 2X4X >X &Z =e BW@X DP8[ L^?Z 7X :h EY;\\    \"d >~X ?e LY ;U@W>Y"
"AU:W>W Ks KX *X*X,w Lq IX6f+~R'X -X -b 7X -XGWFWGX0XDWCX)X%X.X@^ NX%X.s Bl 8X <X/X\"X>X IXDVCVDX)[ 4\\ -Z @W *V #W       $W JX5W\"X -W5X W4W KW 0W5X MX7W"
" MW ,W ,WIZ =W ,X8X8W=X7W W4W MX5W\"W5X MX 0X *W ,W6W LW<W HWCVLVCW&YMY AW=X 6Y 1X 9V  LX 1X.Q  /TA]AU/W:\\ LWIb A`JW GV5X NW +X7W KW>X >XMX BW6W W#W1WD"
"WDW W=W JWCWCW!W4W#X6X >W >| HW>W 7Y BX 0X%X1X?X?X-X0X'XAXAX.XImIX.Y  CV  DY DV EY)Y DV   DX 2XBS 6X 2W<W =^ =V 2V>Y   BSFV'S9bMV ;XFY D~X  .S@h>S    "
"@~W2i >g   <W6W HcGU IX   4g 9e 8YFX EgEV;Y<gEVHf?gBV;Y0Y 3W>W EW>W EW>W EW>W EW>W EW>W EX?w?X *w Lw Lw Lw LX -X -X -X 5p9X-XDWCX)X%X1X%X1X%X1X%X1X%X "
"Ke X=W?X.X/X'X/X'X/X'X/X I\\ >X7X NWEY \"W ,W ,W ,W ,W ,W ,X5W@X -W4W W4W W4W W4W MW ,W ,W ,W -W6X MX7W W4W W4W W4W W4W W4W  $W=VMW MW6W MW6W MW6W MW6W "
"LW=X HX5W NW=X     MVLuKU/VLuKU/V?[>U/V=Y>U/V=X=U&V 3X=W     7X FW@T   ?~&~T*~V)~R*W5V NW4W EXJX ?XBX L~^               $X   ,X   &VBV Mb 4]CVC]4XJZ:W"
"  0W !W +T  KV       KV 2X4X >X 'Z <g EW?X +Z L]=Z 9Y <l GZ=]    %e    e!Y :UAW<XAU;X>X Lu MX *X*X,w Lq IX6f+~R'X -X -c 8X -XFVFVFX0XDXDX)X%X.u MX%X.r"
" ?l :X <X/X\"X>X IXDVCVDX)\\ 4Z ,Y ?W *V #W       $W JX5W\"W ,W5X W3W LW 0W5X MX7W MW ,W ,WJY ;W ,X8X8W=X7W W4W MX5W\"W5X MX 0X *W ,W6W LW<W HWCVKUCW%XMX "
"?W>W 6Y 0X 9V  LX 5`3R  0T?[?T/W:[ KWId DbKW HW5X NW +X7W JV>W =WLX BW6W W#W1WDWDW W=W JWCWCW!W4W#W4W >W >| IX>X 9Y AX 0X%X1X?X?X-X0X'XAXAX.XImIX/Y  B"
"V  CY EV FY'Y EV   DX 2WAS ?r CV:V =^ =V 2V=Y   CSFV'S8`LV <XFX B~X  .S@e;S    @~W2i >e   :W6W GbGU IX   4g 8c 5XFX FgFV:Y<gFVGg@eAV:Y1Y 3X>X GX>X GX>"
"X GX>X GX>X GX>X FX?w?X *w Lw Lw Lw LX -X -X -X 5p9X-XDXDX)X%X1X%X1X%X1X%X1X%X Jc NX>W>X.X/X'X/X'X/X'X/X HZ =X7X NWEZ #W ,W ,W ,W ,W ,W ,X4WAW ,W3W!W3"
"W!W3W!W3W NW ,W ,W ,W .X5W MX7W W4W W4W W4W W4W W4W  $W>VLW MW6W MW6W MW6W MW6W KW>W GX5W MW>W     LVLuKU/VLuKU/V>Z>U/V>Y=U/V=X=U&V 2W>X     8Y FW@T  "
" ?~P(~V*~T(~Q)V4V NW4W EXJX >WBX L~^               $X   ,X   &VBV Ld 4WAVD`6XHZ;W  0W !W +T  KV       LW 2X4X >X 'Y ;i GV>X *Z M\\;Y 9X =p HZ?^    'd  "
"  Id$Y 9UAW<XAU;W<W Lw X *X*X,w Lq IX6f+~R'X -X -d 9X -XFVFVFX0XCWDX)X%X.t LX%X.p ;k ;X <X/X!X@X HXDVCVDX*^ 4X ,Z ?W *W $W       $W JX5W\"W ,W5X W3W LW"
" 0W5X MW6W MW ,W ,WKY :W ,W7W7W=W6W W4W MX5W\"W5X MX /Y ,W ,W6W LX>X GWEVJVEW#a >W>W 7Y 1Y 8V  KY 9e8T  0T?Z>T0X:[ KWIf GdLW HW4W MW ,W6W JV?X >XKW BW6"
"W W#W2XDWDX!W=W JWCWCW!W4W#W4W >W >| IW<W :Y @X 0X%X1X?X?X-X0X&XBXBX-XImIX0Y  AV  BY FV GY%Y FV   DX 2WAS ?r DW:W =\\ <V 2V;W   CSFV'S7]JV =XFX A~X  .S"
"@d:S    (V Ii <a   8W6W FaGU IX   4g 6_ 2XFX GgGV:Z<gGVFUFY?a@V:Z2Y 2W<W GW<W GW<W GW<W GW<W GX>X GX>w?X *w Lw Lw Lw LX -X -X -X 5p9X-XCWDX)X%X1X%X1X%",

"X1X%X1X%X Ia MX?W=X.X/X'X/X'X/X'X/X GX <X7X NWDZ $W ,W ,W ,W ,W ,W ,X4WAW ,W3W!W3W!W3W!W3W NW ,W ,W ,W .W4W MW6W W4W W4W W4W W4W W4W  $W?VKW MW6W MW6W"
" MW6W MW6W KW>W GX5W MW>W     LVLuKU/VLuKU/V?\\?U/V?Y<U/V=X=U&V 2W>X     8X DWBT   ?~Q)~W)~R&~(V4V NW4W EWHW >WBW K~^               $X   ,X   &VBV Kg \""
"VEc8WFZ=W  /W !W +T 4~W      5V 1X4X >X (Y -] IW>X )Y M[9X 9X >\\F\\ H[C`    'a    Ca$Y 9UAV:WAU;W<W LX<\\!X *X*X,X -X 0X6f+X/X'X -X -XN[ :X -XEVHVEX0XCX"
"EX)X%X.s KX%X.o 6h <X <X/X!X@X GWDVCVDW*_ 4X -Z >W )V $W       6i JX5X$X -X5X V2W LW 1W3W MW6W MW ,W ,WLY 9W ,W7W7W=W6W!X4X NX5X$X5X MW .[ .W ,W6W KW>"
"W FWEVJVEW#a >W?X 8Z 4\\ 8V  K[ =i<V  0S=Y=S0X:[ KW@^ IfMW HW4W MY .W6W JW@W =XKX CW6W W#W2WCWCW!W=W JWCWCW\"X4X%X4X ?W >W2W IW<W :Y @X 0X%X1X?X?X-X0X&X"
"BXBX-X%X1~` GV H~` GV H~` GV   DX 3XAS ?r DV8V =\\ <V 2V;X   DSFV'S4W /XFX @~X  .S@VIX;S    (V Ii 8Z   5W6W D_GU IX   4g 3Y .XFX HgGV;TNU<gGVFQ@W;Z=V;T"
"NU3Y 1W<W GW<W GW<W GW<W GW<W GW<W GX>X X *X -X -X -X -X -X -X -X ,X*X-XCXEX)X%X1X%X1X%X1X%X1X%X H_ LX@W<X.X/X'X/X'X/X'X/X GX <X7X NWD\\ 8i >i >i >i >i"
" >i >i3WBX ,V2W!V2W!V2W!V2W NW ,W ,W ,W .W4W MW6W!X4X\"X4X\"X4X\"X4X\"X4X M~Y2X@VIW NW6W MW6W MW6W MW6W KW?X GX5X NW?X     LVLuKU/VLuKU/V@^@U/V@Y;U/V=X=U&"
"V 2X?W     8X CWBT   ?~R*~X)~Q%}(V4W W4W FXHX ?XDX K~^               $X   ,X   'WCV Ii &VEe:XEZ>W  /W !W +T 4~W      5V 1X4X >X )Y )[ KW=X (Y N[9Y ;Y "
"?Z@Z I]Gb    '^    =^$X 9U@V:WAU<X<X MX9Z\"X *X*X,X -X 0X6f+X/X'X -X -XM[ ;X -XEVHVEX0XBWEX)X%X.r JX%X.q 4e =X <X/X!X@X GXFVAVFX*` 5X .Z =W )V $W      "
" :m JW3W$W ,W3W!W2W LW 1W3W MW6W MW ,W ,WMY 8W ,W7W7W=W6W!W2W NW3W$W3W MW -^ 2W ,W6W KX@X FWEVJVEW\"_ <W@W 7Y :b 7V  Jb FmAX  0S<W<S0W8Y JW<[ KYHVMV GV"
"3X MZ 0W6W IVAX >XIW CW6W!W!W3WCWCW!W=W JWCWCW\"W2W%W3X ?W >W2W JW;X <Y ?X 0X&Y1X?X?X-X0X&YCXCY-X%X2~a GV H~a HV I~b HV   DX 3W@S ?r DV8V <Z ;V 2W;W   "
"DSFV'S  <XFX  =V  .S@VGW<S    (V      \"W6W A\\GU IX       2XFX *V;TMU LV2V V;TMU4Z 2X<X IX<X IX<X IX<X IX<X IX<X IX=X X *X -X -X -X -X -X -X -X ,X*X-XB"
"WEX)X%X1X%X1X%X1X%X1X%X G] KX@V;X.X/X'X/X'X/X'X/X GX <X8Y NWC\\ =m Bm Bm Bm Bm Bm Bm3WBW ,W2W\"W2W\"W2W\"W2W NW ,W ,W ,W /X4X NW6W!W2W\"W2W\"W2W\"W2W\"W2W M~Y"
"2W@VHW NW6W MW6W MW6W MW6W JW@W FW3W MW@W     KVLuKU/VLuKU/VA`AU/VAY:U/V=X=U&V 1W@X     9X BWBS   >~R+~Z*~P#{'V4W W4W FXHX ?XDX K~^               $X  "
" ,X   'VBV Gi (VFg;WCZ?W  /W !W +T 4~W      6W 1X4X >X *Y &Z LW=X (Y NZ7X ;X ?Z>Z ImNX    '[    8\\%Y 9UAW:WAU<W:W MX7Y#X *X*X,X -X 0X6f+X/X'X -X -XL[ "
"<X -XEWJWEX0XBXFX)X%X.p HX%X.r 0a >X <X/X XBX FXFVAVFX+b 6X /Z <W )W %W       =p JW3W$W ,W3W!| LW 1W3W MW6W MW ,W ,WNY 7W ,W7W7W=W6W!W2W NW3W$W3W MW -"
"b 6W ,W6W JW@W EWFVHVFW!] ;WAX 8Y 9` 5V  H` HrG[  0S<W<S0W8Y JW:Y KXF^ HW2W Kc ;W6W IVAX >XIW CW6W!W!W3WCWCW!W=W JWCWCW\"W2W%W2W ?W >W2W JW:W =Y >X 0Y'"
"X0X?X?X-X0X%XCXCX,X%X2~a GV H~a HV I~b HV   DX 3W@S ?r DV8V <Z   FW;W   DSFV'S  =XFX  <V  .S@VFW=S    (V      \"W6W <WGU IX       1XFX +V;SLU LV2V V;SL"
"U5Z 1W:W IW:W IW:W IW:W IW:W IX<X IX=X X *X -X -X -X -X -X -X -X ,X*X-XBXFX)X%X1X%X1X%X1X%X1X%X F[ JXAW;X.X/X'X/X'X/X'X/X GX <X8X MWB] Bp Ep Ep Ep Ep "
"Ep E~eBW ,|\"|\"|\"| NW ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W M~Y2WAWHW NW6W MW6W MW6W MW6W JWAX FW3W MWAX     KV<V=V/V#V/VBbCV/VBY:V/V=X>V&V 1XAW     9"
"X @WDT   ?~S+~Z)}!y'W4W W4W FWFW >WDW J~^               *r   ?V   &VBV Eh *VEXIX<XBZ@W  /W !W +T 4~W  5f   8V 0X4X >X +Y $Z NW<X 'X NZ7X ;X ?X:X HkMX "
"   '[    7[%X 8UAV8VAU=X:X NX6X#X *X*X,X -X 0X6f+X/X'X -X -XK[ =X -XDVJVDX0XAWFX)X%X.m EX%X.XA\\ -^ ?X <X/X XBX FXFVAVFX,c 6X /Y ;W (V %W       ?r JW3W"
"$W ,W3W!| LW 1W3W MW6W MW ,W ,a 6W ,W7W7W=W6W!W2W NW3W$W3W MW ,e :W ,W6W JW@W DWGVHVGW N[ 9WBW 8Y 8^ 3V  F^ I~X  0S;U;T1W8Y JW8X MXC\\ HW2W Ia ;W6W IWB"
"W >XHX DW6W!W<W<W3WCWCW!W=W JWCWCW\"W2W%W2W ?W >W2W KX:X ?Y =X /X'X0Y@X@Y-X0X%YDXDY,X%X2~a GV H~a HV I~b HV   DX 3W@S ?r DV8V ;X   DW;V   DSFV'S  >XFX "
" ;V  .S@VFW=S    (V      \"W6W :UGU IX       0XFX -V;TLU MV0U!V;TLU6Y 0X:X KX:X KX:X KX:X KX:X KX:X JW<X X *X -X -X -X -X -X -X -X ,X*X-XAWFX)X%X1X%X1X"
"%X1X%X1X%X F[ JXBW:X.X/X'X/X'X/X'X/X GX <X9Y MWA] Er Gr Gr Gr Gr Gr G~gBW ,|\"|\"|\"| NW ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W M~Y2WBWGW NW6W MW6W MW6W "
"MW6W IWBW EW3W LWBW     IU<V=V.U#V.UCdDV.UCY9V.U=X>V&V 1XBX     :X ?WDT   ?~S,~[({ x&W4W W4W FWFX ?XFX JV                \"q   >V   &VBV Af -VEXGX=W@ZB"
"W  .W !W +T 4~W  5f   8V 0X4X >X ,Y \"Y W;X 'X NZ7X <Y @Y:Y HiLX    '^    =^%X 8UAV8VAU=X:X NX5X$X *X*X,X -X 0X(X+X/X'X -X -XJ[ >X -XDVJVDX0XAXGX)X%X.i"
" AX%X.X>Z ,\\ ?X <X/X NWBW DWFVAVFW+XMY 7X 0Z ;W (V %W       @s JW3W$W ,W3W!| LW 1W3W MW6W MW ,W ,` 5W ,W7W7W=W6W!W2W NW3W$W3W MW +g =W ,W6W JXBX DWGVH"
"VGW N[ 9WBW 9Y 7^ 3V  F^ I[Gr  /S;U;T1W8X IW7X NWA[ HW2W F^ ;W6W HVCX >XGW DW6W!W<W<W3WCWCW!W=W JWCWCW\"W2W%W2W ?W >W2W KW9X ?Y =X /X'X/X@X@X,X0X$YEXEY"
"+X%X2~a GV H~a HV I~b HV   DX 3W@S 6X 3V8V ;X   DX<V   DTFV)T  >WEW  :V  .TAVEW?T    (V      \"W6W :UGU IX       /WEW .V;TKU NV/U\"V;TKU7Y /X:X KX:X KX:"
"X KX:X KX:X KX:X KX<X X *X -X -X -X -X -X -X -X ,X*X-XAXGX)X%X1X%X1X%X1X%X1X%X G] KXCW9X.X/X'X/X'X/X'X/X GX <X9Y MW?] Hs Hs Hs Hs Hs Hs H~hBW ,|\"|\"|\"|"
" NW ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W M~Y2WBVFW NW6W MW6W MW6W MW6W IWBW EW3W LWBW     IU<V=V.U#V.UDYMZEV.UDY8V.U#V&V 0WBX     ;X >WDS   >~T-~\\(y"
" Mw&W4W W4W GXFX ?XFX JV                #r   >V   'WCV <c .VEWEW=W?ZCW  .W !W   :~W  5f   9W 0X4X >X -Y  Y!W;X 'Y Y5X =X @Y8Y HgKX    'a    Ca%X 8UAV8"
"VAU=W8W NX4X%X *X+Y,X -X 0X(X+X/X'X -X -XI[ ?X -XDWLWDX0X@WGX)X&Y.X 0X&Y.X=Y *[ @X <X/X NXDX DXHW@VHX,YMZ 8X 1Z :W (W &W       At JW3W$W ,W3W!| LW 1W3"
"W MW6W MW ,W ,` 5W ,W7W7W=W6W!W2W NW3W$W3W MW )g ?W ,W6W IWBW CWGVHVGW MY 8WCX :Y 6` 5V  H` IW@m  -S;V<T1W8X IW7X W@[ HW2W Ia ;W6W HVCW >XFX EW6W!W<W<"
"W3WCWCW!W=W JWCWCW\"W2W%W2W ?W >W2W KW8W @Y <X /X'X/X@X@X,X0X#YFXFY*X&Y2~a GV H~a HV I~b HV   DX 3W@S 6X 3V8V ;X   CX=V   CSFV)S  =WEW  :V  -SAVDW@S   "
" 'V      \"W6W :UGU IX       /WEW .V<TJU NV/U\"V<TJU8Z /W8W KW8W KW8W KW8W KW8W KX:X KX<X X *X -X -X -X -X -X -X -X ,X+Y-X@WGX)X&Y1X&Y1X&Y1X&Y1X&Y H_ LX"
"DW9Y.X/X'X/X'X/X'X/X GX <X:Y LW>] Jt It It It It It I~iBW ,|\"|\"|\"| NW ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W M~Y2WCVEW NW6W MW6W MW6W MW6W IWCX EW3W L"
"WCX     IV=V=V.V$V.VFYKZFV.VFY7V.V$V&V 0XCW     ;Y =WFT   >~T-~\\'w Ku%W4W W4W GXEW >WFW IV                #q   =V   6~X JSN^ /VEWCW?W=ZDW  .W !W   :~W"
"  5f   9V /X4X >X .Y  MX\"W:X &X Y5X >Y @X6X FcJX    &d    Id%X 8UAV8VAU>X8X X4X$X +X+X+X -X /X)X+X/X'X -X -XH[ @X -XCVLVCX0X@XHX(X'X-X /X'X-X<Y *Z @X "
"<X/X NXDX DXHV?VHX-YKY 8X 2Z 9W 'V &W       B]?W JW3W$W ,W3W!| LW 1W3W MW6W MW ,W ,a 6W ,W7W7W=W6W!W2W NW3W$W3W MW 'g AW ,W6W IWBW CWHVFVHW NZ 7WDW :Z"
" 6a 6V  Jb IU;i  ,S;V<S0W7W IW6W W?Z HW2W Kc ;W6W HWEX >XFX EW6W!W<W<W3WCWCW!W=W JWCWCW\"W2W%W2W ?W =V2V KX8X BY ;X /Y)Y/X@X@X,X0X#YFXGZ)X'X0~` GV H~` "
"GV H~` GV   DX 3W@S 6X 3V8V M|  &Z?V   CSFV)S:m AXFX  ;V  -SAVDW@S    'V      \"W6W :UGU      *m 5XFX /V;SIU V.T\"V;SIU9Z /X8X MX8X MX8X MX8X MX8X MX8X "
"MX;X NX +X -X -X -X -X -X -X -X ,X+X,X@XHX(X'X/X'X/X'X/X'X/X'X Ha LXFW8X-X/X'X/X'X/X'X/X GX <X;Z LW<\\ L]?W J]?W J]?W J]?W J]?W J]?W J]?{BW ,|\"|\"|\"| NW"
" ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W M~Y2WDVDW NW6W MW6W MW6W MW6W HWDW DW3W KWDW     HV=V>V-V%V-VGYIZHV-VGY7V-V%V%V /WDX     ;X <WFT   >~T-~\\'v Is"
"$W4W W4W GWDX ?XGW HV                %r   =V   6~X JSJ[ 0VEVAV?W<ZFW  -W !W   \"V   Lf   9V /X5X =X /Z  MX\"V9X &X NX5X >X ?X6X D`IX    $d    Ne#X 8UAV8"
"VBU=x X4X$X +X+X+X -X /X)X+X/X'X -X -XG[ AX -XCVLVCX0X?WHX(X'X-X /X'X-X;Y *Y @X <X/X MXFX CXHV?VHX-XIY 9X 3Z 8W 'V &W       CZ;W JW3W$W ,W3W!| LW 1W3W"
" MW6W MW ,W ,b 7W ,W7W7W=W6W!W2W NW3W$W3W MW %f BW ,W6W IXDX BWIVFVIW N\\ 8WEX :Y .[ 7V  K\\ BT8e  *S<X=S0W7V HW6X\"W=X GW2W Me ;W6W GVEX >WDW EW6W!W<W<W"
"3WCWCW!W=W JWCWCW\"W2W%W2W ?W =W4W KW6W CY :X .X)X.YAXAY,X0X\"ZHXHZ(X'X/Y  AV  BY FV GY%Y FV   DX 3W@S 6X 2V:V L|  %ZAV   BSEV*S:m @XFX  <V  -SAVCWAS   "
" 'V      \"W6W :UGU      *m 6XFX .V<TIU V/U\"V<TIU9Y .x Mx Mx Mx Mx Mx Mu NX +X -X -X -X -X -X -X -X ,X+X,X?WHX(X'X/X'X/X'X/X'X/X'X Ic MXGW7X-X/X'X/X'X/"
"X'X/X GX <X=[ KW:[ NZ;W KZ;W KZ;W KZ;W KZ;W KZ;W KZ;{BW ,|\"|\"|\"| NW ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W  &WEVCW NW6W MW6W MW6W MW6W HWEX DW3W KWEX "
"    GV>V>V,V&V,VIYGZIV,VIY6V,V&V&W /XEW     N~X'VGT   =~T-~\\&u Ir#W4W NV4W HXDX ?XHX HV                 KX   ,V   6~X JSHZ 2VDVAV?W;ZGW  -W !W   \"V   "
"Lf   :W .X6X =X 0Z  LY#~ /X NX5X >X @X5Y AYFX    !d >~X >d X 8UAV8VBU>z!X3X%X +X+X+X -X /X)X+X/X'X -X -XF[ BX -XCWNWCX0X?XIX(X'X-X /X'X-X:X )Y AX <X/X"
" MXFX BWHV?VHW-YIY 9X 3Y 7W 'W 'W       CX9W JW3W$W ,W3W!W 'W 1W3W MW6W MW ,W ,WNZ 8W ,W7W7W=W6W!W2W NW3W$W3W MW !c CW ,W6W HWDW AWIVFVIW N] 8WFW :Y *"
"Y 8V  KY ?R3`  (S<X=S0W7V HW5W\"W=X GW2W N[ 0W6W GWFW >XDX FW6W!W<W<W3WCWCW!W=W JWCWCW\"W2W%W2W ?W =W4W LX6X DY :X .X)X-XAXAX+X0X!ZIXIZ'X'X.Y  BV  CY EV"
" FY'Y EV   DX 3W@S 6X 2V:V L|  $[CV   BTFW,T:m ?XFX  =V  -TBVBVBT    'V      \"W6W :UGU      *m 7XFX .V<THU!V/U\"V<THU:Y .z z z z z Nx Nv NX +X -X -X -X"
" -X -X -X -X ,X+X,X?XIX(X'X/X'X/X'X/X'X/X'X Je NXGV6X-X/X'X/X'X/X'X/X GX <X@^ KW9[ X9W KX9W KX9W KX9W KX9W KX9W KX9W MW ,W ,W ,W ,W )W ,W ,W ,W /W2W N"
"W6W!W2W\"W2W\"W2W\"W2W\"W2W  &WFVBW NW6W MW6W MW6W MW6W GWFW CW3W JWFW     FV>V?W,V'W,VJYEZKW,VJY6W,V'W&W /XFX     N~X'WHT   =~T-~\\%s Gp\"W4W NV4V GXCW >WH"
"X HW                 LX   ,V   6~X JSGY 3VDWAW@W:ZIW  ,W !W   \"V   Lf   :W .X6X =X 1Z  JX#~ /X NX5X ?Y @X4X .X     Md A~X Ad LX 8UAV8VBU>z!X3X%X +X+X+"
"X -X /X)X+X/X'X -X -XE[ CX -XBVNVBX0X>WIX(X'X-X /X'X-X9X *Y AX <X/X MXFX BXJW?WJX.YGY :X 4Z 7W 'W 'W       DX8W JW3W$W ,W3W!W 'W 1W3W MW6W MW ,W ,WLY "
"9W ,W7W7W=W6W!W2W NW3W$W3W MW  K_ DW ,W6W HXFX AWIVFVIW ^ 8WFW ;Y (Y 9V  LY >Q.X  $T>Z?T0W8W HW5W\"W<W GW2W Y -W6W GWGX >WCX FW6W!W<W<W3WCWCW!W=W JWCWC"
"W\"W2W%W2W ?W =W4W LX6X EY 9X .Y+Y-YBXBY+X0X ZJXJZ&X'X-Y  CV  DY DV EY)Y DV   DX 3W@S 6X 2W<W L|  #\\FW   ASFW,S9m >XFX  >V  ,SBVBWCS    &V      \"W6W :U"
"GU      *m 8XFX .V<TGU\"V.U#V<TGU;Y -z z z z z z v NX +X -X -X -X -X -X -X -X ,X+X,X>WIX(X'X/X'X/X'X/X'X/X'X KZMZ XHW6X-X/X'X/X'X/X'X/X GX <u JW7Y!X8W "
"LX8W LX8W LX8W LX8W LX8W LX8W MW ,W ,W ,W ,W )W ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W  &WGWBW NW6W MW6W MW6W MW6W GWFW CW3W JWFW     FW?V?V+W(V+WKXCY"
"KV+WKX5V+W(V%W .WFX     N~X'WHT   =~T-~\\$q Eo\"W4W NV4V GWBW >XIW GW                 LX       ;~X JSFX 3VDV?V@W9ZJW  +V \"W   !V       V -X6X =X 2Z  IX#"
"~ /X NX5X ?X ?X4X .X     Jd D~X Dd IX 8UAV8VCV>z!X3X%Y ,X,Y+X -X /Y*X+X/X'X -X -XD[ DX -XBVNVBX0X>XJX(Y)X,X /Y)X,X9Y *X AX <X/X LXHX AXJV=VJX.XEY ;X 5"
"Z 6W &V 'W       DW7W JW3W$W ,W3W!W 'W 1W3W MW6W MW ,W ,WKY :W ,W7W7W=W6W!W2W NW3W$W3W MW  H\\ DW ,W6W GWFW @WJVDVJW!` 9WGX <Y &X 9V  LX =P   (T?\\@T0W8"
"X IW5W\"W<W GW2W X ,W6W FVGW >XBW FW6W!W<W<W3WCWCW!W=W JWCWCW\"W2W%W2W ?W =W4W LW4W FY 8X -X+X+YCXCY*X0X N\\MXM\\%Y)X+Y  DV  EY NQFVFQ Y+Y CV   DX 3W@S 6X"
" 1V<V K|  ![HW   @TFW.T9m =XFX  ?V  ,TCVAVDT    &V      \"W6W :UGU      *m 9XFX -V<SFU\"V/U\"V<SFU;X ,z z z z z z v NY ,X -X -X -X -X -X -X -X ,X,Y,X>XJX"
"(Y)X.Y)X.Y)X.Y)X.Y)X KZKZ!YJW6X,X/X'X/X'X/X'X/X GX <t IW6Y\"W7W LW7W LW7W LW7W LW7W LW7W LW7W MW ,W ,W ,W ,W )W ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W "
" &WHWAW NW6W MW6W MW6W MW6W GWGX CW3W JWGX     EV?V@W*V)W*VJVAWKW*VJV5W*V)W%W .XGW     M~X&WJT   <~S,kNn#o Cm!W4W NV4V HXBX ?XJX FW                 MY"
"       <~X JSEX 5VCV?V@W8ZLW  *W #W   !V       V -X6X =X 3Z  HX#~ /X NX5X @Y ?X4X /X     Ge G~X Ge GX 8UAV9WCU>|\"X3X$X ,X,X*X -X .X*X+X/X'X -X -XC[ EX"
" -XA\\AX0X=WJX'X)X,X .X)X,X8X *X AX <X/X LXHX AXJV=VJX/YEY ;X 6Z 5W &V 'W       DW7W JW3W$W ,W3W!W 'W 1W3W MW6W MW ,W ,WJY ;W ,W7W7W=W6W!W2W NW3W$W3W M"
"W  EZ EW ,W6W GWFW ?WKVDVKW!b 9WHW <Y $W 9V  LW     BTAVNUAT/W8X IW5W#W;V FW2W!X +W6W FWIX >XBX GW6W!W<W<W3WCWCW!W=W JWCWCW\"W2W%W2W ?W =W4W MX4X HY 7X"
" -Y-Y+ZDXDZ*X0X Mt#X)X*Y  EV  FY NSGVGS Y-Y MQFVFQ   X 3W@S 6X 1W>W 9X   =\\KW   >SEW<PCS  6XFX  @V  +SCVAWES    %V      \"W6W :UGU        &XFX -V<TFU#V"
"/U\"V<TFU<X ,|\"|\"|\"|\"|\"|\"w MX ,X -X -X -X -X -X -X -X ,X,X+X=WJX'X)X-X)X-X)X-X)X-X)X LZIZ!XKW5X,X/X'X/X'X/X'X/X GX <s HW5X\"W7W LW7W LW7W LW7W LW7W LW7W"
" LW7W MW ,W ,W ,W ,W )W ,W ,W ,W /W2W NW6W!W2W\"W2W\"W2W\"W2W\"W2W  &WIW@W NW6W MW6W MW6W MW6W FWHW BW3W IWHW     DW@VAW)W+W)WJT?UKW)WJT5W)W+W$W -WHX     "
"M~X&WJT   ;eMQMe+jNQNj!m Bl W4W NW6W HXBX >WJX FW                 LX       <~X JSEX 6WCV?V@W7ZMW  *W #W   !V      !W -X6X =X 4Z  GX#~ /X NX5X @X >X4X "
"/X     De J~X Je DX 8U@V:WDV>|\"X3X$X ,X-Y*X -X .X*X+X/X'X -X -XB[ FX -XA\\AX0X=XKX'X*Y,X .X*Y,X8Y +X AX <Y1Y KWHW ?WJV=VJW/YCY <X 7Z 4W &W (W       EW6"
"W JX5X$X -X5X!X (W 0W5X MW6W MW ,W ,WIY <W ,W7W7W=W6W!X4X NX5X$X5X MW  CX EW ,W6W GXHX ?WKVDVKW!XNY :WIX =Y #X :V  MX     BUCVMVBT/W9Y IW5W#W<W FW3X!W"
" *W6W EVIX ?X@W GW6W!W=Y=W3XDWDX!W=W JWCWCW\"X4X%X4W >W <W6W LX4X HY 7X ,X-X)ZEXEZ)X0X Lr\"X)X)Y  FV  GY NUHVHU Y/Y MSGVGS  !X 3XAS 6X 0W@W 8X   ;\\NW   "
"=TEX@RDT  5XFY  BV  +TDV@WGT    %V      \"W6W :UGU        (YFX ,V=TEU#V0U!V=TEU<X ,|\"|\"|\"|\"|\"|\"w MX ,X -X -X -X -X -X -X -X ,X-Y+X=XKX'X*Y-X*Y-X*Y-X*Y-"
"X*Y MZGZ\"XLW5Y,Y1Y'Y1Y'Y1Y'Y1Y GX <r GW4X$W6W MW6W MW6W MW6W MW6W MW6W MW6X NX -X -X -X -X *W ,W ,W ,W /W2W NW6W!X4X\"X4X\"X4X\"X4X\"X4X  &WIV@X NW6W MW6W"
" MW6W MW6W FWIX BX5X IWIX     CWAVAW(W,W(WJR=SJW(WJR4W(W,W$W -XIX     M~X&WJS   :dLQLd+iMQNj!l @j NW4W NW6W HW@W >WJW DW                 MX       .VCV"
" :SDW 6VBV?V@W6b  )W #W   !V      !V +X8X <X 5Z  FX#~ /X MW5X @X >X4X /X     Ad L~X Ld AX 8VAV:WDU=|\"X3X$Y -X-Y*X -X .Y+X+X/X'X -X -XA[ GX -XA\\AX0X<WK"
"X'Y+X+X .Y+Y,X7X +X AX ;X1X JXJX ?XLW=WLX/XAY =X 7Y 3W %V (W       EW7X JX5W\"W ,W5X W (W 0W5X MW6W MW ,W ,WHY =W ,W7W7W=W6W W4W MX5W\"W5X MW  BX FW ,W6"
"W FWHW >WKVDVKW\"XLX 9WJW =Z #X :V  MX     AUEVKVDU/X:Y IW5W#W<W EW4W!X *W6W EVJX >X@W GW6W!W=Y=W2WDWDW W=W JWCWCW\"X4W#W4W >W <W6W LW2W IY 6X ,Y/Y(ZFXF"
"Z(X0X Kp!Y+X'Y  GV  HY NWIVIW Y1Y MUHVHU  \"X 2WAS 6X 0YDY 8X   :c   <TE[FUDS  3XFY  CV  *SDV@WGS    $V      \"W6W :UGU        )YFX ,V=TDU$V0V\"V=TDU=X +"
"|\"|\"|\"|\"|\"|#x MY -X -X -X -X -X -X -X -X ,X-Y+X<WKX'Y+X,Y+X,Y+X,Y+X,Y+X MZEZ#YNW4X*X1X%X1X%X1X%X1X FX <p EW4X$W7X MW7X MW7X MW7X MW7X MW7X MW7Y MW ,W "
",W ,W ,W *W ,W ,W ,W .W4W MW6W W4W W4W W4W W4W W4W  $WKV?W MW6W MW6W MW6W MW6W EWJW AX5W GWJW     BXBVBW'X.W'XJP;QJW'XJP4W'X.W#V ,XIW     L~X%WLT   :d"
"LQLc*iMQMi k ?i NW4W NW6W IX@X ?XLX DW                 MY       0VBV :SDW 7VAV?V@X6a  )W #W   !V      !V +X8X <X 6Z  EX#~ 0Y MW5X AY >X4X 0X     =d ~X"
" d   LUAW<XEV>X2X#X3X#X -X.Y)X -X -X+X+X/X'X -X -X@[ HX -X@Z@X0X<XLX&X+X+X -X+X+X7Y ,X AX ;X1X JXJX ?XLV;VLX0YAY =X 8Z 3W %V (W       EW7X JX5W\"W ,W5X"
" W (W 0W5X MW6W MW ,W ,WGY >W ,W7W7W=W6W W4W MX5W\"W5X MW  BX FW ,W7X FWHW >WLVBVLW#YKX :WJW =Y !W :V  MW     @VHXJWHV-W:Y IW5W#W<W EW4W!W )W6W EWKX ?X"
"?X HW6W!X>Y>W1WDWDW W=W JWCWCW\"X4W#W4W >W <W6W MX2X KY 5X +Y1Y'[GXH\\(X0X Jn NX+X&Y  HV  IY NYJVJY Y3Y MWIVIW  #X 2WAS 6X 0[H[ 8X :V %`   :TEiET  2YGY "
" DV  *TEV?WIT    $V      \"W6W :UGU        *YGY ,V<SCU%V0V\"V<SCU=X ,X2X$X2X$X2X$X2X$X2X$X2X$X8X LX -X -X -X -X -X -X -X -X ,X.Y*X<XLX&X+X+X+X+X+X+X+X+X"
"+X NZCZ#`3X*X1X%X1X%X1X%X1X FX <m BW3W$W7X MW7X MW7X MW7X MW7X MW7X MW7Y MW ,W ,W ,W ,W *W ,W ,W ,W .W4W MW6W W4W W4W W4W W4W W4W 5Z IWLV>W MW7X MW7X "
"MW7X MW7X EWJW AX5W GWJW     AXCVCW%X0W%X0W%X0W%X0W\"V +WJX     ?X 2WLT   9bKQKb)gLQMh Mi =g MW4W MV6W IX@X ?XLX CW                 MX       0VBV :SDW "
"7VAV?V@X5_  (W #W   !V      \"W +X8X <X 7Z  DX 5X 'X LX7X @X =X4X 0X     ;e   Le   JUAW<XFV=X1W#X3X#Y .X.Y)X -X -Y,X+X/X'X -X -X?[ IX -X@Z@X0X;XMX&Y-Y+"
"X -Y-Y+X6X ,X AX ;X1X IXLX >XLV;VLX1Y?Y >X 9Z 2W %W )W       EW7X JX5W\"X -W5X X )W 0X7Y MW6W MW ,W ,WFY ?W ,W7W7W=W6W W4W MX5W\"W5X MW  AW FW ,W7X FXJX"
" =WMVBVMW#YJY ;WKX >Y  W :V  MW     ?dId,W;Z IW5W#W=W DW4W!W )W6W DVKW >X>W HW6W W>Y>W1WDWDW W=W JWCWDX\"X4W#W4W >W ;V7W LX2X LY 4X *X1X%]JXJ]'X0X Hj L"
"Y-Y%Y  IV  JY LYKVKY MY5Y MYJVJY  $X 2XBS 6X 2q 9X :V #\\   7TDgFT  /XFX  EV  )TFV>VJT    #V      \"W6W :UGU        +XFX *V=TCU%V1V!V=TCU=X ,X1W$X1W$X1W"
"$X1W$X1W$X2X%X7X LY .X -X -X -X -X -X -X -X ,X.Y*X;XMX&Y-Y+Y-Y+Y-Y+Y-Y+Y-Y ZAZ$_3Y*X1X%X1X%X1X%X1X FX <i >W3W$W7X MW7X MW7X MW7X MW7X MW7X MW7Z NX -X "
"-X -X -X +W ,W ,W ,W .W4W MW6W W4W W4W W4W W4W W4W 5Z IWMV=W MW7X MW7X MW7X MW7X EWKX AX5W GWKX     @XDVDX$X2X$X2X$X2X$X2X\"V +XKW     ?X 1WMT   7`JQKa"
"'fLQLf Kg <f LW4W MW8W HW>W >WLW BX                 NY       1VBV :SDW 8V@V?V?W4]  &V $W    V      \"V *Y:Y <X 8Z  DY 5X 'X KW7X @X =X5Y 1Y     8e  #e "
"  GU@W>YGW>X0X$X4Y\"Y /X/Y(X -X ,Y-X+X/X'X -X -X>[ JX -X@Z@X0X;XMX%Y/Y*X ,Y/Y*X6Y -X AX ;Y3Y IXLX =WLV;VLW0X=Y ?X :Z 1W $V )W       EW8Y JY7X\"X -X7Y X "
")W 0X7Y MW6W MW ,W ,WEY @W ,W7W7W=W6W X6X MY7X\"X7Y MW  AW FW ,X8X EWJW <WMVBVMW#XHX :WLW >Y  NW :V  MW     >bGc,W;[ JW6X#W=W DX6X!W )W6W DVLX >W=X IW7"
"X W>Y>W1XEWEX W=W IWDWDW!Y6X#X6X >W ;W8W MX0X MY 4X *Y3Y$^LXL^&X0X Ff IY/Y#Y  JV  KY JYLVLY KY7Y KYKVKY  #X 2XBS 6X 3t ;X :V ![   8TCfFT  .XFX  FV  )U"
"GV>WKT            MW7X :UGU        ,XFX *V=TBU&V2W!V=TBU=X -X0X&X0X&X0X&X0X&X0X&X0W%X7X KY /X -X -X -X -X -X -X -X ,X/Y)X;XMX%Y/Y)Y/Y)Y/Y)Y/Y)Y/Y Z?Z$"
"^4Y)Y3Y%Y3Y%Y3Y%Y3Y FX <X -W3W$W8Y MW8Y MW8Y MW8Y MW8Y MW8Y MW8[ NX -X -X -X -X +W ,W ,W ,W .X6X MW6W X6X X6X X6X X6X X6X 5Z I_=X MX8X MX8X MX8X MX8X "
"DWLW @Y7X FWLW     >XEVFY\"X5Y\"X5Y\"X5Y\"X5Y!V *WLX     @X /WNT   7`JQJ_&eKQKe Je :d KW4W MW8W HW>X ?XNX AX                 Y       1VCV 9SDW 9V?V?V?X4\\ "
" &W %W    V      \"V )X:X ;X 9Z  CX 4X (Y KW7X AX <Y6Y 1X     4e  )e   DVAX@ZHW=X0X$X4Y\"Y*P&X0Z(X -X ,Y-X+X/X'X -X -X=[ KX -X?X?X0X:XNX%Y/Y*X ,Y/Y*X5X "
".Y AX :X3X HXLX =XNW;WNX1Y=Y ?X ;Z 0W $V )W       EW8Y JY7W W ,W7Y NX *W /W8Z MW6W MW ,W ,WDY AW ,W7W7W=W6W NW6W LY7W W7Y MW  AW FW ,X9Y EWJW <WMVBVMW"
"$XFX ;WMX ?Y  MW :V  MW     =`Ea+X<[ JW6W\"W>W BW6W W )W6W DWMX ?X=X IX8X W?[?W0WEWEW NW=W IWDWDW!Y6W!W6W =W ;W8W MX0X NY 3X )Y5Y\"z%X0X C` FY/Y\"X  JV  "
"KX HYMVMY IX7X IYLVLY  \"X 1XCS 6X 4v <X :V  [   8TBbET  ,WEW  FV  (T$T            LX8X :UGU        ,WEW )V=m,V3W V=mCX -X0X&X0X&X0X&X0X&X0X&X0X&X7X KY"
"*P&X -X -X -X -X -X -X -X ,X0Z)X:XNX%Y/Y)Y/Y)Y/Y)Y/Y)Y/Y!Z=Z%]3Y(X3X#X3X#X3X#X3X EX <X -W3W$W8Y MW8Y MW8Y MW8Y MW8Y MW8Y MW8[ MW ,X -X -X -X ,W ,W ,W "
",W -W6W LW6W NW6W MW6W MW6W MW6W MW6W 4Z H^=W LX9Y MX9Y MX9Y MX9Y DWMX @Y7W EWMX     =Y8Y Y8Y Y8Y Y8Y Y8Y V *WLX     AX .WNT   6^IQI]$cKRJc Id 8c KW4W"
" MX:X IX>X ?XNX AY                 Y4P       VBV 9SDW 9V?V?V?Y4Z  %W %W    V      #W )X:X ;X :Z  CY 4X (Y KX9Y AX ;X6X 1Y     1e  /e   @U@XB[JX<X/W$X4"
"X Y,Q&X1Z'X -X +Y.X+X/X'X -X -X<[ LX -X?X?X0X:XNX$Y1Y)X +Y1Y)X5Y /X @X :X4Y GXNX <XNV9VNX2Y;Y @X ;Y /W $W *W       EW9Z JZ9X X -X9Z NX *W /X9Z MW6W MW"
" ,W ,WCY BW ,W7W7W=W6W NX8X LZ9X X9Z MW  AW FW +W9Y EXLX <WNV@VNW%YEX ;WNW ?Y  LW :V  MW     <^C_)W=\\ JX7W\"W>W BX8X W )W6W CVNX >W;W IX8X X@[@X0XFWEW "
"NW=W IWDWEX!Z8X!X8X =W :W:W LX0X Y 2X (Y7Y Nv#X0X ?X AY1Y V  IV  JV FYNVNY GV5V GYMVMY  !X 1XCS 6X 5x =X :V  MZ   8T?ZBT  *VDV  FV  'T&T            KX"
"8X :UGU        ,VDV )V<m-V3V NV<mCX -X/W&X/W&X/W&X/W&X/W&X0X'X6X JY,Q&X -X -X -X -X -X -X -X ,X1Z(X:XNX$Y1Y'Y1Y'Y1Y'Y1Y'Y1Y!Z;Z%[3Y'X4Y#X4Y#X4Y#X4Y EX"
" <X -W3W$W9Z MW9Z MW9Z MW9Z MW9Z MW9Z MW9] NX -X -X -X -X ,W ,W ,W ,W -X8X LW6W NX8X MX8X MX8X MX8X MX8X 4Z H]=X KW9Y LW9Y LW9Y LW9Y CWNW ?Z9X DWNW   "
"  ;Y;Z MY;Z MY;Z MY;Z MY;Z NV *XMW     AY -[   3ZHRH[\"aJRI` Fb 6a JW4W LW:W HX=W >WNX @Y                !Z6Q       VBV KP>SEW 9V>WAW>X3Z  &W %W    V  "
"    #V 'X<X :X ;Z  BY 4X )Y IW9X AY ;Y8Y 2Y     .d  1d   >U?ZH^MZ<X.X%X5Y NY.R&X2Z&X -X *Y/X+X/X'X -X -X;[ MX -X&X0X9a$Z3Y(X *Y3Y(X4X$P-Y @X :Y5Y GXNX"
" <XNV9VNX2X9Y AX <Z /W #V *W       EX:Z JZ9X NX .X9Z MX +W .X;[ MW6W MW ,W ,WBY CW ,W7W7W=W6W NX9Y LZ9X X9Z MW  AW FW +W:Z DWLW :^@^$XDY <WNW @Z  LW :"
"V  MW     ;\\@['X>\\ JX8X\"W?W AX9Y X *W6W CVNX ?X;X JX9Y NW@[@W/XFWFX NW=W IXEWEX!Z8X!X8W ;W ;W;X MX.X\"Y 1X 'Y9Y Lt\"X0X ?X @Y3Y MT  HV  IT Dj ET3T EYNVN"
"Y   X 0XDS 6X 6ZM`LY >X :V  LY   7T)T  (UCU     ET(T            JX9Y :UGU        ,UCU )V;m.V3V NV;mCY7P HX.X(X.X(X.X(X.X(X.X(X.X(X6X IY.R&X -X -X -X -"
"X -X -X -X ,X2Z'X9a$Z3Y&Z3Y&Z3Y&Z3Y&Z3Y!Z9Z&Z3Y&Y5Y#Y5Y#Y5Y#Y5Y EX <X -W3W$X:Z MX:Z MX:Z MX:Z MX:Z MX:Z MX:^ NX -X -X -X -X -W ,W ,W ,W -X8X LW6W NX9Y"
" MX9Y MX9Y MX9Y MX9Y 4Z H\\=Y KW:Z LW:Z LW:Z LW:Z CWNW ?Z9X DWNW     :[@[ K[@[ K[@[ K[@[ K[@[ MV )WNX     AX ,[   1WGRFW N_IRH^ Da 5_ IW4W LX<X HW<W >`"
" >Y                !Y8S   MX   +VBV KQ?SFX 9V=VAV=Y6]  &V &W    NV BX   1X 1V 'Y>Y :X <Z  BY 3X GP3Z IX;Y AX :Y9Z 2X GX -X  7a  1a .X 6V@iNa;X.X%X6Z N"
"Z1T&X4\\&X -X *Z0X+X/X'X -X -X:[ NX -X&X0X9a#Z5Z(X *Z5Z(X4Y%R/Y @X 9Y7Y EWNW :WNV9VNW2Y9Y AX =Z .W #V *W       EX;[ J[;X MY .X;[ MY2P JW .Y=\\ MW6W MW ,"
"W ,WAY DW ,W7W7W=W6W MX:X K[;X MX;[ MW /P4X FX ,X<[ DXNX :^@^%XBX <` @Y  KW :V  MW     8V;W%X?^ KY9X!V@X @X:X NX *W6W C_ >X:W JY;Z NXB]BX.XGWGX MW=W H"
"XFWFX [:X NX:X ;W :W<W LX.X\"Y 1X &Y;Y Ip X0X ?X @Z5Z LR  GV  HR Bh CR1R Cj   NX 0YES 6X 7ZJ\\IY ?X :V  KY   8U+U  'TBT     DU+T            IY;Z :UGU   "
"     ,TBT (V;m.V4V MV;mCY8Q HX.X(X.X(X.X(X.X(X.X(X.X)X5X IZ1T&X -X -X -X -X -X -X -X ,X4\\'X9a#Z5Z%Z5Z%Z5Z%Z5Z%Z5Z\"Z7Z&Z5Z%Y7Y!Y7Y!Y7Y!Y7Y DX <X -W4X$X"
";[ MX;[ MX;[ MX;[ MX;[ MX;[ MX;`3P=Y .Y2P LY2P LY2P LY2P LW ,W ,W ,W ,X:X KW6W MX:X KX:X KX:X KX:X KX:X 3Z GZ<X JX<[ LX<[ LX<[ LX<[ C` ?[;X C`     9_J"
"_ I_J_ I_J_ I_J_ I_J_ LV )`     AX +Z    S <[GRFZ A_ 4^ HW4W KX>X HX<X ?` =Z                \"Y:T   MX   +VCV JSASFX :V<VAV<Y8_  'W 'W    NV BX   1X 2W"
" &X>X 9X =Z 1P2Z 3X GQ5Z GX=Y @X 9Y:Y KP8Z GX -X  4^  1^ +X 5U?gM_9W,W%X7Z L[4U&X6]%X -X )[2X+X/X'X -X -X9[ X -X&X0X8`\"Z7Z'X )Z7Z'X3X%T2Y ?X 9Z9Z E` :"
"_9_3Y7Y BX >Z -W #W +W       DX=\\ J\\=Y LY7P HY=\\ LY5R JW -Y?] MW6W MW ,W ,W@Y EW ,W7W7W=W6W MY<Y K\\=Y MY=\\ MW /R6W DW ,Y=[ CWNW 9^@^&X@X <^ @Y  JW :V "
" MW       HXA` LZ;X V@W ?Y<Y MX +W6W B^ ?X9W JZ<Z NXB]BX.YHWHY MW=W HYGWGY \\<Y NY<X :W :X>X LX.X#Y 0X %Y=Z Gl MX0X ?X ?Z7Z JP  FV  GP @f AP/P Ah   MX "
"/YFSDP BX 8ZFVEY @X :V  JX   7V.U  %SAS     CU.U            HZ<Z :UGU        ,SAS (V:m/V5W MV:mBY;S HW,W(W,W(W,W(W,W(W,W(X.X)X5X H[4U&X -X -X -X -X -X"
" -X -X ,X6]&X8`\"Z7Z#Z7Z#Z7Z#Z7Z#Z7Z\"Z5Z&[8Z$Z9Z!Z9Z!Z9Z!Z9Z DX <X -W4W\"X=\\ LX=\\ LX=\\ LX=\\ LX=\\ LX=\\ LX=b6R<Y7P GY5R KY5R KY5R KY5R LW ,W ,W ,W ,Y<Y KW"
"6W MY<Y KY<Y KY<Y KY<Y KY<Y 3Z GY<Y JY=[ LY=[ LY=[ LY=[ B^ >\\=Y B^     7r Gr Gr Gr Gr KV (_     BX )Y    S 8RBSCR <] 2\\ GW4W KZBZ HX;W >_ <[          "
"      $[=U   MX   ,VBV JUCSHY :V;WCW<[<b  (W 'W    NV BX   1X 2W &Y@Y 9X >Z 0R5Z 2X GT9[ GY?Z AY 9[>[ KR;Z FX -X  1[  1[ (X 5V>dL^9X,X&X9[ J[7W&X9_$X "
"-X (\\6Z+X/X'X -X -X8[!X -X&X0X8`![;[&X ([;[&X3Y&W7[ ?X 8Z;Z D` :^7^3X5Y CX ?Z ,W #W +W       DY?] J]?Y KZ:R GY?] LZ8T JW -ZA^ MW6W MW ,W ,W?Y FW ,W7W7"
"W=W6W LY>Y J]?Y KY?] MW /T9X DX ,Y@] CWNW 9]>]'Y@Y =^ AY  IW :V  MW       HYCXNW L\\>Y VAX >Y>Y LY ,W6W B] >X9X K[>[ MXDVMVDX,YIWIY LW=W GYHWHY N]>Y LY"
">Y :X :X@X LX,X%Y /X $ZAZ Ch KX0X ?X >[;[   ?V   6d   >f   LX /[HSFR BX 9Z3Y AX :V  IX   7V1V  #R@R     BU0U            G[>[ :UGU        ,R@R 'V(U)V6W"
" LV(U<Z>U IX,X*X,X*X,X*X,X*X,X*X,X*W4X G[7W&X -X -X -X -X -X -X -X ,X9_%X8`![;[![;[![;[![;[![;[\"Z3Z(];[\"Z;Z NZ;Z NZ;Z NZ;Z CX <X -WJP;X\"Y?] LY?] LY?] "
"LY?] LY?] LY?] LY?XNZ9T<Z:R GZ8T KZ8T KZ8T KZ8T LW ,W ,W ,W +Y>Y JW6W LY>Y IY>Y IY>Y IY>Y IY>Y 2Z FY>Y HY@] KY@] KY@] KY@] B^ >]?Y A^     6o Do Do Do "
"Do IV (_     CX (Y    S (S ,[ 0[ GW4W J\\H\\ GW:W >^ :\\                %[@W   MX   ,VBV JXFSIZ :V:WEW:\\@e  (V 'V    MV BX   1X 2V $ZDZ 8X ?Z /U;] 2X GV="
"\\ EZC[ @X 7[@[ JT?[ EX -X  /Y  1Y &X 5V=bK\\7X,X&X<^ I]=Z&X=b#X -X ']:\\+X/X'X -X -X7[\"X -X&X0X7_ \\?\\%X '\\?\\%X2X&Z<\\ >X 7[?[ B^ 9^7^4Y5Y CX ?Y +W \"V +W "
"      DZB_ J_CZ I[>T G[C_ K[=W JW ,\\GXNW MW6W MW ,W ,W>Y GW ,W7W7W=W6W KZBZ I_CZ J[C_ MW /W>Z DZ .ZB^ C` 8\\>\\&X>Y =\\ AY  HW :V  MW       GZFYNY N]AZ N"
"WCX <ZBZ JZ:Q EW6W B] ?X7W K\\A^ NYFWMWFY,ZJWJY KW=X H[JWJ[ N_BZ JZBZ 8Y <ZDZ LX,X&Y .X #ZCZ >_ FX0X ?X =\\?\\   >V   5b   <d   KX .\\JSHT BX 8X2X @X :V  "
"IX   5V4U   Q?Q     AV4V            F\\A^ ;UGU        ,Q?Q 'V'U*V6W LV'U<[AW IX,X*X,X*X,X*X,X*X,X*X,X+X4X F]=Z&X -X -X -X -X -X -X -X ,X=b$X7_ \\?\\ N\\?\\"
" N\\?\\ N\\?\\ N\\?\\ X1X(`?\\ [?[ L[?[ L[?[ L[?[ BX <X -WJS@Z\"ZB_ LZB_ LZB_ LZB_ LZB_ LZB_ LZBYM\\>W;[>T F[=W J[=W J[=W J[=W LW ,W ,W ,W *ZBZ IW6W KZBZ GZBZ "
"GZBZ GZBZ GZBZ 1Z F[BZ GZB^ KZB^ KZB^ KZB^ A\\ =_CZ ?\\     3l Al Al Al Al HV (^     BX (X    NS (S ,Z .Y FW4W In GX:X ?^ 9_                (]FZ   MX   "
",VBV J[ISL\\ :V9XGX9^Fi  )W )W    MV BX   1X 3W #[H[ Et Mx MZC_ 1X GZD^ C[G\\ @Y 7^F] IXF] DX -X  ,V  1V #X 4V<^IY5X*X'y G_D^&{!y NX &`B`+X/X'X -X -X6[#"
"w LX&X0X7_ N^E^$X &^E^$X2Y'^C^ =X 7^E^ B^ 8]7]4Y3Y DX @~U&W \"W ,W       C\\HYNW JWNXG\\ H]EX F\\GXNW J]D[ JW +kMW MW6W MW ,W ,W=Y HW ,W7W7W=W6W K]H] IWNX"
"G\\ I\\GXNW MW /[E\\ Be 9[GXNW B^ 7\\>\\'X<X =\\ AX  GW :V  MW       G\\IYM^$`F\\ MWEX ;]H] J]BV EW6W A\\ ?X7X L_GaKP#ZJYMYJZ*[LWL[ KW=Y H\\LWL\\ MWNXG] J]H\\ 7a "
"C[H[ L~W'x MX 1iEi HX CX0X ?X <^E^   =V   4`   :b   JX -^MSLX Lz V0V ?X :V  HW   4V7V   MP>P     @W8W    3~W      :_GaKP @UGU        ,P>P 'V&U+V6V KV&"
"U;]GZ JX*X,X*X,X*X,X*X,X*X,Y,Y,X4y7_D^&y Ny Ny Ny NX -X -X -X ,{\"X7_ N^E^ L^E^ L^E^ L^E^ L^E^ MV/V(dE^ N^E^ L^E^ L^E^ L^E^ BX <X -WJWF[ \\HYNW K\\HYNW K"
"\\HYNW K\\HYNW K\\HYNW K\\HYNW K\\H[K^E[:]EX E]D[ I]D[ I]D[ I]D[ LW ,W ,W ,W )[F[ HW6W K]H] G]H] G]H] G]H] G]H] 1Z F]G] F[GXNW J[GXNW J[GXNW J[GXNW A\\ =WNX"
"G\\ ?\\     1h =h =h =h =h FV ']     AV &W    T )T +X -X EW4W Hl FX9W ?^ 8~R                Jp   MX   ,VCV It 9V8XIX7sLZ  *W )W    MV BX   1X 3W #n Et M"
"x Mu 0X Gs Ao @X 5t In CX -X  )S  1S  X 4V9XFU1X*X'x Ex&z y NX %|*X/X'X -X -X5[$w LX&X0X6^ Mu#X %u#X1X'y =X 6u A^ 8]7]4X1X DX @~U&W \"W ,W       ClMW J"
"WMk Fo EkMW Is JW *jMW MW6W MW ,W ,W<Y IW ,W7W7W=W6W Jp HWMk GkMW MW /q Ae 9kMW B^ 7\\=[(Y;X >\\ Av 6W :V  MW       FkL]$u LXGX 9p Hp EW6W A[ ?X6X LpN\\#"
"hKh)s JW<] Lu LWNm Hp 6` Bl K~W'x MX 1iEi HX CX0X ?X ;u   <V   3^   8`   IX ,o Lz NT.T >X :V  HW   3X=X        )X<X    2~W      :pN\\ @UGU           V&"
"U+V7i.V&U:o JX*X,X*X,X*X,X*X,X*X,X*X-X3y6x&y Ny Ny Ny NX -X -X -X ,z!X6^ Mu Ju Ju Ju Ju KT-T(} Lu Ju Ju Ju AX <X -WJk NlMW KlMW KlMW KlMW KlMW KlMW Kn"
"Is9o Ds Hs Hs Hs LW ,W ,W ,W )p HW6W Jp Ep Ep Ep Ep   Ls EkMW JkMW JkMW JkMW A\\ =WMk >\\     /c 8c 8c 8c 8c CV '\\     ?T %W    U *T *W ,V DW4W Gj EW8W "
">\\ 5~P                In   LX   -VBV Is 9V7g6qJZ  *V )V    LV BX   1X 3V !l Dt Mx Mt /X Gr ?m ?X 4r Hm BX -X  &P  1P  LX 3V 3X*X'w Cv%x My NX #x(X/X'X"
" -X -X4[%w LX&X0X5] Ls\"X $s\"X1Y(w ;X 5s ?\\ 7\\5\\5Y1Y EX @~U&W !V ,W       BjLW JWMj Dn DjMW Hr JW )hLW MW6W MW ,W ,W;Y JW ,W7W7W=W6W In GWMj EjMW MW /p"
" ?d 8iLW B^ 6Z<[)Y:Y >Z @v 6W :V  MW       EiK]$t JYLZ 7n Fo EW6W A[ ?X5W LWNfM\\\"gKg'q IW<] Ks KWMk Fn 5` Aj J~W'x MX 1iEi HX CX0X ?X :s   ;V   2\\   6"
"^   HX +n Lz MR,R =X :V  HW   1ZEZ        %ZDZ    0~W      :WNfM\\ @UGU          !V%U,V6i/V%U9n JX*X,X*X,X*X,X*X,X*X,X*X-X3y5v%y Ny Ny Ny NX -X -X -X ,"
"x NX5] Ls Hs Hs Hs Hs IR+R(WMs Js Hs Hs Hs @X <X -WJk MjLW JjLW JjLW JjLW JjLW JjLW JmHr8n Cr Gr Gr Gr LW ,W ,W ,W (n GW6W In Cn Cn Cn Cn   Ls CiLW Ii"
"LW IiLW IiLW @Z <WMj <Z     +] 2] 2] 2] 2] @V &[     >R $V    NU *U *U *U DW4W Fh DW8X ?\\ 4~                Hl   KX   -VBV Hp 8V5e4nGZ  +W +W    LV BX"
"   1X 3V  j Ct Mx Mr -X Gq =j >Y 3p Gl AX -X       2X 3W 5X(X(u ?s$v Ky NX \"v'X/X'X -X -X3[&w LX&X0X5] Kq!X #p X0X(v :X 4p =\\ 7\\5\\6Y/Y FX @~U&W !V ,W "
"      AhKW JWLh Bm ChLW Gq JW (eJW MW6W MW ,W ,W:Y KW ,W7W7W=W6W Hl FWLh ChLW MW /o >d 7gKW A\\ 5Z<Z(X8X >Z @v 6W :V  MW       DgI\\$s He 5l Dn EW6W @Y "
">W4X MWMeM\\!eIe%o HW<] Jq JWLi Dk 2_ @h J~Y(x MX 1iEi HX CX0X ?X 9q   :V   1Z   4\\   GX *m Lz LP*P <X :V  HW   0m        \"l    .~W      :WMeM\\ @UGU   "
"       !V%U,V6i/V%U8l JX(X.X(X.X(X.X(X.X(X.Y)X/X2y3s$y Ny Ny Ny NX -X -X -X ,v LX5] Kq Fq Fq Fq Fq GP)P'VKp Gp Ep Ep Ep >X <X -WJj KhKW IhKW IhKW IhKW"
" IhKW IhKW IjEq7m Bq Fq Fq Fq LW ,W ,W ,W &j EW6W Hl Al Al Al Al   Ls AgKW HgKW HgKW HgKW @Z <WLh ;Z               MV &[     =P \"U    V +V )S (S CW4W "
"De DX8X ?\\ 2|                Fh   IX   -VBV Ek 6V4c1kEZ  +V +V    KV BW   0X 4W  Mf At Mx Mq ,X Go :h =X 0l Ej ?X -W       1X 2W 6X(X(s ;o\"s Hy NX  r%"
"X/X'X -X -X2['w LX&X0X4\\ Im NX !m NX0Y(t 9X 2m ;Z 5[5[5X-X FX @~U&W !W -W       @fJW JWJe ?j AeJW En IW 'cIW MW6W MW ,W ,W9Y LW ,W7W7W=W6W Fh DWJe AeJ"
"W MW .m ;b 6eJW A\\ 5Z<Z)X6X >X ?v 6W :V  MW       CeG[$r Fc 2h Am EW6W @Y ?X3W MWMdL\\ cGc#m GW;\\ Hm HWKg Ah /] ?f I~Y(x MX 1iEi HX CX0X ?X 7m   8V   0"
"X   2Z   FX (j Kz   AX :V  HW   -g         Lh    ,~W      :WMdL\\ @UGU          \"V$U-V5i0V$U7i HX(X.X(X.X(X.X(X.X(X.X(X/X2y1o\"y Ny Ny Ny NX -X -X -X ,t"
" JX4\\ Im Bm Bm Bm Bm  %VHm Dm Bm Bm Bm =X <X -WJh HfJW HfJW HfJW HfJW HfJW HfJW HhBn4j ?n Cn Cn Cn KW ,W ,W ,W %h DW6W Fh =h =h =h =h   KVMi >eJW GeJW"
" GeJW GeJW ?X ;WJe 9X               MW &Z       =U    W ,W *R &Q BW4W B` AW6W >[ /y                Dd   GX   -VCV Af 5V2a.gBZ  ,W -W    KV CX   0X 4V "
" Kd @t Mx Km *X Ek 6d ;X .h Bh >X .X       1X 1W 7X(X(q 7j Np Ey NX  Mm\"X/X'X -X -X1[(w LX&X0X4\\ Gi LX  Ni LX/X$n 7X 0i 9Z 5[5[6Y-Y GX @~U&W  V -W    "
"   >cIW JWIb <g =bIW Ci FW %_GW MW6W MW ,W ,W8Y MW ,W7W7W=W6W Ef CWIb =bIW MW +h 8a 5cIW @Z 4Y:Y*Y5X ?X ?v 6W :V  MW       AbDY$WMf Ca 0f >k EW6W @Y ?"
"W2W MWK`I[ NaEa i EW;\\ Fi FWIc >e ,\\ =b G~Y(x MX 1iEi HX CX0X ?X 5i   6V   /V   0X   EX &f Iz   AX :V /P;W   *c         Gb    )~W      :WK`I[ @UGU    "
"      #V#U.V4i1V#U6f FX(X.X(X.X(X.X(X.X(X.X(X/X2y/j Ny Ny Ny Ny NX -X -X -X ,p FX4\\ Gi >i >i >i >i  $VEi @i >i >i >i ;X <X -WIf EcIW FcIW FcIW FcIW Fc"
"IW FcIW Fd>i0g ;i >i >i >i HW ,W ,W ,W #d BW6W Ef ;f ;f ;f ;f   JUJe ;cIW FcIW FcIW FcIW ?X ;WIb 7X               MW %Y       =T    X -X )P %P AW4W ?Z"
" >W6X ?Z ,w                B`   EX   .VBV <] 1V0]*b?[  -W -W    KV CW   /X 4V  I` >t Mx Hg 'X Bf 2` :X +d =b ;X .W       0X 1X 9X&X)m 0d Kj ?y NX  Jg "
"NX/X'X -X -X0[)w LX&X0X3[ Dc IX  Kf LX/Y!g 4X .e 7Z 5Z3Z7Y+Y HX @~U&W  V -W       =`GW JWG^ 7b 9^GW Ad CW \"YDW MW6W MW ,W ,W7Y NW ,W7W7W=W6W B` @WG^ 9"
"^GW MW (c 2] 3_GW @Z 3X:X*Y4Y @X ?v 6W :V  MW       ?_AW$WKb @^ +` 9g CW6W ?W ?X2X NWJ^GY K]B^ Ke CW:[ Dd CWG_ 9` 'Y ;^ F~[)x MX 1iEi HX CX0X ?X 2c   "
"3V   .T   .V   DX $b Gz   AX :V /R>X   &[         ?Z    %~W      :WJ^GY ?UGU          #V +V +V 1b EX&X0X&X0X&X0X&X0X&X0Y'X1X1y,d Ky Ny Ny Ny NX -X -X "
"-X ,j @X3[ Dc 8c 8c 8c 8c  !VBc ;e :e :e :e 9X <X -WFa B`GW E`GW E`GW E`GW E`GW E`GW D`:d*b 7d 9d 9d 9d EW ,W ,W ,W !` @W6W B` 5` 5` 5` 5`   HVHa 7_GW"
" D_GW D_GW D_GW ?X ;WG^ 5X               MW         7S                   @r                >Y         BS .V,W#Z   ;V -V     7W     ;W  EX     ;\\   6] "
"+Z   5\\ 5Z   <W         7X     %\\       <]    \"X         ([   4c   E]   /[          (W  W .W       :Y #X 0Z 2X *\\   $W    &W         .Z =WDX 3XDW   I["
"   0Y       8W   -W :V  MW       <Z ;WH[ 9Y &Z 1]  LW ?W   >WGXBU FX=X E` \"W >] @WDY 3Z   2X               C[           >T     :[       KV /TAY       "
"                   EWGXBU =UGU   BT       6V +V +V ,Y               ?\\                    +[ 0[ 0[ 0[ 0[   KT=[ 2[ 0[ 0[ 0[     7Z ;Y .Y .Y .Y .Y .Y -"
"Y2\\\"Z /\\ 1\\ 1\\ 1\\         CZ   3Z /Z /Z /Z /Z   FVCZ 1Y .Y .Y .Y ,W :WDX 2W               LW         7R                                             #S"
"       >W /W     8W     :V                      \"W         5X                  )X             &Z                  CW  NV .W                   :W    %W"
"           @W  :W              -X   -W :V  MW         LW        FW ?W   >W    NW   0W =W                                      3S       GV /XGZ        "
"                  DW  HUGU   AT                            %T                               'R                             JT                         "
"      #T         (X :W  NX               LW                                                       7S       =V /V     7W     :V                      \"W"
"         4X'Q                 &Y             %Z                  DW  NV .W                   :W    %W           @W  :W              -W   ,W :V  MW    "
"     LW        FW ?W   >W    NW   0W =W                                      3S       GV /j                          CW  HUGU   @T                    "
"        %T                               'P                             HT                               \"Q         'W 9W  NW               KW        "
"                                               7S       =W 1W     7V     :W                      \"V         2X)R                 &X             #Z    "
"              EW  NW /W                   :W    %W           @W  :W              -W   ,X ;V  NX         LW        FW ?W   >W    NW   0W =W            "
"                          3S       GV /j                          CW  HUGU   @U                            &U                                         "
"                    U                               \"P         'W 9W  NW               KV                                                       6S    "
"   <V 1V     6V     :V                      !V         1Y-U                 'X             \"Z                  FW  MV /W                   ;X    %W   "
"        @W  :W              .X   +W ;V  NW         KW        FW ?W   >W    NW   0W =W                                      3S       GV /h             "
"             AW  HUGU   ?T                            %T                                                             NT                               "
"          )X 9W  X               KV                                                       6S       <W 3V     6V     9V                      \"V        "
" /Z1X                 (X             !Z                  Ga (V 9a                   ;W    $W           @W  :W              .W   *W ;V  NW         KW  "
"      FW ?W   >W    NW   0W =W                                      3S       GV .f                          @W  HUGU   ?U                            &"
"U                                                             U                                         *W 8W  W               JV                     "
"                                  6S       ;V 3V     6V     :W                      \"V         .[5[                 *Y              Z                 "
" Ha (W :a                   <X    $W           @W  :W              /X   *X <V  X         KW        FW ?W   >W    NW   0W =W                           "
"           3S       GV +a                          >W  HUGU   >T                            %T                                                        "
"     NT                                         +X 8W !X              (VIV                                                       6S       :V 5V     5U"
"     9W                      \"U         +\\;]                 )X              MZ                  Ia (W :a                   =Y    %W           ?W  :W "
"             /W   )[ ?V #[         KW        FW ?W   >W    NW   0W =W                                      3S       GV 'Z                          ;W "
" HUGU   >U                            &U                                                             U                                         ,W 7W !"
"W              'VIV                                                       6S       :V 6W     6V                            4V         *_C`            "
"     )Y              LZ                  Ja   :a                  (P7Y    $W           ?W  :W              0X   (b GV +b         JW        FW ?W   >W "
"   NW   0W =W                                      3S       GV                            7W  HUGU   >U                            &U                 "
"                                            U                                         -X 7W \"X              'VJW                                      "
"                 6S       9V 7V     5U                            3U         'x                 (Z              KZ                  Ka   :a           "
"       (R:Z    $W           ?W  :W              0X   (b GV +b         JW        FW ?W   >W    NW   0W =W                                      3S      "
" GV                            7W     #U                            &U                                                             U                  "
"                       -X 7W \"X              &UJW                                                       6S       9W 9W                                "
"            Bu                 ([              IZ                  La   :a                  (T>[    $X           ?W  :W              1X   &a GV +a    "
"     IW        FW ?W   >W    NW   0W =W                                      3S       GV                            7W     $V                         "
"   'V                                                            !V                                         .X 6W #X              %VLW                "
"                                       5S                                                     2p                 -a                                   "
"                    8XE]    %Y           >W  :W              3Z   $_ GV +_         GW        FW ?W   >W    NW   0W =W                                 "
"     3S       GV                            7W     /QGW                            2QGW                                                            ,QG"
"W                                         0Z 6W %Z              %a                                                       5S                           "
"                          0l                 +a                                                       8p    +_           >W  :W              ;a   !] G"
"V +]         EW        FW ?W   >W    NW   0W =W                                      3S       GV                            7W     /`                 "
"           1`                                                            +`                                         7a 5W -a              #`          "
"                                                                                                   >e                 '`                              "
"                         7o    *^           =W  :W              ;`    KY GV +Y         AW        FW ?W   >W    NW   0W =W                             "
"         3S       GV                            7W     /`                            1`                                                            +` "
"                                        7` 4W -`              \"_                                                                                      "
"                       8\\                 #_                                       \"}              3n    )^           =W  :W              ;`     9V   "
"        BW        FW ?W   >W    NW   0W =W                                             'V                            7W     /_                        "
"    0_                                                            *_                                         6` 4W -`              !]                 "
"                                                                                                              -]                                      "
"  }              3l    ']           <W  :W              ;_     8V           BW        FW ?W   >W    NW   0W =W                                        "
"     'V                            7W     /^                            /^                                                            )^              "
"                           5_ 3W -_               N[                                                                                                  "
"                             ,[                                        M}              2j    &\\           ;W  :W              ;^     7V           BW  "
"      FW ?W   >W    NW   0W =W                                                                          7W     -Y                            *Y       "
"                                                     $Y                                         2^ 2W -^               LX                             "
"                                                                                                  *X                                        J}        "
"      /d    #Z           9W  :W              ;\\     5V           BW        FW ?W   >W    NW   0W =W                                                   "
"                       7W                                                                                                                             "
"            /\\ 0W                 HT                                                                                                                  "
"                                                      I}              *[     NW           6W  :W              ;Z     3V           BW        FW ?W   >W"
"    NW   0W =W                                                                          7W                                                            "
"                                                                             /Z .W                                                                    "
"                                                                                                                     =}                               "
"                                                                                                                                                      "
"                                                                                                                              D" };


    const unsigned char logo40x38[4576] = {
      177,200,200,200,3,123,123,0,36,200,200,200,1,123,123,0,2,255,255,0,1,189,189,189,1,0,0,0,34,200,200,200,
      1,123,123,0,4,255,255,0,1,189,189,189,1,0,0,0,1,123,123,123,32,200,200,200,1,123,123,0,5,255,255,0,1,0,0,
      0,2,123,123,123,30,200,200,200,1,123,123,0,6,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,29,200,200,200,
      1,123,123,0,7,255,255,0,1,0,0,0,2,123,123,123,28,200,200,200,1,123,123,0,8,255,255,0,1,189,189,189,1,0,0,0,
      2,123,123,123,27,200,200,200,1,123,123,0,9,255,255,0,1,0,0,0,2,123,123,123,26,200,200,200,1,123,123,0,10,255,
      255,0,1,189,189,189,1,0,0,0,2,123,123,123,25,200,200,200,1,123,123,0,3,255,255,0,1,189,189,189,3,0,0,0,1,189,
      189,189,3,255,255,0,1,0,0,0,2,123,123,123,24,200,200,200,1,123,123,0,4,255,255,0,5,0,0,0,3,255,255,0,1,189,
      189,189,1,0,0,0,2,123,123,123,23,200,200,200,1,123,123,0,4,255,255,0,5,0,0,0,4,255,255,0,1,0,0,0,2,123,123,123,
      22,200,200,200,1,123,123,0,5,255,255,0,5,0,0,0,4,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,21,200,200,200,
      1,123,123,0,5,255,255,0,5,0,0,0,5,255,255,0,1,0,0,0,2,123,123,123,20,200,200,200,1,123,123,0,6,255,255,0,5,0,0,
      0,5,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,19,200,200,200,1,123,123,0,6,255,255,0,1,123,123,0,3,0,0,0,1,
      123,123,0,6,255,255,0,1,0,0,0,2,123,123,123,18,200,200,200,1,123,123,0,7,255,255,0,1,189,189,189,3,0,0,0,1,189,
      189,189,6,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,17,200,200,200,1,123,123,0,8,255,255,0,3,0,0,0,8,255,255,
      0,1,0,0,0,2,123,123,123,16,200,200,200,1,123,123,0,9,255,255,0,1,123,123,0,1,0,0,0,1,123,123,0,8,255,255,0,1,189,
      189,189,1,0,0,0,2,123,123,123,15,200,200,200,1,123,123,0,9,255,255,0,1,189,189,189,1,0,0,0,1,189,189,189,9,255,255,
      0,1,0,0,0,2,123,123,123,14,200,200,200,1,123,123,0,11,255,255,0,1,0,0,0,10,255,255,0,1,189,189,189,1,0,0,0,2,123,
      123,123,13,200,200,200,1,123,123,0,23,255,255,0,1,0,0,0,2,123,123,123,12,200,200,200,1,123,123,0,11,255,255,0,1,189,
      189,189,2,0,0,0,1,189,189,189,9,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,11,200,200,200,1,123,123,0,11,255,255,
      0,4,0,0,0,10,255,255,0,1,0,0,0,2,123,123,123,10,200,200,200,1,123,123,0,12,255,255,0,4,0,0,0,10,255,255,0,1,189,189,
      189,1,0,0,0,2,123,123,123,9,200,200,200,1,123,123,0,12,255,255,0,1,189,189,189,2,0,0,0,1,189,189,189,11,255,255,0,1,
      0,0,0,2,123,123,123,9,200,200,200,1,123,123,0,27,255,255,0,1,0,0,0,3,123,123,123,8,200,200,200,1,123,123,0,26,255,
      255,0,1,189,189,189,1,0,0,0,3,123,123,123,9,200,200,200,1,123,123,0,24,255,255,0,1,189,189,189,1,0,0,0,4,123,123,
      123,10,200,200,200,1,123,123,0,24,0,0,0,5,123,123,123,12,200,200,200,27,123,123,123,14,200,200,200,25,123,123,123,86,
      200,200,200,91,49,124,118,124,71,32,124,95,49,56,114,52,82,121,0};






    inline std::FILE* output(std::FILE *file) {
      cimg::mutex(1);
      static std::FILE *res = stderr;
      if (file) res = file;
      cimg::mutex(1,0);
      return res;
    }


    inline unsigned int nb_cpus() {
      unsigned int res = 1;





      res = (unsigned int)sysconf(_SC_NPROCESSORS_ONLN);

      return res?res:1U;
    }


    inline int mutex(const unsigned int n, const int lock_mode) {
      switch (lock_mode) {
      case 0 : cimg::Mutex_attr().unlock(n); return 0;
      case 1 : cimg::Mutex_attr().lock(n); return 0;
      default : return cimg::Mutex_attr().trylock(n);
      }
    }
# 3884 "../src/CImg.h"
    inline void warn(const char *const format, ...) {
      if (cimg::exception_mode()>=1) {
        char message[16384] = { 0 };
        std::va_list ap;
        __builtin_va_start(ap,format);
        vsnprintf(message,sizeof(message),format,ap);
        __builtin_va_end(ap);



        std::fprintf(cimg::output(),"\n%s[CImg] *** Warning ***%s%s",cimg::t_red,cimg::t_normal,message);

      }
    }
# 3908 "../src/CImg.h"
    inline int system(const char *const command, const char *const module_name=0) {
      cimg::unused(module_name);




      const unsigned int l = std::strlen(command);
      if (l) {
        char *const ncommand = new char[l+16];
        std::strncpy(ncommand,command,l);
        std::strcpy(ncommand+l," 2> /dev/null");
        const int out_val = std::system(ncommand);
        delete[] ncommand;
        return out_val;
      } else return -1;
# 3941 "../src/CImg.h"
    }


    template<typename T>
    inline T& temporary(const T&) {
      static T temp;
      return temp;
    }


    template<typename T>
    inline void swap(T& a, T& b) { T t = a; a = b; b = t; }


    template<typename T1, typename T2>
    inline void swap(T1& a1, T1& b1, T2& a2, T2& b2) {
      cimg::swap(a1,b1); cimg::swap(a2,b2);
    }


    template<typename T1, typename T2, typename T3>
    inline void swap(T1& a1, T1& b1, T2& a2, T2& b2, T3& a3, T3& b3) {
      cimg::swap(a1,b1,a2,b2); cimg::swap(a3,b3);
    }


    template<typename T1, typename T2, typename T3, typename T4>
    inline void swap(T1& a1, T1& b1, T2& a2, T2& b2, T3& a3, T3& b3, T4& a4, T4& b4) {
      cimg::swap(a1,b1,a2,b2,a3,b3); cimg::swap(a4,b4);
    }


    template<typename T1, typename T2, typename T3, typename T4, typename T5>
    inline void swap(T1& a1, T1& b1, T2& a2, T2& b2, T3& a3, T3& b3, T4& a4, T4& b4, T5& a5, T5& b5) {
      cimg::swap(a1,b1,a2,b2,a3,b3,a4,b4); cimg::swap(a5,b5);
    }


    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
    inline void swap(T1& a1, T1& b1, T2& a2, T2& b2, T3& a3, T3& b3, T4& a4, T4& b4, T5& a5, T5& b5, T6& a6, T6& b6) {
      cimg::swap(a1,b1,a2,b2,a3,b3,a4,b4,a5,b5); cimg::swap(a6,b6);
    }


    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
    inline void swap(T1& a1, T1& b1, T2& a2, T2& b2, T3& a3, T3& b3, T4& a4, T4& b4, T5& a5, T5& b5, T6& a6, T6& b6,
                     T7& a7, T7& b7) {
      cimg::swap(a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6); cimg::swap(a7,b7);
    }


    template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
    inline void swap(T1& a1, T1& b1, T2& a2, T2& b2, T3& a3, T3& b3, T4& a4, T4& b4, T5& a5, T5& b5, T6& a6, T6& b6,
                     T7& a7, T7& b7, T8& a8, T8& b8) {
      cimg::swap(a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6,a7,b7); cimg::swap(a8,b8);
    }





    inline bool endianness() {
      const int x = 1;
      return ((unsigned char*)&x)[0]?false:true;
    }






    template<typename T>
    inline void invert_endianness(T* const buffer, const unsigned long size) {
      if (size) switch (sizeof(T)) {
      case 1 : break;
      case 2 : { for (unsigned short *ptr = (unsigned short*)buffer+size; ptr>(unsigned short*)buffer; ) {
        const unsigned short val = *(--ptr);
        *ptr = (unsigned short)((val>>8)|((val<<8)));
      }
      } break;
      case 4 : { for (unsigned int *ptr = (unsigned int*)buffer+size; ptr>(unsigned int*)buffer; ) {
        const unsigned int val = *(--ptr);
        *ptr = (val>>24)|((val>>8)&0xff00)|((val<<8)&0xff0000)|(val<<24);
      }
      } break;
      default : { for (T* ptr = buffer+size; ptr>buffer; ) {
        unsigned char *pb = (unsigned char*)(--ptr), *pe = pb + sizeof(T);
        for (int i = 0; i<(int)sizeof(T)/2; ++i) swap(*(pb++),*(--pe));
      }
      }
      }
    }






    template<typename T>
    inline T& invert_endianness(T& a) {
      invert_endianness(&a,1);
      return a;
    }


    inline unsigned int float2uint(const float f) {
      int tmp = 0;
      std::memcpy(&tmp,&f,sizeof(float));
      if (tmp>=0) return (unsigned int)f;
      unsigned int u;

      std::memcpy(&u,&f,sizeof(float));
      return ((u)<<1)>>1;
    }

    inline float uint2float(const unsigned int u) {
      if (u<(1U<<19)) return (float)u;
      float f;
      const unsigned int v = u|(1U<<(8*sizeof(unsigned int)-1));

      std::memcpy(&f,&v,sizeof(float));
      return f;
    }





    inline unsigned long time() {

      struct timeval st_time;
      gettimeofday(&st_time,0);
      return (unsigned long)(st_time.tv_usec/1000 + st_time.tv_sec*1000);







    }


    inline unsigned long tictoc(const bool is_tic);





    inline unsigned long tic() {
      return cimg::tictoc(true);
    }





    inline unsigned long toc() {
      return cimg::tictoc(false);
    }







    inline void sleep(const unsigned int milliseconds) {

      struct timespec tv;
      tv.tv_sec = milliseconds/1000;
      tv.tv_nsec = (milliseconds%1000)*1000000;
      nanosleep(&tv,0);



    }

    inline unsigned int _wait(const unsigned int milliseconds, unsigned long& timer) {
      if (!timer) timer = cimg::time();
      const unsigned long current_time = cimg::time();
      if (current_time>=timer+milliseconds) { timer = current_time; return 0; }
      const unsigned long time_diff = timer + milliseconds - current_time;
      timer = current_time + time_diff;
      cimg::sleep(time_diff);
      return (unsigned int)time_diff;
    }
# 4136 "../src/CImg.h"
    inline unsigned int wait(const unsigned int milliseconds) {
      cimg::mutex(3);
      static unsigned long timer = 0;
      if (!timer) timer = cimg::time();
      cimg::mutex(3,0);
      return _wait(milliseconds,timer);
    }
# 4184 "../src/CImg.h"
    inline void srand() {
      const unsigned int t = (unsigned int)cimg::time();

      std::srand(t+(unsigned int)getpid());





    }

    inline void srand(const unsigned int seed) {
      std::srand(seed);
    }




    inline double rand() {
      return (double)std::rand()/2147483647;
    }





    inline double crand() {
      return 1-2*cimg::rand();
    }




    inline double grand() {
      double x1, w;
      do {
        const double x2 = 2*cimg::rand() - 1.0;
        x1 = 2*cimg::rand()-1.0;
        w = x1*x1 + x2*x2;
      } while (w<=0 || w>=1.0);
      return x1*std::sqrt((-2*std::log(w))/w);
    }




    inline unsigned int prand(const double z) {
      if (z<=1.0e-10) return 0;
      if (z>100) return (unsigned int)((std::sqrt(z) * cimg::grand()) + z);
      unsigned int k = 0;
      const double y = std::exp(-z);
      for (double s = 1.0; s>=y; ++k) s*=cimg::rand();
      return k-1;
    }


    template<typename T>
    inline T rol(const T a, const unsigned int n=1) {
      return n?(T)((a<<n)|(a>>((sizeof(T)<<3)-n))):a;
    }

    inline float rol(const float a, const unsigned int n=1) {
      return (float)rol((int)a,n);
    }

    inline double rol(const double a, const unsigned int n=1) {
      return (double)rol((long)a,n);
    }


    template<typename T>
    inline T ror(const T a, const unsigned int n=1) {
      return n?(T)((a>>n)|(a<<((sizeof(T)<<3)-n))):a;
    }

    inline float ror(const float a, const unsigned int n=1) {
      return (float)ror((int)a,n);
    }

    inline double ror(const double a, const unsigned int n=1) {
      return (double)ror((long)a,n);
    }


    template<typename T>
    inline T abs(const T a) {
      return a>=0?a:-a;
    }
    inline bool abs(const bool a) {
      return a;
    }
    inline unsigned char abs(const unsigned char a) {
      return a;
    }
    inline unsigned short abs(const unsigned short a) {
      return a;
    }
    inline unsigned int abs(const unsigned int a) {
      return a;
    }
    inline unsigned long abs(const unsigned long a) {
      return a;
    }
    inline double abs(const double a) {
      return std::fabs(a);
    }
    inline float abs(const float a) {
      return (float)std::fabs((double)a);
    }
    inline int abs(const int a) {
      return std::abs(a);
    }


    template<typename T>
    inline T sqr(const T val) {
      return val*val;
    }


    inline int xln(const int x) {
      return x>0?(int)(1+std::log10((double)x)):1;
    }


    template<typename t1, typename t2>
    inline typename cimg::superset<t1,t2>::type min(const t1& a, const t2& b) {
      typedef typename cimg::superset<t1,t2>::type t1t2;
      return (t1t2)(a<=b?a:b);
    }


    template<typename t1, typename t2, typename t3>
    inline typename cimg::superset2<t1,t2,t3>::type min(const t1& a, const t2& b, const t3& c) {
      typedef typename cimg::superset2<t1,t2,t3>::type t1t2t3;
      return (t1t2t3)cimg::min(cimg::min(a,b),c);
    }


    template<typename t1, typename t2, typename t3, typename t4>
    inline typename cimg::superset3<t1,t2,t3,t4>::type min(const t1& a, const t2& b, const t3& c, const t4& d) {
      typedef typename cimg::superset3<t1,t2,t3,t4>::type t1t2t3t4;
      return (t1t2t3t4)cimg::min(cimg::min(a,b,c),d);
    }


    template<typename t1, typename t2>
    inline typename cimg::superset<t1,t2>::type max(const t1& a, const t2& b) {
      typedef typename cimg::superset<t1,t2>::type t1t2;
      return (t1t2)(a>=b?a:b);
    }


    template<typename t1, typename t2, typename t3>
    inline typename cimg::superset2<t1,t2,t3>::type max(const t1& a, const t2& b, const t3& c) {
      typedef typename cimg::superset2<t1,t2,t3>::type t1t2t3;
      return (t1t2t3)cimg::max(cimg::max(a,b),c);
    }


    template<typename t1, typename t2, typename t3, typename t4>
    inline typename cimg::superset3<t1,t2,t3,t4>::type max(const t1& a, const t2& b, const t3& c, const t4& d) {
      typedef typename cimg::superset3<t1,t2,t3,t4>::type t1t2t3t4;
      return (t1t2t3t4)cimg::max(cimg::max(a,b,c),d);
    }


    template<typename T>
    inline T sign(const T x) {
      return (x<0)?(T)(-1):(x==0?(T)0:(T)1);
    }


    template<typename T>
    inline unsigned long nearest_pow2(const T x) {
      unsigned long i = 1;
      while (x>i) i<<=1;
      return i;
    }


    inline double sinc(const double x) {
      return x?std::sin(x)/x:1;
    }







    template<typename T>
    inline T mod(const T& x, const T& m) {
      const double dx = (double)x, dm = (double)m;
      return (T)(dx - dm * std::floor(dx / dm));
    }
    inline int mod(const bool x, const bool m) {
      return m?(x?1:0):0;
    }
    inline int mod(const char x, const char m) {
      return x>=0?x%m:(x%m?m+x%m:0);
    }
    inline int mod(const short x, const short m) {
      return x>=0?x%m:(x%m?m+x%m:0);
    }
    inline int mod(const int x, const int m) {
      return x>=0?x%m:(x%m?m+x%m:0);
    }
    inline int mod(const long x, const long m) {
      return x>=0?x%m:(x%m?m+x%m:0);
    }
    inline int mod(const unsigned char x, const unsigned char m) {
      return x%m;
    }
    inline int mod(const unsigned short x, const unsigned short m) {
      return x%m;
    }
    inline int mod(const unsigned int x, const unsigned int m) {
      return x%m;
    }
    inline int mod(const unsigned long x, const unsigned long m) {
      return x%m;
    }







    template<typename T>
    inline T minmod(const T a, const T b) {
      return a*b<=0?0:(a>0?(a<b?a:b):(a<b?b:a));
    }


    inline double log2(const double x) {
      static const double base = std::log(2.0);
      return std::log(x)/base;
    }
# 4432 "../src/CImg.h"
    template<typename T>
    inline T round(const T x, const double y=1, const int rounding_type=0) {
      if (y<=0) return x;
      const double sx = (double)x/y, floor = std::floor(sx), delta = sx - floor;
      return (T)(y*(rounding_type<0?floor:rounding_type>0?std::ceil(sx):delta<0.5?floor:std::ceil(sx)));
    }

    inline double _pythagore(double a, double b) {
      const double absa = cimg::abs(a), absb = cimg::abs(b);
      if (absa>absb) { const double tmp = absb/absa; return absa*std::sqrt(1.0+tmp*tmp); }
      else { const double tmp = absa/absb; return absb==0?0:absb*std::sqrt(1.0+tmp*tmp); }
    }

    inline bool _is_self_expr(const char *expression) {
      if (!expression || *expression=='>' || *expression=='<') return false;
      for (const char *s = expression; *s; ++s)
        if ((*s=='i' || *s=='j') && (s[1]=='(' || s[1]=='[')) return true;
      return false;
    }


    inline char uncase(const char x) {
      return (char)((x<'A'||x>'Z')?x:x-'A'+'a');
    }


    inline void uncase(char *const str) {
      if (str) for (char *ptr = str; *ptr; ++ptr) *ptr = uncase(*ptr);
    }
# 4469 "../src/CImg.h"
    inline double atof(const char *const str) {
      double x = 0, y = 1;
      if (!str) return 0; else { std::sscanf(str,"%lf/%lf",&x,&y); return x/y; }
    }
# 4482 "../src/CImg.h"
    inline int strncasecmp(const char *const str1, const char *const str2, const int l) {
      if (!l) return 0;
      if (!str1) return str2?-1:0;
      const char *nstr1 = str1, *nstr2 = str2;
      int k, diff = 0; for (k = 0; k<l && !(diff = uncase(*nstr1)-uncase(*nstr2)); ++k) { ++nstr1; ++nstr2; }
      return k!=l?diff:0;
    }
# 4497 "../src/CImg.h"
    inline int strcasecmp(const char *const str1, const char *const str2) {
      if (!str1) return str2?-1:0;
      const unsigned int
        l1 = (unsigned int)std::strlen(str1),
        l2 = (unsigned int)std::strlen(str2);
      return cimg::strncasecmp(str1,str2,1+(l1<l2?l1:l2));
    }
# 4514 "../src/CImg.h"
    inline bool strpare(char *const str, const char delimiter=' ',
                        const bool is_symmetric=false, const bool is_iterative=false) {
      if (!str) return false;
      const int l = (int)std::strlen(str);
      int p, q;
      if (is_symmetric) for (p = 0, q = l-1; p<q && str[p]==delimiter && str[q]==delimiter; ) {
          --q; ++p; if (!is_iterative) break;
        } else {
        for (p = 0; p<l && str[p]==delimiter; ) { ++p; if (!is_iterative) break; }
        for (q = l-1; q>p && str[q]==delimiter; ) { --q; if (!is_iterative) break; }
      }
      const int n = q - p + 1;
      if (n!=l) { std::memmove(str,str+p,n); str[n] = 0; return true; }
      return false;
    }





    inline void strunescape(char *const str) {

      unsigned int val = 0;
      for (char *ns = str, *nd = str; *ns || (bool)(*nd=0); ++nd) if (*ns=='\\') switch (*(++ns)) {
            case 'n': *nd = '\n'; ++ns; break;;
            case 't': *nd = '\t'; ++ns; break;;
            case 'v': *nd = '\v'; ++ns; break;;
            case 'b': *nd = '\b'; ++ns; break;;
            case 'r': *nd = '\r'; ++ns; break;;
            case 'f': *nd = '\f'; ++ns; break;;
            case 'a': *nd = '\a'; ++ns; break;;
            case '\\': *nd = '\\'; ++ns; break;;
            case '\?': *nd = '\?'; ++ns; break;;
            case '\'': *nd = '\''; ++ns; break;;
            case '\"': *nd = '\"'; ++ns; break;;
          case 0 : *nd = 0; break;
          case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' :
            std::sscanf(ns,"%o",&val); while (*ns>='0' && *ns<='7') ++ns;
            *nd = val; break;
          case 'x':
            std::sscanf(++ns,"%x",&val);
            while ((*ns>='0' && *ns<='7') || (*ns>='a' && *ns<='f') || (*ns>='A' && *ns<='F')) ++ns;
            *nd = val; break;
          default : *nd = *(ns++);
          } else *nd = *(ns++);
    }


    inline const char *strbuffersize(const unsigned long size) {
      static char res[256] = { 0 };
      cimg::mutex(5);
      if (size<1024LU) snprintf(res,sizeof(res),"%lu byte%s",size,size>1?"s":"");
      else if (size<1024*1024LU) { const float nsize = size/1024.0f; snprintf(res,sizeof(res),"%.1f Kio",nsize); }
      else if (size<1024*1024*1024LU) {
        const float nsize = size/(1024*1024.0f); snprintf(res,sizeof(res),"%.1f Mio",nsize);
      } else { const float nsize = size/(1024*1024*1024.0f); snprintf(res,sizeof(res),"%.1f Gio",nsize); }
      cimg::mutex(5,0);
      return res;
    }


    inline const char *stros() {

      const char *const str = "Linux";
# 4597 "../src/CImg.h"
      return str;
    }


    inline const char* basename(const char *const str) {
      const char *p = 0;
      for (const char *np = str; np>=str && (p=np); np = std::strchr(np,'/')+1) {}
      return p;
    }


    inline const char* filenamerand() {
      cimg::mutex(6);
      static char randomid[9] = { 0 };
      cimg::srand();
      for (unsigned int k = 0; k<8; ++k) {
        const int v = (int)std::rand()%3;
        randomid[k] = (char)(v==0?('0'+(std::rand()%10)):(v==1?('a'+(std::rand()%26)):('A'+(std::rand()%26))));
      }
      cimg::mutex(6,0);
      return randomid;
    }


    inline void winformat_string(char *const str) {
      if (str && *str) {




      }
    }
# 4638 "../src/CImg.h"
    inline std::FILE *fopen(const char *const path, const char *const mode) {
      if (!path)
        throw CImgArgumentException("cimg::fopen(): Specified file path is (null).");
      if (!mode)
        throw CImgArgumentException("cimg::fopen(): File '%s', specified mode is (null).",
                                    path);
      std::FILE *res = 0;
      if (*path=='-' && (!path[1] || path[1]=='.')) {
        res = (*mode=='r')?stdin:stdout;





      } else res = std::fopen(path,mode);
      if (!res) throw CImgIOException("cimg::fopen(): Failed to open file '%s' with mode '%s'.",
                                      path,mode);
      return res;
    }
# 4665 "../src/CImg.h"
    inline int fclose(std::FILE *file) {
      if (!file) warn("cimg::fclose(): Specified file is (null).");
      if (!file || file==stdin || file==stdout) return 0;
      const int errn = std::fclose(file);
      if (errn!=0) warn("cimg::fclose(): Error code %d returned during file closing.",
                        errn);
      return errn;
    }





    inline bool is_directory(const char *const path) {
      if (!path || !*path) return false;

      struct stat st_buf;
      if (!stat(path,&st_buf) && ((((st_buf.st_mode)) & 0170000) == (0040000))) return true;



      return false;
    }







    inline const char* temporary_path(const char *const user_path=0, const bool reinit_path=false) {






      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        char tmp[1024] = { 0 }, filetmp[512] = { 0 };
        std::FILE *file = 0;
        snprintf(filetmp,sizeof(filetmp),"%s.tmp",cimg::filenamerand());
        char *tmpPath = std::getenv("TMP");
        if (!tmpPath) { tmpPath = std::getenv("TEMP"); winformat_string(tmpPath); }
        if (tmpPath) if (!path_found) { snprintf(s_path,1024,"%s",tmpPath); snprintf(tmp,sizeof(tmp),"%s%c%s",s_path,'/',filetmp); if ((file=std::fopen(tmp,"wb"))!=0) { cimg::fclose(file); std::remove(tmp); path_found = true; } };
# 4729 "../src/CImg.h"
        if (!path_found) { snprintf(s_path,1024,"%s","/tmp"); snprintf(tmp,sizeof(tmp),"%s%c%s",s_path,'/',filetmp); if ((file=std::fopen(tmp,"wb"))!=0) { cimg::fclose(file); std::remove(tmp); path_found = true; } };
        if (!path_found) { snprintf(s_path,1024,"%s","/var/tmp"); snprintf(tmp,sizeof(tmp),"%s%c%s",s_path,'/',filetmp); if ((file=std::fopen(tmp,"wb"))!=0) { cimg::fclose(file); std::remove(tmp); path_found = true; } };

        if (!path_found) {
          *s_path = 0;
          std::strncpy(tmp,filetmp,sizeof(tmp)-1);
          if ((file=std::fopen(tmp,"wb"))!=0) { cimg::fclose(file); std::remove(tmp); path_found = true; }
        }
        if (!path_found) {
          cimg::mutex(7,0);
          throw CImgIOException("cimg::temporary_path(): Failed to locate path for writing temporary files.\n");
        }
      }
      cimg::mutex(7,0);
      return s_path;
    }
# 4786 "../src/CImg.h"
    inline const char* imagemagick_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;
# 4879 "../src/CImg.h"
        if (!path_found) {
          std::strcpy(s_path,"./convert");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"convert");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }







    inline const char* graphicsmagick_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;
# 4990 "../src/CImg.h"
        if (!path_found) {
          std::strcpy(s_path,"./gm");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"gm");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }







    inline const char* medcon_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;
# 5041 "../src/CImg.h"
        if (!path_found) {
          std::strcpy(s_path,"./medcon");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"medcon");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }







    inline const char *ffmpeg_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;







        if (!path_found) {
          std::strcpy(s_path,"./ffmpeg");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"ffmpeg");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }







    inline const char *gzip_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;







        if (!path_found) {
          std::strcpy(s_path,"./gzip");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"gzip");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }







    inline const char *gunzip_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;







        if (!path_found) {
          std::strcpy(s_path,"./gunzip");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"gunzip");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }







    inline const char *dcraw_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;







        if (!path_found) {
          std::strcpy(s_path,"./dcraw");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"dcraw");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }







    inline const char *wget_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;







        if (!path_found) {
          std::strcpy(s_path,"./wget");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"wget");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }







    inline const char *curl_path(const char *const user_path=0, const bool reinit_path=false) {
      static char *s_path = 0;
      cimg::mutex(7);
      if (reinit_path) { delete[] s_path; s_path = 0; }
      if (user_path) {
        if (!s_path) s_path = new char[1024];
        std::memset(s_path,0,1024);
        std::strncpy(s_path,user_path,1023);
      } else if (!s_path) {
        s_path = new char[1024];
        std::memset(s_path,0,1024);
        bool path_found = false;
        std::FILE *file = 0;







        if (!path_found) {
          std::strcpy(s_path,"./curl");
          if ((file=std::fopen(s_path,"r"))!=0) { cimg::fclose(file); path_found = true; }
        }
        if (!path_found) std::strcpy(s_path,"curl");

        winformat_string(s_path);
      }
      cimg::mutex(7,0);
      return s_path;
    }


    inline const char *split_filename(const char *const filename, char *const body=0) {
      if (!filename) { if (body) *body = 0; return 0; }
      const char *p = 0; for (const char *np = filename; np>=filename && (p=np); np = std::strchr(np,'.')+1) {}
      if (p==filename) {
        if (body) std::strcpy(body,filename);
        return filename + std::strlen(filename);
      }
      const unsigned int l = (unsigned int)(p - filename - 1);
      if (body) { std::memcpy(body,filename,l); body[l] = 0; }
      return p;
    }


    inline char* number_filename(const char *const filename, const int number,
                                 const unsigned int digits, char *const str) {
      if (!filename) { if (str) *str = 0; return 0; }
      char format[1024] = { 0 }, body[1024] = { 0 };
      const char *const ext = cimg::split_filename(filename,body);
      if (*ext) snprintf(format,sizeof(format),"%%s_%%.%ud.%%s",digits);
      else snprintf(format,sizeof(format),"%%s_%%.%ud",digits);
      std::sprintf(str,format,body,number,ext);
      return str;
    }







    inline const char *file_type(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("cimg::file_type(): Specified filename is (null).");
      static const char
        *const _pnm = "pnm",
        *const _pfm = "pfm",
        *const _bmp = "bmp",
        *const _gif = "gif",
        *const _jpg = "jpg",
        *const _off = "off",
        *const _pan = "pan",
        *const _png = "png",
        *const _tif = "tif",
        *const _inr = "inr",
        *const _dcm = "dcm";
      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      const char *f_type = 0, *head;
      char header[2048] = { 0 }, item[1024] = { 0 };
      const unsigned char *const uheader = (unsigned char*)header;
      int err; char cerr;
      const unsigned int siz = (unsigned int)std::fread(header,2048,1,nfile);
      if (!file) cimg::fclose(nfile);

      if (!std::strncmp(header,"OFF\n",4)) f_type = _off;
      else if (!std::strncmp(header,"#INRIMAGE",9)) f_type = _inr;
      else if (!std::strncmp(header,"PANDORE",7)) f_type = _pan;
      else if (!std::strncmp(header+128,"DICM",4)) f_type = _dcm;
      else if (uheader[0]==0xFF && uheader[1]==0xD8 && uheader[2]==0xFF) f_type = _jpg;
      else if (header[0]=='B' && header[1]=='M') f_type = _bmp;
      else if (header[0]=='G' && header[1]=='I' && header[2]=='F' && header[3]=='8' && header[5]=='a' &&
               (header[4]=='7' || header[4]=='9')) f_type = _gif;
      else if (uheader[0]==0x89 && uheader[1]==0x50 && uheader[2]==0x4E && uheader[3]==0x47 &&
               uheader[4]==0x0D && uheader[5]==0x0A && uheader[6]==0x1A && uheader[7]==0x0A) f_type = _png;
      else if ((uheader[0]==0x49 && uheader[1]==0x49) || (uheader[0]==0x4D && uheader[1]==0x4D)) f_type = _tif;
      else {
        head = header;
        while (head<header+siz && (err=std::sscanf(head,"%1023[^\n]",item))!=(-1) && (*item=='#' || !err))
          head+=1+(err?std::strlen(item):0);
        if (std::sscanf(item," P%d",&err)==1) f_type = _pnm;
        else if (std::sscanf(item," P%c",&cerr)==1 && (cerr=='f' || cerr=='F')) f_type = _pfm;
      }
      return f_type;
    }
# 5364 "../src/CImg.h"
    template<typename T>
    inline int fread(T *const ptr, const unsigned long nmemb, std::FILE *stream) {
      if (!ptr || nmemb<=0 || !stream)
        throw CImgArgumentException("cimg::fread(): Invalid reading request of %u %s%s from file %p to buffer %p.",
                                    nmemb,cimg::type<T>::string(),nmemb>1?"s":"",stream,ptr);

      const unsigned long wlimitT = 63*1024*1024, wlimit = wlimitT/sizeof(T);
      unsigned long to_read = nmemb, al_read = 0, l_to_read = 0, l_al_read = 0;
      do {
        l_to_read = (to_read*sizeof(T))<wlimitT?to_read:wlimit;
        l_al_read = (unsigned long)std::fread((void*)(ptr+al_read),sizeof(T),l_to_read,stream);
        al_read+=l_al_read;
        to_read-=l_al_read;
      } while (l_to_read==l_al_read && to_read>0);
      if (to_read>0)
        warn("cimg::fread(): Only %u/%u elements could be read from file.",
             al_read,nmemb);
      return al_read;
    }
# 5392 "../src/CImg.h"
    template<typename T>
    inline int fwrite(const T *ptr, const unsigned long nmemb, std::FILE *stream) {
      if (!ptr || !stream)
        throw CImgArgumentException("cimg::fwrite(): Invalid writing request of %u %s%s from buffer %p to file %p.",
                                    nmemb,cimg::type<T>::string(),nmemb>1?"s":"",ptr,stream);
      if (nmemb<=0) return 0;
      const unsigned long wlimitT = 63*1024*1024, wlimit = wlimitT/sizeof(T);
      unsigned long to_write = nmemb, al_write = 0, l_to_write = 0, l_al_write = 0;
      do {
        l_to_write = (to_write*sizeof(T))<wlimitT?to_write:wlimit;
        l_al_write = (unsigned long)std::fwrite((void*)(ptr+al_write),sizeof(T),l_to_write,stream);
        al_write+=l_al_write;
        to_write-=l_al_write;
      } while (l_to_write==l_al_write && to_write>0);
      if (to_write>0)
        warn("cimg::fwrite(): Only %u/%u elements could be written in file.",
             al_write,nmemb);
      return al_write;
    }






    inline void fempty(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("cimg::file_type(): Specified filename is (null).");
      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      if (!file) cimg::fclose(nfile);
    }
# 5432 "../src/CImg.h"
    inline char *load_network_external(const char *const filename, char *const filename_local) {
      if (!filename)
        throw CImgArgumentException("cimg::load_network_external(): Specified filename is (null).");
      if (!filename_local)
        throw CImgArgumentException("cimg::load_network_external(): Specified destination string is (null).");
      const char *const _ext = cimg::split_filename(filename), *const ext = (*_ext && _ext>filename)?_ext-1:_ext;
      char command[1024] = { 0 };
      std::FILE *file = 0;
      *filename_local = 0;
      do {
        snprintf(filename_local,512,"%s%c%s%s",
                      cimg::temporary_path(),'/',cimg::filenamerand(),ext);
        if ((file=std::fopen(filename_local,"rb"))!=0) cimg::fclose(file);
      } while (file);


      snprintf(command,sizeof(command),"%s -f --silent --compressed -o \"%s\" \"%s\"",
                    cimg::curl_path(),filename_local,filename);
      cimg::system(command);
      if (!(file = std::fopen(filename_local,"rb"))) {


        snprintf(command,sizeof(command),"%s -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
                      cimg::wget_path(),filename_local,filename);
        cimg::system(command);
        if (!(file = std::fopen(filename_local,"rb")))
          throw CImgIOException("cimg::load_network_external(): Failed to load file '%s' with external commands "
                                "'wget' or 'curl'.",filename);
        cimg::fclose(file);


        snprintf(command,sizeof(command),"%s.gz",filename_local);
        std::rename(filename_local,command);
        snprintf(command,sizeof(command),"%s --quiet \"%s.gz\"",
                      gunzip_path(),filename_local);
        cimg::system(command);
        file = std::fopen(filename_local,"rb");
        if (!file) {
          snprintf(command,sizeof(command),"%s.gz",filename_local);
          std::rename(command,filename_local);
          file = std::fopen(filename_local,"rb");
        }
      }
      std::fseek(file,0,2);
      if (std::ftell(file)<=0)
        throw CImgIOException("cimg::load_network_external(): Failed to load file '%s' with external commands "
                              "'wget' or 'curl'.",filename);
      cimg::fclose(file);
      return filename_local;
    }


    inline const char* option(const char *const name, const int argc, const char *const *const argv,
                              const char *const defaut, const char *const usage, const bool reset_static) {
      static bool first = true, visu = false;
      if (reset_static) { first = true; return 0; }
      const char *res = 0;
      if (first) {
        first = false;
        visu = cimg::option("-h",argc,argv,(char*)0,(char*)0,false)!=0;
        visu |= cimg::option("-help",argc,argv,(char*)0,(char*)0,false)!=0;
        visu |= cimg::option("--help",argc,argv,(char*)0,(char*)0,false)!=0;
      }
      if (!name && visu) {
        if (usage) {
          std::fprintf(cimg::output(),"\n %s%s%s",cimg::t_red,cimg::basename(argv[0]),cimg::t_normal);
          std::fprintf(cimg::output(),": %s",usage);
          std::fprintf(cimg::output()," (%s, %s)\n\n","Jan  7 2015","20:58:11");
        }
        if (defaut) std::fprintf(cimg::output(),"%s\n",defaut);
      }
      if (name) {
        if (argc>0) {
          int k = 0;
          while (k<argc && std::strcmp(argv[k],name)) ++k;
          res = (k++==argc?defaut:(k==argc?argv[--k]:argv[k]));
        } else res = defaut;
        if (visu && usage) std::fprintf(cimg::output(),"    %s%-16s%s %-24s %s%s%s\n",
                                        cimg::t_bold,name,cimg::t_normal,res?res:"0",
                                        cimg::t_green,usage,cimg::t_normal);
      }
      return res;
    }

    inline const char* option(const char *const name, const int argc, const char *const *const argv,
                              const char *const defaut, const char *const usage=0) {
      return option(name,argc,argv,defaut,usage,false);
    }

    inline bool option(const char *const name, const int argc, const char *const *const argv,
                       const bool defaut, const char *const usage=0) {
      const char *const s = cimg::option(name,argc,argv,(char*)0);
      const bool res = s?(cimg::strcasecmp(s,"false") && cimg::strcasecmp(s,"off") && cimg::strcasecmp(s,"0")):defaut;
      cimg::option(name,0,0,res?"true":"false",usage);
      return res;
    }

    inline int option(const char *const name, const int argc, const char *const *const argv,
                      const int defaut, const char *const usage=0) {
      const char *const s = cimg::option(name,argc,argv,(char*)0);
      const int res = s?std::atoi(s):defaut;
      char tmp[256] = { 0 };
      snprintf(tmp,sizeof(tmp),"%d",res);
      cimg::option(name,0,0,tmp,usage);
      return res;
    }

    inline char option(const char *const name, const int argc, const char *const *const argv,
                       const char defaut, const char *const usage=0) {
      const char *const s = cimg::option(name,argc,argv,(char*)0);
      const char res = s?*s:defaut;
      char tmp[8] = { 0 };
      *tmp = res;
      cimg::option(name,0,0,tmp,usage);
      return res;
    }

    inline float option(const char *const name, const int argc, const char *const *const argv,
                        const float defaut, const char *const usage=0) {
      const char *const s = cimg::option(name,argc,argv,(char*)0);
      const float res = s?(float)cimg::atof(s):defaut;
      char tmp[256] = { 0 };
      snprintf(tmp,sizeof(tmp),"%g",res);
      cimg::option(name,0,0,tmp,usage);
      return res;
    }

    inline double option(const char *const name, const int argc, const char *const *const argv,
                         const double defaut, const char *const usage=0) {
      const char *const s = cimg::option(name,argc,argv,(char*)0);
      const double res = s?cimg::atof(s):defaut;
      char tmp[256] = { 0 };
      snprintf(tmp,sizeof(tmp),"%g",res);
      cimg::option(name,0,0,tmp,usage);
      return res;
    }

    inline const char* argument(const unsigned int nb, const int argc, const char *const *const argv,
                                const unsigned int nb_singles=0, ...) {
      for (int k = 1, pos = 0; k<argc;) {
        const char *const item = argv[k];
        bool option = (*item=='-'), single_option = false;
        if (option) {
          va_list ap;
          __builtin_va_start(ap,nb_singles);
          for (unsigned int i = 0; i<nb_singles; ++i) if (!cimg::strcasecmp(item,__builtin_va_arg(ap,char*))) {
              single_option = true; break;
            }
          __builtin_va_end(ap);
        }
        if (option) { ++k; if (!single_option) ++k; }
        else { if (pos++==(int)nb) return item; else ++k; }
      }
      return 0;
    }





    inline void info() {
      char tmp[1024] = { 0 };
      std::fprintf(cimg::output(),"\n %s%sCImg Library %u.%u.%u%s, compiled %s ( %s ) with the following flags:\n\n",
                   cimg::t_red,cimg::t_bold,160/100,(160/10)%10,160%10,
                   cimg::t_normal,"Jan  7 2015","20:58:11");

      std::fprintf(cimg::output(),"  > Operating System:       %s%-13s%s %s('cimg_OS'=%d)%s\n",
                   cimg::t_bold,
                   1==1?"Unix":(1==2?"Windows":"Unknow"),
                   cimg::t_normal,cimg::t_green,
                   1,
                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > CPU endianness:         %s%s Endian%s\n",
                   cimg::t_bold,
                   cimg::endianness()?"Big":"Little",
                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Verbosity mode:         %s%-13s%s %s('cimg_verbosity'=%d)%s\n",
                   cimg::t_bold,
                   2==0?"Quiet":
                   2==1?"Console":
                   2==2?"Dialog":
                   2==3?"Console+Warnings":"Dialog+Warnings",
                   cimg::t_normal,cimg::t_green,
                   2,
                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Stricts warnings:       %s%-13s%s %s('cimg_strict_warnings' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Using VT100 messages:   %s%-13s%s %s('cimg_use_vt100' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Display type:           %s%-13s%s %s('cimg_display'=%d)%s\n",
                   cimg::t_bold,
                   1==0?"No display":1==1?"X11":1==2?"Windows GDI":"Unknown",
                   cimg::t_normal,cimg::t_green,
                   1,
                   cimg::t_normal);


      std::fprintf(cimg::output(),"  > Using XShm for X11:     %s%-13s%s %s('cimg_use_xshm' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Using XRand for X11:    %s%-13s%s %s('cimg_use_xrandr' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Using OpenMP:           %s%-13s%s %s('cimg_use_openmp' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);
      std::fprintf(cimg::output(),"  > Using PNG library:      %s%-13s%s %s('cimg_use_png' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);
      std::fprintf(cimg::output(),"  > Using JPEG library:     %s%-13s%s %s('cimg_use_jpeg' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Using TIFF library:     %s%-13s%s %s('cimg_use_tiff' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Using Magick++ library: %s%-13s%s %s('cimg_use_magick' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Using FFTW3 library:    %s%-13s%s %s('cimg_use_fftw3' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      std::fprintf(cimg::output(),"  > Using LAPACK library:   %s%-13s%s %s('cimg_use_lapack' %s)%s\n",
                   cimg::t_bold,



                   "No",cimg::t_normal,cimg::t_green,"undefined",

                   cimg::t_normal);

      snprintf(tmp,sizeof(tmp),"\"%.1020s\"",cimg::imagemagick_path());
      std::fprintf(cimg::output(),"  > Path of ImageMagick:    %s%-13s%s\n",
                   cimg::t_bold,
                   tmp,
                   cimg::t_normal);

      snprintf(tmp,sizeof(tmp),"\"%.1020s\"",cimg::graphicsmagick_path());
      std::fprintf(cimg::output(),"  > Path of GraphicsMagick: %s%-13s%s\n",
                   cimg::t_bold,
                   tmp,
                   cimg::t_normal);

      snprintf(tmp,sizeof(tmp),"\"%.1020s\"",cimg::medcon_path());
      std::fprintf(cimg::output(),"  > Path of 'medcon':       %s%-13s%s\n",
                   cimg::t_bold,
                   tmp,
                   cimg::t_normal);

      snprintf(tmp,sizeof(tmp),"\"%.1020s\"",cimg::temporary_path());
      std::fprintf(cimg::output(),"  > Temporary path:         %s%-13s%s\n",
                   cimg::t_bold,
                   tmp,
                   cimg::t_normal);

      std::fprintf(cimg::output(),"\n");
    }
# 5817 "../src/CImg.h"
  }
# 5867 "../src/CImg.h"
  template<typename T> inline CImg<typename cimg::superset<T,bool>::type> operator+(const bool val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,bool>::type> operator-(const bool val, const CImg<T>& img) { typedef typename cimg::superset<T,bool>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,bool>::type> operator*(const bool val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,bool>::type> operator/(const bool val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,bool>::type> operator&(const bool val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,bool>::type> operator|(const bool val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,bool>::type> operator^(const bool val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const bool val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const bool val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,unsigned char>::type> operator+(const unsigned char val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned char>::type> operator-(const unsigned char val, const CImg<T>& img) { typedef typename cimg::superset<T,unsigned char>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,unsigned char>::type> operator*(const unsigned char val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned char>::type> operator/(const unsigned char val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,unsigned char>::type> operator&(const unsigned char val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned char>::type> operator|(const unsigned char val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned char>::type> operator^(const unsigned char val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const unsigned char val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const unsigned char val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,char>::type> operator+(const char val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,char>::type> operator-(const char val, const CImg<T>& img) { typedef typename cimg::superset<T,char>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,char>::type> operator*(const char val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,char>::type> operator/(const char val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,char>::type> operator&(const char val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,char>::type> operator|(const char val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,char>::type> operator^(const char val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const char val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const char val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,signed char>::type> operator+(const signed char val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,signed char>::type> operator-(const signed char val, const CImg<T>& img) { typedef typename cimg::superset<T,signed char>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,signed char>::type> operator*(const signed char val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,signed char>::type> operator/(const signed char val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,signed char>::type> operator&(const signed char val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,signed char>::type> operator|(const signed char val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,signed char>::type> operator^(const signed char val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const signed char val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const signed char val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,unsigned short>::type> operator+(const unsigned short val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned short>::type> operator-(const unsigned short val, const CImg<T>& img) { typedef typename cimg::superset<T,unsigned short>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,unsigned short>::type> operator*(const unsigned short val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned short>::type> operator/(const unsigned short val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,unsigned short>::type> operator&(const unsigned short val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned short>::type> operator|(const unsigned short val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned short>::type> operator^(const unsigned short val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const unsigned short val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const unsigned short val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,short>::type> operator+(const short val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,short>::type> operator-(const short val, const CImg<T>& img) { typedef typename cimg::superset<T,short>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,short>::type> operator*(const short val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,short>::type> operator/(const short val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,short>::type> operator&(const short val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,short>::type> operator|(const short val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,short>::type> operator^(const short val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const short val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const short val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,unsigned int>::type> operator+(const unsigned int val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned int>::type> operator-(const unsigned int val, const CImg<T>& img) { typedef typename cimg::superset<T,unsigned int>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,unsigned int>::type> operator*(const unsigned int val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned int>::type> operator/(const unsigned int val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,unsigned int>::type> operator&(const unsigned int val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned int>::type> operator|(const unsigned int val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned int>::type> operator^(const unsigned int val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const unsigned int val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const unsigned int val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,int>::type> operator+(const int val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,int>::type> operator-(const int val, const CImg<T>& img) { typedef typename cimg::superset<T,int>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,int>::type> operator*(const int val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,int>::type> operator/(const int val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,int>::type> operator&(const int val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,int>::type> operator|(const int val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,int>::type> operator^(const int val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const int val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const int val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,unsigned long>::type> operator+(const unsigned long val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned long>::type> operator-(const unsigned long val, const CImg<T>& img) { typedef typename cimg::superset<T,unsigned long>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,unsigned long>::type> operator*(const unsigned long val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned long>::type> operator/(const unsigned long val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,unsigned long>::type> operator&(const unsigned long val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned long>::type> operator|(const unsigned long val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,unsigned long>::type> operator^(const unsigned long val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const unsigned long val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const unsigned long val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,long>::type> operator+(const long val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,long>::type> operator-(const long val, const CImg<T>& img) { typedef typename cimg::superset<T,long>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,long>::type> operator*(const long val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,long>::type> operator/(const long val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,long>::type> operator&(const long val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,long>::type> operator|(const long val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,long>::type> operator^(const long val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const long val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const long val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,float>::type> operator+(const float val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,float>::type> operator-(const float val, const CImg<T>& img) { typedef typename cimg::superset<T,float>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,float>::type> operator*(const float val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,float>::type> operator/(const float val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,float>::type> operator&(const float val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,float>::type> operator|(const float val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,float>::type> operator^(const float val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const float val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const float val, const CImg<T>& img) { return img != val; }
  template<typename T> inline CImg<typename cimg::superset<T,double>::type> operator+(const double val, const CImg<T>& img) { return img + val; } template<typename T> inline CImg<typename cimg::superset<T,double>::type> operator-(const double val, const CImg<T>& img) { typedef typename cimg::superset<T,double>::type Tt; return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; } template<typename T> inline CImg<typename cimg::superset<T,double>::type> operator*(const double val, const CImg<T>& img) { return img*val; } template<typename T> inline CImg<typename cimg::superset<T,double>::type> operator/(const double val, const CImg<T>& img) { return val*img.get_invert(); } template<typename T> inline CImg<typename cimg::superset<T,double>::type> operator&(const double val, const CImg<T>& img) { return img & val; } template<typename T> inline CImg<typename cimg::superset<T,double>::type> operator|(const double val, const CImg<T>& img) { return img | val; } template<typename T> inline CImg<typename cimg::superset<T,double>::type> operator^(const double val, const CImg<T>& img) { return img ^ val; } template<typename T> inline bool operator==(const double val, const CImg<T>& img) { return img == val; } template<typename T> inline bool operator!=(const double val, const CImg<T>& img) { return img != val; }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> operator+(const char *const expression, const CImg<T>& img) {
    return img + expression;
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> operator-(const char *const expression, const CImg<T>& img) {
    return CImg<typename cimg::superset<T,float>::type>(img._width,img._height,img._depth,img._spectrum,expression,true)-=img;
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> operator*(const char *const expression, const CImg<T>& img) {
    return img*expression;
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> operator/(const char *const expression, const CImg<T>& img) {
    return expression*img.get_invert();
  }

  template<typename T>
  inline CImg<T> operator&(const char *const expression, const CImg<T>& img) {
    return img & expression;
  }

  template<typename T>
  inline CImg<T> operator|(const char *const expression, const CImg<T>& img) {
    return img | expression;
  }

  template<typename T>
  inline CImg<T> operator^(const char *const expression, const CImg<T>& img) {
    return img ^ expression;
  }

  template<typename T>
  inline bool operator==(const char *const expression, const CImg<T>& img) {
    return img == expression;
  }

  template<typename T>
  inline bool operator!=(const char *const expression, const CImg<T>& img) {
    return img != expression;
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> sqr(const CImg<T>& instance) {
    return instance.get_sqr();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> sqrt(const CImg<T>& instance) {
    return instance.get_sqrt();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> exp(const CImg<T>& instance) {
    return instance.get_exp();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> log(const CImg<T>& instance) {
    return instance.get_log();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> log2(const CImg<T>& instance) {
    return instance.get_log2();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> log10(const CImg<T>& instance) {
    return instance.get_log10();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> abs(const CImg<T>& instance) {
    return instance.get_abs();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> sign(const CImg<T>& instance) {
    return instance.get_sign();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> cos(const CImg<T>& instance) {
    return instance.get_cos();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> sin(const CImg<T>& instance) {
    return instance.get_sin();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> sinc(const CImg<T>& instance) {
    return instance.get_sinc();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> tan(const CImg<T>& instance) {
    return instance.get_tan();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> acos(const CImg<T>& instance) {
    return instance.get_acos();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> asin(const CImg<T>& instance) {
    return instance.get_asin();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> atan(const CImg<T>& instance) {
    return instance.get_atan();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> cosh(const CImg<T>& instance) {
    return instance.get_cosh();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> sinh(const CImg<T>& instance) {
    return instance.get_sinh();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> tanh(const CImg<T>& instance) {
    return instance.get_tanh();
  }

  template<typename T>
  inline CImg<T> transpose(const CImg<T>& instance) {
    return instance.get_transpose();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> invert(const CImg<T>& instance) {
    return instance.get_invert();
  }

  template<typename T>
  inline CImg<typename cimg::superset<T,float>::type> pseudoinvert(const CImg<T>& instance) {
    return instance.get_pseudoinvert();
  }
# 6052 "../src/CImg.h"
  struct CImgDisplay {
    unsigned long _timer, _fps_frames, _fps_timer;
    unsigned int _width, _height, _normalization;
    float _fps_fps, _min, _max;
    bool _is_fullscreen;
    char *_title;
    volatile unsigned int _window_width, _window_height, _button, _keys[128], _released_keys[128];
    volatile int _window_x, _window_y, _mouse_x, _mouse_y, _wheel;
    volatile bool _is_closed, _is_resized, _is_moved, _is_event,
      _is_keyESC, _is_keyF1, _is_keyF2, _is_keyF3, _is_keyF4, _is_keyF5, _is_keyF6, _is_keyF7,
      _is_keyF8, _is_keyF9, _is_keyF10, _is_keyF11, _is_keyF12, _is_keyPAUSE, _is_key1, _is_key2,
      _is_key3, _is_key4, _is_key5, _is_key6, _is_key7, _is_key8, _is_key9, _is_key0,
      _is_keyBACKSPACE, _is_keyINSERT, _is_keyHOME, _is_keyPAGEUP, _is_keyTAB, _is_keyQ, _is_keyW, _is_keyE,
      _is_keyR, _is_keyT, _is_keyY, _is_keyU, _is_keyI, _is_keyO, _is_keyP, _is_keyDELETE,
      _is_keyEND, _is_keyPAGEDOWN, _is_keyCAPSLOCK, _is_keyA, _is_keyS, _is_keyD, _is_keyF, _is_keyG,
      _is_keyH, _is_keyJ, _is_keyK, _is_keyL, _is_keyENTER, _is_keySHIFTLEFT, _is_keyZ, _is_keyX,
      _is_keyC, _is_keyV, _is_keyB, _is_keyN, _is_keyM, _is_keySHIFTRIGHT, _is_keyARROWUP, _is_keyCTRLLEFT,
      _is_keyAPPLEFT, _is_keyALT, _is_keySPACE, _is_keyALTGR, _is_keyAPPRIGHT, _is_keyMENU, _is_keyCTRLRIGHT,
      _is_keyARROWLEFT, _is_keyARROWDOWN, _is_keyARROWRIGHT, _is_keyPAD0, _is_keyPAD1, _is_keyPAD2, _is_keyPAD3,
      _is_keyPAD4, _is_keyPAD5, _is_keyPAD6, _is_keyPAD7, _is_keyPAD8, _is_keyPAD9, _is_keyPADADD, _is_keyPADSUB,
      _is_keyPADMUL, _is_keyPADDIV;
# 6120 "../src/CImg.h"
    ~CImgDisplay() {
      assign();
    }
# 6135 "../src/CImg.h"
    CImgDisplay():
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _window_x(0),_window_y(0),_mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) {
      assign();
    }
# 6156 "../src/CImg.h"
    CImgDisplay(const unsigned int width, const unsigned int height,
                const char *const title=0, const unsigned int normalization=3,
                const bool is_fullscreen=false, const bool is_closed=false):
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _window_x(0),_window_y(0),_mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) {
      assign(width,height,title,normalization,is_fullscreen,is_closed);
    }
# 6178 "../src/CImg.h"
    template<typename T>
    explicit CImgDisplay(const CImg<T>& img,
                         const char *const title=0, const unsigned int normalization=3,
                         const bool is_fullscreen=false, const bool is_closed=false):
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _window_x(0),_window_y(0),_mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) {
      assign(img,title,normalization,is_fullscreen,is_closed);
    }
# 6201 "../src/CImg.h"
    template<typename T>
    explicit CImgDisplay(const CImgList<T>& list,
                         const char *const title=0, const unsigned int normalization=3,
                         const bool is_fullscreen=false, const bool is_closed=false):
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _window_x(0),_window_y(0),_mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) {
      assign(list,title,normalization,is_fullscreen,is_closed);
    }






    CImgDisplay(const CImgDisplay& disp):
      _width(0),_height(0),_normalization(0),
      _min(0),_max(0),
      _is_fullscreen(false),
      _title(0),
      _window_width(0),_window_height(0),_button(0),
      _window_x(0),_window_y(0),_mouse_x(-1),_mouse_y(-1),_wheel(0),
      _is_closed(true),_is_resized(false),_is_moved(false),_is_event(false) {
      assign(disp);
    }
# 6297 "../src/CImg.h"
    static CImgDisplay& empty() {
      static CImgDisplay _empty;
      return _empty.assign();
    }



    static unsigned int _fitscreen(const unsigned int dx, const unsigned int dy, const unsigned int dz,
                                   const int dmin, const int dmax,const bool return_y) {
      const unsigned int _nw = dx + (dz>1?dz:0), _nh = dy + (dz>1?dz:0);
      unsigned int nw = _nw?_nw:1, nh = _nh?_nh:1;
      const unsigned int
        sw = CImgDisplay::screen_width(), sh = CImgDisplay::screen_height(),
        mw = dmin<0?(unsigned int)(sw*-dmin/100):(unsigned int)dmin,
        mh = dmin<0?(unsigned int)(sh*-dmin/100):(unsigned int)dmin,
        Mw = dmax<0?(unsigned int)(sw*-dmax/100):(unsigned int)dmax,
        Mh = dmax<0?(unsigned int)(sh*-dmax/100):(unsigned int)dmax;
      if (nw<mw) { nh = nh*mw/nw; nh+=(nh==0?1:0); nw = mw; }
      if (nh<mh) { nw = nw*mh/nh; nw+=(nw==0?1:0); nh = mh; }
      if (nw>Mw) { nh = nh*Mw/nw; nh+=(nh==0?1:0); nw = Mw; }
      if (nh>Mh) { nw = nw*Mh/nh; nw+=(nw==0?1:0); nh = Mh; }
      if (nw<mw) nw = mw;
      if (nh<mh) nh = mh;
      return return_y?nh:nw;
    }
# 6334 "../src/CImg.h"
    template<typename t>
    CImgDisplay& operator=(const CImg<t>& img) {
      return display(img);
    }





    template<typename t>
    CImgDisplay& operator=(const CImgList<t>& list) {
      return display(list);
    }





    CImgDisplay& operator=(const CImgDisplay& disp) {
      return assign(disp);
    }





    operator bool() const {
      return !is_empty();
    }
# 6374 "../src/CImg.h"
    bool is_empty() const {
      return !(_width && _height);
    }







    bool is_closed() const {
      return _is_closed;
    }




    bool is_resized() const {
      return _is_resized;
    }




    bool is_moved() const {
      return _is_moved;
    }




    bool is_event() const {
      return _is_event;
    }




    bool is_fullscreen() const {
      return _is_fullscreen;
    }





    bool is_key() const {
      return _is_keyESC || _is_keyF1 || _is_keyF2 || _is_keyF3 ||
        _is_keyF4 || _is_keyF5 || _is_keyF6 || _is_keyF7 ||
        _is_keyF8 || _is_keyF9 || _is_keyF10 || _is_keyF11 ||
        _is_keyF12 || _is_keyPAUSE || _is_key1 || _is_key2 ||
        _is_key3 || _is_key4 || _is_key5 || _is_key6 ||
        _is_key7 || _is_key8 || _is_key9 || _is_key0 ||
        _is_keyBACKSPACE || _is_keyINSERT || _is_keyHOME ||
        _is_keyPAGEUP || _is_keyTAB || _is_keyQ || _is_keyW ||
        _is_keyE || _is_keyR || _is_keyT || _is_keyY ||
        _is_keyU || _is_keyI || _is_keyO || _is_keyP ||
        _is_keyDELETE || _is_keyEND || _is_keyPAGEDOWN ||
        _is_keyCAPSLOCK || _is_keyA || _is_keyS || _is_keyD ||
        _is_keyF || _is_keyG || _is_keyH || _is_keyJ ||
        _is_keyK || _is_keyL || _is_keyENTER ||
        _is_keySHIFTLEFT || _is_keyZ || _is_keyX || _is_keyC ||
        _is_keyV || _is_keyB || _is_keyN || _is_keyM ||
        _is_keySHIFTRIGHT || _is_keyARROWUP || _is_keyCTRLLEFT ||
        _is_keyAPPLEFT || _is_keyALT || _is_keySPACE || _is_keyALTGR ||
        _is_keyAPPRIGHT || _is_keyMENU || _is_keyCTRLRIGHT ||
        _is_keyARROWLEFT || _is_keyARROWDOWN || _is_keyARROWRIGHT ||
        _is_keyPAD0 || _is_keyPAD1 || _is_keyPAD2 ||
        _is_keyPAD3 || _is_keyPAD4 || _is_keyPAD5 ||
        _is_keyPAD6 || _is_keyPAD7 || _is_keyPAD8 ||
        _is_keyPAD9 || _is_keyPADADD || _is_keyPADSUB ||
        _is_keyPADMUL || _is_keyPADDIV;
    }
# 6462 "../src/CImg.h"
    bool is_key(const unsigned int keycode) const {

      if (keycode==cimg::keyESC) return _is_keyESC;; if (keycode==cimg::keyF1) return _is_keyF1;; if (keycode==cimg::keyF2) return _is_keyF2;; if (keycode==cimg::keyF3) return _is_keyF3;;
      if (keycode==cimg::keyF4) return _is_keyF4;; if (keycode==cimg::keyF5) return _is_keyF5;; if (keycode==cimg::keyF6) return _is_keyF6;; if (keycode==cimg::keyF7) return _is_keyF7;;
      if (keycode==cimg::keyF8) return _is_keyF8;; if (keycode==cimg::keyF9) return _is_keyF9;; if (keycode==cimg::keyF10) return _is_keyF10;; if (keycode==cimg::keyF11) return _is_keyF11;;
      if (keycode==cimg::keyF12) return _is_keyF12;; if (keycode==cimg::keyPAUSE) return _is_keyPAUSE;; if (keycode==cimg::key1) return _is_key1;; if (keycode==cimg::key2) return _is_key2;;
      if (keycode==cimg::key3) return _is_key3;; if (keycode==cimg::key4) return _is_key4;; if (keycode==cimg::key5) return _is_key5;; if (keycode==cimg::key6) return _is_key6;;
      if (keycode==cimg::key7) return _is_key7;; if (keycode==cimg::key8) return _is_key8;; if (keycode==cimg::key9) return _is_key9;; if (keycode==cimg::key0) return _is_key0;;
      if (keycode==cimg::keyBACKSPACE) return _is_keyBACKSPACE;; if (keycode==cimg::keyINSERT) return _is_keyINSERT;; if (keycode==cimg::keyHOME) return _is_keyHOME;;
      if (keycode==cimg::keyPAGEUP) return _is_keyPAGEUP;; if (keycode==cimg::keyTAB) return _is_keyTAB;; if (keycode==cimg::keyQ) return _is_keyQ;; if (keycode==cimg::keyW) return _is_keyW;;
      if (keycode==cimg::keyE) return _is_keyE;; if (keycode==cimg::keyR) return _is_keyR;; if (keycode==cimg::keyT) return _is_keyT;; if (keycode==cimg::keyY) return _is_keyY;;
      if (keycode==cimg::keyU) return _is_keyU;; if (keycode==cimg::keyI) return _is_keyI;; if (keycode==cimg::keyO) return _is_keyO;; if (keycode==cimg::keyP) return _is_keyP;;
      if (keycode==cimg::keyDELETE) return _is_keyDELETE;; if (keycode==cimg::keyEND) return _is_keyEND;; if (keycode==cimg::keyPAGEDOWN) return _is_keyPAGEDOWN;;
      if (keycode==cimg::keyCAPSLOCK) return _is_keyCAPSLOCK;; if (keycode==cimg::keyA) return _is_keyA;; if (keycode==cimg::keyS) return _is_keyS;; if (keycode==cimg::keyD) return _is_keyD;;
      if (keycode==cimg::keyF) return _is_keyF;; if (keycode==cimg::keyG) return _is_keyG;; if (keycode==cimg::keyH) return _is_keyH;; if (keycode==cimg::keyJ) return _is_keyJ;;
      if (keycode==cimg::keyK) return _is_keyK;; if (keycode==cimg::keyL) return _is_keyL;; if (keycode==cimg::keyENTER) return _is_keyENTER;;
      if (keycode==cimg::keySHIFTLEFT) return _is_keySHIFTLEFT;; if (keycode==cimg::keyZ) return _is_keyZ;; if (keycode==cimg::keyX) return _is_keyX;; if (keycode==cimg::keyC) return _is_keyC;;
      if (keycode==cimg::keyV) return _is_keyV;; if (keycode==cimg::keyB) return _is_keyB;; if (keycode==cimg::keyN) return _is_keyN;; if (keycode==cimg::keyM) return _is_keyM;;
      if (keycode==cimg::keySHIFTRIGHT) return _is_keySHIFTRIGHT;; if (keycode==cimg::keyARROWUP) return _is_keyARROWUP;; if (keycode==cimg::keyCTRLLEFT) return _is_keyCTRLLEFT;;
      if (keycode==cimg::keyAPPLEFT) return _is_keyAPPLEFT;; if (keycode==cimg::keyALT) return _is_keyALT;; if (keycode==cimg::keySPACE) return _is_keySPACE;; if (keycode==cimg::keyALTGR) return _is_keyALTGR;;
      if (keycode==cimg::keyAPPRIGHT) return _is_keyAPPRIGHT;; if (keycode==cimg::keyMENU) return _is_keyMENU;; if (keycode==cimg::keyCTRLRIGHT) return _is_keyCTRLRIGHT;;
      if (keycode==cimg::keyARROWLEFT) return _is_keyARROWLEFT;; if (keycode==cimg::keyARROWDOWN) return _is_keyARROWDOWN;; if (keycode==cimg::keyARROWRIGHT) return _is_keyARROWRIGHT;;
      if (keycode==cimg::keyPAD0) return _is_keyPAD0;; if (keycode==cimg::keyPAD1) return _is_keyPAD1;; if (keycode==cimg::keyPAD2) return _is_keyPAD2;;
      if (keycode==cimg::keyPAD3) return _is_keyPAD3;; if (keycode==cimg::keyPAD4) return _is_keyPAD4;; if (keycode==cimg::keyPAD5) return _is_keyPAD5;;
      if (keycode==cimg::keyPAD6) return _is_keyPAD6;; if (keycode==cimg::keyPAD7) return _is_keyPAD7;; if (keycode==cimg::keyPAD8) return _is_keyPAD8;;
      if (keycode==cimg::keyPAD9) return _is_keyPAD9;; if (keycode==cimg::keyPADADD) return _is_keyPADADD;; if (keycode==cimg::keyPADSUB) return _is_keyPADSUB;;
      if (keycode==cimg::keyPADMUL) return _is_keyPADMUL;; if (keycode==cimg::keyPADDIV) return _is_keyPADDIV;;
      return false;
    }
# 6506 "../src/CImg.h"
    volatile bool& is_key(const char *const keycode) {
      static bool f = false;
      f = false;

      if (!cimg::strcasecmp(keycode,"ESC")) return _is_keyESC;; if (!cimg::strcasecmp(keycode,"F1")) return _is_keyF1;; if (!cimg::strcasecmp(keycode,"F2")) return _is_keyF2;; if (!cimg::strcasecmp(keycode,"F3")) return _is_keyF3;;
      if (!cimg::strcasecmp(keycode,"F4")) return _is_keyF4;; if (!cimg::strcasecmp(keycode,"F5")) return _is_keyF5;; if (!cimg::strcasecmp(keycode,"F6")) return _is_keyF6;; if (!cimg::strcasecmp(keycode,"F7")) return _is_keyF7;;
      if (!cimg::strcasecmp(keycode,"F8")) return _is_keyF8;; if (!cimg::strcasecmp(keycode,"F9")) return _is_keyF9;; if (!cimg::strcasecmp(keycode,"F10")) return _is_keyF10;; if (!cimg::strcasecmp(keycode,"F11")) return _is_keyF11;;
      if (!cimg::strcasecmp(keycode,"F12")) return _is_keyF12;; if (!cimg::strcasecmp(keycode,"PAUSE")) return _is_keyPAUSE;; if (!cimg::strcasecmp(keycode,"1")) return _is_key1;; if (!cimg::strcasecmp(keycode,"2")) return _is_key2;;
      if (!cimg::strcasecmp(keycode,"3")) return _is_key3;; if (!cimg::strcasecmp(keycode,"4")) return _is_key4;; if (!cimg::strcasecmp(keycode,"5")) return _is_key5;; if (!cimg::strcasecmp(keycode,"6")) return _is_key6;;
      if (!cimg::strcasecmp(keycode,"7")) return _is_key7;; if (!cimg::strcasecmp(keycode,"8")) return _is_key8;; if (!cimg::strcasecmp(keycode,"9")) return _is_key9;; if (!cimg::strcasecmp(keycode,"0")) return _is_key0;;
      if (!cimg::strcasecmp(keycode,"BACKSPACE")) return _is_keyBACKSPACE;; if (!cimg::strcasecmp(keycode,"INSERT")) return _is_keyINSERT;; if (!cimg::strcasecmp(keycode,"HOME")) return _is_keyHOME;;
      if (!cimg::strcasecmp(keycode,"PAGEUP")) return _is_keyPAGEUP;; if (!cimg::strcasecmp(keycode,"TAB")) return _is_keyTAB;; if (!cimg::strcasecmp(keycode,"Q")) return _is_keyQ;; if (!cimg::strcasecmp(keycode,"W")) return _is_keyW;;
      if (!cimg::strcasecmp(keycode,"E")) return _is_keyE;; if (!cimg::strcasecmp(keycode,"R")) return _is_keyR;; if (!cimg::strcasecmp(keycode,"T")) return _is_keyT;; if (!cimg::strcasecmp(keycode,"Y")) return _is_keyY;;
      if (!cimg::strcasecmp(keycode,"U")) return _is_keyU;; if (!cimg::strcasecmp(keycode,"I")) return _is_keyI;; if (!cimg::strcasecmp(keycode,"O")) return _is_keyO;; if (!cimg::strcasecmp(keycode,"P")) return _is_keyP;;
      if (!cimg::strcasecmp(keycode,"DELETE")) return _is_keyDELETE;; if (!cimg::strcasecmp(keycode,"END")) return _is_keyEND;; if (!cimg::strcasecmp(keycode,"PAGEDOWN")) return _is_keyPAGEDOWN;;
      if (!cimg::strcasecmp(keycode,"CAPSLOCK")) return _is_keyCAPSLOCK;; if (!cimg::strcasecmp(keycode,"A")) return _is_keyA;; if (!cimg::strcasecmp(keycode,"S")) return _is_keyS;; if (!cimg::strcasecmp(keycode,"D")) return _is_keyD;;
      if (!cimg::strcasecmp(keycode,"F")) return _is_keyF;; if (!cimg::strcasecmp(keycode,"G")) return _is_keyG;; if (!cimg::strcasecmp(keycode,"H")) return _is_keyH;; if (!cimg::strcasecmp(keycode,"J")) return _is_keyJ;;
      if (!cimg::strcasecmp(keycode,"K")) return _is_keyK;; if (!cimg::strcasecmp(keycode,"L")) return _is_keyL;; if (!cimg::strcasecmp(keycode,"ENTER")) return _is_keyENTER;;
      if (!cimg::strcasecmp(keycode,"SHIFTLEFT")) return _is_keySHIFTLEFT;; if (!cimg::strcasecmp(keycode,"Z")) return _is_keyZ;; if (!cimg::strcasecmp(keycode,"X")) return _is_keyX;; if (!cimg::strcasecmp(keycode,"C")) return _is_keyC;;
      if (!cimg::strcasecmp(keycode,"V")) return _is_keyV;; if (!cimg::strcasecmp(keycode,"B")) return _is_keyB;; if (!cimg::strcasecmp(keycode,"N")) return _is_keyN;; if (!cimg::strcasecmp(keycode,"M")) return _is_keyM;;
      if (!cimg::strcasecmp(keycode,"SHIFTRIGHT")) return _is_keySHIFTRIGHT;; if (!cimg::strcasecmp(keycode,"ARROWUP")) return _is_keyARROWUP;; if (!cimg::strcasecmp(keycode,"CTRLLEFT")) return _is_keyCTRLLEFT;;
      if (!cimg::strcasecmp(keycode,"APPLEFT")) return _is_keyAPPLEFT;; if (!cimg::strcasecmp(keycode,"ALT")) return _is_keyALT;; if (!cimg::strcasecmp(keycode,"SPACE")) return _is_keySPACE;; if (!cimg::strcasecmp(keycode,"ALTGR")) return _is_keyALTGR;;
      if (!cimg::strcasecmp(keycode,"APPRIGHT")) return _is_keyAPPRIGHT;; if (!cimg::strcasecmp(keycode,"MENU")) return _is_keyMENU;; if (!cimg::strcasecmp(keycode,"CTRLRIGHT")) return _is_keyCTRLRIGHT;;
      if (!cimg::strcasecmp(keycode,"ARROWLEFT")) return _is_keyARROWLEFT;; if (!cimg::strcasecmp(keycode,"ARROWDOWN")) return _is_keyARROWDOWN;; if (!cimg::strcasecmp(keycode,"ARROWRIGHT")) return _is_keyARROWRIGHT;;
      if (!cimg::strcasecmp(keycode,"PAD0")) return _is_keyPAD0;; if (!cimg::strcasecmp(keycode,"PAD1")) return _is_keyPAD1;; if (!cimg::strcasecmp(keycode,"PAD2")) return _is_keyPAD2;;
      if (!cimg::strcasecmp(keycode,"PAD3")) return _is_keyPAD3;; if (!cimg::strcasecmp(keycode,"PAD4")) return _is_keyPAD4;; if (!cimg::strcasecmp(keycode,"PAD5")) return _is_keyPAD5;;
      if (!cimg::strcasecmp(keycode,"PAD6")) return _is_keyPAD6;; if (!cimg::strcasecmp(keycode,"PAD7")) return _is_keyPAD7;; if (!cimg::strcasecmp(keycode,"PAD8")) return _is_keyPAD8;;
      if (!cimg::strcasecmp(keycode,"PAD9")) return _is_keyPAD9;; if (!cimg::strcasecmp(keycode,"PADADD")) return _is_keyPADADD;; if (!cimg::strcasecmp(keycode,"PADSUB")) return _is_keyPADSUB;;
      if (!cimg::strcasecmp(keycode,"PADMUL")) return _is_keyPADMUL;; if (!cimg::strcasecmp(keycode,"PADDIV")) return _is_keyPADDIV;;
      return f;
    }
# 6555 "../src/CImg.h"
    bool is_key_sequence(const unsigned int *const keycodes_sequence, const unsigned int length,
                         const bool remove_sequence=false) {
      if (keycodes_sequence && length) {
        const unsigned int
          *const ps_end = keycodes_sequence + length - 1,
          *const pk_end = (unsigned int*)_keys + 1 + sizeof(_keys)/sizeof(unsigned int) - length,
          k = *ps_end;
        for (unsigned int *pk = (unsigned int*)_keys; pk<pk_end; ) {
          if (*(pk++)==k) {
            bool res = true;
            const unsigned int *ps = ps_end, *pk2 = pk;
            for (unsigned int i = 1; i<length; ++i) res = (*(--ps)==*(pk2++));
            if (res) {
              if (remove_sequence) std::memset((void*)(pk-1),0,sizeof(unsigned int)*length);
              return true;
            }
          }
        }
      }
      return false;
    }
# 6586 "../src/CImg.h"
    bool is_keyESC() const { return _is_keyESC; }; bool is_keyF1() const { return _is_keyF1; }; bool is_keyF2() const { return _is_keyF2; }; bool is_keyF3() const { return _is_keyF3; };
    bool is_keyF4() const { return _is_keyF4; }; bool is_keyF5() const { return _is_keyF5; }; bool is_keyF6() const { return _is_keyF6; }; bool is_keyF7() const { return _is_keyF7; };
    bool is_keyF8() const { return _is_keyF8; }; bool is_keyF9() const { return _is_keyF9; }; bool is_keyF10() const { return _is_keyF10; }; bool is_keyF11() const { return _is_keyF11; };
    bool is_keyF12() const { return _is_keyF12; }; bool is_keyPAUSE() const { return _is_keyPAUSE; }; bool is_key1() const { return _is_key1; }; bool is_key2() const { return _is_key2; };
    bool is_key3() const { return _is_key3; }; bool is_key4() const { return _is_key4; }; bool is_key5() const { return _is_key5; }; bool is_key6() const { return _is_key6; };
    bool is_key7() const { return _is_key7; }; bool is_key8() const { return _is_key8; }; bool is_key9() const { return _is_key9; }; bool is_key0() const { return _is_key0; };
    bool is_keyBACKSPACE() const { return _is_keyBACKSPACE; }; bool is_keyINSERT() const { return _is_keyINSERT; }; bool is_keyHOME() const { return _is_keyHOME; };
    bool is_keyPAGEUP() const { return _is_keyPAGEUP; }; bool is_keyTAB() const { return _is_keyTAB; }; bool is_keyQ() const { return _is_keyQ; }; bool is_keyW() const { return _is_keyW; };
    bool is_keyE() const { return _is_keyE; }; bool is_keyR() const { return _is_keyR; }; bool is_keyT() const { return _is_keyT; }; bool is_keyY() const { return _is_keyY; };
    bool is_keyU() const { return _is_keyU; }; bool is_keyI() const { return _is_keyI; }; bool is_keyO() const { return _is_keyO; }; bool is_keyP() const { return _is_keyP; };
    bool is_keyDELETE() const { return _is_keyDELETE; }; bool is_keyEND() const { return _is_keyEND; }; bool is_keyPAGEDOWN() const { return _is_keyPAGEDOWN; };
    bool is_keyCAPSLOCK() const { return _is_keyCAPSLOCK; }; bool is_keyA() const { return _is_keyA; }; bool is_keyS() const { return _is_keyS; }; bool is_keyD() const { return _is_keyD; };
    bool is_keyF() const { return _is_keyF; }; bool is_keyG() const { return _is_keyG; }; bool is_keyH() const { return _is_keyH; }; bool is_keyJ() const { return _is_keyJ; };
    bool is_keyK() const { return _is_keyK; }; bool is_keyL() const { return _is_keyL; }; bool is_keyENTER() const { return _is_keyENTER; };
    bool is_keySHIFTLEFT() const { return _is_keySHIFTLEFT; }; bool is_keyZ() const { return _is_keyZ; }; bool is_keyX() const { return _is_keyX; }; bool is_keyC() const { return _is_keyC; };
    bool is_keyV() const { return _is_keyV; }; bool is_keyB() const { return _is_keyB; }; bool is_keyN() const { return _is_keyN; }; bool is_keyM() const { return _is_keyM; };
    bool is_keySHIFTRIGHT() const { return _is_keySHIFTRIGHT; }; bool is_keyARROWUP() const { return _is_keyARROWUP; }; bool is_keyCTRLLEFT() const { return _is_keyCTRLLEFT; };
    bool is_keyAPPLEFT() const { return _is_keyAPPLEFT; }; bool is_keyALT() const { return _is_keyALT; }; bool is_keySPACE() const { return _is_keySPACE; }; bool is_keyALTGR() const { return _is_keyALTGR; };
    bool is_keyAPPRIGHT() const { return _is_keyAPPRIGHT; }; bool is_keyMENU() const { return _is_keyMENU; }; bool is_keyCTRLRIGHT() const { return _is_keyCTRLRIGHT; };
    bool is_keyARROWLEFT() const { return _is_keyARROWLEFT; }; bool is_keyARROWDOWN() const { return _is_keyARROWDOWN; }; bool is_keyARROWRIGHT() const { return _is_keyARROWRIGHT; };
    bool is_keyPAD0() const { return _is_keyPAD0; }; bool is_keyPAD1() const { return _is_keyPAD1; }; bool is_keyPAD2() const { return _is_keyPAD2; };
    bool is_keyPAD3() const { return _is_keyPAD3; }; bool is_keyPAD4() const { return _is_keyPAD4; }; bool is_keyPAD5() const { return _is_keyPAD5; };
    bool is_keyPAD6() const { return _is_keyPAD6; }; bool is_keyPAD7() const { return _is_keyPAD7; }; bool is_keyPAD8() const { return _is_keyPAD8; };
    bool is_keyPAD9() const { return _is_keyPAD9; }; bool is_keyPADADD() const { return _is_keyPADADD; }; bool is_keyPADSUB() const { return _is_keyPADSUB; };
    bool is_keyPADMUL() const { return _is_keyPADMUL; }; bool is_keyPADDIV() const { return _is_keyPADDIV; };
# 6644 "../src/CImg.h"
    int width() const {
      return (int)_width;
    }






    int height() const {
      return (int)_height;
    }
# 6680 "../src/CImg.h"
    unsigned int normalization() const {
      return _normalization;
    }






    const char *title() const {
      return _title;
    }






    int window_width() const {
      return (int)_window_width;
    }






    int window_height() const {
      return (int)_window_height;
    }





    int window_x() const {
      return _window_x;
    }





    int window_y() const {
      return _window_y;
    }







    int mouse_x() const {
      return _mouse_x;
    }







    int mouse_y() const {
      return _mouse_y;
    }
# 6773 "../src/CImg.h"
    unsigned int button() const {
      return _button;
    }
# 6802 "../src/CImg.h"
    int wheel() const {
      return _wheel;
    }
# 6819 "../src/CImg.h"
    unsigned int key(const unsigned int pos=0) const {
      return pos<(sizeof(_keys)/sizeof(unsigned int))?_keys[pos]:0;
    }
# 6836 "../src/CImg.h"
    unsigned int released_key(const unsigned int pos=0) const {
      return pos<(sizeof(_released_keys)/sizeof(unsigned int))?_released_keys[pos]:0;
    }
# 6849 "../src/CImg.h"
    static unsigned int keycode(const char *const keycode) {

      if (!cimg::strcasecmp(keycode,"ESC")) return cimg::keyESC;; if (!cimg::strcasecmp(keycode,"F1")) return cimg::keyF1;; if (!cimg::strcasecmp(keycode,"F2")) return cimg::keyF2;; if (!cimg::strcasecmp(keycode,"F3")) return cimg::keyF3;;
      if (!cimg::strcasecmp(keycode,"F4")) return cimg::keyF4;; if (!cimg::strcasecmp(keycode,"F5")) return cimg::keyF5;; if (!cimg::strcasecmp(keycode,"F6")) return cimg::keyF6;; if (!cimg::strcasecmp(keycode,"F7")) return cimg::keyF7;;
      if (!cimg::strcasecmp(keycode,"F8")) return cimg::keyF8;; if (!cimg::strcasecmp(keycode,"F9")) return cimg::keyF9;; if (!cimg::strcasecmp(keycode,"F10")) return cimg::keyF10;; if (!cimg::strcasecmp(keycode,"F11")) return cimg::keyF11;;
      if (!cimg::strcasecmp(keycode,"F12")) return cimg::keyF12;; if (!cimg::strcasecmp(keycode,"PAUSE")) return cimg::keyPAUSE;; if (!cimg::strcasecmp(keycode,"1")) return cimg::key1;; if (!cimg::strcasecmp(keycode,"2")) return cimg::key2;;
      if (!cimg::strcasecmp(keycode,"3")) return cimg::key3;; if (!cimg::strcasecmp(keycode,"4")) return cimg::key4;; if (!cimg::strcasecmp(keycode,"5")) return cimg::key5;; if (!cimg::strcasecmp(keycode,"6")) return cimg::key6;;
      if (!cimg::strcasecmp(keycode,"7")) return cimg::key7;; if (!cimg::strcasecmp(keycode,"8")) return cimg::key8;; if (!cimg::strcasecmp(keycode,"9")) return cimg::key9;; if (!cimg::strcasecmp(keycode,"0")) return cimg::key0;;
      if (!cimg::strcasecmp(keycode,"BACKSPACE")) return cimg::keyBACKSPACE;; if (!cimg::strcasecmp(keycode,"INSERT")) return cimg::keyINSERT;; if (!cimg::strcasecmp(keycode,"HOME")) return cimg::keyHOME;;
      if (!cimg::strcasecmp(keycode,"PAGEUP")) return cimg::keyPAGEUP;; if (!cimg::strcasecmp(keycode,"TAB")) return cimg::keyTAB;; if (!cimg::strcasecmp(keycode,"Q")) return cimg::keyQ;; if (!cimg::strcasecmp(keycode,"W")) return cimg::keyW;;
      if (!cimg::strcasecmp(keycode,"E")) return cimg::keyE;; if (!cimg::strcasecmp(keycode,"R")) return cimg::keyR;; if (!cimg::strcasecmp(keycode,"T")) return cimg::keyT;; if (!cimg::strcasecmp(keycode,"Y")) return cimg::keyY;;
      if (!cimg::strcasecmp(keycode,"U")) return cimg::keyU;; if (!cimg::strcasecmp(keycode,"I")) return cimg::keyI;; if (!cimg::strcasecmp(keycode,"O")) return cimg::keyO;; if (!cimg::strcasecmp(keycode,"P")) return cimg::keyP;;
      if (!cimg::strcasecmp(keycode,"DELETE")) return cimg::keyDELETE;; if (!cimg::strcasecmp(keycode,"END")) return cimg::keyEND;; if (!cimg::strcasecmp(keycode,"PAGEDOWN")) return cimg::keyPAGEDOWN;;
      if (!cimg::strcasecmp(keycode,"CAPSLOCK")) return cimg::keyCAPSLOCK;; if (!cimg::strcasecmp(keycode,"A")) return cimg::keyA;; if (!cimg::strcasecmp(keycode,"S")) return cimg::keyS;; if (!cimg::strcasecmp(keycode,"D")) return cimg::keyD;;
      if (!cimg::strcasecmp(keycode,"F")) return cimg::keyF;; if (!cimg::strcasecmp(keycode,"G")) return cimg::keyG;; if (!cimg::strcasecmp(keycode,"H")) return cimg::keyH;; if (!cimg::strcasecmp(keycode,"J")) return cimg::keyJ;;
      if (!cimg::strcasecmp(keycode,"K")) return cimg::keyK;; if (!cimg::strcasecmp(keycode,"L")) return cimg::keyL;; if (!cimg::strcasecmp(keycode,"ENTER")) return cimg::keyENTER;;
      if (!cimg::strcasecmp(keycode,"SHIFTLEFT")) return cimg::keySHIFTLEFT;; if (!cimg::strcasecmp(keycode,"Z")) return cimg::keyZ;; if (!cimg::strcasecmp(keycode,"X")) return cimg::keyX;; if (!cimg::strcasecmp(keycode,"C")) return cimg::keyC;;
      if (!cimg::strcasecmp(keycode,"V")) return cimg::keyV;; if (!cimg::strcasecmp(keycode,"B")) return cimg::keyB;; if (!cimg::strcasecmp(keycode,"N")) return cimg::keyN;; if (!cimg::strcasecmp(keycode,"M")) return cimg::keyM;;
      if (!cimg::strcasecmp(keycode,"SHIFTRIGHT")) return cimg::keySHIFTRIGHT;; if (!cimg::strcasecmp(keycode,"ARROWUP")) return cimg::keyARROWUP;; if (!cimg::strcasecmp(keycode,"CTRLLEFT")) return cimg::keyCTRLLEFT;;
      if (!cimg::strcasecmp(keycode,"APPLEFT")) return cimg::keyAPPLEFT;; if (!cimg::strcasecmp(keycode,"ALT")) return cimg::keyALT;; if (!cimg::strcasecmp(keycode,"SPACE")) return cimg::keySPACE;; if (!cimg::strcasecmp(keycode,"ALTGR")) return cimg::keyALTGR;;
      if (!cimg::strcasecmp(keycode,"APPRIGHT")) return cimg::keyAPPRIGHT;; if (!cimg::strcasecmp(keycode,"MENU")) return cimg::keyMENU;; if (!cimg::strcasecmp(keycode,"CTRLRIGHT")) return cimg::keyCTRLRIGHT;;
      if (!cimg::strcasecmp(keycode,"ARROWLEFT")) return cimg::keyARROWLEFT;; if (!cimg::strcasecmp(keycode,"ARROWDOWN")) return cimg::keyARROWDOWN;; if (!cimg::strcasecmp(keycode,"ARROWRIGHT")) return cimg::keyARROWRIGHT;;
      if (!cimg::strcasecmp(keycode,"PAD0")) return cimg::keyPAD0;; if (!cimg::strcasecmp(keycode,"PAD1")) return cimg::keyPAD1;; if (!cimg::strcasecmp(keycode,"PAD2")) return cimg::keyPAD2;;
      if (!cimg::strcasecmp(keycode,"PAD3")) return cimg::keyPAD3;; if (!cimg::strcasecmp(keycode,"PAD4")) return cimg::keyPAD4;; if (!cimg::strcasecmp(keycode,"PAD5")) return cimg::keyPAD5;;
      if (!cimg::strcasecmp(keycode,"PAD6")) return cimg::keyPAD6;; if (!cimg::strcasecmp(keycode,"PAD7")) return cimg::keyPAD7;; if (!cimg::strcasecmp(keycode,"PAD8")) return cimg::keyPAD8;;
      if (!cimg::strcasecmp(keycode,"PAD9")) return cimg::keyPAD9;; if (!cimg::strcasecmp(keycode,"PADADD")) return cimg::keyPADADD;; if (!cimg::strcasecmp(keycode,"PADSUB")) return cimg::keyPADSUB;;
      if (!cimg::strcasecmp(keycode,"PADMUL")) return cimg::keyPADMUL;; if (!cimg::strcasecmp(keycode,"PADDIV")) return cimg::keyPADDIV;;
      return 0;
    }






    float frames_per_second() {
      if (!_fps_timer) _fps_timer = cimg::time();
      const float delta = (cimg::time()-_fps_timer)/1000.0f;
      ++_fps_frames;
      if (delta>=1) {
        _fps_fps = _fps_frames/delta;
        _fps_frames = 0;
        _fps_timer = cimg::time();
      }
      return _fps_fps;
    }
# 6925 "../src/CImg.h"
    template<typename T>
    CImgDisplay& display(const CImgList<T>& list, const char axis='x', const float align=0) {
      CImgList<typename CImg<T>::ucharT> visu(list._width);
      for (int l = 0; l<(int)(list)._width; ++l) {
        const CImg<T>& img = list._data[l];
        img.__get_select(*this,_normalization,(img._width-1)/2,(img._height-1)/2,(img._depth-1)/2).move_to(visu[l]);
      }
      visu.get_append(axis,align).display(*this);
      return *this;
    }
# 6981 "../src/CImg.h"
    CImgDisplay& resize(const bool force_redraw=true) {
      resize(_window_width,_window_height,force_redraw);
      return *this;
    }
# 7010 "../src/CImg.h"
    template<typename T>
    CImgDisplay& resize(const CImg<T>& img, const bool force_redraw=true) {
      return resize(img._width,img._height,force_redraw);
    }
# 7024 "../src/CImg.h"
    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {
      return resize(disp._width,disp._height,force_redraw);
    }


    template<typename t, typename T>
    static void _render_resize(const T *ptrs, const unsigned int ws, const unsigned int hs,
                               t *ptrd, const unsigned int wd, const unsigned int hd) {
      unsigned int *const offx = new unsigned int[wd], *const offy = new unsigned int[hd+1], *poffx, *poffy;
      float s, curr, old;
      s = (float)ws/wd;
      poffx = offx; curr = 0; for (unsigned int x = 0; x<wd; ++x) {
        old = curr; curr+=s; *(poffx++) = (unsigned int)curr - (unsigned int)old;
      }
      s = (float)hs/hd;
      poffy = offy; curr = 0; for (unsigned int y = 0; y<hd; ++y) {
        old = curr; curr+=s; *(poffy++) = ws*((unsigned int)curr - (unsigned int)old);
      }
      *poffy = 0;
      poffy = offy;
      for (unsigned int y = 0; y<hd; ) {
        const T *ptr = ptrs;
        poffx = offx;
        for (unsigned int x = 0; x<wd; ++x) { *(ptrd++) = *ptr; ptr+=*(poffx++); }
        ++y;
        unsigned int dy = *(poffy++);
        for ( ; !dy && y<hd; std::memcpy(ptrd,ptrd - wd,sizeof(t)*wd), ++y, ptrd+=wd, dy = *(poffy++)) {}
        ptrs+=dy;
      }
      delete[] offx; delete[] offy;
    }





    CImgDisplay& set_normalization(const unsigned int normalization) {
      _normalization = normalization;
      _min = _max = 0;
      return *this;
    }
# 7099 "../src/CImg.h"
    CImgDisplay& set_fullscreen(const bool is_fullscreen, const bool force_redraw=true) {
      if (is_empty() || _is_fullscreen==is_fullscreen) return *this;
      return toggle_fullscreen(force_redraw);
    }
# 7148 "../src/CImg.h"
    CImgDisplay& set_button() {
      _button = 0;
      _is_event = true;

      pthread_cond_broadcast(&cimg::X11_attr().wait_event);



      return *this;
    }






    CImgDisplay& set_button(const unsigned int button, const bool is_pressed=true) {
      const unsigned int buttoncode = button==1?1:button==2?2:button==3?4:0;
      if (is_pressed) _button |= buttoncode; else _button &= ~buttoncode;
      _is_event = buttoncode?true:false;
      if (buttoncode) {

        pthread_cond_broadcast(&cimg::X11_attr().wait_event);



      }
      return *this;
    }





    CImgDisplay& set_wheel() {
      _wheel = 0;
      _is_event = true;

      pthread_cond_broadcast(&cimg::X11_attr().wait_event);



      return *this;
    }






    CImgDisplay& set_wheel(const int amplitude) {
      _wheel+=amplitude;
      _is_event = amplitude?true:false;
      if (amplitude) {

        pthread_cond_broadcast(&cimg::X11_attr().wait_event);



      }
      return *this;
    }





    CImgDisplay& set_key() {
      std::memset((void*)_keys,0,sizeof(_keys));
      std::memset((void*)_released_keys,0,sizeof(_released_keys));
      _is_keyESC = _is_keyF1 = _is_keyF2 = _is_keyF3 = _is_keyF4 = _is_keyF5 = _is_keyF6 = _is_keyF7 = _is_keyF8 =
        _is_keyF9 = _is_keyF10 = _is_keyF11 = _is_keyF12 = _is_keyPAUSE = _is_key1 = _is_key2 = _is_key3 = _is_key4 =
        _is_key5 = _is_key6 = _is_key7 = _is_key8 = _is_key9 = _is_key0 = _is_keyBACKSPACE = _is_keyINSERT =
        _is_keyHOME = _is_keyPAGEUP = _is_keyTAB = _is_keyQ = _is_keyW = _is_keyE = _is_keyR = _is_keyT = _is_keyY =
        _is_keyU = _is_keyI = _is_keyO = _is_keyP = _is_keyDELETE = _is_keyEND = _is_keyPAGEDOWN = _is_keyCAPSLOCK =
        _is_keyA = _is_keyS = _is_keyD = _is_keyF = _is_keyG = _is_keyH = _is_keyJ = _is_keyK = _is_keyL =
        _is_keyENTER = _is_keySHIFTLEFT = _is_keyZ = _is_keyX = _is_keyC = _is_keyV = _is_keyB = _is_keyN =
        _is_keyM = _is_keySHIFTRIGHT = _is_keyARROWUP = _is_keyCTRLLEFT = _is_keyAPPLEFT = _is_keyALT = _is_keySPACE =
        _is_keyALTGR = _is_keyAPPRIGHT = _is_keyMENU = _is_keyCTRLRIGHT = _is_keyARROWLEFT = _is_keyARROWDOWN =
        _is_keyARROWRIGHT = _is_keyPAD0 = _is_keyPAD1 = _is_keyPAD2 = _is_keyPAD3 = _is_keyPAD4 = _is_keyPAD5 =
        _is_keyPAD6 = _is_keyPAD7 = _is_keyPAD8 = _is_keyPAD9 = _is_keyPADADD = _is_keyPADSUB = _is_keyPADMUL =
        _is_keyPADDIV = false;
      _is_event = true;

      pthread_cond_broadcast(&cimg::X11_attr().wait_event);



      return *this;
    }
# 7246 "../src/CImg.h"
    CImgDisplay& set_key(const unsigned int keycode, const bool is_pressed=true) {

      if (keycode==cimg::keyESC) _is_keyESC = is_pressed;; if (keycode==cimg::keyF1) _is_keyF1 = is_pressed;; if (keycode==cimg::keyF2) _is_keyF2 = is_pressed;; if (keycode==cimg::keyF3) _is_keyF3 = is_pressed;;
      if (keycode==cimg::keyF4) _is_keyF4 = is_pressed;; if (keycode==cimg::keyF5) _is_keyF5 = is_pressed;; if (keycode==cimg::keyF6) _is_keyF6 = is_pressed;; if (keycode==cimg::keyF7) _is_keyF7 = is_pressed;;
      if (keycode==cimg::keyF8) _is_keyF8 = is_pressed;; if (keycode==cimg::keyF9) _is_keyF9 = is_pressed;; if (keycode==cimg::keyF10) _is_keyF10 = is_pressed;; if (keycode==cimg::keyF11) _is_keyF11 = is_pressed;;
      if (keycode==cimg::keyF12) _is_keyF12 = is_pressed;; if (keycode==cimg::keyPAUSE) _is_keyPAUSE = is_pressed;; if (keycode==cimg::key1) _is_key1 = is_pressed;; if (keycode==cimg::key2) _is_key2 = is_pressed;;
      if (keycode==cimg::key3) _is_key3 = is_pressed;; if (keycode==cimg::key4) _is_key4 = is_pressed;; if (keycode==cimg::key5) _is_key5 = is_pressed;; if (keycode==cimg::key6) _is_key6 = is_pressed;;
      if (keycode==cimg::key7) _is_key7 = is_pressed;; if (keycode==cimg::key8) _is_key8 = is_pressed;; if (keycode==cimg::key9) _is_key9 = is_pressed;; if (keycode==cimg::key0) _is_key0 = is_pressed;;
      if (keycode==cimg::keyBACKSPACE) _is_keyBACKSPACE = is_pressed;; if (keycode==cimg::keyINSERT) _is_keyINSERT = is_pressed;; if (keycode==cimg::keyHOME) _is_keyHOME = is_pressed;;
      if (keycode==cimg::keyPAGEUP) _is_keyPAGEUP = is_pressed;; if (keycode==cimg::keyTAB) _is_keyTAB = is_pressed;; if (keycode==cimg::keyQ) _is_keyQ = is_pressed;; if (keycode==cimg::keyW) _is_keyW = is_pressed;;
      if (keycode==cimg::keyE) _is_keyE = is_pressed;; if (keycode==cimg::keyR) _is_keyR = is_pressed;; if (keycode==cimg::keyT) _is_keyT = is_pressed;; if (keycode==cimg::keyY) _is_keyY = is_pressed;;
      if (keycode==cimg::keyU) _is_keyU = is_pressed;; if (keycode==cimg::keyI) _is_keyI = is_pressed;; if (keycode==cimg::keyO) _is_keyO = is_pressed;; if (keycode==cimg::keyP) _is_keyP = is_pressed;;
      if (keycode==cimg::keyDELETE) _is_keyDELETE = is_pressed;; if (keycode==cimg::keyEND) _is_keyEND = is_pressed;; if (keycode==cimg::keyPAGEDOWN) _is_keyPAGEDOWN = is_pressed;;
      if (keycode==cimg::keyCAPSLOCK) _is_keyCAPSLOCK = is_pressed;; if (keycode==cimg::keyA) _is_keyA = is_pressed;; if (keycode==cimg::keyS) _is_keyS = is_pressed;; if (keycode==cimg::keyD) _is_keyD = is_pressed;;
      if (keycode==cimg::keyF) _is_keyF = is_pressed;; if (keycode==cimg::keyG) _is_keyG = is_pressed;; if (keycode==cimg::keyH) _is_keyH = is_pressed;; if (keycode==cimg::keyJ) _is_keyJ = is_pressed;;
      if (keycode==cimg::keyK) _is_keyK = is_pressed;; if (keycode==cimg::keyL) _is_keyL = is_pressed;; if (keycode==cimg::keyENTER) _is_keyENTER = is_pressed;;
      if (keycode==cimg::keySHIFTLEFT) _is_keySHIFTLEFT = is_pressed;; if (keycode==cimg::keyZ) _is_keyZ = is_pressed;; if (keycode==cimg::keyX) _is_keyX = is_pressed;; if (keycode==cimg::keyC) _is_keyC = is_pressed;;
      if (keycode==cimg::keyV) _is_keyV = is_pressed;; if (keycode==cimg::keyB) _is_keyB = is_pressed;; if (keycode==cimg::keyN) _is_keyN = is_pressed;; if (keycode==cimg::keyM) _is_keyM = is_pressed;;
      if (keycode==cimg::keySHIFTRIGHT) _is_keySHIFTRIGHT = is_pressed;; if (keycode==cimg::keyARROWUP) _is_keyARROWUP = is_pressed;; if (keycode==cimg::keyCTRLLEFT) _is_keyCTRLLEFT = is_pressed;;
      if (keycode==cimg::keyAPPLEFT) _is_keyAPPLEFT = is_pressed;; if (keycode==cimg::keyALT) _is_keyALT = is_pressed;; if (keycode==cimg::keySPACE) _is_keySPACE = is_pressed;; if (keycode==cimg::keyALTGR) _is_keyALTGR = is_pressed;;
      if (keycode==cimg::keyAPPRIGHT) _is_keyAPPRIGHT = is_pressed;; if (keycode==cimg::keyMENU) _is_keyMENU = is_pressed;; if (keycode==cimg::keyCTRLRIGHT) _is_keyCTRLRIGHT = is_pressed;;
      if (keycode==cimg::keyARROWLEFT) _is_keyARROWLEFT = is_pressed;; if (keycode==cimg::keyARROWDOWN) _is_keyARROWDOWN = is_pressed;; if (keycode==cimg::keyARROWRIGHT) _is_keyARROWRIGHT = is_pressed;;
      if (keycode==cimg::keyPAD0) _is_keyPAD0 = is_pressed;; if (keycode==cimg::keyPAD1) _is_keyPAD1 = is_pressed;; if (keycode==cimg::keyPAD2) _is_keyPAD2 = is_pressed;;
      if (keycode==cimg::keyPAD3) _is_keyPAD3 = is_pressed;; if (keycode==cimg::keyPAD4) _is_keyPAD4 = is_pressed;; if (keycode==cimg::keyPAD5) _is_keyPAD5 = is_pressed;;
      if (keycode==cimg::keyPAD6) _is_keyPAD6 = is_pressed;; if (keycode==cimg::keyPAD7) _is_keyPAD7 = is_pressed;; if (keycode==cimg::keyPAD8) _is_keyPAD8 = is_pressed;;
      if (keycode==cimg::keyPAD9) _is_keyPAD9 = is_pressed;; if (keycode==cimg::keyPADADD) _is_keyPADADD = is_pressed;; if (keycode==cimg::keyPADSUB) _is_keyPADSUB = is_pressed;;
      if (keycode==cimg::keyPADMUL) _is_keyPADMUL = is_pressed;; if (keycode==cimg::keyPADDIV) _is_keyPADDIV = is_pressed;;
      if (is_pressed) {
        if (*_keys)
          std::memmove((void*)(_keys+1),(void*)_keys,sizeof(_keys) - sizeof(unsigned int));
        *_keys = keycode;
        if (*_released_keys) {
          std::memmove((void*)(_released_keys+1),(void*)_released_keys,sizeof(_released_keys) - sizeof(unsigned int));
          *_released_keys = 0;
        }
      } else {
        if (*_keys) {
          std::memmove((void*)(_keys+1),(void*)_keys,sizeof(_keys) - sizeof(unsigned int));
          *_keys = 0;
        }
        if (*_released_keys)
          std::memmove((void*)(_released_keys+1),(void*)_released_keys,sizeof(_released_keys) - sizeof(unsigned int));
        *_released_keys = keycode;
      }
      _is_event = keycode?true:false;
      if (keycode) {

        pthread_cond_broadcast(&cimg::X11_attr().wait_event);



      }
      return *this;
    }





    CImgDisplay& flush() {
      set_key().set_button().set_wheel();
      _is_resized = _is_moved = _is_event = false;
      _fps_timer = _fps_frames = _timer = 0;
      _fps_fps = 0;
      return *this;
    }


    CImgDisplay& wait() {
      wait(*this);
      return *this;
    }






    CImgDisplay& wait(const unsigned int milliseconds) {
      cimg::_wait(milliseconds,_timer);
      return *this;
    }


    static void wait(CImgDisplay& disp1) {
      disp1._is_event = false;
      while (!disp1._is_closed && !disp1._is_event) wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2) {
      disp1._is_event = disp2._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed) &&
             !disp1._is_event && !disp2._is_event) wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3) {
      disp1._is_event = disp2._is_event = disp3._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event) wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event) wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4,
                     CImgDisplay& disp5) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event)
        wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event) wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event) wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event) wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event) wait_all();
    }


    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,
                     CImgDisplay& disp10) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)
        wait_all();
    }
# 7468 "../src/CImg.h"
    Atom _wm_window_atom, _wm_protocol_atom;
    Window _window, _background_window;
    Colormap _colormap;
    XImage *_image;
    void *_data;




    static int screen_width() {
      Display *const dpy = cimg::X11_attr().display;
      int res = 0;
      if (!dpy) {
        Display *const _dpy = XOpenDisplay(0);
        if (!_dpy)
          throw CImgDisplayException("CImgDisplay::screen_width(): Failed to open X11 display.");
        res = ((&((_XPrivDisplay)_dpy)->screens[(((_XPrivDisplay)_dpy)->default_screen)])->width);
        XCloseDisplay(_dpy);
      } else {





        res = ((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->width);

      }
      return res;
    }

    static int screen_height() {
      Display *const dpy = cimg::X11_attr().display;
      int res = 0;
      if (!dpy) {
        Display *const _dpy = XOpenDisplay(0);
        if (!_dpy)
          throw CImgDisplayException("CImgDisplay::screen_height(): Failed to open X11 display.");
        res = ((&((_XPrivDisplay)_dpy)->screens[(((_XPrivDisplay)_dpy)->default_screen)])->height);
        XCloseDisplay(_dpy);
      } else {





        res = ((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->height);

      }
      return res;
    }

    static void wait_all() {
      if (!cimg::X11_attr().display) return;
      if (cimg::mutex(13,2)) { cimg::sleep(10); return; }
      pthread_cond_wait(&cimg::X11_attr().wait_event,&cimg::X11_attr().wait_event_mutex);
      cimg::mutex(13,0);
    }

    void _handle_events(const XEvent *const pevent) {
      Display *const dpy = cimg::X11_attr().display;
      XEvent event = *pevent;
      switch (event.type) {
      case 33 : {
        if ((int)event.xclient.message_type==(int)_wm_protocol_atom &&
            (int)event.xclient.data.l[0]==(int)_wm_window_atom) {
          XUnmapWindow(cimg::X11_attr().display,_window);
          _is_closed = _is_event = true;
          pthread_cond_broadcast(&cimg::X11_attr().wait_event);
        }
      } break;
      case 22 : {
        while (XCheckWindowEvent(dpy,_window,(1L<<17),&event)) {}
        const unsigned int nw = event.xconfigure.width, nh = event.xconfigure.height;
        const int nx = event.xconfigure.x, ny = event.xconfigure.y;
        if (nw && nh && (nw!=_window_width || nh!=_window_height)) {
          _window_width = nw; _window_height = nh; _mouse_x = _mouse_y = -1;
          XResizeWindow(dpy,_window,_window_width,_window_height);
          _is_resized = _is_event = true;
          pthread_cond_broadcast(&cimg::X11_attr().wait_event);
        }
        if (nx!=_window_x || ny!=_window_y) {
          _window_x = nx; _window_y = ny; _is_moved = _is_event = true;
          pthread_cond_broadcast(&cimg::X11_attr().wait_event);
        }
      } break;
      case 12 : {
        while (XCheckWindowEvent(dpy,_window,(1L<<15),&event)) {}
        _paint(false);
        if (_is_fullscreen) {
          XWindowAttributes attr;
          XGetWindowAttributes(dpy,_window,&attr);
          while (attr.map_state!=2) XSync(dpy,0);
          XSetInputFocus(dpy,_window,2,0L);
        }
      } break;
      case 4 : {
        do {
          _mouse_x = event.xmotion.x; _mouse_y = event.xmotion.y;
          if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
          switch (event.xbutton.button) {
          case 1 : set_button(1); break;
          case 3 : set_button(2); break;
          case 2 : set_button(3); break;
          }
        } while (XCheckWindowEvent(dpy,_window,(1L<<2),&event));
      } break;
      case 5 : {
        do {
          _mouse_x = event.xmotion.x; _mouse_y = event.xmotion.y;
          if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
          switch (event.xbutton.button) {
          case 1 : set_button(1,false); break;
          case 3 : set_button(2,false); break;
          case 2 : set_button(3,false); break;
          case 4 : set_wheel(1); break;
          case 5 : set_wheel(-1); break;
          }
        } while (XCheckWindowEvent(dpy,_window,(1L<<3),&event));
      } break;
      case 2 : {
        char tmp = 0; KeySym ksym;
        XLookupString(&event.xkey,&tmp,1,&ksym,0);
        set_key((unsigned int)ksym,true);
      } break;
      case 3 : {
        char keys_return[32];
        XQueryKeymap(dpy,keys_return);
        const unsigned int kc = event.xkey.keycode, kc1 = kc/8, kc2 = kc%8;
        const bool is_key_pressed = kc1>=32?false:(keys_return[kc1]>>kc2)&1;
        if (!is_key_pressed) {
          char tmp = 0; KeySym ksym;
          XLookupString(&event.xkey,&tmp,1,&ksym,0);
          set_key((unsigned int)ksym,false);
        }
      } break;
      case 7: {
        while (XCheckWindowEvent(dpy,_window,(1L<<4),&event)) {}
        _mouse_x = event.xmotion.x;
        _mouse_y = event.xmotion.y;
        if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
      } break;
      case 8 : {
        while (XCheckWindowEvent(dpy,_window,(1L<<5),&event)) {}
        _mouse_x = _mouse_y =-1; _is_event = true;
        pthread_cond_broadcast(&cimg::X11_attr().wait_event);
      } break;
      case 6 : {
        while (XCheckWindowEvent(dpy,_window,(1L<<6),&event)) {}
        _mouse_x = event.xmotion.x;
        _mouse_y = event.xmotion.y;
        if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
        _is_event = true;
        pthread_cond_broadcast(&cimg::X11_attr().wait_event);
      } break;
      }
    }

    static void* _events_thread(void *arg) {
      Display *const dpy = cimg::X11_attr().display;
      XEvent event;
      pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,0);
      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,0);
      if (!arg) for (;;) {
        XLockDisplay(dpy);
        bool event_flag = XCheckTypedEvent(dpy,33,&event);
        if (!event_flag) event_flag = XCheckMaskEvent(dpy,
                                                      (1L<<15) | (1L<<17) | (1L<<2) |
                                                      (1L<<0) | (1L<<6) | (1L<<4) |
                                                      (1L<<5) | (1L<<3) | (1L<<1),&event);
        if (event_flag)
          for (unsigned int i = 0; i<cimg::X11_attr().nb_wins; ++i)
            if (!cimg::X11_attr().wins[i]->_is_closed && event.xany.window==cimg::X11_attr().wins[i]->_window)
              cimg::X11_attr().wins[i]->_handle_events(&event);
        XUnlockDisplay(dpy);
        pthread_testcancel();
        cimg::sleep(8);
      }
      return 0;
    }

    void _set_colormap(Colormap& _colormap, const unsigned int dim) {
      XColor colormap[256];
      switch (dim) {
      case 1 : {
        for (unsigned int index = 0; index<256; ++index) {
          colormap[index].pixel = index;
          colormap[index].red = colormap[index].green = colormap[index].blue = (unsigned short)(index<<8);
          colormap[index].flags = (1<<0) | (1<<1) | (1<<2);
        }
      } break;
      case 2 : {
        for (unsigned int index = 0, r = 8; r<256; r+=16)
          for (unsigned int g = 8; g<256; g+=16) {
            colormap[index].pixel = index;
            colormap[index].red = colormap[index].blue = (unsigned short)(r<<8);
            colormap[index].green = (unsigned short)(g<<8);
            colormap[index++].flags = (1<<0) | (1<<1) | (1<<2);
          }
      } break;
      default : {
        for (unsigned int index = 0, r = 16; r<256; r+=32)
          for (unsigned int g = 16; g<256; g+=32)
            for (unsigned int b = 32; b<256; b+=64) {
              colormap[index].pixel = index;
              colormap[index].red = (unsigned short)(r<<8);
              colormap[index].green = (unsigned short)(g<<8);
              colormap[index].blue = (unsigned short)(b<<8);
              colormap[index++].flags = (1<<0) | (1<<1) | (1<<2);
            }
      }
      }
      XStoreColors(cimg::X11_attr().display,_colormap,colormap,256);
    }

    void _map_window() {
      Display *const dpy = cimg::X11_attr().display;
      bool is_exposed = false, is_mapped = false;
      XWindowAttributes attr;
      XEvent event;
      XMapRaised(dpy,_window);
      do {
        XWindowEvent(dpy,_window,(1L<<17) | (1L<<15),&event);
        switch (event.type) {
        case 19 : is_mapped = true; break;
        case 12 : is_exposed = true; break;
        }
      } while (!is_exposed || !is_mapped);
      do {
        XGetWindowAttributes(dpy,_window,&attr);
        if (attr.map_state!=2) { XSync(dpy,0); cimg::sleep(10); }
      } while (attr.map_state!=2);
      _window_x = attr.x;
      _window_y = attr.y;
    }

    void _paint(const bool wait_expose=true) {
      if (_is_closed || !_image) return;
      Display *const dpy = cimg::X11_attr().display;
      if (wait_expose) {
        XEvent event;
        event.xexpose.type = 12;
        event.xexpose.serial = 0;
        event.xexpose.send_event = 1;
        event.xexpose.display = dpy;
        event.xexpose.window = _window;
        event.xexpose.x = 0;
        event.xexpose.y = 0;
        event.xexpose.width = width();
        event.xexpose.height = height();
        event.xexpose.count = 0;
        XSendEvent(dpy,_window,0,0,&event);
      } else {
        GC gc = ((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->default_gc);




        XPutImage(dpy,_window,gc,_image,0,0,0,0,_width,_height);

      }
    }

    template<typename T>
    void _resize(T pixel_type, const unsigned int ndimx, const unsigned int ndimy, const bool force_redraw) {
      Display *const dpy = cimg::X11_attr().display;
      cimg::unused(pixel_type);
# 7779 "../src/CImg.h"
        {
          T *ndata = (T*)std::malloc(ndimx*ndimy*sizeof(T));
          if (force_redraw) _render_resize((T*)_data,_width,_height,ndata,ndimx,ndimy);
          else std::memset(ndata,0,sizeof(T)*ndimx*ndimy);
          _data = (void*)ndata;
          ((*((_image)->f.destroy_image))((_image)));
          _image = XCreateImage(dpy,((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root_visual),
                                cimg::X11_attr().nb_bits,2,0,(char*)_data,ndimx,ndimy,8,0);
        }
    }

    void _init_fullscreen() {
      if (!_is_fullscreen || _is_closed) return;
      Display *const dpy = cimg::X11_attr().display;
      _background_window = 0;
# 7829 "../src/CImg.h"
      const unsigned int sx = screen_width(), sy = screen_height();
      if (sx==_width && sy==_height) return;
      XSetWindowAttributes winattr;
      winattr.override_redirect = 1;
      _background_window = XCreateWindow(dpy,((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root),0,0,sx,sy,0,0,
                                         1,0L,(1L<<9),&winattr);
      const unsigned long buf_size = (unsigned long)sx*sy*(cimg::X11_attr().nb_bits==8?1:
                                                           (cimg::X11_attr().nb_bits==16?2:4));
      void *background_data = std::malloc(buf_size);
      std::memset(background_data,0,buf_size);
      XImage *background_image = XCreateImage(dpy,((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root_visual),cimg::X11_attr().nb_bits,
                                              2,0,(char*)background_data,sx,sy,8,0);
      XEvent event;
      XSelectInput(dpy,_background_window,(1L<<17));
      XMapRaised(dpy,_background_window);
      do XWindowEvent(dpy,_background_window,(1L<<17),&event);
      while (event.type!=19);
      GC gc = ((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->default_gc);




      XPutImage(dpy,_background_window,gc,background_image,0,0,0,0,sx,sy);

      XWindowAttributes attr;
      XGetWindowAttributes(dpy,_background_window,&attr);
      while (attr.map_state!=2) XSync(dpy,0);
      ((*((background_image)->f.destroy_image))((background_image)));
    }

    void _desinit_fullscreen() {
      if (!_is_fullscreen) return;
      Display *const dpy = cimg::X11_attr().display;
      XUngrabKeyboard(dpy,0L);
# 7872 "../src/CImg.h"
      if (_background_window) XDestroyWindow(dpy,_background_window);
      _background_window = 0;
      _is_fullscreen = false;
    }

    static int _assign_xshm(Display *dpy, XErrorEvent *error) {
      cimg::unused(dpy,error);
      cimg::X11_attr().is_shm_enabled = false;
      return 0;
    }

    void _assign(const unsigned int dimw, const unsigned int dimh, const char *const ptitle=0,
                 const unsigned int normalization_type=3,
                 const bool fullscreen_flag=false, const bool closed_flag=false) {
      cimg::mutex(14);


      const char *const nptitle = ptitle?ptitle:"";
      const unsigned int s = std::strlen(nptitle) + 1;
      char *const tmp_title = s?new char[s]:0;
      if (s) std::memcpy(tmp_title,nptitle,s*sizeof(char));


      if (!is_empty()) assign();


      Display* &dpy = cimg::X11_attr().display;
      if (!dpy) {
        dpy = XOpenDisplay(0);
        if (!dpy)
          throw CImgDisplayException("[instance(%u,%u,%u,%c%s%c)] CImgDisplay::"
                                     "assign(): Failed to open X11 display.",
                                     _width,_height,_normalization,_title?'\"':'[',_title?_title:"untitled",_title?'\"':']');

        cimg::X11_attr().nb_bits = ((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root_depth);
        if (cimg::X11_attr().nb_bits!=8 && cimg::X11_attr().nb_bits!=16 &&
            cimg::X11_attr().nb_bits!=24 && cimg::X11_attr().nb_bits!=32)
          throw CImgDisplayException("[instance(%u,%u,%u,%c%s%c)] CImgDisplay::"
                                     "assign(): Invalid %u bits screen mode detected "
                                     "(only 8, 16, 24 and 32 bits modes are managed).",
                                     _width,_height,_normalization,_title?'\"':'[',_title?_title:"untitled",_title?'\"':']',
                                     cimg::X11_attr().nb_bits);
        XVisualInfo vtemplate;
        vtemplate.visualid = XVisualIDFromVisual(((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root_visual));
        int nb_visuals;
        XVisualInfo *vinfo = XGetVisualInfo(dpy,0x1,&vtemplate,&nb_visuals);
        if (vinfo && vinfo->red_mask<vinfo->blue_mask) cimg::X11_attr().is_blue_first = true;
        cimg::X11_attr().byte_order = (((_XPrivDisplay)dpy)->byte_order);
        XFree(vinfo);

        XLockDisplay(dpy);
        cimg::X11_attr().events_thread = new pthread_t;
        pthread_create(cimg::X11_attr().events_thread,0,_events_thread,0);
      } else XLockDisplay(dpy);


      _width = cimg::min(dimw,(unsigned int)screen_width());
      _height = cimg::min(dimh,(unsigned int)screen_height());
      _normalization = normalization_type<4?normalization_type:3;
      _is_fullscreen = fullscreen_flag;
      _window_x = _window_y = 0;
      _is_closed = closed_flag;
      _title = tmp_title;
      flush();


      if (_is_fullscreen) {
        if (!_is_closed) _init_fullscreen();
        const unsigned int sx = screen_width(), sy = screen_height();
        XSetWindowAttributes winattr;
        winattr.override_redirect = 1;
        _window = XCreateWindow(dpy,((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root),(sx-_width)/2,(sy-_height)/2,_width,_height,0,0,
                                1,0L,(1L<<9),&winattr);
      } else
        _window = XCreateSimpleWindow(dpy,((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root),0,0,_width,_height,0,0L,0L);

      XSelectInput(dpy,_window,
                   (1L<<15) | (1L<<17) | (1L<<2) | (1L<<0) | (1L<<6) |
                   (1L<<4) | (1L<<5) | (1L<<3) | (1L<<1));

      XStoreName(dpy,_window,_title?_title:" ");
      if (cimg::X11_attr().nb_bits==8) {
        _colormap = XCreateColormap(dpy,_window,((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root_visual),1);
        _set_colormap(_colormap,3);
        XSetWindowColormap(dpy,_window,_colormap);
      }

      static const char *const _window_class = "CImg";
      XClassHint *const window_class = XAllocClassHint();
      window_class->res_name = (char*)_window_class;
      window_class->res_class = (char*)_window_class;
      XSetClassHint(dpy,_window,window_class);
      XFree(window_class);

      _window_width = _width;
      _window_height = _height;
# 8001 "../src/CImg.h"
        {
          const unsigned long buf_size = (unsigned long)_width*_height*(cimg::X11_attr().nb_bits==8?1:
                                                                        (cimg::X11_attr().nb_bits==16?2:4));
          _data = std::malloc(buf_size);
          _image = XCreateImage(dpy,((&((_XPrivDisplay)dpy)->screens[(((_XPrivDisplay)dpy)->default_screen)])->root_visual),cimg::X11_attr().nb_bits,
                                2,0,(char*)_data,_width,_height,8,0);
        }

      _wm_window_atom = XInternAtom(dpy,"WM_DELETE_WINDOW",0);
      _wm_protocol_atom = XInternAtom(dpy,"WM_PROTOCOLS",0);
      XSetWMProtocols(dpy,_window,&_wm_window_atom,1);

      if (_is_fullscreen) XGrabKeyboard(dpy,_window,1,1,1,0L);
      cimg::X11_attr().wins[cimg::X11_attr().nb_wins++]=this;
      if (!_is_closed) _map_window(); else { _window_x = _window_y = cimg::type<int>::min(); }
      XUnlockDisplay(dpy);
      cimg::mutex(14,0);
    }

    CImgDisplay& assign() {
      if (is_empty()) return flush();
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);


      unsigned int i;
      for (i = 0; i<cimg::X11_attr().nb_wins && cimg::X11_attr().wins[i]!=this; ++i) {}
      for (; i<cimg::X11_attr().nb_wins-1; ++i) cimg::X11_attr().wins[i] = cimg::X11_attr().wins[i+1];
      --cimg::X11_attr().nb_wins;


      if (_is_fullscreen && !_is_closed) _desinit_fullscreen();
      XDestroyWindow(dpy,_window);
      _window = 0;
# 8045 "../src/CImg.h"
        ((*((_image)->f.destroy_image))((_image)));
      _data = 0; _image = 0;
      if (cimg::X11_attr().nb_bits==8) XFreeColormap(dpy,_colormap);
      _colormap = 0;
      XSync(dpy,0);


      delete[] _title;
      _width = _height = _normalization = _window_width = _window_height = 0;
      _window_x = _window_y = 0;
      _is_fullscreen = false;
      _is_closed = true;
      _min = _max = 0;
      _title = 0;
      flush();

      XUnlockDisplay(dpy);
      return *this;
    }

    CImgDisplay& assign(const unsigned int dimw, const unsigned int dimh, const char *const title=0,
                        const unsigned int normalization_type=3,
                        const bool fullscreen_flag=false, const bool closed_flag=false) {
      if (!dimw || !dimh) return assign();
      _assign(dimw,dimh,title,normalization_type,fullscreen_flag,closed_flag);
      _min = _max = 0;
      std::memset(_data,0,(cimg::X11_attr().nb_bits==8?sizeof(unsigned char):
                           (cimg::X11_attr().nb_bits==16?sizeof(unsigned short):sizeof(unsigned int)))*
                  (unsigned long)_width*_height);
      return paint();
    }

    template<typename T>
    CImgDisplay& assign(const CImg<T>& img, const char *const title=0,
                        const unsigned int normalization_type=3,
                        const bool fullscreen_flag=false, const bool closed_flag=false) {
      if (!img) return assign();
      CImg<T> tmp;
      const CImg<T>& nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width-1)/2,
                                                                           (img._height-1)/2,
                                                                           (img._depth-1)/2));
      _assign(nimg._width,nimg._height,title,normalization_type,fullscreen_flag,closed_flag);
      if (_normalization==2) _min = (float)nimg.min_max(_max);
      return render(nimg).paint();
    }

    template<typename T>
    CImgDisplay& assign(const CImgList<T>& list, const char *const title=0,
                        const unsigned int normalization_type=3,
                        const bool fullscreen_flag=false, const bool closed_flag=false) {
      if (!list) return assign();
      CImg<T> tmp;
      const CImg<T> img = list>'x', &nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width-1)/2,
                                                                                           (img._height-1)/2,
                                                                                           (img._depth-1)/2));
      _assign(nimg._width,nimg._height,title,normalization_type,fullscreen_flag,closed_flag);
      if (_normalization==2) _min = (float)nimg.min_max(_max);
      return render(nimg).paint();
    }

    CImgDisplay& assign(const CImgDisplay& disp) {
      if (!disp) return assign();
      _assign(disp._width,disp._height,disp._title,disp._normalization,disp._is_fullscreen,disp._is_closed);
      std::memcpy(_data,disp._data,(cimg::X11_attr().nb_bits==8?sizeof(unsigned char):
                                    cimg::X11_attr().nb_bits==16?sizeof(unsigned short):
                                    sizeof(unsigned int))*(unsigned long)_width*_height);
      return paint();
    }

    CImgDisplay& resize(const int nwidth, const int nheight, const bool force_redraw=true) {
      if (!nwidth || !nheight || (is_empty() && (nwidth<0 || nheight<0))) return assign();
      if (is_empty()) return assign(nwidth,nheight);
      Display *const dpy = cimg::X11_attr().display;
      const unsigned int
        tmpdimx = (nwidth>0)?nwidth:(-nwidth*width()/100),
        tmpdimy = (nheight>0)?nheight:(-nheight*height()/100),
        dimx = tmpdimx?tmpdimx:1,
        dimy = tmpdimy?tmpdimy:1;
      XLockDisplay(dpy);
      if (_window_width!=dimx || _window_height!=dimy) {
        XWindowAttributes attr;
        for (unsigned int i = 0; i<10; ++i) {
          XResizeWindow(dpy,_window,dimx,dimy);
          XGetWindowAttributes(dpy,_window,&attr);
          if (attr.width==(int)dimx && attr.height==(int)dimy) break;
          cimg::wait(5);
        }
      }
      if (_width!=dimx || _height!=dimy) switch (cimg::X11_attr().nb_bits) {
        case 8 : { unsigned char pixel_type = 0; _resize(pixel_type,dimx,dimy,force_redraw); } break;
        case 16 : { unsigned short pixel_type = 0; _resize(pixel_type,dimx,dimy,force_redraw); } break;
        default : { unsigned int pixel_type = 0; _resize(pixel_type,dimx,dimy,force_redraw); }
        }
      _window_width = _width = dimx; _window_height = _height = dimy;
      _is_resized = false;
      XUnlockDisplay(dpy);
      if (_is_fullscreen) move((screen_width()-_width)/2,(screen_height()-_height)/2);
      if (force_redraw) return paint();
      return *this;
    }

    CImgDisplay& toggle_fullscreen(const bool force_redraw=true) {
      if (is_empty()) return *this;
      if (force_redraw) {
        const unsigned long buf_size = (unsigned long)_width*_height*
          (cimg::X11_attr().nb_bits==8?1:(cimg::X11_attr().nb_bits==16?2:4));
        void *image_data = std::malloc(buf_size);
        std::memcpy(image_data,_data,buf_size);
        assign(_width,_height,_title,_normalization,!_is_fullscreen,false);
        std::memcpy(_data,image_data,buf_size);
        std::free(image_data);
        return paint();
      }
      return assign(_width,_height,_title,_normalization,!_is_fullscreen,false);
    }

    CImgDisplay& show() {
      if (is_empty() || !_is_closed) return *this;
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);
      if (_is_fullscreen) _init_fullscreen();
      _map_window();
      _is_closed = false;
      XUnlockDisplay(dpy);
      return paint();
    }

    CImgDisplay& close() {
      if (is_empty() || _is_closed) return *this;
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);
      if (_is_fullscreen) _desinit_fullscreen();
      XUnmapWindow(dpy,_window);
      _window_x = _window_y = -1;
      _is_closed = true;
      XUnlockDisplay(dpy);
      return *this;
    }

    CImgDisplay& move(const int posx, const int posy) {
      if (is_empty()) return *this;
      show();
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);
      XMoveWindow(dpy,_window,posx,posy);
      _window_x = posx; _window_y = posy;
      _is_moved = false;
      XUnlockDisplay(dpy);
      return paint();
    }

    CImgDisplay& show_mouse() {
      if (is_empty()) return *this;
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);
      XUndefineCursor(dpy,_window);
      XUnlockDisplay(dpy);
      return *this;
    }

    CImgDisplay& hide_mouse() {
      if (is_empty()) return *this;
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);
      const char pix_data[8] = { 0 };
      XColor col;
      col.red = col.green = col.blue = 0;
      Pixmap pix = XCreateBitmapFromData(dpy,_window,pix_data,8,8);
      Cursor cur = XCreatePixmapCursor(dpy,pix,pix,&col,&col,0,0);
      XFreePixmap(dpy,pix);
      XDefineCursor(dpy,_window,cur);
      XUnlockDisplay(dpy);
      return *this;
    }

    CImgDisplay& set_mouse(const int posx, const int posy) {
      if (is_empty() || _is_closed) return *this;
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);
      XWarpPointer(dpy,0L,_window,0,0,0,0,posx,posy);
      _mouse_x = posx; _mouse_y = posy;
      _is_moved = false;
      XSync(dpy,0);
      XUnlockDisplay(dpy);
      return *this;
    }

    CImgDisplay& set_title(const char *const format, ...) {
      if (is_empty()) return *this;
      char tmp[1024] = { 0 };
      va_list ap;
      __builtin_va_start(ap,format);
      vsnprintf(tmp,sizeof(tmp),format,ap);
      __builtin_va_end(ap);
      if (!std::strcmp(_title,tmp)) return *this;
      delete[] _title;
      const unsigned int s = std::strlen(tmp) + 1;
      _title = new char[s];
      std::memcpy(_title,tmp,s*sizeof(char));
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);
      XStoreName(dpy,_window,tmp);
      XUnlockDisplay(dpy);
      return *this;
    }

    template<typename T>
    CImgDisplay& display(const CImg<T>& img) {
      if (!img)
        throw CImgArgumentException("[instance(%u,%u,%u,%c%s%c)] CImgDisplay::"
                                    "display(): Empty specified image.",
                                    _width,_height,_normalization,_title?'\"':'[',_title?_title:"untitled",_title?'\"':']');
      if (is_empty()) return assign(img);
      return render(img).paint(false);
    }

    CImgDisplay& paint(const bool wait_expose=true) {
      if (is_empty()) return *this;
      Display *const dpy = cimg::X11_attr().display;
      XLockDisplay(dpy);
      _paint(wait_expose);
      XUnlockDisplay(dpy);
      return *this;
    }

    template<typename T>
    CImgDisplay& render(const CImg<T>& img, const bool flag8=false) {
      if (!img)
        throw CImgArgumentException("[instance(%u,%u,%u,%c%s%c)] CImgDisplay::"
                                    "render(): Empty specified image.",
                                    _width,_height,_normalization,_title?'\"':'[',_title?_title:"untitled",_title?'\"':']');
      if (is_empty()) return *this;
      if (img._depth!=1) return render(img.get_projections2d((img._width-1)/2,(img._height-1)/2,(img._depth-1)/2));
      if (cimg::X11_attr().nb_bits==8 && (img._width!=_width || img._height!=_height))
        return render(img.get_resize(_width,_height,1,-100,1));
      if (cimg::X11_attr().nb_bits==8 && !flag8 && img._spectrum==3) {
        static const CImg<typename CImg<T>::ucharT> default_colormap = CImg<typename CImg<T>::ucharT>::default_LUT256();
        return render(img.get_index(default_colormap,1,false));
      }

      Display *const dpy = cimg::X11_attr().display;
      const T
        *data1 = img._data,
        *data2 = (img._spectrum>1)?img.data(0,0,0,1):data1,
        *data3 = (img._spectrum>2)?img.data(0,0,0,2):data1;

      if (cimg::X11_attr().is_blue_first) cimg::swap(data1,data3);
      XLockDisplay(dpy);

      if (!_normalization || (_normalization==3 && cimg::type<T>::string()==cimg::type<unsigned char>::string())) {
        _min = _max = 0;
        switch (cimg::X11_attr().nb_bits) {
        case 8 : {
          _set_colormap(_colormap,img._spectrum);
          unsigned char *const ndata = (img._width==_width && img._height==_height)?(unsigned char*)_data:new unsigned char[(unsigned long)img._width*img._height];
          unsigned char *ptrd = (unsigned char*)ndata;
          switch (img._spectrum) {
          case 1 : for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) (*ptrd++) = (unsigned char)*(data1++);
            break;
          case 2 : for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char R = (unsigned char)*(data1++), G = (unsigned char)*(data2++);
              (*ptrd++) = (R&0xf0) | (G>>4);
            } break;
          default : for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char R = (unsigned char)*(data1++), G = (unsigned char)*(data2++), B = (unsigned char)*(data3++);
              (*ptrd++) = (R&0xe0) | ((G>>5)<<2) | (B>>6);
            }
          }
          if (ndata!=_data) { _render_resize(ndata,img._width,img._height,(unsigned char*)_data,_width,_height); delete[] ndata; }
        } break;
        case 16 : {
          unsigned short *const ndata = (img._width==_width && img._height==_height)?(unsigned short*)_data:new unsigned short[(unsigned long)img._width*img._height];
          unsigned char *ptrd = (unsigned char*)ndata;
          const unsigned int M = 248;
          switch (img._spectrum) {
          case 1 :
            if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char val = (unsigned char)*(data1++), G = val>>2;
              *(ptrd++) = (val&M) | (G>>3);
              *(ptrd++) = (G<<5) | (G>>1);
              } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char val = (unsigned char)*(data1++), G = val>>2;
              *(ptrd++) = (G<<5) | (G>>1);
              *(ptrd++) = (val&M) | (G>>3);
            }
            break;
          case 2 :
            if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char G = (unsigned char)*(data2++)>>2;
              *(ptrd++) = ((unsigned char)*(data1++)&M) | (G>>3);
              *(ptrd++) = (G<<5);
              } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char G = (unsigned char)*(data2++)>>2;
              *(ptrd++) = (G<<5);
              *(ptrd++) = ((unsigned char)*(data1++)&M) | (G>>3);
            }
            break;
          default :
            if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char G = (unsigned char)*(data2++)>>2;
              *(ptrd++) = ((unsigned char)*(data1++)&M) | (G>>3);
              *(ptrd++) = (G<<5) | ((unsigned char)*(data3++)>>3);
              } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char G = (unsigned char)*(data2++)>>2;
              *(ptrd++) = (G<<5) | ((unsigned char)*(data3++)>>3);
              *(ptrd++) = ((unsigned char)*(data1++)&M) | (G>>3);
            }
          }
          if (ndata!=_data) { _render_resize(ndata,img._width,img._height,(unsigned short*)_data,_width,_height); delete[] ndata; }
        } break;
        default : {
          unsigned int *const ndata = (img._width==_width && img._height==_height)?(unsigned int*)_data:new unsigned int[(unsigned long)img._width*img._height];
          if (sizeof(int)==4) {
            unsigned int *ptrd = ndata;
            switch (img._spectrum) {
            case 1 :
              if (cimg::X11_attr().byte_order==cimg::endianness())
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                  const unsigned char val = (unsigned char)*(data1++);
                  *(ptrd++) = (val<<16) | (val<<8) | val;
                }
              else
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                 const unsigned char val = (unsigned char)*(data1++);
                  *(ptrd++) = (val<<16) | (val<<8) | val;
                }
              break;
            case 2 :
              if (cimg::X11_attr().byte_order==cimg::endianness())
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy)
                  *(ptrd++) = ((unsigned char)*(data1++)<<16) | ((unsigned char)*(data2++)<<8);
              else
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy)
                  *(ptrd++) = ((unsigned char)*(data2++)<<16) | ((unsigned char)*(data1++)<<8);
              break;
            default :
              if (cimg::X11_attr().byte_order==cimg::endianness())
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy)
                  *(ptrd++) = ((unsigned char)*(data1++)<<16) | ((unsigned char)*(data2++)<<8) | (unsigned char)*(data3++);
              else
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy)
                  *(ptrd++) = ((unsigned char)*(data3++)<<24) | ((unsigned char)*(data2++)<<16) | ((unsigned char)*(data1++)<<8);
            }
          } else {
            unsigned char *ptrd = (unsigned char*)ndata;
            switch (img._spectrum) {
            case 1 :
              if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                *(ptrd++) = 0;
                *(ptrd++) = (unsigned char)*(data1++);
                *(ptrd++) = 0;
                *(ptrd++) = 0;
                } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                *(ptrd++) = 0;
                *(ptrd++) = 0;
                *(ptrd++) = (unsigned char)*(data1++);
                *(ptrd++) = 0;
              }
              break;
            case 2 :
              if (cimg::X11_attr().byte_order) cimg::swap(data1,data2);
              for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                *(ptrd++) = 0;
                *(ptrd++) = (unsigned char)*(data2++);
                *(ptrd++) = (unsigned char)*(data1++);
                *(ptrd++) = 0;
              }
              break;
            default :
              if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                *(ptrd++) = 0;
                *(ptrd++) = (unsigned char)*(data1++);
                *(ptrd++) = (unsigned char)*(data2++);
                *(ptrd++) = (unsigned char)*(data3++);
                } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                *(ptrd++) = (unsigned char)*(data3++);
                *(ptrd++) = (unsigned char)*(data2++);
                *(ptrd++) = (unsigned char)*(data1++);
                *(ptrd++) = 0;
              }
            }
          }
          if (ndata!=_data) { _render_resize(ndata,img._width,img._height,(unsigned int*)_data,_width,_height); delete[] ndata; }
        }
        }
      } else {
        if (_normalization==3) {
          if (cimg::type<T>::is_float()) _min = (float)img.min_max(_max);
          else { _min = (float)cimg::type<T>::min(); _max = (float)cimg::type<T>::max(); }
        } else if ((_min>_max) || _normalization==1) _min = (float)img.min_max(_max);
        const float delta = _max - _min, mm = 255/(delta?delta:1.0f);
        switch (cimg::X11_attr().nb_bits) {
        case 8 : {
          _set_colormap(_colormap,img._spectrum);
          unsigned char *const ndata = (img._width==_width && img._height==_height)?(unsigned char*)_data:new unsigned char[(unsigned long)img._width*img._height];
          unsigned char *ptrd = (unsigned char*)ndata;
          switch (img._spectrum) {
          case 1 : for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char R = (unsigned char)((*(data1++)-_min)*mm);
              *(ptrd++) = R;
            } break;
          case 2 : for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char
                R = (unsigned char)((*(data1++)-_min)*mm),
                G = (unsigned char)((*(data2++)-_min)*mm);
            (*ptrd++) = (R&0xf0) | (G>>4);
          } break;
          default :
            for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char
                R = (unsigned char)((*(data1++)-_min)*mm),
                G = (unsigned char)((*(data2++)-_min)*mm),
                B = (unsigned char)((*(data3++)-_min)*mm);
              *(ptrd++) = (R&0xe0) | ((G>>5)<<2) | (B>>6);
            }
          }
          if (ndata!=_data) { _render_resize(ndata,img._width,img._height,(unsigned char*)_data,_width,_height); delete[] ndata; }
        } break;
        case 16 : {
          unsigned short *const ndata = (img._width==_width && img._height==_height)?(unsigned short*)_data:new unsigned short[(unsigned long)img._width*img._height];
          unsigned char *ptrd = (unsigned char*)ndata;
          const unsigned int M = 248;
          switch (img._spectrum) {
          case 1 :
            if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char val = (unsigned char)((*(data1++)-_min)*mm), G = val>>2;
              *(ptrd++) = (val&M) | (G>>3);
              *(ptrd++) = (G<<5) | (val>>3);
              } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char val = (unsigned char)((*(data1++)-_min)*mm), G = val>>2;
              *(ptrd++) = (G<<5) | (val>>3);
              *(ptrd++) = (val&M) | (G>>3);
            }
            break;
          case 2 :
            if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char G = (unsigned char)((*(data2++)-_min)*mm)>>2;
              *(ptrd++) = ((unsigned char)((*(data1++)-_min)*mm)&M) | (G>>3);
              *(ptrd++) = (G<<5);
              } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char G = (unsigned char)((*(data2++)-_min)*mm)>>2;
              *(ptrd++) = (G<<5);
              *(ptrd++) = ((unsigned char)((*(data1++)-_min)*mm)&M) | (G>>3);
            }
            break;
          default :
            if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char G = (unsigned char)((*(data2++)-_min)*mm)>>2;
              *(ptrd++) = ((unsigned char)((*(data1++)-_min)*mm)&M) | (G>>3);
              *(ptrd++) = (G<<5) | ((unsigned char)((*(data3++)-_min)*mm)>>3);
              } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
              const unsigned char G = (unsigned char)((*(data2++)-_min)*mm)>>2;
              *(ptrd++) = (G<<5) | ((unsigned char)((*(data3++)-_min)*mm)>>3);
              *(ptrd++) = ((unsigned char)((*(data1++)-_min)*mm)&M) | (G>>3);
            }
          }
          if (ndata!=_data) { _render_resize(ndata,img._width,img._height,(unsigned short*)_data,_width,_height); delete[] ndata; }
        } break;
        default : {
          unsigned int *const ndata = (img._width==_width && img._height==_height)?(unsigned int*)_data:new unsigned int[(unsigned long)img._width*img._height];
          if (sizeof(int)==4) {
            unsigned int *ptrd = ndata;
            switch (img._spectrum) {
            case 1 :
              if (cimg::X11_attr().byte_order==cimg::endianness())
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                  const unsigned char val = (unsigned char)((*(data1++)-_min)*mm);
                  *(ptrd++) = (val<<16) | (val<<8) | val;
                }
              else
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                  const unsigned char val = (unsigned char)((*(data1++)-_min)*mm);
                  *(ptrd++) = (val<<24) | (val<<16) | (val<<8);
                }
              break;
            case 2 :
              if (cimg::X11_attr().byte_order==cimg::endianness())
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy)
                  *(ptrd++) =
                    ((unsigned char)((*(data1++)-_min)*mm)<<16) |
                    ((unsigned char)((*(data2++)-_min)*mm)<<8);
              else
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy)
                  *(ptrd++) =
                    ((unsigned char)((*(data2++)-_min)*mm)<<16) |
                    ((unsigned char)((*(data1++)-_min)*mm)<<8);
              break;
            default :
              if (cimg::X11_attr().byte_order==cimg::endianness())
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy)
                  *(ptrd++) =
                    ((unsigned char)((*(data1++)-_min)*mm)<<16) |
                    ((unsigned char)((*(data2++)-_min)*mm)<<8) |
                    (unsigned char)((*(data3++)-_min)*mm);
              else
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy)
                  *(ptrd++) =
                    ((unsigned char)((*(data3++)-_min)*mm)<<24) |
                    ((unsigned char)((*(data2++)-_min)*mm)<<16) |
                    ((unsigned char)((*(data1++)-_min)*mm)<<8);
            }
          } else {
            unsigned char *ptrd = (unsigned char*)ndata;
            switch (img._spectrum) {
            case 1 :
              if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                const unsigned char val = (unsigned char)((*(data1++)-_min)*mm);
                (*ptrd++) = 0;
                (*ptrd++) = val;
                (*ptrd++) = val;
                (*ptrd++) = val;
                } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                const unsigned char val = (unsigned char)((*(data1++)-_min)*mm);
                (*ptrd++) = val;
                (*ptrd++) = val;
                (*ptrd++) = val;
                (*ptrd++) = 0;
              }
              break;
            case 2 :
              if (cimg::X11_attr().byte_order) cimg::swap(data1,data2);
              for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                (*ptrd++) = 0;
                (*ptrd++) = (unsigned char)((*(data2++)-_min)*mm);
                (*ptrd++) = (unsigned char)((*(data1++)-_min)*mm);
                (*ptrd++) = 0;
              }
              break;
            default :
              if (cimg::X11_attr().byte_order)
                for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                  (*ptrd++) = 0;
                  (*ptrd++) = (unsigned char)((*(data1++)-_min)*mm);
                  (*ptrd++) = (unsigned char)((*(data2++)-_min)*mm);
                  (*ptrd++) = (unsigned char)((*(data3++)-_min)*mm);
                } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
                  (*ptrd++) = (unsigned char)((*(data3++)-_min)*mm);
                  (*ptrd++) = (unsigned char)((*(data2++)-_min)*mm);
                  (*ptrd++) = (unsigned char)((*(data1++)-_min)*mm);
                  (*ptrd++) = 0;
                }
            }
          }
          if (ndata!=_data) {
            _render_resize(ndata,img._width,img._height,(unsigned int*)_data,_width,_height); delete[] ndata;
          }
        }
        }
      }
      XUnlockDisplay(dpy);
      return *this;
    }

    template<typename T>
    const CImgDisplay& snapshot(CImg<T>& img) const {
      if (is_empty()) { img.assign(); return *this; }
      const unsigned char *ptrs = (unsigned char*)_data;
      img.assign(_width,_height,1,3);
      T
        *data1 = img.data(0,0,0,0),
        *data2 = img.data(0,0,0,1),
        *data3 = img.data(0,0,0,2);
      if (cimg::X11_attr().is_blue_first) cimg::swap(data1,data3);
      switch (cimg::X11_attr().nb_bits) {
      case 8 : {
        for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
          const unsigned char val = *(ptrs++);
          *(data1++) = (T)(val&0xe0);
          *(data2++) = (T)((val&0x1c)<<3);
          *(data3++) = (T)(val<<6);
        }
      } break;
      case 16 : {
        if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
          const unsigned char val0 = *(ptrs++), val1 = *(ptrs++);
          *(data1++) = (T)(val0&0xf8);
          *(data2++) = (T)((val0<<5) | ((val1&0xe0)>>5));
          *(data3++) = (T)(val1<<3);
          } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
          const unsigned short val0 = *(ptrs++), val1 = *(ptrs++);
          *(data1++) = (T)(val1&0xf8);
          *(data2++) = (T)((val1<<5) | ((val0&0xe0)>>5));
          *(data3++) = (T)(val0<<3);
        }
      } break;
      default : {
        if (cimg::X11_attr().byte_order) for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
          ++ptrs;
          *(data1++) = (T)*(ptrs++);
          *(data2++) = (T)*(ptrs++);
          *(data3++) = (T)*(ptrs++);
          } else for (unsigned long xy = (unsigned long)img._width*img._height; xy>0; --xy) {
            *(data3++) = (T)*(ptrs++);
            *(data2++) = (T)*(ptrs++);
            *(data1++) = (T)*(ptrs++);
            ++ptrs;
          }
      }
      }
      return *this;
    }
# 9230 "../src/CImg.h"
  };
# 9337 "../src/CImg.h"
  template<typename T>
  struct CImg {

    unsigned int _width, _height, _depth, _spectrum;
    bool _is_shared;
    T *_data;
# 9357 "../src/CImg.h"
    typedef T* iterator;
# 9373 "../src/CImg.h"
    typedef const T* const_iterator;
# 9383 "../src/CImg.h"
    typedef T value_type;


    typedef typename cimg::superset<T,bool>::type Tbool;
    typedef typename cimg::superset<T,unsigned char>::type Tuchar;
    typedef typename cimg::superset<T,char>::type Tchar;
    typedef typename cimg::superset<T,unsigned short>::type Tushort;
    typedef typename cimg::superset<T,short>::type Tshort;
    typedef typename cimg::superset<T,unsigned int>::type Tuint;
    typedef typename cimg::superset<T,int>::type Tint;
    typedef typename cimg::superset<T,unsigned long>::type Tulong;
    typedef typename cimg::superset<T,long>::type Tlong;
    typedef typename cimg::superset<T,float>::type Tfloat;
    typedef typename cimg::superset<T,double>::type Tdouble;
    typedef typename cimg::last<T,bool>::type boolT;
    typedef typename cimg::last<T,unsigned char>::type ucharT;
    typedef typename cimg::last<T,char>::type charT;
    typedef typename cimg::last<T,unsigned short>::type ushortT;
    typedef typename cimg::last<T,short>::type shortT;
    typedef typename cimg::last<T,unsigned int>::type uintT;
    typedef typename cimg::last<T,int>::type intT;
    typedef typename cimg::last<T,unsigned long>::type ulongT;
    typedef typename cimg::last<T,long>::type longT;
    typedef typename cimg::last<T,float>::type floatT;
    typedef typename cimg::last<T,double>::type doubleT;
# 9460 "../src/CImg.h"
    ~CImg() {
      if (!_is_shared) delete[] _data;
    }
# 9481 "../src/CImg.h"
    CImg():_width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) {}
# 9506 "../src/CImg.h"
    explicit CImg(const unsigned int size_x, const unsigned int size_y=1,
                  const unsigned int size_z=1, const unsigned int size_c=1):
      _is_shared(false) {
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (siz) {
        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c;
        try { _data = new T[siz]; } catch (...) {
          _width = _height = _depth = _spectrum = 0; _data = 0;
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                      size_x,size_y,size_z,size_c);
        }
      } else { _width = _height = _depth = _spectrum = 0; _data = 0; }
    }
# 9538 "../src/CImg.h"
    CImg(const unsigned int size_x, const unsigned int size_y,
         const unsigned int size_z, const unsigned int size_c, const T value):
      _is_shared(false) {
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (siz) {
        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c;
        try { _data = new T[siz]; } catch (...) {
          _width = _height = _depth = _spectrum = 0; _data = 0;
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                      size_x,size_y,size_z,size_c);
        }
        fill(value);
      } else { _width = _height = _depth = _spectrum = 0; _data = 0; }
    }
# 9584 "../src/CImg.h"
    CImg(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z, const unsigned int size_c,
         const int value0, const int value1, ...):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) {
# 9601 "../src/CImg.h"
      assign(size_x,size_y,size_z,size_c);
      { unsigned long _siz = (unsigned long)(unsigned long)size_x*size_y*size_z*size_c; if (_siz--) { va_list ap; __builtin_va_start(ap,value1); T *ptrd = (*this)._data; *(ptrd++) = (T)value0; if (_siz--) { *(ptrd++) = (T)value1; for (; _siz; --_siz) *(ptrd++) = (T)__builtin_va_arg(ap,int); } __builtin_va_end(ap); } };
    }
# 9727 "../src/CImg.h"
    CImg(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z, const unsigned int size_c,
         const double value0, const double value1, ...):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) {
      assign(size_x,size_y,size_z,size_c);
      { unsigned long _siz = (unsigned long)(unsigned long)size_x*size_y*size_z*size_c; if (_siz--) { va_list ap; __builtin_va_start(ap,value1); T *ptrd = (*this)._data; *(ptrd++) = (T)value0; if (_siz--) { *(ptrd++) = (T)value1; for (; _siz; --_siz) *(ptrd++) = (T)__builtin_va_arg(ap,double); } __builtin_va_end(ap); } };
    }
# 9764 "../src/CImg.h"
    CImg(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z, const unsigned int size_c,
         const char *const values, const bool repeat_values):_is_shared(false) {
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (siz) {
        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c;
        try { _data = new T[siz]; } catch (...) {
          _width = _height = _depth = _spectrum = 0; _data = 0;
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                      size_x,size_y,size_z,size_c);
        }
        fill(values,repeat_values);
      } else { _width = _height = _depth = _spectrum = 0; _data = 0; }
    }
# 9811 "../src/CImg.h"
    template<typename t>
    CImg(const t *const values, const unsigned int size_x, const unsigned int size_y=1,
         const unsigned int size_z=1, const unsigned int size_c=1, const bool is_shared=false):_is_shared(false) {
      if (is_shared) {
        _width = _height = _depth = _spectrum = 0; _data = 0;
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "CImg(): Invalid construction request of a (%u,%u,%u,%u) shared instance "
                                    "from a (%s*) buffer (pixel types are different).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    size_x,size_y,size_z,size_c,CImg<t>::pixel_type());
      }
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (values && siz) {
        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c;
        try { _data = new T[siz]; } catch (...) {
          _width = _height = _depth = _spectrum = 0; _data = 0;
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                      size_x,size_y,size_z,size_c);

        }
        const t *ptrs = values; for (T *ptrd = (*this)._data, *_maxptrd = (*this)._data + (*this).size(); ptrd<_maxptrd; ++ptrd) *ptrd = (T)*(ptrs++);
      } else { _width = _height = _depth = _spectrum = 0; _data = 0; }
    }


    CImg(const T *const values, const unsigned int size_x, const unsigned int size_y=1,
         const unsigned int size_z=1, const unsigned int size_c=1, const bool is_shared=false) {
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (values && siz) {
        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c; _is_shared = is_shared;
        if (_is_shared) _data = const_cast<T*>(values);
        else {
          try { _data = new T[siz]; } catch (...) {
            _width = _height = _depth = _spectrum = 0; _data = 0;
            throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                        size_x,size_y,size_z,size_c);
          }
          std::memcpy(_data,values,siz*sizeof(T)); }
      } else { _width = _height = _depth = _spectrum = 0; _is_shared = false; _data = 0; }
    }
# 9879 "../src/CImg.h"
    explicit CImg(const char *const filename):_width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) {
      assign(filename);
    }
# 9902 "../src/CImg.h"
    template<typename t>
    CImg(const CImg<t>& img):_is_shared(false) {
      const unsigned long siz = img.size();
      if (img._data && siz) {
        _width = img._width; _height = img._height; _depth = img._depth; _spectrum = img._spectrum;
        try { _data = new T[siz]; } catch (...) {
          _width = _height = _depth = _spectrum = 0; _data = 0;
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      cimg::strbuffersize(sizeof(T)*img._width*img._height*img._depth*img._spectrum),
                                      img._width,img._height,img._depth,img._spectrum);
        }
        const t *ptrs = img._data; for (T *ptrd = (*this)._data, *_maxptrd = (*this)._data + (*this).size(); ptrd<_maxptrd; ++ptrd) *ptrd = (T)*(ptrs++);
      } else { _width = _height = _depth = _spectrum = 0; _data = 0; }
    }


    CImg(const CImg<T>& img) {
      const unsigned long siz = img.size();
      if (img._data && siz) {
        _width = img._width; _height = img._height; _depth = img._depth; _spectrum = img._spectrum;
        _is_shared = img._is_shared;
        if (_is_shared) _data = const_cast<T*>(img._data);
        else {
          try { _data = new T[siz]; } catch (...) {
            _width = _height = _depth = _spectrum = 0; _data = 0;
            throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        cimg::strbuffersize(sizeof(T)*img._width*img._height*img._depth*img._spectrum),
                                        img._width,img._height,img._depth,img._spectrum);

          }
          std::memcpy(_data,img._data,siz*sizeof(T));
        }
      } else { _width = _height = _depth = _spectrum = 0; _is_shared = false; _data = 0; }
    }
# 9956 "../src/CImg.h"
    template<typename t>
    CImg(const CImg<t>& img, const bool is_shared):_is_shared(false) {
      if (is_shared) {
        _width = _height = _depth = _spectrum = 0; _data = 0;
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "CImg(): Invalid construction request of a shared instance from a "
                                    "CImg<%s> image (%u,%u,%u,%u,%p) (pixel types are different).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    CImg<t>::pixel_type(),img._width,img._height,img._depth,img._spectrum,img._data);
      }
      const unsigned long siz = img.size();
      if (img._data && siz) {
        _width = img._width; _height = img._height; _depth = img._depth; _spectrum = img._spectrum;
        try { _data = new T[siz]; } catch (...) {
          _width = _height = _depth = _spectrum = 0; _data = 0;
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      cimg::strbuffersize(sizeof(T)*img._width*img._height*img._depth*img._spectrum),
                                      img._width,img._height,img._depth,img._spectrum);
        }
        const t *ptrs = img._data; for (T *ptrd = (*this)._data, *_maxptrd = (*this)._data + (*this).size(); ptrd<_maxptrd; ++ptrd) *ptrd = (T)*(ptrs++);
      } else { _width = _height = _depth = _spectrum = 0; _data = 0; }
    }


    CImg(const CImg<T>& img, const bool is_shared) {
      const unsigned long siz = img.size();
      if (img._data && siz) {
        _width = img._width; _height = img._height; _depth = img._depth; _spectrum = img._spectrum;
        _is_shared = is_shared;
        if (_is_shared) _data = const_cast<T*>(img._data);
        else {
          try { _data = new T[siz]; } catch (...) {
            _width = _height = _depth = _spectrum = 0; _data = 0;
            throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        cimg::strbuffersize(sizeof(T)*img._width*img._height*img._depth*img._spectrum),
                                        img._width,img._height,img._depth,img._spectrum);
          }
          std::memcpy(_data,img._data,siz*sizeof(T));
        }
      } else { _width = _height = _depth = _spectrum = 0; _is_shared = false; _data = 0; }
    }
# 10022 "../src/CImg.h"
    template<typename t>
    CImg(const CImg<t>& img, const char *const dimensions):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) {
      assign(img,dimensions);
    }
# 10038 "../src/CImg.h"
    template<typename t>
    CImg(const CImg<t>& img, const char *const dimensions, const T value):
      _width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) {
      assign(img,dimensions).fill(value);
    }
# 10054 "../src/CImg.h"
    explicit CImg(const CImgDisplay &disp):_width(0),_height(0),_depth(0),_spectrum(0),_is_shared(false),_data(0) {
      disp.snapshot(*this);
    }
# 10074 "../src/CImg.h"
    CImg<T>& assign() {
      if (!_is_shared) delete[] _data;
      _width = _height = _depth = _spectrum = 0; _is_shared = false; _data = 0;
      return *this;
    }





    CImg<T>& assign(const unsigned int size_x, const unsigned int size_y=1,
                    const unsigned int size_z=1, const unsigned int size_c=1) {
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (!siz) return assign();
      const unsigned long curr_siz = size();
      if (siz!=curr_siz) {
        if (_is_shared)
          throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "assign(): Invalid assignement request of shared instance from specified "
                                      "image (%u,%u,%u,%u).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      size_x,size_y,size_z,size_c);
        else {
          delete[] _data;
          try { _data = new T[siz]; } catch (...) {
            _width = _height = _depth = _spectrum = 0; _data = 0;
            throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "assign(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                        size_x,size_y,size_z,size_c);
          }
        }
      }
      _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c;
      return *this;
    }





    CImg<T>& assign(const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c, const T value) {
      return assign(size_x,size_y,size_z,size_c).fill(value);
    }





    CImg<T>& assign(const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c,
                    const int value0, const int value1, ...) {
      assign(size_x,size_y,size_z,size_c);
      { unsigned long _siz = (unsigned long)(unsigned long)size_x*size_y*size_z*size_c; if (_siz--) { va_list ap; __builtin_va_start(ap,value1); T *ptrd = (*this)._data; *(ptrd++) = (T)value0; if (_siz--) { *(ptrd++) = (T)value1; for (; _siz; --_siz) *(ptrd++) = (T)__builtin_va_arg(ap,int); } __builtin_va_end(ap); } };
      return *this;
    }





    CImg<T>& assign(const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c,
                    const double value0, const double value1, ...) {
      assign(size_x,size_y,size_z,size_c);
      { unsigned long _siz = (unsigned long)(unsigned long)size_x*size_y*size_z*size_c; if (_siz--) { va_list ap; __builtin_va_start(ap,value1); T *ptrd = (*this)._data; *(ptrd++) = (T)value0; if (_siz--) { *(ptrd++) = (T)value1; for (; _siz; --_siz) *(ptrd++) = (T)__builtin_va_arg(ap,double); } __builtin_va_end(ap); } };
      return *this;
    }





    CImg<T>& assign(const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c,
                    const char *const values, const bool repeat_values) {
      return assign(size_x,size_y,size_z,size_c).fill(values,repeat_values);
    }





    template<typename t>
    CImg<T>& assign(const t *const values, const unsigned int size_x, const unsigned int size_y=1,
                    const unsigned int size_z=1, const unsigned int size_c=1) {
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (!values || !siz) return assign();
      assign(size_x,size_y,size_z,size_c);
      const t *ptrs = values; for (T *ptrd = (*this)._data, *_maxptrd = (*this)._data + (*this).size(); ptrd<_maxptrd; ++ptrd) *ptrd = (T)*(ptrs++);
      return *this;
    }


    CImg<T>& assign(const T *const values, const unsigned int size_x, const unsigned int size_y=1,
                    const unsigned int size_z=1, const unsigned int size_c=1) {
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (!values || !siz) return assign();
      const unsigned long curr_siz = size();
      if (values==_data && siz==curr_siz) return assign(size_x,size_y,size_z,size_c);
      if (_is_shared || values+siz<_data || values>=_data+size()) {
        assign(size_x,size_y,size_z,size_c);
        if (_is_shared) std::memmove(_data,values,siz*sizeof(T));
        else std::memcpy(_data,values,siz*sizeof(T));
      } else {
        T *new_data = 0;
        try { new_data = new T[siz]; } catch (...) {
          _width = _height = _depth = _spectrum = 0; _data = 0;
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "assign(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                      size_x,size_y,size_z,size_c);
        }
        std::memcpy(new_data,values,siz*sizeof(T));
        delete[] _data; _data = new_data; _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c;
      }
      return *this;
    }


    template<typename t>
    CImg<T>& assign(const t *const values, const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c, const bool is_shared) {
      if (is_shared)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "assign(): Invalid assignment request of shared instance from (%s*) buffer"
                                    "(pixel types are different).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    CImg<t>::pixel_type());
      return assign(values,size_x,size_y,size_z,size_c);
    }


    CImg<T>& assign(const T *const values, const unsigned int size_x, const unsigned int size_y,
                    const unsigned int size_z, const unsigned int size_c, const bool is_shared) {
      const unsigned long siz = (unsigned long)size_x*size_y*size_z*size_c;
      if (!values || !siz) {
        if (is_shared)
          throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "assign(): Invalid assignment request of shared instance from (null) or "
                                      "empty buffer.",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
        else return assign();
      }
      if (!is_shared) { if (_is_shared) assign(); assign(values,size_x,size_y,size_z,size_c); }
      else {
        if (!_is_shared) {
          if (values+siz<_data || values>=_data+size()) assign();
          else cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                          "assign(): Shared image instance has overlapping memory.",
                          _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
        }
        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c; _is_shared = true;
        _data = const_cast<T*>(values);
      }
      return *this;
    }





    CImg<T>& assign(const char *const filename) {
      return load(filename);
    }





    template<typename t>
    CImg<T>& assign(const CImg<t>& img) {
      return assign(img._data,img._width,img._height,img._depth,img._spectrum);
    }





    template<typename t>
    CImg<T>& assign(const CImg<t>& img, const bool is_shared) {
      return assign(img._data,img._width,img._height,img._depth,img._spectrum,is_shared);
    }





    template<typename t>
    CImg<T>& assign(const CImg<t>& img, const char *const dimensions) {
      if (!dimensions || !*dimensions) return assign(img._width,img._height,img._depth,img._spectrum);
      unsigned int siz[4] = { 0,1,1,1 }, k = 0;
      for (const char *s = dimensions; *s && k<4; ++k) {
        char item[256] = { 0 };
        if (std::sscanf(s,"%255[^0-9%xyzvwhdcXYZVWHDC]",item)>0) s+=std::strlen(item);
        if (*s) {
          unsigned int val = 0; char sep = 0;
          if (std::sscanf(s,"%u%c",&val,&sep)>0) {
            if (sep=='%') siz[k] = val*(k==0?_width:k==1?_height:k==2?_depth:_spectrum)/100;
            else siz[k] = val;
            while (*s>='0' && *s<='9') ++s; if (sep=='%') ++s;
          } else switch (cimg::uncase(*s)) {
          case 'x' : case 'w' : siz[k] = img._width; ++s; break;
          case 'y' : case 'h' : siz[k] = img._height; ++s; break;
          case 'z' : case 'd' : siz[k] = img._depth; ++s; break;
          case 'c' : case 's' : siz[k] = img._spectrum; ++s; break;
          default :
            throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "assign(): Invalid character '%c' detected in specified dimension string '%s'.",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        *s,dimensions);
          }
        }
      }
      return assign(siz[0],siz[1],siz[2],siz[3]);
    }





    template<typename t>
    CImg<T>& assign(const CImg<t>& img, const char *const dimensions, const T value) {
      return assign(img,dimensions).fill(value);
    }





    CImg<T>& assign(const CImgDisplay &disp) {
      disp.snapshot(*this);
      return *this;
    }







    CImg<T>& clear() {
      return assign();
    }
# 10338 "../src/CImg.h"
    template<typename t>
    CImg<t>& move_to(CImg<t>& img) {
      img.assign(*this);
      assign();
      return img;
    }


    CImg<T>& move_to(CImg<T>& img) {
      if (_is_shared || img._is_shared) img.assign(*this);
      else swap(img);
      assign();
      return img;
    }
# 10371 "../src/CImg.h"
    template<typename t>
    CImgList<t>& move_to(CImgList<t>& list, const unsigned int pos=~0U) {
      const unsigned int npos = pos>list._width?list._width:pos;
      move_to(list.insert(1,npos)[npos]);
      return list;
    }
# 10391 "../src/CImg.h"
    CImg<T>& swap(CImg<T>& img) {
      cimg::swap(_width,img._width);
      cimg::swap(_height,img._height);
      cimg::swap(_depth,img._depth);
      cimg::swap(_spectrum,img._spectrum);
      cimg::swap(_data,img._data);
      cimg::swap(_is_shared,img._is_shared);
      return img;
    }
# 10410 "../src/CImg.h"
    static CImg<T>& empty() {
      static CImg<T> _empty;
      return _empty.assign();
    }
# 10501 "../src/CImg.h"
    T& operator()(const unsigned int x) {
      return _data[x];
    }

    const T& operator()(const unsigned int x) const {
      return _data[x];
    }

    T& operator()(const unsigned int x, const unsigned int y) {
      return _data[x + y*_width];
    }

    const T& operator()(const unsigned int x, const unsigned int y) const {
      return _data[x + y*_width];
    }

    T& operator()(const unsigned int x, const unsigned int y, const unsigned int z) {
      return _data[x + y*(unsigned long)_width + z*(unsigned long)_width*_height];
   }

    const T& operator()(const unsigned int x, const unsigned int y, const unsigned int z) const {
      return _data[x + y*(unsigned long)_width + z*(unsigned long)_width*_height];
    }

    T& operator()(const unsigned int x, const unsigned int y, const unsigned int z, const unsigned int c) {
      return _data[x + y*(unsigned long)_width + z*(unsigned long)_width*_height +
                   c*(unsigned long)_width*_height*_depth];
    }

    const T& operator()(const unsigned int x, const unsigned int y, const unsigned int z, const unsigned int c) const {
      return _data[x + y*(unsigned long)_width + z*(unsigned long)_width*_height +
                   c*(unsigned long)_width*_height*_depth];
    }

    T& operator()(const unsigned int x, const unsigned int y, const unsigned int z, const unsigned int,
                  const unsigned long wh) {
      return _data[x + y*_width + z*wh];
    }

    const T& operator()(const unsigned int x, const unsigned int y, const unsigned int z, const unsigned int,
                        const unsigned long wh) const {
      return _data[x + y*_width + z*wh];
    }

    T& operator()(const unsigned int x, const unsigned int y, const unsigned int z, const unsigned int c,
                  const unsigned long wh, const unsigned long whd) {
      return _data[x + y*_width + z*wh + c*whd];
    }

    const T& operator()(const unsigned int x, const unsigned int y, const unsigned int z, const unsigned int c,
                        const unsigned long wh, const unsigned long whd) const {
      return _data[x + y*_width + z*wh + c*whd];
    }
# 10578 "../src/CImg.h"
    operator T*() {
      return _data;
    }


    operator const T*() const {
      return _data;
    }
# 10601 "../src/CImg.h"
    CImg<T>& operator=(const T value) {
      return fill(value);
    }
# 10625 "../src/CImg.h"
    CImg<T>& operator=(const char *const expression) {
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        fill(expression,true);
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        load(expression);
      }
      cimg::exception_mode() = omode;
      return *this;
    }





    template<typename t>
    CImg<T>& operator=(const CImg<t>& img) {
      return assign(img);
    }


    CImg<T>& operator=(const CImg<T>& img) {
      return assign(img);
    }





    CImg<T>& operator=(const CImgDisplay& disp) {
      disp.snapshot(*this);
      return *this;
    }
# 10688 "../src/CImg.h"
    template<typename t>
    CImg<T>& operator+=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)(*ptrd + value);
      return *this;
    }
# 10706 "../src/CImg.h"
    CImg<T>& operator+=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator+=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)(*ptrd + mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)(*ptrd + mp(x,y,z,c)); ++ptrd; }
        else {
# 10730 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)(*ptrd + mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        *this+=CImg<T>(_width,_height,_depth,_spectrum,expression,true);
      }
      cimg::exception_mode() = omode;
      return *this;
    }
# 10760 "../src/CImg.h"
    template<typename t>
    CImg<T>& operator+=(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return *this+=+img;
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)(*ptrd + *(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)(*ptrd + *(ptrs++));
      }
      return *this;
    }







    CImg<T>& operator++() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) ++*ptrd;
      return *this;
    }
# 10796 "../src/CImg.h"
    CImg<T> operator++(int) {
      const CImg<T> copy(*this,false);
      ++*this;
      return copy;
    }
# 10811 "../src/CImg.h"
    CImg<T> operator+() const {
      return CImg<T>(*this,false);
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator+(const t value) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false)+=value;
    }






    CImg<Tfloat> operator+(const char *const expression) const {
      return CImg<Tfloat>(*this,false)+=expression;
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator+(const CImg<t>& img) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false)+=img;
    }





    template<typename t>
    CImg<T>& operator-=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)(*ptrd - value);
      return *this;
    }





    CImg<T>& operator-=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator-=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)(*ptrd - mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)(*ptrd - mp(x,y,z,c)); ++ptrd; }
        else {
# 10886 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)(*ptrd - mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        *this-=CImg<T>(_width,_height,_depth,_spectrum,expression,true);
      }
      cimg::exception_mode() = omode;
      return *this;
    }





    template<typename t>
    CImg<T>& operator-=(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return *this-=+img;
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)(*ptrd - *(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)(*ptrd - *(ptrs++));
      }
      return *this;
    }





    CImg<T>& operator--() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = *ptrd-(T)1;
      return *this;
    }





    CImg<T> operator--(int) {
      const CImg<T> copy(*this,false);
      --*this;
      return copy;
    }
# 10951 "../src/CImg.h"
    CImg<T> operator-() const {
      return CImg<T>(_width,_height,_depth,_spectrum,(T)0)-=*this;
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator-(const t value) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false)-=value;
    }






    CImg<Tfloat> operator-(const char *const expression) const {
      return CImg<Tfloat>(*this,false)-=expression;
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator-(const CImg<t>& img) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false)-=img;
    }





    template<typename t>
    CImg<T>& operator*=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)(*ptrd * value);
      return *this;
    }





    CImg<T>& operator*=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator*=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)(*ptrd * mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)(*ptrd * mp(x,y,z,c)); ++ptrd; }
        else {
# 11026 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)(*ptrd * mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        mul(CImg<T>(_width,_height,_depth,_spectrum,expression,true));
      }
      cimg::exception_mode() = omode;
      return *this;
    }
# 11053 "../src/CImg.h"
    template<typename t>
    CImg<T>& operator*=(const CImg<t>& img) {
      return ((*this)*img).move_to(*this);
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator*(const t value) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false)*=value;
    }






    CImg<Tfloat> operator*(const char *const expression) const {
      return CImg<Tfloat>(*this,false)*=expression;
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator*(const CImg<t>& img) const {
      if (_width!=img._height || _depth!=1 || _spectrum!=1)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "operator*(): Invalid multiplication of instance by specified "
                                    "matrix (%u,%u,%u,%u,%p)",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    img._width,img._height,img._depth,img._spectrum,img._data);
      CImg<typename cimg::superset<T,t>::type> res(img._width,_height);






      typename cimg::superset<T,t>::type *ptrd = res._data;
      for (int j = 0; j<(int)((res)._height); ++j) for (int i = 0; i<(int)((res)._width); ++i) {
        typename cimg::superset2<T,t,double>::type value = 0; for (int k = 0; k<(int)((*this)._width); ++k) value+=(*this)(k,j)*img(i,k); *(ptrd++) = (typename cimg::superset<T,t>::type)value;
      }

      return res;
    }





    template<typename t>
    CImg<T>& operator/=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)(*ptrd / value);
      return *this;
    }





    CImg<T>& operator/=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator/=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)(*ptrd / mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)(*ptrd / mp(x,y,z,c)); ++ptrd; }
        else {
# 11147 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)(*ptrd / mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        div(CImg<T>(_width,_height,_depth,_spectrum,expression,true));
      }
      cimg::exception_mode() = omode;
      return *this;
    }
# 11168 "../src/CImg.h"
    template<typename t>
    CImg<T>& operator/=(const CImg<t>& img) {
      return (*this*img.get_invert()).move_to(*this);
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator/(const t value) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false)/=value;
    }






    CImg<Tfloat> operator/(const char *const expression) const {
      return CImg<Tfloat>(*this,false)/=expression;
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator/(const CImg<t>& img) const {
      return (*this)*img.get_invert();
    }





    template<typename t>
    CImg<T>& operator%=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)cimg::mod(*ptrd,(T)value);
      return *this;
    }





    CImg<T>& operator%=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator%=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)cimg::mod(*ptrd,(T)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::mod(*ptrd,(T)mp(x,y,z,c)); ++ptrd; }
        else {
# 11244 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::mod(*ptrd,(T)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        *this%=CImg<T>(_width,_height,_depth,_spectrum,expression,true);
      }
      cimg::exception_mode() = omode;
      return *this;
    }





    template<typename t>
    CImg<T>& operator%=(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return *this%=+img;
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = cimg::mod(*ptrd,(T)*(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = cimg::mod(*ptrd,(T)*(ptrs++));
      }
      return *this;
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator%(const t value) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false)%=value;
    }






    CImg<Tfloat> operator%(const char *const expression) const {
      return CImg<Tfloat>(*this,false)%=expression;
    }






    template<typename t>
    CImg<typename cimg::superset<T,t>::type> operator%(const CImg<t>& img) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false)%=img;
    }





    template<typename t>
    CImg<T>& operator&=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)((unsigned long)*ptrd & (unsigned long)value);
      return *this;
    }





    CImg<T>& operator&=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator&=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<')
          for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)((unsigned long)*ptrd & (unsigned long)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>')
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((unsigned long)*ptrd & (unsigned long)mp(x,y,z,c)); ++ptrd; }
        else {
# 11345 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((unsigned long)*ptrd & (unsigned long)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        *this&=CImg<T>(_width,_height,_depth,_spectrum,expression,true);
      }
      cimg::exception_mode() = omode;
      return *this;
    }





    template<typename t>
    CImg<T>& operator&=(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return *this&=+img;
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)((unsigned long)*ptrd & (unsigned long)*(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)((unsigned long)*ptrd & (unsigned long)*(ptrs++));
      }
      return *this;
    }






    template<typename t>
    CImg<T> operator&(const t value) const {
      return (+*this)&=value;
    }






    CImg<T> operator&(const char *const expression) const {
      return (+*this)&=expression;
    }






    template<typename t>
    CImg<T> operator&(const CImg<t>& img) const {
      return (+*this)&=img;
    }





    template<typename t>
    CImg<T>& operator|=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)((unsigned long)*ptrd | (unsigned long)value);
      return *this;
    }





    CImg<T>& operator|=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator|=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<')
          for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)((unsigned long)*ptrd | (unsigned long)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>')
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((unsigned long)*ptrd | (unsigned long)mp(x,y,z,c)); ++ptrd; }
        else {
# 11446 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((unsigned long)*ptrd | (unsigned long)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        *this|=CImg<T>(_width,_height,_depth,_spectrum,expression,true);
      }
      cimg::exception_mode() = omode;
      return *this;
    }





    template<typename t>
    CImg<T>& operator|=(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return *this|=+img;
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)((unsigned long)*ptrd | (unsigned long)*(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)((unsigned long)*ptrd | (unsigned long)*(ptrs++));
      }
      return *this;
    }






    template<typename t>
    CImg<T> operator|(const t value) const {
      return (+*this)|=value;
    }






    CImg<T> operator|(const char *const expression) const {
      return (+*this)|=expression;
    }






    template<typename t>
    CImg<T> operator|(const CImg<t>& img) const {
      return (+*this)|=img;
    }







    template<typename t>
    CImg<T>& operator^=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)((unsigned long)*ptrd ^ (unsigned long)value);
      return *this;
    }







    CImg<T>& operator^=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator^=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<')
          for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)((unsigned long)*ptrd ^ (unsigned long)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>')
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((unsigned long)*ptrd ^ (unsigned long)mp(x,y,z,c)); ++ptrd; }
        else {
# 11551 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((unsigned long)*ptrd ^ (unsigned long)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        *this^=CImg<T>(_width,_height,_depth,_spectrum,expression,true);
      }
      cimg::exception_mode() = omode;
      return *this;
    }







    template<typename t>
    CImg<T>& operator^=(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return *this^=+img;
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)((unsigned long)*ptrd ^ (unsigned long)*(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)((unsigned long)*ptrd ^ (unsigned long)*(ptrs++));
      }
      return *this;
    }






    template<typename t>
    CImg<T> operator^(const t value) const {
      return (+*this)^=value;
    }






    CImg<T> operator^(const char *const expression) const {
      return (+*this)^=expression;
    }






    template<typename t>
    CImg<T> operator^(const CImg<t>& img) const {
      return (+*this)^=img;
    }





    template<typename t>
    CImg<T>& operator<<=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)(((long)*ptrd) << (int)value);
      return *this;
    }





    CImg<T>& operator<<=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator<<=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)((long)*ptrd << (int)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((long)*ptrd << (int)mp(x,y,z,c)); ++ptrd; }
        else {
# 11652 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((long)*ptrd << (int)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        *this<<=CImg<T>(_width,_height,_depth,_spectrum,expression,true);
      }
      cimg::exception_mode() = omode;
      return *this;
    }





    template<typename t>
    CImg<T>& operator<<=(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return *this^=+img;
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)((long)*ptrd << (int)*(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)((long)*ptrd << (int)*(ptrs++));
      }
      return *this;
    }






    template<typename t>
    CImg<T> operator<<(const t value) const {
      return (+*this)<<=value;
    }






    CImg<T> operator<<(const char *const expression) const {
      return (+*this)<<=expression;
    }







    template<typename t>
    CImg<T> operator<<(const CImg<t>& img) const {
      return (+*this)<<=img;
    }





    template<typename t>
    CImg<T>& operator>>=(const t value) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)(((long)*ptrd) >> (int)value);
      return *this;
    }





    CImg<T>& operator>>=(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator<<=");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)((long)*ptrd >> (int)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((long)*ptrd >> (int)mp(x,y,z,c)); ++ptrd; }
        else {
# 11752 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)((long)*ptrd >> (int)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        *this>>=CImg<T>(_width,_height,_depth,_spectrum,expression,true);
      }
      cimg::exception_mode() = omode;
      return *this;
    }





    template<typename t>
    CImg<T>& operator>>=(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return *this^=+img;
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)((long)*ptrd >> (int)*(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)((long)*ptrd >> (int)*(ptrs++));
      }
      return *this;
    }






    template<typename t>
    CImg<T> operator>>(const t value) const {
      return (+*this)>>=value;
    }






    CImg<T> operator>>(const char *const expression) const {
      return (+*this)>>=expression;
    }







    template<typename t>
    CImg<T> operator>>(const CImg<t>& img) const {
      return (+*this)>>=img;
    }





    CImg<T> operator~() const {
      CImg<T> res(_width,_height,_depth,_spectrum);
      const T *ptrs = _data;
      for (T *ptrd = (res)._data, *_maxptrd = (res)._data + (res).size(); ptrd<_maxptrd; ++ptrd) { const unsigned long value = (unsigned long)*(ptrs++); *ptrd = (T)~value; }
      return res;
    }






    template<typename t>
    bool operator==(const t value) const {
      if (is_empty()) return false;
      typedef typename cimg::superset<T,t>::type Tt;
      bool is_equal = true;
      for (T *ptrd = _data + size(); is_equal && ptrd>_data; is_equal = ((Tt)*(--ptrd)==(Tt)value)) {}
      return is_equal;
    }






    bool operator==(const char *const expression) const {
      if (is_empty()) return !*expression;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      bool is_equal = true;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"operator<<=");
        const T *ptrs = *expression=='<'?end()-1:_data;
        if (*expression=='<')
          for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { if (!is_equal) break; is_equal = ((double)*(ptrs--)==mp(x,y,z,c)); }
        else if (*expression=='>')
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { if (!is_equal) break; is_equal = ((double)*(ptrs++)==mp(x,y,z,c)); }
        else for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { if (!is_equal) break; is_equal = ((double)*(ptrs++)==mp(x,y,z,c)); }
      } catch (CImgException&) {
        cimg::exception_mode() = omode;
        is_equal = (*this==CImg<T>(_width,_height,_depth,_spectrum,expression,true));
      }
      cimg::exception_mode() = omode;
      return is_equal;
    }
# 11881 "../src/CImg.h"
    template<typename t>
    bool operator==(const CImg<t>& img) const {
      typedef typename cimg::superset<T,t>::type Tt;
      const unsigned long siz = size();
      bool is_equal = true;
      if (siz!=img.size()) return false;
      t *ptrs = img._data + siz;
      for (T *ptrd = _data + siz; is_equal && ptrd>_data; is_equal = ((Tt)*(--ptrd)==(Tt)*(--ptrs))) {}
      return is_equal;
    }






    template<typename t>
    bool operator!=(const t value) const {
      return !((*this)==value);
    }






    bool operator!=(const char *const expression) const {
      return !((*this)==expression);
    }
# 11919 "../src/CImg.h"
    template<typename t>
    bool operator!=(const CImg<t>& img) const {
      return !((*this)==img);
    }
# 11954 "../src/CImg.h"
    template<typename t>
    CImgList<typename cimg::superset<T,t>::type> operator,(const CImg<t>& img) const {
      return CImgList<typename cimg::superset<T,t>::type>(*this,img);
    }
# 11969 "../src/CImg.h"
    template<typename t>
    CImgList<typename cimg::superset<T,t>::type> operator,(const CImgList<t>& list) const {
      return CImgList<typename cimg::superset<T,t>::type>(list,false).insert(*this,0);
    }
# 11989 "../src/CImg.h"
    CImgList<T> operator<(const char axis) const {
      return get_split(axis);
    }
# 12008 "../src/CImg.h"
    static const char* pixel_type() {
      return cimg::type<T>::string();
    }
# 12024 "../src/CImg.h"
    int width() const {
      return (int)_width;
    }
# 12039 "../src/CImg.h"
    int height() const {
      return (int)_height;
    }
# 12056 "../src/CImg.h"
    int depth() const {
      return (int)_depth;
    }
# 12075 "../src/CImg.h"
    int spectrum() const {
      return (int)_spectrum;
    }
# 12095 "../src/CImg.h"
    unsigned long size() const {
      return (unsigned long)_width*_height*_depth*_spectrum;
    }
# 12110 "../src/CImg.h"
    T* data() {
      return _data;
    }


    const T* data() const {
      return _data;
    }
# 12148 "../src/CImg.h"
    T* data(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int c=0) {
      return _data + x + y*(unsigned long)_width + z*(unsigned long)_width*_height +
        c*(unsigned long)_width*_height*_depth;
    }

    const T* data(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int c=0) const {
      return _data + x + y*_width + z*(unsigned long)_width*_height + c*(unsigned long)_width*_height*_depth;
    }
# 12174 "../src/CImg.h"
    long offset(const int x, const int y=0, const int z=0, const int c=0) const {
      return x + y*(long)_width + z*(long)_width*_height + c*(long)_width*_height*_depth;
    }







    iterator begin() {
      return _data;
    }


    const_iterator begin() const {
      return _data;
    }
# 12209 "../src/CImg.h"
    iterator end() {
      return _data + size();
    }


    const_iterator end() const {
      return _data + size();
    }







    T& front() {
      return *_data;
    }


    const T& front() const {
      return *_data;
    }
# 12240 "../src/CImg.h"
    T& back() {
      return *(_data + size() - 1);
    }


    const T& back() const {
      return *(_data + size() - 1);
    }
# 12262 "../src/CImg.h"
    T& at(const int offset, const T out_value) {
      return (offset<0 || offset>=(int)size())?(cimg::temporary(out_value)=out_value):(*this)[offset];
    }


    T at(const int offset, const T out_value) const {
      return (offset<0 || offset>=(int)size())?out_value:(*this)[offset];
    }
# 12285 "../src/CImg.h"
    T& at(const int offset) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "at(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _at(offset);
    }

    T& _at(const int offset) {
      const unsigned int siz = (unsigned int)size();
      return (*this)[offset<0?0:(unsigned int)offset>=siz?siz-1:offset];
    }


    T at(const int offset) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "at(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _at(offset);
    }

    T _at(const int offset) const {
      const unsigned int siz = (unsigned int)size();
      return (*this)[offset<0?0:(unsigned int)offset>=siz?siz-1:offset];
    }
# 12329 "../src/CImg.h"
    T& atX(const int x, const int y, const int z, const int c, const T out_value) {
      return (x<0 || x>=width())?(cimg::temporary(out_value)=out_value):(*this)(x,y,z,c);
    }


    T atX(const int x, const int y, const int z, const int c, const T out_value) const {
      return (x<0 || x>=width())?out_value:(*this)(x,y,z,c);
    }
# 12356 "../src/CImg.h"
    T& atX(const int x, const int y=0, const int z=0, const int c=0) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "atX(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _atX(x,y,z,c);
    }

    T& _atX(const int x, const int y=0, const int z=0, const int c=0) {
      return (*this)(x<0?0:(x>=width()?width()-1:x),y,z,c);
    }


    T atX(const int x, const int y=0, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "atX(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _atX(x,y,z,c);
    }

    T _atX(const int x, const int y=0, const int z=0, const int c=0) const {
      return (*this)(x<0?0:(x>=width()?width()-1:x),y,z,c);
    }





    T& atXY(const int x, const int y, const int z, const int c, const T out_value) {
      return (x<0 || y<0 || x>=width() || y>=height())?(cimg::temporary(out_value)=out_value):(*this)(x,y,z,c);
    }


    T atXY(const int x, const int y, const int z, const int c, const T out_value) const {
      return (x<0 || y<0 || x>=width() || y>=height())?out_value:(*this)(x,y,z,c);
    }
# 12401 "../src/CImg.h"
    T& atXY(const int x, const int y, const int z=0, const int c=0) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "atXY(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _atXY(x,y,z,c);
    }

    T& _atXY(const int x, const int y, const int z=0, const int c=0) {
      return (*this)(x<0?0:(x>=width()?width()-1:x), y<0?0:(y>=height()?height()-1:y),z,c);
    }


    T atXY(const int x, const int y, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "atXY(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _atXY(x,y,z,c);
    }

    T _atXY(const int x, const int y, const int z=0, const int c=0) const {
      return (*this)(x<0?0:(x>=width()?width()-1:x), y<0?0:(y>=height()?height()-1:y),z,c);
    }






    T& atXYZ(const int x, const int y, const int z, const int c, const T out_value) {
      return (x<0 || y<0 || z<0 || x>=width() || y>=height() || z>=depth())?
        (cimg::temporary(out_value)=out_value):(*this)(x,y,z,c);
    }


    T atXYZ(const int x, const int y, const int z, const int c, const T out_value) const {
      return (x<0 || y<0 || z<0 || x>=width() || y>=height() || z>=depth())?out_value:(*this)(x,y,z,c);
    }
# 12448 "../src/CImg.h"
    T& atXYZ(const int x, const int y, const int z, const int c=0) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "atXYZ(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _atXYZ(x,y,z,c);
    }

    T& _atXYZ(const int x, const int y, const int z, const int c=0) {
      return (*this)(x<0?0:(x>=width()?width()-1:x),y<0?0:(y>=height()?height()-1:y),
                     z<0?0:(z>=depth()?depth()-1:z),c);
    }


    T atXYZ(const int x, const int y, const int z, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "atXYZ(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _atXYZ(x,y,z,c);
    }

    T _atXYZ(const int x, const int y, const int z, const int c=0) const {
      return (*this)(x<0?0:(x>=width()?width()-1:x),y<0?0:(y>=height()?height()-1:y),
                     z<0?0:(z>=depth()?depth()-1:z),c);
    }






    T& atXYZC(const int x, const int y, const int z, const int c, const T out_value) {
      return (x<0 || y<0 || z<0 || c<0 || x>=width() || y>=height() || z>=depth() || c>=spectrum())?
        (cimg::temporary(out_value)=out_value):(*this)(x,y,z,c);
    }


    T atXYZC(const int x, const int y, const int z, const int c, const T out_value) const {
      return (x<0 || y<0 || z<0 || c<0 || x>=width() || y>=height() || z>=depth() || c>=spectrum())?out_value:
        (*this)(x,y,z,c);
    }
# 12498 "../src/CImg.h"
    T& atXYZC(const int x, const int y, const int z, const int c) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "atXYZC(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _atXYZC(x,y,z,c);
    }

    T& _atXYZC(const int x, const int y, const int z, const int c) {
      return (*this)(x<0?0:(x>=width()?width()-1:x), y<0?0:(y>=height()?height()-1:y),
                     z<0?0:(z>=depth()?depth()-1:z), c<0?0:(c>=spectrum()?spectrum()-1:c));
    }


    T atXYZC(const int x, const int y, const int z, const int c) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "atXYZC(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _atXYZC(x,y,z,c);
    }

    T _atXYZC(const int x, const int y, const int z, const int c) const {
      return (*this)(x<0?0:(x>=width()?width()-1:x), y<0?0:(y>=height()?height()-1:y),
                     z<0?0:(z>=depth()?depth()-1:z), c<0?0:(c>=spectrum()?spectrum()-1:c));
    }
# 12541 "../src/CImg.h"
    Tfloat linear_atX(const float fx, const int y, const int z, const int c, const T out_value) const {
      const int
        x = (int)fx - (fx>=0?0:1), nx = x + 1;
      const float
        dx = fx - x;
      const Tfloat
        Ic = (Tfloat)atX(x,y,z,c,out_value), In = (Tfloat)atXY(nx,y,z,c,out_value);
      return Ic + dx*(In-Ic);
    }
# 12568 "../src/CImg.h"
    Tfloat linear_atX(const float fx, const int y=0, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "linear_atX(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      return _linear_atX(fx,y,z,c);
    }

    Tfloat _linear_atX(const float fx, const int y=0, const int z=0, const int c=0) const {
      const float
        nfx = fx<0?0:(fx>_width-1?_width-1:fx);
      const unsigned int
        x = (unsigned int)nfx;
      const float
        dx = nfx - x;
      const unsigned int
        nx = dx>0?x+1:x;
      const Tfloat
        Ic = (Tfloat)(*this)(x,y,z,c), In = (Tfloat)(*this)(nx,y,z,c);
      return Ic + dx*(In-Ic);
    }






    Tfloat linear_atXY(const float fx, const float fy, const int z, const int c, const T out_value) const {
      const int
        x = (int)fx - (fx>=0?0:1), nx = x + 1,
        y = (int)fy - (fy>=0?0:1), ny = y + 1;
      const float
        dx = fx - x,
        dy = fy - y;
      const Tfloat
        Icc = (Tfloat)atXY(x,y,z,c,out_value), Inc = (Tfloat)atXY(nx,y,z,c,out_value),
        Icn = (Tfloat)atXY(x,ny,z,c,out_value), Inn = (Tfloat)atXY(nx,ny,z,c,out_value);
      return Icc + dx*(Inc-Icc + dy*(Icc+Inn-Icn-Inc)) + dy*(Icn-Icc);
    }
# 12617 "../src/CImg.h"
    Tfloat linear_atXY(const float fx, const float fy, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "linear_atXY(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      return _linear_atXY(fx,fy,z,c);
    }

    Tfloat _linear_atXY(const float fx, const float fy, const int z=0, const int c=0) const {
      const float
        nfx = fx<0?0:(fx>_width-1?_width-1:fx),
        nfy = fy<0?0:(fy>_height-1?_height-1:fy);
      const unsigned int
        x = (unsigned int)nfx,
        y = (unsigned int)nfy;
      const float
        dx = nfx - x,
        dy = nfy - y;
      const unsigned int
        nx = dx>0?x+1:x,
        ny = dy>0?y+1:y;
      const Tfloat
        Icc = (Tfloat)(*this)(x,y,z,c), Inc = (Tfloat)(*this)(nx,y,z,c),
        Icn = (Tfloat)(*this)(x,ny,z,c), Inn = (Tfloat)(*this)(nx,ny,z,c);
      return Icc + dx*(Inc-Icc + dy*(Icc+Inn-Icn-Inc)) + dy*(Icn-Icc);
    }






    Tfloat linear_atXYZ(const float fx, const float fy, const float fz, const int c, const T out_value) const {
      const int
        x = (int)fx - (fx>=0?0:1), nx = x + 1,
        y = (int)fy - (fy>=0?0:1), ny = y + 1,
        z = (int)fz - (fz>=0?0:1), nz = z + 1;
      const float
        dx = fx - x,
        dy = fy - y,
        dz = fz - z;
      const Tfloat
        Iccc = (Tfloat)atXYZ(x,y,z,c,out_value), Incc = (Tfloat)atXYZ(nx,y,z,c,out_value),
        Icnc = (Tfloat)atXYZ(x,ny,z,c,out_value), Innc = (Tfloat)atXYZ(nx,ny,z,c,out_value),
        Iccn = (Tfloat)atXYZ(x,y,nz,c,out_value), Incn = (Tfloat)atXYZ(nx,y,nz,c,out_value),
        Icnn = (Tfloat)atXYZ(x,ny,nz,c,out_value), Innn = (Tfloat)atXYZ(nx,ny,nz,c,out_value);
      return Iccc +
        dx*(Incc-Iccc +
            dy*(Iccc+Innc-Icnc-Incc +
                dz*(Iccn+Innn+Icnc+Incc-Icnn-Incn-Iccc-Innc)) +
            dz*(Iccc+Incn-Iccn-Incc)) +
        dy*(Icnc-Iccc +
            dz*(Iccc+Icnn-Iccn-Icnc)) +
        dz*(Iccn-Iccc);
    }
# 12682 "../src/CImg.h"
    Tfloat linear_atXYZ(const float fx, const float fy=0, const float fz=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "linear_atXYZ(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      return _linear_atXYZ(fx,fy,fz,c);
    }

    Tfloat _linear_atXYZ(const float fx, const float fy=0, const float fz=0, const int c=0) const {
      const float
        nfx = fx<0?0:(fx>_width-1?_width-1:fx),
        nfy = fy<0?0:(fy>_height-1?_height-1:fy),
        nfz = fz<0?0:(fz>_depth-1?_depth-1:fz);
      const unsigned int
        x = (unsigned int)nfx,
        y = (unsigned int)nfy,
        z = (unsigned int)nfz;
      const float
        dx = nfx - x,
        dy = nfy - y,
        dz = nfz - z;
      const unsigned int
        nx = dx>0?x+1:x,
        ny = dy>0?y+1:y,
        nz = dz>0?z+1:z;
      const Tfloat
        Iccc = (Tfloat)(*this)(x,y,z,c), Incc = (Tfloat)(*this)(nx,y,z,c),
        Icnc = (Tfloat)(*this)(x,ny,z,c), Innc = (Tfloat)(*this)(nx,ny,z,c),
        Iccn = (Tfloat)(*this)(x,y,nz,c), Incn = (Tfloat)(*this)(nx,y,nz,c),
        Icnn = (Tfloat)(*this)(x,ny,nz,c), Innn = (Tfloat)(*this)(nx,ny,nz,c);
      return Iccc +
        dx*(Incc-Iccc +
            dy*(Iccc+Innc-Icnc-Incc +
                dz*(Iccn+Innn+Icnc+Incc-Icnn-Incn-Iccc-Innc)) +
            dz*(Iccc+Incn-Iccn-Incc)) +
        dy*(Icnc-Iccc +
            dz*(Iccc+Icnn-Iccn-Icnc)) +
        dz*(Iccn-Iccc);
    }






    Tfloat linear_atXYZC(const float fx, const float fy, const float fz, const float fc, const T out_value) const {
      const int
        x = (int)fx - (fx>=0?0:1), nx = x + 1,
        y = (int)fy - (fy>=0?0:1), ny = y + 1,
        z = (int)fz - (fz>=0?0:1), nz = z + 1,
        c = (int)fc - (fc>=0?0:1), nc = c + 1;
      const float
        dx = fx - x,
        dy = fy - y,
        dz = fz - z,
        dc = fc - c;
      const Tfloat
        Icccc = (Tfloat)atXYZC(x,y,z,c,out_value), Inccc = (Tfloat)atXYZC(nx,y,z,c,out_value),
        Icncc = (Tfloat)atXYZC(x,ny,z,c,out_value), Inncc = (Tfloat)atXYZC(nx,ny,z,c,out_value),
        Iccnc = (Tfloat)atXYZC(x,y,nz,c,out_value), Incnc = (Tfloat)atXYZC(nx,y,nz,c,out_value),
        Icnnc = (Tfloat)atXYZC(x,ny,nz,c,out_value), Innnc = (Tfloat)atXYZC(nx,ny,nz,c,out_value),
        Icccn = (Tfloat)atXYZC(x,y,z,nc,out_value), Inccn = (Tfloat)atXYZC(nx,y,z,nc,out_value),
        Icncn = (Tfloat)atXYZC(x,ny,z,nc,out_value), Inncn = (Tfloat)atXYZC(nx,ny,z,nc,out_value),
        Iccnn = (Tfloat)atXYZC(x,y,nz,nc,out_value), Incnn = (Tfloat)atXYZC(nx,y,nz,nc,out_value),
        Icnnn = (Tfloat)atXYZC(x,ny,nz,nc,out_value), Innnn = (Tfloat)atXYZC(nx,ny,nz,nc,out_value);
      return Icccc +
        dx*(Inccc-Icccc +
            dy*(Icccc+Inncc-Icncc-Inccc +
                dz*(Iccnc+Innnc+Icncc+Inccc-Icnnc-Incnc-Icccc-Inncc +
                    dc*(Iccnn+Innnn+Icncn+Inccn+Icnnc+Incnc+Icccc+Inncc-
                        Icnnn-Incnn-Icccn-Inncn-Iccnc-Innnc-Icncc-Inccc)) +
                dc*(Icccn+Inncn+Icncc+Inccc-Icncn-Inccn-Icccc-Inncc)) +
            dz*(Icccc+Incnc-Iccnc-Inccc +
                dc*(Icccn+Incnn+Iccnc+Inccc-Iccnn-Inccn-Icccc-Incnc)) +
            dc*(Icccc+Inccn-Inccc-Icccn)) +
        dy*(Icncc-Icccc +
            dz*(Icccc+Icnnc-Iccnc-Icncc +
                dc*(Icccn+Icnnn+Iccnc+Icncc-Iccnn-Icncn-Icccc-Icnnc)) +
            dc*(Icccc+Icncn-Icncc-Icccn)) +
        dz*(Iccnc-Icccc +
            dc*(Icccc+Iccnn-Iccnc-Icccn)) +
        dc*(Icccn-Icccc);
    }
# 12775 "../src/CImg.h"
    Tfloat linear_atXYZC(const float fx, const float fy=0, const float fz=0, const float fc=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "linear_atXYZC(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      return _linear_atXYZC(fx,fy,fz,fc);
    }

    Tfloat _linear_atXYZC(const float fx, const float fy=0, const float fz=0, const float fc=0) const {
      const float
        nfx = fx<0?0:(fx>_width-1?_width-1:fx),
        nfy = fy<0?0:(fy>_height-1?_height-1:fy),
        nfz = fz<0?0:(fz>_depth-1?_depth-1:fz),
        nfc = fc<0?0:(fc>_spectrum-1?_spectrum-1:fc);
      const unsigned int
        x = (unsigned int)nfx,
        y = (unsigned int)nfy,
        z = (unsigned int)nfz,
        c = (unsigned int)nfc;
      const float
        dx = nfx - x,
        dy = nfy - y,
        dz = nfz - z,
        dc = nfc - c;
      const unsigned int
        nx = dx>0?x+1:x,
        ny = dy>0?y+1:y,
        nz = dz>0?z+1:z,
        nc = dc>0?c+1:c;
      const Tfloat
        Icccc = (Tfloat)(*this)(x,y,z,c), Inccc = (Tfloat)(*this)(nx,y,z,c),
        Icncc = (Tfloat)(*this)(x,ny,z,c), Inncc = (Tfloat)(*this)(nx,ny,z,c),
        Iccnc = (Tfloat)(*this)(x,y,nz,c), Incnc = (Tfloat)(*this)(nx,y,nz,c),
        Icnnc = (Tfloat)(*this)(x,ny,nz,c), Innnc = (Tfloat)(*this)(nx,ny,nz,c),
        Icccn = (Tfloat)(*this)(x,y,z,nc), Inccn = (Tfloat)(*this)(nx,y,z,nc),
        Icncn = (Tfloat)(*this)(x,ny,z,nc), Inncn = (Tfloat)(*this)(nx,ny,z,nc),
        Iccnn = (Tfloat)(*this)(x,y,nz,nc), Incnn = (Tfloat)(*this)(nx,y,nz,nc),
        Icnnn = (Tfloat)(*this)(x,ny,nz,nc), Innnn = (Tfloat)(*this)(nx,ny,nz,nc);
      return Icccc +
        dx*(Inccc-Icccc +
            dy*(Icccc+Inncc-Icncc-Inccc +
                dz*(Iccnc+Innnc+Icncc+Inccc-Icnnc-Incnc-Icccc-Inncc +
                    dc*(Iccnn+Innnn+Icncn+Inccn+Icnnc+Incnc+Icccc+Inncc-
                        Icnnn-Incnn-Icccn-Inncn-Iccnc-Innnc-Icncc-Inccc)) +
                dc*(Icccn+Inncn+Icncc+Inccc-Icncn-Inccn-Icccc-Inncc)) +
            dz*(Icccc+Incnc-Iccnc-Inccc +
                dc*(Icccn+Incnn+Iccnc+Inccc-Iccnn-Inccn-Icccc-Incnc)) +
            dc*(Icccc+Inccn-Inccc-Icccn)) +
        dy*(Icncc-Icccc +
            dz*(Icccc+Icnnc-Iccnc-Icncc +
                dc*(Icccn+Icnnn+Iccnc+Icncc-Iccnn-Icncn-Icccc-Icnnc)) +
            dc*(Icccc+Icncn-Icncc-Icccn)) +
        dz*(Iccnc-Icccc +
            dc*(Icccc+Iccnn-Iccnc-Icccn)) +
        dc*(Icccn-Icccc);
    }
# 12850 "../src/CImg.h"
    Tfloat cubic_atX(const float fx, const int y, const int z, const int c, const T out_value) const {
      const int
        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2;
      const float
        dx = fx - x;
      const Tfloat
        Ip = (Tfloat)atX(px,y,z,c,out_value), Ic = (Tfloat)atX(x,y,z,c,out_value),
        In = (Tfloat)atX(nx,y,z,c,out_value), Ia = (Tfloat)atX(ax,y,z,c,out_value);
      return Ic + 0.5f*(dx*(-Ip+In) + dx*dx*(2*Ip-5*Ic+4*In-Ia) + dx*dx*dx*(-Ip+3*Ic-3*In+Ia));
    }






    Tfloat cubic_atX(const float fx, const int y, const int z, const int c, const T out_value,
                     const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = cubic_atX(fx,y,z,c,out_value);
      return val<min_value?min_value:val>max_value?max_value:val;
    }
# 12889 "../src/CImg.h"
    Tfloat cubic_atX(const float fx, const int y=0, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "cubic_atX(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _cubic_atX(fx,y,z,c);
    }

    Tfloat _cubic_atX(const float fx, const int y=0, const int z=0, const int c=0) const {
      const float
        nfx = fx<0?0:(fx>_width-1?_width-1:fx);
      const int
        x = (int)nfx;
      const float
        dx = nfx - x;
      const int
        px = x-1<0?0:x-1, nx = dx>0?x+1:x, ax = x+2>=width()?width()-1:x+2;
      const Tfloat
        Ip = (Tfloat)(*this)(px,y,z,c), Ic = (Tfloat)(*this)(x,y,z,c),
        In = (Tfloat)(*this)(nx,y,z,c), Ia = (Tfloat)(*this)(ax,y,z,c);
      return Ic + 0.5f*(dx*(-Ip+In) + dx*dx*(2*Ip-5*Ic+4*In-Ia) + dx*dx*dx*(-Ip+3*Ic-3*In+Ia));
    }






    Tfloat cubic_atX(const float fx, const int y, const int z, const int c,
                     const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = cubic_atX(fx,y,z,c);
      return val<min_value?min_value:val>max_value?max_value:val;
    }

    Tfloat _cubic_atX(const float fx, const int y, const int z, const int c,
                      const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = _cubic_atX(fx,y,z,c);
      return val<min_value?min_value:val>max_value?max_value:val;
    }






    Tfloat cubic_atXY(const float fx, const float fy, const int z, const int c, const T out_value) const {
      const int
        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2,
        y = (int)fy - (fy>=0?0:1), py = y - 1, ny = y + 1, ay = y + 2;
      const float dx = fx - x, dy = fy - y;
      const Tfloat
        Ipp = (Tfloat)atXY(px,py,z,c,out_value), Icp = (Tfloat)atXY(x,py,z,c,out_value),
        Inp = (Tfloat)atXY(nx,py,z,c,out_value), Iap = (Tfloat)atXY(ax,py,z,c,out_value),
        Ip = Icp + 0.5f*(dx*(-Ipp+Inp) + dx*dx*(2*Ipp-5*Icp+4*Inp-Iap) + dx*dx*dx*(-Ipp+3*Icp-3*Inp+Iap)),
        Ipc = (Tfloat)atXY(px,y,z,c,out_value), Icc = (Tfloat)atXY(x, y,z,c,out_value),
        Inc = (Tfloat)atXY(nx,y,z,c,out_value), Iac = (Tfloat)atXY(ax,y,z,c,out_value),
        Ic = Icc + 0.5f*(dx*(-Ipc+Inc) + dx*dx*(2*Ipc-5*Icc+4*Inc-Iac) + dx*dx*dx*(-Ipc+3*Icc-3*Inc+Iac)),
        Ipn = (Tfloat)atXY(px,ny,z,c,out_value), Icn = (Tfloat)atXY(x,ny,z,c,out_value),
        Inn = (Tfloat)atXY(nx,ny,z,c,out_value), Ian = (Tfloat)atXY(ax,ny,z,c,out_value),
        In = Icn + 0.5f*(dx*(-Ipn+Inn) + dx*dx*(2*Ipn-5*Icn+4*Inn-Ian) + dx*dx*dx*(-Ipn+3*Icn-3*Inn+Ian)),
        Ipa = (Tfloat)atXY(px,ay,z,c,out_value), Ica = (Tfloat)atXY(x,ay,z,c,out_value),
        Ina = (Tfloat)atXY(nx,ay,z,c,out_value), Iaa = (Tfloat)atXY(ax,ay,z,c,out_value),
        Ia = Ica + 0.5f*(dx*(-Ipa+Ina) + dx*dx*(2*Ipa-5*Ica+4*Ina-Iaa) + dx*dx*dx*(-Ipa+3*Ica-3*Ina+Iaa));
      return Ic + 0.5f*(dy*(-Ip+In) + dy*dy*(2*Ip-5*Ic+4*In-Ia) + dy*dy*dy*(-Ip+3*Ic-3*In+Ia));
    }






    Tfloat cubic_atXY(const float fx, const float fy, const int z, const int c, const T out_value,
                      const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = cubic_atXY(fx,fy,z,c,out_value);
      return val<min_value?min_value:val>max_value?max_value:val;
    }
# 12974 "../src/CImg.h"
    Tfloat cubic_atXY(const float fx, const float fy, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "cubic_atXY(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _cubic_atXY(fx,fy,z,c);
    }

    Tfloat _cubic_atXY(const float fx, const float fy, const int z=0, const int c=0) const {
      const float
        nfx = fx<0?0:(fx>_width-1?_width-1:fx),
        nfy = fy<0?0:(fy>_height-1?_height-1:fy);
      const int x = (int)nfx, y = (int)nfy;
      const float dx = nfx - x, dy = nfy - y;
      const int
        px = x-1<0?0:x-1, nx = dx>0?x+1:x, ax = x+2>=width()?width()-1:x+2,
        py = y-1<0?0:y-1, ny = dy>0?y+1:y, ay = y+2>=height()?height()-1:y+2;
      const Tfloat
        Ipp = (Tfloat)(*this)(px,py,z,c), Icp = (Tfloat)(*this)(x,py,z,c), Inp = (Tfloat)(*this)(nx,py,z,c),
        Iap = (Tfloat)(*this)(ax,py,z,c),
        Ip = Icp + 0.5f*(dx*(-Ipp+Inp) + dx*dx*(2*Ipp-5*Icp+4*Inp-Iap) + dx*dx*dx*(-Ipp+3*Icp-3*Inp+Iap)),
        Ipc = (Tfloat)(*this)(px,y,z,c), Icc = (Tfloat)(*this)(x, y,z,c), Inc = (Tfloat)(*this)(nx,y,z,c),
        Iac = (Tfloat)(*this)(ax,y,z,c),
        Ic = Icc + 0.5f*(dx*(-Ipc+Inc) + dx*dx*(2*Ipc-5*Icc+4*Inc-Iac) + dx*dx*dx*(-Ipc+3*Icc-3*Inc+Iac)),
        Ipn = (Tfloat)(*this)(px,ny,z,c), Icn = (Tfloat)(*this)(x,ny,z,c), Inn = (Tfloat)(*this)(nx,ny,z,c),
        Ian = (Tfloat)(*this)(ax,ny,z,c),
        In = Icn + 0.5f*(dx*(-Ipn+Inn) + dx*dx*(2*Ipn-5*Icn+4*Inn-Ian) + dx*dx*dx*(-Ipn+3*Icn-3*Inn+Ian)),
        Ipa = (Tfloat)(*this)(px,ay,z,c), Ica = (Tfloat)(*this)(x,ay,z,c), Ina = (Tfloat)(*this)(nx,ay,z,c),
        Iaa = (Tfloat)(*this)(ax,ay,z,c),
        Ia = Ica + 0.5f*(dx*(-Ipa+Ina) + dx*dx*(2*Ipa-5*Ica+4*Ina-Iaa) + dx*dx*dx*(-Ipa+3*Ica-3*Ina+Iaa));
      return Ic + 0.5f*(dy*(-Ip+In) + dy*dy*(2*Ip-5*Ic+4*In-Ia) + dy*dy*dy*(-Ip+3*Ic-3*In+Ia));
    }






    Tfloat cubic_atXY(const float fx, const float fy, const int z, const int c,
                      const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = cubic_atXY(fx,fy,z,c);
      return val<min_value?min_value:val>max_value?max_value:val;
    }

    Tfloat _cubic_atXY(const float fx, const float fy, const int z, const int c,
                       const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = _cubic_atXY(fx,fy,z,c);
      return val<min_value?min_value:val>max_value?max_value:val;
    }






    Tfloat cubic_atXYZ(const float fx, const float fy, const float fz, const int c, const T out_value) const {
      const int
        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2,
        y = (int)fy - (fy>=0?0:1), py = y - 1, ny = y + 1, ay = y + 2,
        z = (int)fz - (fz>=0?0:1), pz = z - 1, nz = z + 1, az = z + 2;
      const float dx = fx - x, dy = fy - y, dz = fz - z;
      const Tfloat
        Ippp = (Tfloat)atXYZ(px,py,pz,c,out_value), Icpp = (Tfloat)atXYZ(x,py,pz,c,out_value),
        Inpp = (Tfloat)atXYZ(nx,py,pz,c,out_value), Iapp = (Tfloat)atXYZ(ax,py,pz,c,out_value),
        Ipp = Icpp + 0.5f*(dx*(-Ippp+Inpp) + dx*dx*(2*Ippp-5*Icpp+4*Inpp-Iapp) + dx*dx*dx*(-Ippp+3*Icpp-3*Inpp+Iapp)),
        Ipcp = (Tfloat)atXYZ(px,y,pz,c,out_value), Iccp = (Tfloat)atXYZ(x, y,pz,c,out_value),
        Incp = (Tfloat)atXYZ(nx,y,pz,c,out_value), Iacp = (Tfloat)atXYZ(ax,y,pz,c,out_value),
        Icp = Iccp + 0.5f*(dx*(-Ipcp+Incp) + dx*dx*(2*Ipcp-5*Iccp+4*Incp-Iacp) + dx*dx*dx*(-Ipcp+3*Iccp-3*Incp+Iacp)),
        Ipnp = (Tfloat)atXYZ(px,ny,pz,c,out_value), Icnp = (Tfloat)atXYZ(x,ny,pz,c,out_value),
        Innp = (Tfloat)atXYZ(nx,ny,pz,c,out_value), Ianp = (Tfloat)atXYZ(ax,ny,pz,c,out_value),
        Inp = Icnp + 0.5f*(dx*(-Ipnp+Innp) + dx*dx*(2*Ipnp-5*Icnp+4*Innp-Ianp) + dx*dx*dx*(-Ipnp+3*Icnp-3*Innp+Ianp)),
        Ipap = (Tfloat)atXYZ(px,ay,pz,c,out_value), Icap = (Tfloat)atXYZ(x,ay,pz,c,out_value),
        Inap = (Tfloat)atXYZ(nx,ay,pz,c,out_value), Iaap = (Tfloat)atXYZ(ax,ay,pz,c,out_value),
        Iap = Icap + 0.5f*(dx*(-Ipap+Inap) + dx*dx*(2*Ipap-5*Icap+4*Inap-Iaap) + dx*dx*dx*(-Ipap+3*Icap-3*Inap+Iaap)),
        Ip = Icp + 0.5f*(dy*(-Ipp+Inp) + dy*dy*(2*Ipp-5*Icp+4*Inp-Iap) + dy*dy*dy*(-Ipp+3*Icp-3*Inp+Iap)),
        Ippc = (Tfloat)atXYZ(px,py,z,c,out_value), Icpc = (Tfloat)atXYZ(x,py,z,c,out_value),
        Inpc = (Tfloat)atXYZ(nx,py,z,c,out_value), Iapc = (Tfloat)atXYZ(ax,py,z,c,out_value),
        Ipc = Icpc + 0.5f*(dx*(-Ippc+Inpc) + dx*dx*(2*Ippc-5*Icpc+4*Inpc-Iapc) + dx*dx*dx*(-Ippc+3*Icpc-3*Inpc+Iapc)),
        Ipcc = (Tfloat)atXYZ(px,y,z,c,out_value), Iccc = (Tfloat)atXYZ(x, y,z,c,out_value),
        Incc = (Tfloat)atXYZ(nx,y,z,c,out_value), Iacc = (Tfloat)atXYZ(ax,y,z,c,out_value),
        Icc = Iccc + 0.5f*(dx*(-Ipcc+Incc) + dx*dx*(2*Ipcc-5*Iccc+4*Incc-Iacc) + dx*dx*dx*(-Ipcc+3*Iccc-3*Incc+Iacc)),
        Ipnc = (Tfloat)atXYZ(px,ny,z,c,out_value), Icnc = (Tfloat)atXYZ(x,ny,z,c,out_value),
        Innc = (Tfloat)atXYZ(nx,ny,z,c,out_value), Ianc = (Tfloat)atXYZ(ax,ny,z,c,out_value),
        Inc = Icnc + 0.5f*(dx*(-Ipnc+Innc) + dx*dx*(2*Ipnc-5*Icnc+4*Innc-Ianc) + dx*dx*dx*(-Ipnc+3*Icnc-3*Innc+Ianc)),
        Ipac = (Tfloat)atXYZ(px,ay,z,c,out_value), Icac = (Tfloat)atXYZ(x,ay,z,c,out_value),
        Inac = (Tfloat)atXYZ(nx,ay,z,c,out_value), Iaac = (Tfloat)atXYZ(ax,ay,z,c,out_value),
        Iac = Icac + 0.5f*(dx*(-Ipac+Inac) + dx*dx*(2*Ipac-5*Icac+4*Inac-Iaac) + dx*dx*dx*(-Ipac+3*Icac-3*Inac+Iaac)),
        Ic = Icc + 0.5f*(dy*(-Ipc+Inc) + dy*dy*(2*Ipc-5*Icc+4*Inc-Iac) + dy*dy*dy*(-Ipc+3*Icc-3*Inc+Iac)),
        Ippn = (Tfloat)atXYZ(px,py,nz,c,out_value), Icpn = (Tfloat)atXYZ(x,py,nz,c,out_value),
        Inpn = (Tfloat)atXYZ(nx,py,nz,c,out_value), Iapn = (Tfloat)atXYZ(ax,py,nz,c,out_value),
        Ipn = Icpn + 0.5f*(dx*(-Ippn+Inpn) + dx*dx*(2*Ippn-5*Icpn+4*Inpn-Iapn) + dx*dx*dx*(-Ippn+3*Icpn-3*Inpn+Iapn)),
        Ipcn = (Tfloat)atXYZ(px,y,nz,c,out_value), Iccn = (Tfloat)atXYZ(x, y,nz,c,out_value),
        Incn = (Tfloat)atXYZ(nx,y,nz,c,out_value), Iacn = (Tfloat)atXYZ(ax,y,nz,c,out_value),
        Icn = Iccn + 0.5f*(dx*(-Ipcn+Incn) + dx*dx*(2*Ipcn-5*Iccn+4*Incn-Iacn) + dx*dx*dx*(-Ipcn+3*Iccn-3*Incn+Iacn)),
        Ipnn = (Tfloat)atXYZ(px,ny,nz,c,out_value), Icnn = (Tfloat)atXYZ(x,ny,nz,c,out_value),
        Innn = (Tfloat)atXYZ(nx,ny,nz,c,out_value), Iann = (Tfloat)atXYZ(ax,ny,nz,c,out_value),
        Inn = Icnn + 0.5f*(dx*(-Ipnn+Innn) + dx*dx*(2*Ipnn-5*Icnn+4*Innn-Iann) + dx*dx*dx*(-Ipnn+3*Icnn-3*Innn+Iann)),
        Ipan = (Tfloat)atXYZ(px,ay,nz,c,out_value), Ican = (Tfloat)atXYZ(x,ay,nz,c,out_value),
        Inan = (Tfloat)atXYZ(nx,ay,nz,c,out_value), Iaan = (Tfloat)atXYZ(ax,ay,nz,c,out_value),
        Ian = Ican + 0.5f*(dx*(-Ipan+Inan) + dx*dx*(2*Ipan-5*Ican+4*Inan-Iaan) + dx*dx*dx*(-Ipan+3*Ican-3*Inan+Iaan)),
        In = Icn + 0.5f*(dy*(-Ipn+Inn) + dy*dy*(2*Ipn-5*Icn+4*Inn-Ian) + dy*dy*dy*(-Ipn+3*Icn-3*Inn+Ian)),
        Ippa = (Tfloat)atXYZ(px,py,az,c,out_value), Icpa = (Tfloat)atXYZ(x,py,az,c,out_value),
        Inpa = (Tfloat)atXYZ(nx,py,az,c,out_value), Iapa = (Tfloat)atXYZ(ax,py,az,c,out_value),
        Ipa = Icpa + 0.5f*(dx*(-Ippa+Inpa) + dx*dx*(2*Ippa-5*Icpa+4*Inpa-Iapa) + dx*dx*dx*(-Ippa+3*Icpa-3*Inpa+Iapa)),
        Ipca = (Tfloat)atXYZ(px,y,az,c,out_value), Icca = (Tfloat)atXYZ(x, y,az,c,out_value),
        Inca = (Tfloat)atXYZ(nx,y,az,c,out_value), Iaca = (Tfloat)atXYZ(ax,y,az,c,out_value),
        Ica = Icca + 0.5f*(dx*(-Ipca+Inca) + dx*dx*(2*Ipca-5*Icca+4*Inca-Iaca) + dx*dx*dx*(-Ipca+3*Icca-3*Inca+Iaca)),
        Ipna = (Tfloat)atXYZ(px,ny,az,c,out_value), Icna = (Tfloat)atXYZ(x,ny,az,c,out_value),
        Inna = (Tfloat)atXYZ(nx,ny,az,c,out_value), Iana = (Tfloat)atXYZ(ax,ny,az,c,out_value),
        Ina = Icna + 0.5f*(dx*(-Ipna+Inna) + dx*dx*(2*Ipna-5*Icna+4*Inna-Iana) + dx*dx*dx*(-Ipna+3*Icna-3*Inna+Iana)),
        Ipaa = (Tfloat)atXYZ(px,ay,az,c,out_value), Icaa = (Tfloat)atXYZ(x,ay,az,c,out_value),
        Inaa = (Tfloat)atXYZ(nx,ay,az,c,out_value), Iaaa = (Tfloat)atXYZ(ax,ay,az,c,out_value),
        Iaa = Icaa + 0.5f*(dx*(-Ipaa+Inaa) + dx*dx*(2*Ipaa-5*Icaa+4*Inaa-Iaaa) + dx*dx*dx*(-Ipaa+3*Icaa-3*Inaa+Iaaa)),
        Ia = Ica + 0.5f*(dy*(-Ipa+Ina) + dy*dy*(2*Ipa-5*Ica+4*Ina-Iaa) + dy*dy*dy*(-Ipa+3*Ica-3*Ina+Iaa));
      return Ic + 0.5f*(dz*(-Ip+In) + dz*dz*(2*Ip-5*Ic+4*In-Ia) + dz*dz*dz*(-Ip+3*Ic-3*In+Ia));
    }






    Tfloat cubic_atXYZ(const float fx, const float fy, const float fz, const int c, const T out_value,
                       const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = cubic_atXYZ(fx,fy,fz,c,out_value);
      return val<min_value?min_value:val>max_value?max_value:val;
    }
# 13110 "../src/CImg.h"
    Tfloat cubic_atXYZ(const float fx, const float fy, const float fz, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "cubic_atXYZ(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      return _cubic_atXYZ(fx,fy,fz,c);
    }

    Tfloat _cubic_atXYZ(const float fx, const float fy, const float fz, const int c=0) const {
      const float
        nfx = fx<0?0:(fx>_width-1?_width-1:fx),
        nfy = fy<0?0:(fy>_height-1?_height-1:fy),
        nfz = fz<0?0:(fz>_depth-1?_depth-1:fz);
      const int x = (int)nfx, y = (int)nfy, z = (int)nfz;
      const float dx = nfx - x, dy = nfy - y, dz = nfz - z;
      const int
        px = x-1<0?0:x-1, nx = dx>0?x+1:x, ax = x+2>=width()?width()-1:x+2,
        py = y-1<0?0:y-1, ny = dy>0?y+1:y, ay = y+2>=height()?height()-1:y+2,
        pz = z-1<0?0:z-1, nz = dz>0?z+1:z, az = z+2>=depth()?depth()-1:z+2;
      const Tfloat
        Ippp = (Tfloat)(*this)(px,py,pz,c), Icpp = (Tfloat)(*this)(x,py,pz,c),
        Inpp = (Tfloat)(*this)(nx,py,pz,c), Iapp = (Tfloat)(*this)(ax,py,pz,c),
        Ipp = Icpp + 0.5f*(dx*(-Ippp+Inpp) + dx*dx*(2*Ippp-5*Icpp+4*Inpp-Iapp) + dx*dx*dx*(-Ippp+3*Icpp-3*Inpp+Iapp)),
        Ipcp = (Tfloat)(*this)(px,y,pz,c), Iccp = (Tfloat)(*this)(x, y,pz,c),
        Incp = (Tfloat)(*this)(nx,y,pz,c), Iacp = (Tfloat)(*this)(ax,y,pz,c),
        Icp = Iccp + 0.5f*(dx*(-Ipcp+Incp) + dx*dx*(2*Ipcp-5*Iccp+4*Incp-Iacp) + dx*dx*dx*(-Ipcp+3*Iccp-3*Incp+Iacp)),
        Ipnp = (Tfloat)(*this)(px,ny,pz,c), Icnp = (Tfloat)(*this)(x,ny,pz,c),
        Innp = (Tfloat)(*this)(nx,ny,pz,c), Ianp = (Tfloat)(*this)(ax,ny,pz,c),
        Inp = Icnp + 0.5f*(dx*(-Ipnp+Innp) + dx*dx*(2*Ipnp-5*Icnp+4*Innp-Ianp) + dx*dx*dx*(-Ipnp+3*Icnp-3*Innp+Ianp)),
        Ipap = (Tfloat)(*this)(px,ay,pz,c), Icap = (Tfloat)(*this)(x,ay,pz,c),
        Inap = (Tfloat)(*this)(nx,ay,pz,c), Iaap = (Tfloat)(*this)(ax,ay,pz,c),
        Iap = Icap + 0.5f*(dx*(-Ipap+Inap) + dx*dx*(2*Ipap-5*Icap+4*Inap-Iaap) + dx*dx*dx*(-Ipap+3*Icap-3*Inap+Iaap)),
        Ip = Icp + 0.5f*(dy*(-Ipp+Inp) + dy*dy*(2*Ipp-5*Icp+4*Inp-Iap) + dy*dy*dy*(-Ipp+3*Icp-3*Inp+Iap)),
        Ippc = (Tfloat)(*this)(px,py,z,c), Icpc = (Tfloat)(*this)(x,py,z,c),
        Inpc = (Tfloat)(*this)(nx,py,z,c), Iapc = (Tfloat)(*this)(ax,py,z,c),
        Ipc = Icpc + 0.5f*(dx*(-Ippc+Inpc) + dx*dx*(2*Ippc-5*Icpc+4*Inpc-Iapc) + dx*dx*dx*(-Ippc+3*Icpc-3*Inpc+Iapc)),
        Ipcc = (Tfloat)(*this)(px,y,z,c), Iccc = (Tfloat)(*this)(x, y,z,c),
        Incc = (Tfloat)(*this)(nx,y,z,c), Iacc = (Tfloat)(*this)(ax,y,z,c),
        Icc = Iccc + 0.5f*(dx*(-Ipcc+Incc) + dx*dx*(2*Ipcc-5*Iccc+4*Incc-Iacc) + dx*dx*dx*(-Ipcc+3*Iccc-3*Incc+Iacc)),
        Ipnc = (Tfloat)(*this)(px,ny,z,c), Icnc = (Tfloat)(*this)(x,ny,z,c),
        Innc = (Tfloat)(*this)(nx,ny,z,c), Ianc = (Tfloat)(*this)(ax,ny,z,c),
        Inc = Icnc + 0.5f*(dx*(-Ipnc+Innc) + dx*dx*(2*Ipnc-5*Icnc+4*Innc-Ianc) + dx*dx*dx*(-Ipnc+3*Icnc-3*Innc+Ianc)),
        Ipac = (Tfloat)(*this)(px,ay,z,c), Icac = (Tfloat)(*this)(x,ay,z,c),
        Inac = (Tfloat)(*this)(nx,ay,z,c), Iaac = (Tfloat)(*this)(ax,ay,z,c),
        Iac = Icac + 0.5f*(dx*(-Ipac+Inac) + dx*dx*(2*Ipac-5*Icac+4*Inac-Iaac) + dx*dx*dx*(-Ipac+3*Icac-3*Inac+Iaac)),
        Ic = Icc + 0.5f*(dy*(-Ipc+Inc) + dy*dy*(2*Ipc-5*Icc+4*Inc-Iac) + dy*dy*dy*(-Ipc+3*Icc-3*Inc+Iac)),
        Ippn = (Tfloat)(*this)(px,py,nz,c), Icpn = (Tfloat)(*this)(x,py,nz,c),
        Inpn = (Tfloat)(*this)(nx,py,nz,c), Iapn = (Tfloat)(*this)(ax,py,nz,c),
        Ipn = Icpn + 0.5f*(dx*(-Ippn+Inpn) + dx*dx*(2*Ippn-5*Icpn+4*Inpn-Iapn) + dx*dx*dx*(-Ippn+3*Icpn-3*Inpn+Iapn)),
        Ipcn = (Tfloat)(*this)(px,y,nz,c), Iccn = (Tfloat)(*this)(x, y,nz,c),
        Incn = (Tfloat)(*this)(nx,y,nz,c), Iacn = (Tfloat)(*this)(ax,y,nz,c),
        Icn = Iccn + 0.5f*(dx*(-Ipcn+Incn) + dx*dx*(2*Ipcn-5*Iccn+4*Incn-Iacn) + dx*dx*dx*(-Ipcn+3*Iccn-3*Incn+Iacn)),
        Ipnn = (Tfloat)(*this)(px,ny,nz,c), Icnn = (Tfloat)(*this)(x,ny,nz,c),
        Innn = (Tfloat)(*this)(nx,ny,nz,c), Iann = (Tfloat)(*this)(ax,ny,nz,c),
        Inn = Icnn + 0.5f*(dx*(-Ipnn+Innn) + dx*dx*(2*Ipnn-5*Icnn+4*Innn-Iann) + dx*dx*dx*(-Ipnn+3*Icnn-3*Innn+Iann)),
        Ipan = (Tfloat)(*this)(px,ay,nz,c), Ican = (Tfloat)(*this)(x,ay,nz,c),
        Inan = (Tfloat)(*this)(nx,ay,nz,c), Iaan = (Tfloat)(*this)(ax,ay,nz,c),
        Ian = Ican + 0.5f*(dx*(-Ipan+Inan) + dx*dx*(2*Ipan-5*Ican+4*Inan-Iaan) + dx*dx*dx*(-Ipan+3*Ican-3*Inan+Iaan)),
        In = Icn + 0.5f*(dy*(-Ipn+Inn) + dy*dy*(2*Ipn-5*Icn+4*Inn-Ian) + dy*dy*dy*(-Ipn+3*Icn-3*Inn+Ian)),
        Ippa = (Tfloat)(*this)(px,py,az,c), Icpa = (Tfloat)(*this)(x,py,az,c),
        Inpa = (Tfloat)(*this)(nx,py,az,c), Iapa = (Tfloat)(*this)(ax,py,az,c),
        Ipa = Icpa + 0.5f*(dx*(-Ippa+Inpa) + dx*dx*(2*Ippa-5*Icpa+4*Inpa-Iapa) + dx*dx*dx*(-Ippa+3*Icpa-3*Inpa+Iapa)),
        Ipca = (Tfloat)(*this)(px,y,az,c), Icca = (Tfloat)(*this)(x, y,az,c),
        Inca = (Tfloat)(*this)(nx,y,az,c), Iaca = (Tfloat)(*this)(ax,y,az,c),
        Ica = Icca + 0.5f*(dx*(-Ipca+Inca) + dx*dx*(2*Ipca-5*Icca+4*Inca-Iaca) + dx*dx*dx*(-Ipca+3*Icca-3*Inca+Iaca)),
        Ipna = (Tfloat)(*this)(px,ny,az,c), Icna = (Tfloat)(*this)(x,ny,az,c),
        Inna = (Tfloat)(*this)(nx,ny,az,c), Iana = (Tfloat)(*this)(ax,ny,az,c),
        Ina = Icna + 0.5f*(dx*(-Ipna+Inna) + dx*dx*(2*Ipna-5*Icna+4*Inna-Iana) + dx*dx*dx*(-Ipna+3*Icna-3*Inna+Iana)),
        Ipaa = (Tfloat)(*this)(px,ay,az,c), Icaa = (Tfloat)(*this)(x,ay,az,c),
        Inaa = (Tfloat)(*this)(nx,ay,az,c), Iaaa = (Tfloat)(*this)(ax,ay,az,c),
        Iaa = Icaa + 0.5f*(dx*(-Ipaa+Inaa) + dx*dx*(2*Ipaa-5*Icaa+4*Inaa-Iaaa) + dx*dx*dx*(-Ipaa+3*Icaa-3*Inaa+Iaaa)),
        Ia = Ica + 0.5f*(dy*(-Ipa+Ina) + dy*dy*(2*Ipa-5*Ica+4*Ina-Iaa) + dy*dy*dy*(-Ipa+3*Ica-3*Ina+Iaa));
      return Ic + 0.5f*(dz*(-Ip+In) + dz*dz*(2*Ip-5*Ic+4*In-Ia) + dz*dz*dz*(-Ip+3*Ic-3*In+Ia));
    }






    Tfloat cubic_atXYZ(const float fx, const float fy, const float fz, const int c,
                       const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = cubic_atXYZ(fx,fy,fz,c);
      return val<min_value?min_value:val>max_value?max_value:val;
    }

    Tfloat _cubic_atXYZ(const float fx, const float fy, const float fz, const int c,
                        const Tfloat min_value, const Tfloat max_value) const {
      const Tfloat val = _cubic_atXYZ(fx,fy,fz,c);
      return val<min_value?min_value:val>max_value?max_value:val;
    }
# 13217 "../src/CImg.h"
    CImg<T>& set_linear_atXY(const T& value, const float fx, const float fy=0, const int z=0, const int c=0,
                             const bool is_added=false) {
      const int
        x = (int)fx - (fx>=0?0:1), nx = x + 1,
        y = (int)fy - (fy>=0?0:1), ny = y + 1;
      const float
        dx = fx - x,
        dy = fy - y;
      if (z>=0 && z<depth() && c>=0 && c<spectrum()) {
        if (y>=0 && y<height()) {
          if (x>=0 && x<width()) {
            const float w1 = (1-dx)*(1-dy), w2 = is_added?1:(1-w1);
            (*this)(x,y,z,c) = (T)(w1*value + w2*(*this)(x,y,z,c));
          }
          if (nx>=0 && nx<width()) {
            const float w1 = dx*(1-dy), w2 = is_added?1:(1-w1);
            (*this)(nx,y,z,c) = (T)(w1*value + w2*(*this)(nx,y,z,c));
          }
        }
        if (ny>=0 && ny<height()) {
          if (x>=0 && x<width()) {
            const float w1 = (1-dx)*dy, w2 = is_added?1:(1-w1);
            (*this)(x,ny,z,c) = (T)(w1*value + w2*(*this)(x,ny,z,c));
          }
          if (nx>=0 && nx<width()) {
            const float w1 = dx*dy, w2 = is_added?1:(1-w1);
            (*this)(nx,ny,z,c) = (T)(w1*value + w2*(*this)(nx,ny,z,c));
          }
        }
      }
      return *this;
    }






    CImg<T>& set_linear_atXYZ(const T& value, const float fx, const float fy=0, const float fz=0, const int c=0,
                              const bool is_added=false) {
      const int
        x = (int)fx - (fx>=0?0:1), nx = x + 1,
        y = (int)fy - (fy>=0?0:1), ny = y + 1,
        z = (int)fz - (fz>=0?0:1), nz = z + 1;
      const float
        dx = fx - x,
        dy = fy - y,
        dz = fz - z;
      if (c>=0 && c<spectrum()) {
        if (z>=0 && z<depth()) {
          if (y>=0 && y<height()) {
            if (x>=0 && x<width()) {
              const float w1 = (1-dx)*(1-dy)*(1-dz), w2 = is_added?1:(1-w1);
              (*this)(x,y,z,c) = (T)(w1*value + w2*(*this)(x,y,z,c));
            }
            if (nx>=0 && nx<width()) {
              const float w1 = dx*(1-dy)*(1-dz), w2 = is_added?1:(1-w1);
              (*this)(nx,y,z,c) = (T)(w1*value + w2*(*this)(nx,y,z,c));
            }
          }
          if (ny>=0 && ny<height()) {
            if (x>=0 && x<width()) {
              const float w1 = (1-dx)*dy*(1-dz), w2 = is_added?1:(1-w1);
              (*this)(x,ny,z,c) = (T)(w1*value + w2*(*this)(x,ny,z,c));
            }
            if (nx>=0 && nx<width()) {
              const float w1 = dx*dy*(1-dz), w2 = is_added?1:(1-w1);
              (*this)(nx,ny,z,c) = (T)(w1*value + w2*(*this)(nx,ny,z,c));
            }
          }
        }
        if (nz>=0 && nz<depth()) {
          if (y>=0 && y<height()) {
            if (x>=0 && x<width()) {
              const float w1 = (1-dx)*(1-dy)*dz, w2 = is_added?1:(1-w1);
              (*this)(x,y,nz,c) = (T)(w1*value + w2*(*this)(x,y,nz,c));
            }
            if (nx>=0 && nx<width()) {
              const float w1 = dx*(1-dy)*dz, w2 = is_added?1:(1-w1);
              (*this)(nx,y,nz,c) = (T)(w1*value + w2*(*this)(nx,y,nz,c));
            }
          }
          if (ny>=0 && ny<height()) {
            if (x>=0 && x<width()) {
              const float w1 = (1-dx)*dy*dz, w2 = is_added?1:(1-w1);
              (*this)(x,ny,nz,c) = (T)(w1*value + w2*(*this)(x,ny,nz,c));
            }
            if (nx>=0 && nx<width()) {
              const float w1 = dx*dy*dz, w2 = is_added?1:(1-w1);
              (*this)(nx,ny,nz,c) = (T)(w1*value + w2*(*this)(nx,ny,nz,c));
            }
          }
        }
      }
      return *this;
    }
# 13327 "../src/CImg.h"
    CImg<charT> value_string(const char separator=',', const unsigned int max_size=0) const {
      if (is_empty()) return CImg<charT>::string("");
      CImgList<charT> items;
      char s_item[256] = { 0 };
      const T *ptrs = _data;
      unsigned int string_size = 0;
      for (unsigned long off = 0, siz = (unsigned int)size(); off<siz && string_size<=max_size; ++off) {
        const unsigned int printed_size = 1U + snprintf(s_item,sizeof(s_item),
                                                             cimg::type<T>::format(),cimg::type<T>::format(*(ptrs++)));
        CImg<charT> item(s_item,printed_size);
        item[printed_size-1] = separator;
        item.move_to(items);
        if (max_size) string_size+=printed_size;
      }
      CImg<charT> res;
      (items>'x').move_to(res);
      if (max_size && res._width>max_size) res.crop(0,max_size);
      res.back() = 0;
      return res;
    }
# 13363 "../src/CImg.h"
    bool is_shared() const {
      return _is_shared;
    }






    bool is_empty() const {
      return !(_data && _width && _height && _depth && _spectrum);
    }





    bool is_inf() const {
      if (cimg::type<T>::is_float()) for (T *p = (*this)._data, *_maxp = (*this)._data + (*this).size(); p<_maxp; ++p) if (cimg::type<T>::is_inf((float)*p)) return true;
      return false;
    }





    bool is_nan() const {
      if (cimg::type<T>::is_float()) for (T *p = (*this)._data, *_maxp = (*this)._data + (*this).size(); p<_maxp; ++p) if (cimg::type<T>::is_nan((float)*p)) return true;
      return false;
    }


    bool is_sameX(const unsigned int size_x) const {
      return _width==size_x;
    }


    template<typename t>
    bool is_sameX(const CImg<t>& img) const {
      return is_sameX(img._width);
    }


    bool is_sameX(const CImgDisplay& disp) const {
      return is_sameX(disp._width);
    }


    bool is_sameY(const unsigned int size_y) const {
      return _height==size_y;
    }


    template<typename t>
    bool is_sameY(const CImg<t>& img) const {
      return is_sameY(img._height);
    }


    bool is_sameY(const CImgDisplay& disp) const {
      return is_sameY(disp._height);
    }


    bool is_sameZ(const unsigned int size_z) const {
      return _depth==size_z;
    }


    template<typename t>
    bool is_sameZ(const CImg<t>& img) const {
      return is_sameZ(img._depth);
    }


    bool is_sameC(const unsigned int size_c) const {
      return _spectrum==size_c;
    }


    template<typename t>
    bool is_sameC(const CImg<t>& img) const {
      return is_sameC(img._spectrum);
    }





    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return _width==size_x && _height==size_y;
    }





    template<typename t>
    bool is_sameXY(const CImg<t>& img) const {
      return is_sameXY(img._width,img._height);
    }





    bool is_sameXY(const CImgDisplay& disp) const {
      return is_sameXY(disp._width,disp._height);
    }





    bool is_sameXZ(const unsigned int size_x, const unsigned int size_z) const {
      return _width==size_x && _depth==size_z;
    }





    template<typename t>
    bool is_sameXZ(const CImg<t>& img) const {
      return is_sameXZ(img._width,img._depth);
    }





    bool is_sameXC(const unsigned int size_x, const unsigned int size_c) const {
      return _width==size_x && _spectrum==size_c;
    }





    template<typename t>
    bool is_sameXC(const CImg<t>& img) const {
      return is_sameXC(img._width,img._spectrum);
    }





    bool is_sameYZ(const unsigned int size_y, const unsigned int size_z) const {
      return _height==size_y && _depth==size_z;
    }





    template<typename t>
    bool is_sameYZ(const CImg<t>& img) const {
      return is_sameYZ(img._height,img._depth);
    }





    bool is_sameYC(const unsigned int size_y, const unsigned int size_c) const {
      return _height==size_y && _spectrum==size_c;
    }





    template<typename t>
    bool is_sameYC(const CImg<t>& img) const {
      return is_sameYC(img._height,img._spectrum);
    }





    bool is_sameZC(const unsigned int size_z, const unsigned int size_c) const {
      return _depth==size_z && _spectrum==size_c;
    }





    template<typename t>
    bool is_sameZC(const CImg<t>& img) const {
      return is_sameZC(img._depth,img._spectrum);
    }





    bool is_sameXYZ(const unsigned int size_x, const unsigned int size_y, const unsigned int size_z) const {
      return is_sameXY(size_x,size_y) && _depth==size_z;
    }





    template<typename t>
    bool is_sameXYZ(const CImg<t>& img) const {
      return is_sameXYZ(img._width,img._height,img._depth);
    }





    bool is_sameXYC(const unsigned int size_x, const unsigned int size_y, const unsigned int size_c) const {
      return is_sameXY(size_x,size_y) && _spectrum==size_c;
    }





    template<typename t>
    bool is_sameXYC(const CImg<t>& img) const {
      return is_sameXYC(img._width,img._height,img._spectrum);
    }





    bool is_sameXZC(const unsigned int size_x, const unsigned int size_z, const unsigned int size_c) const {
      return is_sameXZ(size_x,size_z) && _spectrum==size_c;
    }





    template<typename t>
    bool is_sameXZC(const CImg<t>& img) const {
      return is_sameXZC(img._width,img._depth,img._spectrum);
    }





    bool is_sameYZC(const unsigned int size_y, const unsigned int size_z, const unsigned int size_c) const {
      return is_sameYZ(size_y,size_z) && _spectrum==size_c;
    }





    template<typename t>
    bool is_sameYZC(const CImg<t>& img) const {
      return is_sameYZC(img._height,img._depth,img._spectrum);
    }






    bool is_sameXYZC(const unsigned int size_x, const unsigned int size_y,
                     const unsigned int size_z, const unsigned int size_c) const {
      return is_sameXYZ(size_x,size_y,size_z) && _spectrum==size_c;
    }





    template<typename t>
    bool is_sameXYZC(const CImg<t>& img) const {
      return is_sameXYZC(img._width,img._height,img._depth,img._spectrum);
    }
# 13661 "../src/CImg.h"
    bool containsXYZC(const int x, const int y=0, const int z=0, const int c=0) const {
      return !is_empty() && x>=0 && x<width() && y>=0 && y<height() && z>=0 && z<depth() && c>=0 && c<spectrum();
    }
# 13686 "../src/CImg.h"
    template<typename t>
    bool contains(const T& pixel, t& x, t& y, t& z, t& c) const {
      const unsigned long wh = (unsigned long)_width*_height, whd = wh*_depth, siz = whd*_spectrum;
      const T *const ppixel = &pixel;
      if (is_empty() || ppixel<_data || ppixel>=_data+siz) return false;
      unsigned long off = (unsigned long)(ppixel - _data);
      const unsigned long nc = off/whd;
      off%=whd;
      const unsigned long nz = off/wh;
      off%=wh;
      const unsigned long ny = off/_width, nx = off%_width;
      x = (t)nx; y = (t)ny; z = (t)nz; c = (t)nc;
      return true;
    }





    template<typename t>
    bool contains(const T& pixel, t& x, t& y, t& z) const {
      const unsigned long wh = (unsigned long)_width*_height, whd = wh*_depth, siz = whd*_spectrum;
      const T *const ppixel = &pixel;
      if (is_empty() || ppixel<_data || ppixel>=_data+siz) return false;
      unsigned long off = ((unsigned long)(ppixel - _data))%whd;
      const unsigned long nz = off/wh;
      off%=wh;
      const unsigned long ny = off/_width, nx = off%_width;
      x = (t)nx; y = (t)ny; z = (t)nz;
      return true;
    }





    template<typename t>
    bool contains(const T& pixel, t& x, t& y) const {
      const unsigned long wh = (unsigned long)_width*_height, siz = wh*_depth*_spectrum;
      const T *const ppixel = &pixel;
      if (is_empty() || ppixel<_data || ppixel>=_data+siz) return false;
      unsigned long off = ((unsigned int)(ppixel - _data))%wh;
      const unsigned long ny = off/_width, nx = off%_width;
      x = (t)nx; y = (t)ny;
      return true;
    }





    template<typename t>
    bool contains(const T& pixel, t& x) const {
      const T *const ppixel = &pixel;
      if (is_empty() || ppixel<_data || ppixel>=_data+size()) return false;
      x = (t)(((unsigned long)(ppixel - _data))%_width);
      return true;
    }





    bool contains(const T& pixel) const {
      const T *const ppixel = &pixel;
      return !is_empty() && ppixel>=_data && ppixel<_data + size();
    }
# 13773 "../src/CImg.h"
    template<typename t>
    bool is_overlapped(const CImg<t>& img) const {
      const unsigned long csiz = size(), isiz = img.size();
      return !((void*)(_data + csiz)<=(void*)img._data || (void*)_data>=(void*)(img._data + isiz));
    }
# 13793 "../src/CImg.h"
    template<typename tp, typename tc, typename to>
    bool is_object3d(const CImgList<tp>& primitives,
                     const CImgList<tc>& colors,
                     const to& opacities,
                     const bool full_check=true,
                     char *const error_message=0) const {
      if (error_message) *error_message = 0;


      if (is_empty()) {
        if (primitives || colors || opacities) {
          if (error_message) std::sprintf(error_message,
                                          "3d object (%u,%u) defines no vertices but %u primitives, "
                                          "%u colors and %lu opacities",
                                          _width,primitives._width,primitives._width,
                                          colors._width,(unsigned long)opacities.size());
          return false;
        }
        return true;
      }


      if (_height!=3 || _depth>1 || _spectrum>1) {
        if (error_message) std::sprintf(error_message,
                                        "3d object (%u,%u) has invalid vertex dimensions (%u,%u,%u,%u)",
                                        _width,primitives._width,_width,_height,_depth,_spectrum);
        return false;
      }
      if (colors._width>primitives._width+1) {
        if (error_message) std::sprintf(error_message,
                                        "3d object (%u,%u) defines %u colors",
                                        _width,primitives._width,colors._width);
        return false;
      }
      if (opacities.size()>primitives._width) {
        if (error_message) std::sprintf(error_message,
                                        "3d object (%u,%u) defines %lu opacities",
                                        _width,primitives._width,(unsigned long)opacities.size());
        return false;
      }
      if (!full_check) return true;


      for (int l = 0; l<(int)(primitives)._width; ++l) {
        const CImg<tp>& primitive = primitives[l];
        const unsigned long psiz = primitive.size();
        switch (psiz) {
        case 1 : {
          const unsigned int i0 = (unsigned int)primitive(0);
          if (i0>=_width) {
            if (error_message) std::sprintf(error_message,
                                            "3d object (%u,%u) refers to invalid vertex indice %u in "
                                            "point primitive [%u]",
                                            _width,primitives._width,i0,l);
            return false;
          }
        } break;
        case 5 : {
          const unsigned int
            i0 = (unsigned int)primitive(0),
            i1 = (unsigned int)primitive(1);
          if (i0>=_width || i1>=_width) {
            if (error_message) std::sprintf(error_message,
                                            "3d object (%u,%u) refers to invalid vertex indices (%u,%u) in "
                                            "sphere primitive [%u]",
                                            _width,primitives._width,i0,i1,l);
            return false;
          }
        } break;
        case 2 :
        case 6 : {
          const unsigned int
            i0 = (unsigned int)primitive(0),
            i1 = (unsigned int)primitive(1);
          if (i0>=_width || i1>=_width) {
            if (error_message) std::sprintf(error_message,
                                            "3d object (%u,%u) refers to invalid vertex indices (%u,%u) in "
                                            "segment primitive [%u]",
                                            _width,primitives._width,i0,i1,l);
            return false;
          }
        } break;
        case 3 :
        case 9 : {
          const unsigned int
            i0 = (unsigned int)primitive(0),
            i1 = (unsigned int)primitive(1),
            i2 = (unsigned int)primitive(2);
          if (i0>=_width || i1>=_width || i2>=_width) {
            if (error_message) std::sprintf(error_message,
                                            "3d object (%u,%u) refers to invalid vertex indices (%u,%u,%u) in "
                                            "triangle primitive [%u]",
                                            _width,primitives._width,i0,i1,i2,l);
            return false;
          }
        } break;
        case 4 :
        case 12 : {
          const unsigned int
            i0 = (unsigned int)primitive(0),
            i1 = (unsigned int)primitive(1),
            i2 = (unsigned int)primitive(2),
            i3 = (unsigned int)primitive(3);
          if (i0>=_width || i1>=_width || i2>=_width || i3>=_width) {
            if (error_message) std::sprintf(error_message,
                                            "3d object (%u,%u) refers to invalid vertex indices (%u,%u,%u,%u) in "
                                            "quadrangle primitive [%u]",
                                            _width,primitives._width,i0,i1,i2,i3,l);
            return false;
          }
        } break;
        default :
          if (error_message) std::sprintf(error_message,
                                          "3d object (%u,%u) defines an invalid primitive [%u] of size %u",
                                          _width,primitives._width,l,(unsigned int)psiz);
          return false;
        }
      }


      for (int c = 0; c<(int)(colors)._width; ++c) {
        const CImg<tc>& color = colors[c];
        if (!color) {
          if (error_message) std::sprintf(error_message,
                                          "3d object (%u,%u) defines no color for primitive [%u]",
                                          _width,primitives._width,c);
          return false;
        }
      }


      if (colors._width>primitives._width) {
        const CImg<tc> &light = colors.back();
        if (!light || light._depth>1) {
          if (error_message) std::sprintf(error_message,
                                          "3d object (%u,%u) defines an invalid light texture (%u,%u,%u,%u)",
                                          _width,primitives._width,light._width,
                                          light._height,light._depth,light._spectrum);
          return false;
        }
      }

      return true;
    }
# 13948 "../src/CImg.h"
    bool is_CImg3d(const bool full_check=true, char *const error_message=0) const {
      if (error_message) *error_message = 0;


      if (_width!=1 || _height<8 || _depth!=1 || _spectrum!=1) {
        if (error_message) std::sprintf(error_message,
                                        "CImg3d has invalid dimensions (%u,%u,%u,%u)",
                                        _width,_height,_depth,_spectrum);
        return false;
      }
      const T *ptrs = _data, *const ptre = end();
      if (!_is_CImg3d(*(ptrs++),'C') || !_is_CImg3d(*(ptrs++),'I') || !_is_CImg3d(*(ptrs++),'m') ||
          !_is_CImg3d(*(ptrs++),'g') || !_is_CImg3d(*(ptrs++),'3') || !_is_CImg3d(*(ptrs++),'d')) {
        if (error_message) std::sprintf(error_message,
                                        "CImg3d header not found");
        return false;
      }
      const unsigned int
        nb_points = cimg::float2uint((float)*(ptrs++)),
        nb_primitives = cimg::float2uint((float)*(ptrs++));


      if (!full_check) {
        const unsigned long minimal_size = 8UL + 3*nb_points + 6*nb_primitives;
        if (_data + minimal_size>ptre) {
          if (error_message) std::sprintf(error_message,
                                          "CImg3d (%u,%u) has only %lu values, while at least %lu values were expected",
                                          nb_points,nb_primitives,size(),minimal_size);
          return false;
        }
      }


      if (!nb_points) {
        if (nb_primitives) {
          if (error_message) std::sprintf(error_message,
                                          "CImg3d (%u,%u) defines no vertices but %u primitives",
                                          nb_points,nb_primitives,nb_primitives);
          return false;
        }
        if (ptrs!=ptre) {
          if (error_message) std::sprintf(error_message,
                                          "CImg3d (%u,%u) is an empty object but contains %u value%s "
                                          "more than expected",
                                          nb_points,nb_primitives,(unsigned int)(ptre-ptrs),(ptre-ptrs)>1?"s":"");
          return false;
        }
        return true;
      }
      if (ptrs+3*nb_points>ptre) {
        if (error_message) std::sprintf(error_message,
                                        "CImg3d (%u,%u) defines only %u vertices data",
                                        nb_points,nb_primitives,(unsigned int)(ptre-ptrs)/3);
        return false;
      }
      ptrs+=3*nb_points;


      if (ptrs==ptre) {
        if (error_message) std::sprintf(error_message,
                                        "CImg3d (%u,%u) defines %u vertices but no primitive",
                                        nb_points,nb_primitives,nb_points);
        return false;
      }

      if (!full_check) return true;

      for (unsigned int p = 0; p<nb_primitives; ++p) {
        const unsigned int nb_inds = (unsigned int)*(ptrs++);
        switch (nb_inds) {
        case 1 : {
          const unsigned int i0 = cimg::float2uint((float)*(ptrs++));
          if (i0>=nb_points) {
            if (error_message) std::sprintf(error_message,
                                            "CImg3d (%u,%u) refers to invalid vertex indice %u in point primitive [%u]",
                                            nb_points,nb_primitives,i0,p);
            return false;
          }
        } break;
        case 5 : {
          const unsigned int
            i0 = cimg::float2uint((float)*(ptrs++)),
            i1 = cimg::float2uint((float)*(ptrs++));
          ptrs+=3;
          if (i0>=nb_points || i1>=nb_points) {
            if (error_message) std::sprintf(error_message,
                                            "CImg3d (%u,%u) refers to invalid vertex indices (%u,%u) in "
                                            "sphere primitive [%u]",
                                            nb_points,nb_primitives,i0,i1,p);
            return false;
          }
        } break;
        case 2 : case 6 : {
          const unsigned int
            i0 = cimg::float2uint((float)*(ptrs++)),
            i1 = cimg::float2uint((float)*(ptrs++));
          if (nb_inds==6) ptrs+=4;
          if (i0>=nb_points || i1>=nb_points) {
            if (error_message) std::sprintf(error_message,
                                            "CImg3d (%u,%u) refers to invalid vertex indices (%u,%u) in "
                                            "segment primitive [%u]",
                                            nb_points,nb_primitives,i0,i1,p);
            return false;
          }
        } break;
        case 3 : case 9 : {
          const unsigned int
            i0 = cimg::float2uint((float)*(ptrs++)),
            i1 = cimg::float2uint((float)*(ptrs++)),
            i2 = cimg::float2uint((float)*(ptrs++));
          if (nb_inds==9) ptrs+=6;
          if (i0>=nb_points || i1>=nb_points || i2>=nb_points) {
            if (error_message) std::sprintf(error_message,
                                            "CImg3d (%u,%u) refers to invalid vertex indices (%u,%u,%u) in "
                                            "triangle primitive [%u]",
                                            nb_points,nb_primitives,i0,i1,i2,p);
            return false;
          }
        } break;
        case 4 : case 12 : {
          const unsigned int
            i0 = cimg::float2uint((float)*(ptrs++)),
            i1 = cimg::float2uint((float)*(ptrs++)),
            i2 = cimg::float2uint((float)*(ptrs++)),
            i3 = cimg::float2uint((float)*(ptrs++));
          if (nb_inds==12) ptrs+=8;
          if (i0>=nb_points || i1>=nb_points || i2>=nb_points || i3>=nb_points) {
            if (error_message) std::sprintf(error_message,
                                            "CImg3d (%u,%u) refers to invalid vertex indices (%u,%u,%u,%u) in "
                                            "quadrangle primitive [%u]",
                                            nb_points,nb_primitives,i0,i1,i2,i3,p);
            return false;
          }
        } break;
        default :
          if (error_message) std::sprintf(error_message,
                                          "CImg3d (%u,%u) defines an invalid primitive [%u] of size %u",
                                          nb_points,nb_primitives,p,nb_inds);
          return false;
        }
        if (ptrs>ptre) {
          if (error_message) std::sprintf(error_message,
                                          "CImg3d (%u,%u) has incomplete primitive data for primitive [%u], "
                                          "%u values missing",
                                          nb_points,nb_primitives,p,(unsigned int)(ptrs-ptre));
          return false;
        }
      }


      if (ptrs==ptre) {
        if (error_message) std::sprintf(error_message,
                                        "CImg3d (%u,%u) defines no color/texture data",
                                        nb_points,nb_primitives);
        return false;
      }
      for (unsigned int c = 0; c<nb_primitives; ++c) {
        if (*(ptrs++)!=(T)-128) ptrs+=2;
        else if ((ptrs+=3)<ptre) {
          const unsigned int w = (unsigned int)*(ptrs-3), h = (unsigned int)*(ptrs-2), s = (unsigned int)*(ptrs-1);
          if (!h && !s) {
            if (w>=c) {
              if (error_message) std::sprintf(error_message,
                                              "CImg3d (%u,%u) refers to invalid shared sprite/texture indice %u "
                                              "for primitive [%u]",
                                              nb_points,nb_primitives,w,c);
              return false;
            }
          } else ptrs+=w*h*s;
        }
        if (ptrs>ptre) {
          if (error_message) std::sprintf(error_message,
                                          "CImg3d (%u,%u) has incomplete color/texture data for primitive [%u], "
                                          "%u values missing",
                                          nb_points,nb_primitives,c,(unsigned int)(ptrs-ptre));
          return false;
        }
      }


      if (ptrs==ptre) {
        if (error_message) std::sprintf(error_message,
                                        "CImg3d (%u,%u) defines no opacity data",
                                        nb_points,nb_primitives);
        return false;
      }
      for (unsigned int o = 0; o<nb_primitives; ++o) {
        if (*(ptrs++)==(T)-128 && (ptrs+=3)<ptre) {
          const unsigned int w = (unsigned int)*(ptrs-3), h = (unsigned int)*(ptrs-2), s = (unsigned int)*(ptrs-1);
          if (!h && !s) {
            if (w>=o) {
              if (error_message) std::sprintf(error_message,
                                              "CImg3d (%u,%u) refers to invalid shared opacity indice %u "
                                              "for primitive [%u]",
                                              nb_points,nb_primitives,w,o);
              return false;
            }
          } else ptrs+=w*h*s;
        }
        if (ptrs>ptre) {
          if (error_message) std::sprintf(error_message,
                                          "CImg3d (%u,%u) has incomplete opacity data for primitive [%u]",
                                          nb_points,nb_primitives,o);
          return false;
        }
      }


      if (ptrs<ptre) {
        if (error_message) std::sprintf(error_message,
                                        "CImg3d (%u,%u) contains %u value%s more than expected",
                                        nb_points,nb_primitives,(unsigned int)(ptre-ptrs),(ptre-ptrs)>1?"s":"");
        return false;
      }
      return true;
    }

    static bool _is_CImg3d(const T val, const char c) {
      return val>=(T)c && val<(T)(c+1);
    }
# 14177 "../src/CImg.h"
    struct _cimg_math_parser {
      CImgList<longT> code;
      CImg<longT> opcode;
      const CImg<longT>* p_code;
      CImgList<charT> labelM;
      CImg<uintT> level, labelMpos, label1pos;
      CImg<doubleT> mem;
      CImg<charT> expr;
      const CImg<T>& reference;
      CImg<Tdouble> reference_stats;
      unsigned int mempos, result;
      const char *const calling_function;
      typedef double (*mp_func)(_cimg_math_parser&);
# 14211 "../src/CImg.h"
      _cimg_math_parser():reference(CImg<T>::empty()),calling_function(0) {}

      _cimg_math_parser(const CImg<T>& img, const char *const expression, const char *const funcname=0):
        reference(img),calling_function(funcname?funcname:"cimg_math_parser") {
        unsigned int l = 0;
        if (expression) {
          l = (unsigned int)std::strlen(expression);
          expr.assign(expression,l+1);
          if (*expr._data) {
            char *d = expr._data;
            for (const char *s = expr._data; *s || (bool)(*d=0); ++s) if (*s!=' ') *(d++) = *s;
            l = (unsigned int)(d - expr._data);
          }
        }
        if (!l) throw CImgArgumentException("[_cimg_math_parser] "
                                            "CImg<%s>::%s(): Empty specified expression.",
                                            pixel_type(),calling_function);

        int lv = 0;
        level.assign(l);
        unsigned int *pd = level._data;
        for (const char *ps = expr._data; *ps && lv>=0; ++ps)
          *(pd++) = (unsigned int)(*ps=='('||*ps=='['?lv++:*ps==')'||*ps==']'?--lv:lv);
        if (lv!=0) {
          throw CImgArgumentException("[_cimg_math_parser] "
                                      "CImg<%s>::%s(): Unbalanced parentheses/brackets in specified expression '%s'.",
                                      pixel_type(),calling_function,
                                      expr._data);
        }

        mem.assign(512);
        mem[0] = 0;
        mem[1] = 1;
        mem[2] = 2;
        mem[3] = (double)reference._width;
        mem[4] = (double)reference._height;
        mem[5] = (double)reference._depth;
        mem[6] = (double)reference._spectrum;
        mem[7] = cimg::PI;
        mem[8] = std::exp(1.0);
        mempos = 13;
        labelMpos.assign(8);
        label1pos.assign(128,1,1,1,~0U);
        label1pos['w'] = 3;
        label1pos['h'] = 4;
        label1pos['d'] = 5;
        label1pos['s'] = 6;
        label1pos[0] = 7;
        label1pos['e'] = 8;
        label1pos['x'] = 9;
        label1pos['y'] = 10;
        label1pos['z'] = 11;
        label1pos['c'] = 12;
        result = compile(expr._data,expr._data+l);
      }


      unsigned int opcode0(const mp_func op) {
        if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
        const unsigned int pos = mempos++;
        CImg<longT>::vector((long)(op),pos).move_to(code);
        return pos;
      }

      unsigned int opcode1(const mp_func op, const unsigned int arg1) {
        if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
        const unsigned int pos = mempos++;
        CImg<longT>::vector((long)(op),pos,arg1).move_to(code);
        return pos;
      }

      unsigned int opcode2(const mp_func op, const unsigned int arg1, const unsigned int arg2) {
        if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
        const unsigned int pos = mempos++;
        CImg<longT>::vector((long)(op),pos,arg1,arg2).move_to(code);
        return pos;
      }

      unsigned int opcode3(const mp_func op,
                           const unsigned int arg1, const unsigned int arg2, const unsigned int arg3) {
        if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
        const unsigned int pos = mempos++;
        CImg<longT>::vector((long)(op),pos,arg1,arg2,arg3).move_to(code);
        return pos;
      }

      unsigned int opcode6(const mp_func op,
                           const unsigned int arg1, const unsigned int arg2, const unsigned int arg3,
                           const unsigned int arg4, const unsigned int arg5, const unsigned int arg6) {
        if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
        const unsigned int pos = mempos++;
        CImg<longT>::vector((long)(op),pos,arg1,arg2,arg3,arg4,arg5,arg6).move_to(code);
        return pos;
      }


      unsigned int compile(char *const ss, char *const se) {
        if (!ss || se<=ss || !*ss) {
          throw CImgArgumentException("[_cimg_math_parser] "
                                      "CImg<%s>::%s(): Missing item in specified expression '%s'.",
                                      pixel_type(),calling_function,
                                      expr._data);
        }
        char
          *const se1 = se-1, *const se2 = se-2, *const se3 = se-3, *const se4 = se-4,
          *const ss1 = ss+1, *const ss2 = ss+2, *const ss3 = ss+3, *const ss4 = ss+4,
          *const ss5 = ss+5, *const ss6 = ss+6, *const ss7 = ss+7;
        const char saved_char = *se; *se = 0;
        const unsigned int clevel = level[ss-expr._data], clevel1 = clevel+1;
        if (*se1==';') return compile(ss,se1);


        char end = 0, sep = 0; double val = 0;
        const int nb = std::sscanf(ss,"%lf%c%c",&val,&sep,&end);
        if (nb==1) {
          if (val==0 || val==1 || val==2) { *se = saved_char; return (int)val; };
          if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
          const unsigned int pos = mempos++;
          mem[pos] = val;
          { *se = saved_char; return pos; };
        }
        if (nb==2 && sep=='%') {
          if (val==0 || val==100 || val==200) { *se = saved_char; return (int)(val/100); };
          if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
          const unsigned int pos = mempos++;
          mem[pos] = val/100;
          { *se = saved_char; return pos; };
        }
        if (ss1==se) switch (*ss) {
          case 'w' : case 'h' : case 'd' : case 's' :
          case 'x' : case 'y' : case 'z' : case 'c' : case 'e' : { *se = saved_char; return label1pos[*ss]; };
          case 'u' : if (label1pos['u']!=~0U) { *se = saved_char; return label1pos['u']; }; { const unsigned int _i1 = 0, _i2 = 1; { *se = saved_char; return opcode2(mp_u,_i1,_i2); }; };
          case 'g' : if (label1pos['g']!=~0U) { *se = saved_char; return label1pos['g']; }; { *se = saved_char; return opcode0(mp_g); };;
          case 'i' : if (label1pos['i']!=~0U) { *se = saved_char; return label1pos['i']; }; { *se = saved_char; return opcode0(mp_i); };;
          case '?' : { const unsigned int _i1 = 0, _i2 = 1; { *se = saved_char; return opcode2(mp_u,_i1,_i2); }; };
          }
        if (ss1==se1) {
          if (*ss=='p' && *ss1=='i') { *se = saved_char; return label1pos[0]; };
          if (*ss=='i') {
            if (*ss1=='m') { if (label1pos[1]!=~0U) { *se = saved_char; return label1pos[1]; }; { *se = saved_char; return opcode0(mp_im); };; }
            if (*ss1=='M') { if (label1pos[2]!=~0U) { *se = saved_char; return label1pos[2]; }; { *se = saved_char; return opcode0(mp_iM); };; }
            if (*ss1=='a') { if (label1pos[3]!=~0U) { *se = saved_char; return label1pos[3]; }; { *se = saved_char; return opcode0(mp_ia); };; }
            if (*ss1=='v') { if (label1pos[4]!=~0U) { *se = saved_char; return label1pos[4]; }; { *se = saved_char; return opcode0(mp_iv); };; }
          }
          if (*ss1=='m') {
            if (*ss=='x') { if (label1pos[5]!=~0U) { *se = saved_char; return label1pos[5]; }; { *se = saved_char; return opcode0(mp_xm); };; }
            if (*ss=='y') { if (label1pos[6]!=~0U) { *se = saved_char; return label1pos[6]; }; { *se = saved_char; return opcode0(mp_ym); };; }
            if (*ss=='z') { if (label1pos[7]!=~0U) { *se = saved_char; return label1pos[7]; }; { *se = saved_char; return opcode0(mp_zm); };; }
            if (*ss=='c') { if (label1pos[8]!=~0U) { *se = saved_char; return label1pos[8]; }; { *se = saved_char; return opcode0(mp_cm); };; }
          }
          if (*ss1=='M') {
            if (*ss=='x') { if (label1pos[9]!=~0U) { *se = saved_char; return label1pos[9]; }; { *se = saved_char; return opcode0(mp_xM); };; }
            if (*ss=='y') { if (label1pos[10]!=~0U) { *se = saved_char; return label1pos[10]; }; { *se = saved_char; return opcode0(mp_yM); };; }
            if (*ss=='z') { if (label1pos[11]!=~0U) { *se = saved_char; return label1pos[11]; }; { *se = saved_char; return opcode0(mp_zM); };; }
            if (*ss=='c') { if (label1pos[12]!=~0U) { *se = saved_char; return label1pos[12]; }; { *se = saved_char; return opcode0(mp_cM); };; }
          }
        }


        for (char *s = se2; s>ss; --s)
          if (*s==';' && level[s-expr._data]==clevel) { compile(ss,s); { *se = saved_char; return compile(s+1,se); }; }
        for (char *s = ss1, *ps = ss, *ns = ss2; s<se1; ++s, ++ps, ++ns)
          if (*s=='=' && *ns!='=' && *ps!='=' && *ps!='>' && *ps!='<' && *ps!='!' && level[s-expr._data]==clevel) {
            CImg<charT> variable_name(ss,(unsigned int)(s-ss+1));
            variable_name.back() = 0;
            bool is_valid_name = true;
            if (*ss>='0' && *ss<='9') is_valid_name = false;
            else for (const char *ns = ss+1; ns<s; ++ns)
                   if ((*ns<'a' || *ns>'z') && (*ns<'A' || *ns>'Z') && (*ns<'0' || *ns>'9') && *ns!='_') {
                     is_valid_name = false; break;
                   }
            if (!is_valid_name) {
              *se = saved_char;
              throw CImgArgumentException("[_cimg_math_parser] "
                                          "CImg<%s>::%s(): Invalid variable name '%s' in specified expression "
                                          "'%s%s%s'.",
                                          pixel_type(),calling_function,
                                          variable_name._data,
                                          (ss-8)>expr._data?"...":"",
                                          (ss-8)>expr._data?ss-8:expr._data,
                                          se<&expr.back()?"...":"");
            }
            const unsigned int pos = compile(s+1,se);


            if (variable_name[0] && variable_name[1] && !variable_name[2]) {
              const char c1 = variable_name[0], c2 = variable_name[1];
              if (c1=='p' && c2=='i') variable_name.fill((char)0,(char)0);
              else if (c1=='i') {
                if (c2=='m') variable_name.fill(1,0);
                else if (c2=='M') variable_name.fill(2,0);
                else if (c2=='a') variable_name.fill(3,0);
                else if (c2=='v') variable_name.fill(4,0);
              } else if (c2=='m') {
                if (c1=='x') variable_name.fill(5,0);
                else if (c1=='y') variable_name.fill(6,0);
                else if (c1=='z') variable_name.fill(7,0);
                else if (c1=='c') variable_name.fill(8,0);
              } else if (c2=='M') {
                if (c1=='x') variable_name.fill(9,0);
                else if (c1=='y') variable_name.fill(10,0);
                else if (c1=='z') variable_name.fill(11,0);
                else if (c1=='c') variable_name.fill(12,0);
              }
            }
            if (variable_name[1]) {
              int label_pos = -1;
              for (int i = 0; i<(int)(labelM)._width; ++i)
                if (!std::strcmp(variable_name,labelM[i])) { label_pos = i; break; }
              if (label_pos<0) {
                if (labelM._width>=labelMpos._width) labelMpos.resize(-200,1,1,1,0);
                label_pos = labelM._width;
                variable_name.move_to(labelM);
              }
              labelMpos[label_pos] = pos;
            } else label1pos[*variable_name] = pos;
            { *se = saved_char; return pos; };
          }


        for (char *s = se3, *ns = se2; s>ss; --s, --ns) if (*s=='|' && *ns=='|' && level[s-expr._data]==clevel) {
            const unsigned int mem_A = compile(ss,s), bp1 = code._width, mem_B = compile(s+2,se);
            if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
            const unsigned int pos = mempos++;
            CImg<longT>::vector((long)(mp_logical_or),pos,mem_A,mem_B,code._width-bp1).move_to(code,bp1);
            { *se = saved_char; return pos; };
          }
        for (char *s = se3, *ns = se2; s>ss; --s, --ns) if (*s=='&' && *ns=='&' && level[s-expr._data]==clevel) {
            const unsigned int mem_A = compile(ss,s), bp1 = code._width, mem_B = compile(s+2,se);
            if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
            const unsigned int pos = mempos++;
            CImg<longT>::vector((long)(mp_logical_and),pos,mem_A,mem_B,code._width-bp1).move_to(code,bp1);
            { *se = saved_char; return pos; };
          }
        for (char *s = se2; s>ss; --s)
          if (*s=='|' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_bitwise_or,_i1,_i2); }; };
        for (char *s = se2; s>ss; --s)
          if (*s=='&' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_bitwise_and,_i1,_i2); }; };
        for (char *s = se3, *ns = se2; s>ss; --s, --ns)
          if (*s=='!' && *ns=='=' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+2,se); { *se = saved_char; return opcode2(mp_noteq,_i1,_i2); }; };
        for (char *s = se3, *ns = se2; s>ss; --s, --ns)
          if (*s=='=' && *ns=='=' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+2,se); { *se = saved_char; return opcode2(mp_eqeq,_i1,_i2); }; };
        for (char *s = se3, *ns = se2; s>ss; --s, --ns)
          if (*s=='<' && *ns=='=' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+2,se); { *se = saved_char; return opcode2(mp_infeq,_i1,_i2); }; };
        for (char *s = se3, *ns = se2; s>ss; --s, --ns)
          if (*s=='>' && *ns=='=' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+2,se); { *se = saved_char; return opcode2(mp_supeq,_i1,_i2); }; };
        for (char *s = se2, *ns = se1, *ps = se3; s>ss; --s, --ns, --ps)
          if (*s=='<' && *ns!='<' && *ps!='<' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_inf,_i1,_i2); }; };
        for (char *s = se2, *ns = se1, *ps = se3; s>ss; --s, --ns, --ps)
          if (*s=='>' && *ns!='>' && *ps!='>' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_sup,_i1,_i2); }; };
        for (char *s = se3, *ns = se2; s>ss; --s, --ns)
          if (*s=='<' && *ns=='<' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+2,se); { *se = saved_char; return opcode2(mp_lsl,_i1,_i2); }; };
        for (char *s = se3, *ns = se2; s>ss; --s, --ns)
          if (*s=='>' && *ns=='>' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+2,se); { *se = saved_char; return opcode2(mp_lsr,_i1,_i2); }; };
        for (char *s = se2, *ps = se3; s>ss; --s, --ps)
          if (*s=='+' && *ps!='-' && *ps!='+' && *ps!='*' && *ps!='/' && *ps!='%' &&
              *ps!='&' && *ps!='|' && *ps!='^' && *ps!='!' && *ps!='~' &&
              (*ps!='e' || !(ps>ss && (*(ps-1)=='.' || (*(ps-1)>='0' && *(ps-1)<='9')))) && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_add,_i1,_i2); }; };
        for (char *s = se2, *ps = se3; s>ss; --s, --ps)
          if (*s=='-' && *ps!='-' && *ps!='+' && *ps!='*' && *ps!='/' && *ps!='%' &&
              *ps!='&' && *ps!='|' && *ps!='^' && *ps!='!' && *ps!='~' &&
              (*ps!='e' || !(ps>ss && (*(ps-1)=='.' || (*(ps-1)>='0' && *(ps-1)<='9')))) && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_sub,_i1,_i2); }; };
        for (char *s = se2; s>ss; --s) if (*s=='*' && level[s-expr._data]==clevel) {
            const unsigned int mem_A = compile(ss,s), bp1 = code._width, mem_B = compile(s+1,se);
            if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
            const unsigned int pos = mempos++;
            CImg<longT>::vector((long)(mp_mul),pos,mem_A,mem_B,code._width-bp1).move_to(code,bp1);
            { *se = saved_char; return pos; };
          }
        for (char *s = se2; s>ss; --s)
          if (*s=='/' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_div,_i1,_i2); }; };
        for (char *s = se2, *ns = se1; s>ss; --s, --ns)
          if (*s=='%' && *ns!='^' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_modulo,_i1,_i2); }; };
        if (ss<se1) {
          if (*ss=='+') { *se = saved_char; return compile(ss1,se); };
          if (*ss=='-') { *se = saved_char; return opcode1(mp_minus,compile(ss1,se)); };;
          if (*ss=='!') { *se = saved_char; return opcode1(mp_logical_not,compile(ss1,se)); };;
          if (*ss=='~') { *se = saved_char; return opcode1(mp_bitwise_not,compile(ss1,se)); };;
        }
        for (char *s = se2; s>ss; --s)
          if (*s=='^' && level[s-expr._data]==clevel)
            { const unsigned int _i1 = compile(ss,s), _i2 = compile(s+1,se); { *se = saved_char; return opcode2(mp_pow,_i1,_i2); }; };


        if (*se1==']') {
          const bool is_relative = *ss=='j';
          if ((*ss=='i' || is_relative) && *ss1=='[') {
            if (*ss2==']') { *se = saved_char; return opcode0(mp_i); };;
            { *se = saved_char; return opcode1(is_relative?mp_joff:mp_ioff,compile(ss2,se1)); };;
          }
        }
        if (*se1==')') {
          if (*ss=='(') { *se = saved_char; return compile(ss1,se1); };
          if (!std::strncmp(ss,"sin(",4)) { *se = saved_char; return opcode1(mp_sin,compile(ss4,se1)); };;
          if (!std::strncmp(ss,"cos(",4)) { *se = saved_char; return opcode1(mp_cos,compile(ss4,se1)); };;
          if (!std::strncmp(ss,"tan(",4)) { *se = saved_char; return opcode1(mp_tan,compile(ss4,se1)); };;
          if (!std::strncmp(ss,"asin(",5)) { *se = saved_char; return opcode1(mp_asin,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"acos(",5)) { *se = saved_char; return opcode1(mp_acos,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"atan(",5)) { *se = saved_char; return opcode1(mp_atan,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"sinh(",5)) { *se = saved_char; return opcode1(mp_sinh,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"cosh(",5)) { *se = saved_char; return opcode1(mp_cosh,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"tanh(",5)) { *se = saved_char; return opcode1(mp_tanh,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"log10(",6)) { *se = saved_char; return opcode1(mp_log10,compile(ss6,se1)); };;
          if (!std::strncmp(ss,"log2(",5)) { *se = saved_char; return opcode1(mp_log2,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"log(",4)) { *se = saved_char; return opcode1(mp_log,compile(ss4,se1)); };;
          if (!std::strncmp(ss,"exp(",4)) { *se = saved_char; return opcode1(mp_exp,compile(ss4,se1)); };;
          if (!std::strncmp(ss,"sqrt(",5)) { *se = saved_char; return opcode1(mp_sqrt,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"sign(",5)) { *se = saved_char; return opcode1(mp_sign,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"abs(",4)) { *se = saved_char; return opcode1(mp_abs,compile(ss4,se1)); };;
          if (!std::strncmp(ss,"atan2(",6)) {
            char *s1 = ss6; while (s1<se2 && (*s1!=',' || level[s1-expr._data]!=clevel1)) ++s1;
            { const unsigned int _i1 = compile(ss6,s1), _i2 = compile(s1+1,se1); { *se = saved_char; return opcode2(mp_atan2,_i1,_i2); }; };
          }
          if (*ss=='i' && *ss1=='f' && *ss2=='(') {
            char *s1 = ss3; while (s1<se4 && (*s1!=',' || level[s1-expr._data]!=clevel1)) ++s1;
            char *s2 = s1+1; while (s2<se2 && (*s2!=',' || level[s2-expr._data]!=clevel1)) ++s2;
            const unsigned int mem_cond = compile(ss3,s1), bp1 = code._width, mem_A = compile(s1+1,s2),
              bp2 = code._width, mem_B = compile(s2+1,se1);
            if (mempos>=mem._width) mem.resize(-200,1,1,1,0);
            const unsigned int pos = mempos++;
            CImg<longT>::vector((long)(mp_if),pos,mem_cond,mem_A,mem_B,bp2-bp1,code._width-bp2).
              move_to(code,bp1);
            { *se = saved_char; return pos; };
          }
          if (!std::strncmp(ss,"round(",6)) {
            unsigned int value = 0, round = 1, direction = 0;
            char *s1 = ss6; while (s1<se2 && (*s1!=',' || level[s1-expr._data]!=clevel1)) ++s1;
            value = compile(ss6,s1==se2?++s1:s1);
            if (s1<se1) {
              char *s2 = s1+1; while (s2<se2 && (*s2!=',' || level[s2-expr._data]!=clevel1)) ++s2;
              round = compile(s1+1,s2==se2?++s2:s2);
              if (s2<se1) direction = compile(s2+1,se1);
            }
            { const unsigned int _i1 = value, _i2 = round, _i3 = direction; { *se = saved_char; return opcode3(mp_round,_i1,_i2,_i3); }; };
          }
          if ((*ss=='?' || *ss=='u') && *ss1=='(') {
            if (*ss2==')') { const unsigned int _i1 = 0, _i2 = 1; { *se = saved_char; return opcode2(mp_u,_i1,_i2); }; };
            char *s1 = ss2; while (s1<se1 && (*s1!=',' || level[s1-expr._data]!=clevel1)) ++s1;
            if (s1<se1) { const unsigned int _i1 = compile(ss2,s1), _i2 = compile(s1+1,se1); { *se = saved_char; return opcode2(mp_u,_i1,_i2); }; };
            { const unsigned int _i1 = 0, _i2 = compile(ss2,s1); { *se = saved_char; return opcode2(mp_u,_i1,_i2); }; };
          }
          const bool is_relative = *ss=='j';
          if ((*ss=='i' || is_relative) && *ss1=='(') {
            if (*ss2==')') { *se = saved_char; return opcode0(mp_i); };;
            unsigned int
              indx = is_relative?0:9, indy = is_relative?0:10,
              indz = is_relative?0:11, indc = is_relative?0:12,
              borders = 0, interpolation = 0;
            if (ss2!=se1) {
              char *s1 = ss2; while (s1<se2 && (*s1!=',' || level[s1-expr._data]!=clevel1)) ++s1;
              indx = compile(ss2,s1==se2?++s1:s1);
              if (s1<se1) {
                char *s2 = s1+1; while (s2<se2 && (*s2!=',' || level[s2-expr._data]!=clevel1)) ++s2;
                indy = compile(s1+1,s2==se2?++s2:s2);
                if (s2<se1) {
                  char *s3 = s2+1; while (s3<se2 && (*s3!=',' || level[s3-expr._data]!=clevel1)) ++s3;
                  indz = compile(s2+1,s3==se2?++s3:s3);
                  if (s3<se1) {
                    char *s4 = s3+1; while (s4<se2 && (*s4!=',' || level[s4-expr._data]!=clevel1)) ++s4;
                    indc = compile(s3+1,s4==se2?++s4:s4);
                    if (s4<se1) {
                      char *s5 = s4+1; while (s5<se2 && (*s5!=',' || level[s5-expr._data]!=clevel1)) ++s5;
                      interpolation = compile(s4+1,s5==se2?++s5:s5);
                      if (s5<se1) borders = compile(s5+1,se1);
                    }
                  }
                }
              }
            }
            { const unsigned int _i1 = indx, _i2 = indy, _i3 = indz, _i4 = indc, _i5 = interpolation, _i6 = borders; { *se = saved_char; return opcode6(is_relative?mp_jxyzc:mp_ixyzc,_i1,_i2,_i3,_i4,_i5,_i6); }; };
          }
          if (!std::strncmp(ss,"min(",4) || !std::strncmp(ss,"max(",4) ||
              !std::strncmp(ss,"med(",4) || !std::strncmp(ss,"kth(",4)) {
            CImgList<longT> opcode;
            if (mempos>=mem.size()) mem.resize(-200,1,1,1,0);
            const unsigned int pos = mempos++;
            CImg<longT>::vector((long)(*ss=='k'?mp_kth:ss[1]=='i'?mp_min:ss[1]=='a'?mp_max:mp_med),pos).
              move_to(opcode);
            for (char *s = ss4; s<se; ++s) {
              char *ns = s; while (ns<se && (*ns!=',' || level[ns-expr._data]!=clevel1) &&
                                   (*ns!=')' || level[ns-expr._data]!=clevel)) ++ns;
              CImg<longT>::vector(compile(s,ns)).move_to(opcode);
              s = ns;
            }
            (opcode>'y').move_to(code);
            { *se = saved_char; return pos; };
          }
          if (!std::strncmp(ss,"arg(",4)) {
            CImgList<longT> opcode;
            if (mempos>=mem.size()) mem.resize(-200,1,1,1,0);
            const unsigned int pos = mempos++;
            CImg<longT>::vector((long)(mp_arg),pos).move_to(opcode);
            for (char *s = ss4; s<se; ++s) {
              char *ns = s; while (ns<se && (*ns!=',' || level[ns-expr._data]!=clevel1) &&
                                   (*ns!=')' || level[ns-expr._data]!=clevel)) ++ns;
              CImg<longT>::vector(compile(s,ns)).move_to(opcode);
              s = ns;
            }
            (opcode>'y').move_to(code);
            { *se = saved_char; return pos; };
          }
          if (!std::strncmp(ss,"narg(",5)) {
            if (*ss5==')') { *se = saved_char; return 0; };
            unsigned int nb_args = 0;
            for (char *s = ss5; s<se; ++s) {
              char *ns = s; while (ns<se && (*ns!=',' || level[ns-expr._data]!=clevel1) &&
                                   (*ns!=')' || level[ns-expr._data]!=clevel)) ++ns;
              ++nb_args; s = ns;
            }
            if (nb_args==0 || nb_args==1) { *se = saved_char; return nb_args; };
            if (mempos>=mem.size()) mem.resize(-200,1,1,1,0);
            const unsigned int pos = mempos++;
            mem[pos] = nb_args;
            { *se = saved_char; return pos; };
          }
          if (!std::strncmp(ss,"isval(",6)) {
            char sep = 0, end = 0; double val = 0;
            if (std::sscanf(ss6,"%lf%c%c",&val,&sep,&end)==2 && sep==')') { *se = saved_char; return 1; };
            { *se = saved_char; return 0; };
          }
          if (!std::strncmp(ss,"isnan(",6)) { *se = saved_char; return opcode1(mp_isnan,compile(ss6,se1)); };;
          if (!std::strncmp(ss,"isinf(",6)) { *se = saved_char; return opcode1(mp_isinf,compile(ss6,se1)); };;
          if (!std::strncmp(ss,"isint(",6)) { *se = saved_char; return opcode1(mp_isint,compile(ss6,se1)); };;
          if (!std::strncmp(ss,"isbool(",7)) { *se = saved_char; return opcode1(mp_isbool,compile(ss7,se1)); };;
          if (!std::strncmp(ss,"rol(",4) || !std::strncmp(ss,"ror(",4)) {
            unsigned int value = 0, nb = 1;
            char *s1 = ss4; while (s1<se2 && (*s1!=',' || level[s1-expr._data]!=clevel1)) ++s1;
            value = compile(ss4,s1==se2?++s1:s1);
            if (s1<se1) {
              char *s2 = s1+1; while (s2<se2 && (*s2!=',' || level[s2-expr._data]!=clevel1)) ++s2;
              nb = compile(s1+1,se1);
            }
            { const unsigned int _i1 = value, _i2 = nb; { *se = saved_char; return opcode2(*ss2=='l'?mp_rol:mp_ror,_i1,_i2); }; };
          }

          if (!std::strncmp(ss,"sinc(",5)) { *se = saved_char; return opcode1(mp_sinc,compile(ss5,se1)); };;
          if (!std::strncmp(ss,"int(",4)) { *se = saved_char; return opcode1(mp_int,compile(ss4,se1)); };;
        }


        CImg<charT> variable_name(ss,(unsigned int)(se-ss+1));
        variable_name.back() = 0;
        if (variable_name[1]) {
          for (int i = 0; i<(int)(labelM)._width; ++i) if (!std::strcmp(variable_name,labelM[i])) { *se = saved_char; return labelMpos[i]; };
        } else if (label1pos[*variable_name]!=~0U) { *se = saved_char; return label1pos[*variable_name]; };
        *se = saved_char;
        throw CImgArgumentException("[_cimg_math_parser] "
                                    "CImg<%s>::%s(): Invalid item '%s' in specified expression '%s%s%s'.\n",
                                    pixel_type(),calling_function,
                                    variable_name._data,
                                    (ss-8)>expr._data?"...":"",
                                    (ss-8)>expr._data?ss-8:expr._data,
                                    se<&expr.back()?"...":"");
      }




      static double mp_u(_cimg_math_parser& mp) {
        return mp.mem[mp.opcode(2)] + cimg::rand()*(mp.mem[mp.opcode(3)]-mp.mem[mp.opcode(2)]);
      }
      static double mp_g(_cimg_math_parser& mp) {
        cimg::unused(mp);
        return cimg::grand();
      }
      static double mp_i(_cimg_math_parser& mp) {
        return (double)mp.reference.atXYZC((int)mp.mem[9],(int)mp.mem[10],(int)mp.mem[11],(int)mp.mem[12],0);
      }
      static double mp_logical_and(_cimg_math_parser& mp) {
        const bool is_A = (bool)mp.mem[mp.opcode(2)];
        const CImg<longT> *const pE = ++mp.p_code + mp.opcode(4);
        if (!is_A) { mp.p_code = pE - 1; return 0; }
        const unsigned int mem_B = (unsigned int)mp.opcode(3);
        for ( ; mp.p_code<pE; ++mp.p_code) {
          const CImg<longT> &op = *mp.p_code;
          mp.opcode._data = op._data; mp.opcode._height = op._height;
          const unsigned int target = (unsigned int)mp.opcode[1];
          mp.mem[target] = (*(mp_func)((mp).opcode[0]))(mp);
        }
        --mp.p_code;
        return (double)(bool)mp.mem[mem_B];
      }
      static double mp_logical_or(_cimg_math_parser& mp) {
        const bool is_A = (bool)mp.mem[mp.opcode(2)];
        const CImg<longT> *const pE = ++mp.p_code + mp.opcode(4);
        if (is_A) { mp.p_code = pE - 1; return 1; }
        const unsigned int mem_B = (unsigned int)mp.opcode(3);
        for ( ; mp.p_code<pE; ++mp.p_code) {
          const CImg<longT> &op = *mp.p_code;
          mp.opcode._data = op._data; mp.opcode._height = op._height;
          const unsigned int target = (unsigned int)mp.opcode[1];
          mp.mem[target] = (*(mp_func)((mp).opcode[0]))(mp);
        }
        --mp.p_code;
        return (double)(bool)mp.mem[mem_B];
      }
      static double mp_infeq(_cimg_math_parser& mp) {
        return (double)(mp.mem[mp.opcode(2)]<=mp.mem[mp.opcode(3)]);
      }
      static double mp_supeq(_cimg_math_parser& mp) {
        return (double)(mp.mem[mp.opcode(2)]>=mp.mem[mp.opcode(3)]);
      }
      static double mp_noteq(_cimg_math_parser& mp) {
        return (double)(mp.mem[mp.opcode(2)]!=mp.mem[mp.opcode(3)]);
      }
      static double mp_eqeq(_cimg_math_parser& mp) {
        return (double)(mp.mem[mp.opcode(2)]==mp.mem[mp.opcode(3)]);
      }
      static double mp_inf(_cimg_math_parser& mp) {
        return (double)(mp.mem[mp.opcode(2)]<mp.mem[mp.opcode(3)]);
      }
      static double mp_sup(_cimg_math_parser& mp) {
        return (double)(mp.mem[mp.opcode(2)]>mp.mem[mp.opcode(3)]);
      }
      static double mp_add(_cimg_math_parser& mp) {
        return mp.mem[mp.opcode(2)] + mp.mem[mp.opcode(3)];
      }
      static double mp_sub(_cimg_math_parser& mp) {
        return mp.mem[mp.opcode(2)] - mp.mem[mp.opcode(3)];
      }
      static double mp_mul(_cimg_math_parser& mp) {
        const double A = mp.mem[mp.opcode(2)];
        const CImg<longT> *const pE = ++mp.p_code + mp.opcode(4);
        if (!A) { mp.p_code = pE - 1; return 0; }
        const unsigned int mem_B = (unsigned int)mp.opcode(3);
        for ( ; mp.p_code<pE; ++mp.p_code) {
          const CImg<longT> &op = *mp.p_code;
          mp.opcode._data = op._data; mp.opcode._height = op._height;
          const unsigned int target = (unsigned int)mp.opcode[1];
          mp.mem[target] = (*(mp_func)((mp).opcode[0]))(mp);
        }
        --mp.p_code;
        return A*(double)mp.mem[mem_B];
      }
      static double mp_div(_cimg_math_parser& mp) {
        return mp.mem[mp.opcode(2)] / mp.mem[mp.opcode(3)];
      }
      static double mp_minus(_cimg_math_parser& mp) {
        return -mp.mem[mp.opcode(2)];
      }
      static double mp_not(_cimg_math_parser& mp) {
        return !mp.mem[mp.opcode(2)];
      }
      static double mp_logical_not(_cimg_math_parser& mp) {
        return !mp.mem[mp.opcode(2)];
      }
      static double mp_bitwise_not(_cimg_math_parser& mp) {
        return ~(unsigned long)mp.mem[mp.opcode(2)];
      }
      static double mp_modulo(_cimg_math_parser& mp) {
        return cimg::mod(mp.mem[mp.opcode(2)],mp.mem[mp.opcode(3)]);
      }
      static double mp_bitwise_and(_cimg_math_parser& mp) {
        return ((unsigned long)mp.mem[mp.opcode(2)] & (unsigned long)mp.mem[mp.opcode(3)]);
      }
      static double mp_bitwise_or(_cimg_math_parser& mp) {
        return ((unsigned long)mp.mem[mp.opcode(2)] | (unsigned long)mp.mem[mp.opcode(3)]);
      }
      static double mp_pow(_cimg_math_parser& mp) {
        const double v = mp.mem[mp.opcode(2)], p = mp.mem[mp.opcode(3)];
        if (p==0) return 1;
        if (p==0.5) return std::sqrt(v);
        if (p==1) return v;
        if (p==2) return v*v;
        if (p==3) return v*v*v;
        if (p==4) return v*v*v*v;
        return std::pow(v,p);
      }
      static double mp_sin(_cimg_math_parser& mp) {
        return std::sin(mp.mem[mp.opcode(2)]);
      }
      static double mp_cos(_cimg_math_parser& mp) {
        return std::cos(mp.mem[mp.opcode(2)]);
      }
      static double mp_tan(_cimg_math_parser& mp) {
        return std::tan(mp.mem[mp.opcode(2)]);
      }
      static double mp_asin(_cimg_math_parser& mp) {
        return std::asin(mp.mem[mp.opcode(2)]);
      }
      static double mp_acos(_cimg_math_parser& mp) {
        return std::acos(mp.mem[mp.opcode(2)]);
      }
      static double mp_atan(_cimg_math_parser& mp) {
        return std::atan(mp.mem[mp.opcode(2)]);
      }
      static double mp_sinh(_cimg_math_parser& mp) {
        return std::sinh(mp.mem[mp.opcode(2)]);
      }
      static double mp_cosh(_cimg_math_parser& mp) {
        return std::cosh(mp.mem[mp.opcode(2)]);
      }
      static double mp_tanh(_cimg_math_parser& mp) {
        return std::tanh(mp.mem[mp.opcode(2)]);
      }
      static double mp_log10(_cimg_math_parser& mp) {
        return std::log10(mp.mem[mp.opcode(2)]);
      }
      static double mp_log2(_cimg_math_parser& mp) {
        return cimg::log2(mp.mem[mp.opcode(2)]);
      }
      static double mp_log(_cimg_math_parser& mp) {
        return std::log(mp.mem[mp.opcode(2)]);
      }
      static double mp_exp(_cimg_math_parser& mp) {
        return std::exp(mp.mem[mp.opcode(2)]);
      }
      static double mp_sqrt(_cimg_math_parser& mp) {
        return std::sqrt(mp.mem[mp.opcode(2)]);
      }
      static double mp_sign(_cimg_math_parser& mp) {
        return cimg::sign(mp.mem[mp.opcode(2)]);
      }
      static double mp_abs(_cimg_math_parser& mp) {
        return cimg::abs(mp.mem[mp.opcode(2)]);
      }
      static double mp_atan2(_cimg_math_parser& mp) {
        return std::atan2(mp.mem[mp.opcode(2)],mp.mem[mp.opcode(3)]);
      }
      static double mp_if(_cimg_math_parser& mp) {
        const bool is_cond = (bool)mp.mem[mp.opcode(2)];
        const unsigned int mem_A = (unsigned int)mp.opcode(3), mem_B = (unsigned int)mp.opcode(4);
        const CImg<longT>
          *const pB = ++mp.p_code + mp.opcode(5),
          *const pE = pB + mp.opcode(6);
        if (is_cond) {
          for ( ; mp.p_code<pB; ++mp.p_code) {
            const CImg<longT> &op = *mp.p_code;
            mp.opcode._data = op._data; mp.opcode._height = op._height;
            const unsigned int target = (unsigned int)mp.opcode[1];
            mp.mem[target] = (*(mp_func)((mp).opcode[0]))(mp);
          }
          mp.p_code = pE - 1;
          return mp.mem[mem_A];
        }
        for (mp.p_code = pB; mp.p_code<pE; ++mp.p_code) {
          const CImg<longT> &op = *mp.p_code;
          mp.opcode._data = op._data; mp.opcode._height = op._height;
          const unsigned int target = (unsigned int)mp.opcode[1];
          mp.mem[target] = (*(mp_func)((mp).opcode[0]))(mp);
        }
        --mp.p_code;
        return mp.mem[mem_B];
      }
      static double mp_round(_cimg_math_parser& mp) {
        return cimg::round(mp.mem[mp.opcode(2)],mp.mem[mp.opcode(3)],(int)mp.mem[mp.opcode(4)]);
      }
      static double mp_ixyzc(_cimg_math_parser& mp) {
        const int i = (int)mp.mem[mp.opcode(6)], b = (int)mp.mem[mp.opcode(7)];
        if (i==0) {
          if (b==2) return (double)mp.reference.atXYZC(cimg::mod((int)mp.mem[mp.opcode(2)],mp.reference.width()),
                                                    cimg::mod((int)mp.mem[mp.opcode(3)],mp.reference.height()),
                                                    cimg::mod((int)mp.mem[mp.opcode(4)],mp.reference.depth()),
                                                    cimg::mod((int)mp.mem[mp.opcode(5)],mp.reference.spectrum()));
          if (b==1) return (double)mp.reference.atXYZC((int)mp.mem[mp.opcode(2)],
                                                    (int)mp.mem[mp.opcode(3)],
                                                    (int)mp.mem[mp.opcode(4)],
                                                    (int)mp.mem[mp.opcode(5)]);
          return (double)mp.reference.atXYZC((int)mp.mem[mp.opcode(2)],
                                          (int)mp.mem[mp.opcode(3)],
                                          (int)mp.mem[mp.opcode(4)],
                                          (int)mp.mem[mp.opcode(5)],0);
        } else {
          if (b==2) return (double)mp.reference.linear_atXYZC(cimg::mod((float)mp.mem[mp.opcode(2)],(float)mp.reference.width()),
                                                           cimg::mod((float)mp.mem[mp.opcode(3)],(float)mp.reference.height()),
                                                           cimg::mod((float)mp.mem[mp.opcode(4)],(float)mp.reference.depth()),
                                                           cimg::mod((float)mp.mem[mp.opcode(5)],(float)mp.reference.spectrum()));
          if (b==1) return (double)mp.reference.linear_atXYZC((float)mp.mem[mp.opcode(2)],
                                                           (float)mp.mem[mp.opcode(3)],
                                                           (float)mp.mem[mp.opcode(4)],
                                                           (float)mp.mem[mp.opcode(5)]);
          return (double)mp.reference.linear_atXYZC((float)mp.mem[mp.opcode(2)],
                                                 (float)mp.mem[mp.opcode(3)],
                                                 (float)mp.mem[mp.opcode(4)],
                                                 (float)mp.mem[mp.opcode(5)],0);
        }
      }
      static double mp_jxyzc(_cimg_math_parser& mp) {
        const double x = mp.mem[9], y = mp.mem[10], z = mp.mem[11], c = mp.mem[12];
        const int i = (int)mp.mem[mp.opcode(6)], b = (int)mp.mem[mp.opcode(7)];
        if (i==0) {
          if (b==2) return (double)mp.reference.atXYZC(cimg::mod((int)(x+mp.mem[mp.opcode(2)]),mp.reference.width()),
                                                    cimg::mod((int)(y+mp.mem[mp.opcode(3)]),mp.reference.height()),
                                                    cimg::mod((int)(z+mp.mem[mp.opcode(4)]),mp.reference.depth()),
                                                    cimg::mod((int)(c+mp.mem[mp.opcode(5)]),mp.reference.spectrum()));
          if (b==1) return (double)mp.reference.atXYZC((int)(x+mp.mem[mp.opcode(2)]),
                                                    (int)(y+mp.mem[mp.opcode(3)]),
                                                    (int)(z+mp.mem[mp.opcode(4)]),
                                                    (int)(c+mp.mem[mp.opcode(5)]));
          return (double)mp.reference.atXYZC((int)(x+mp.mem[mp.opcode(2)]),
                                          (int)(y+mp.mem[mp.opcode(3)]),
                                          (int)(z+mp.mem[mp.opcode(4)]),
                                          (int)(c+mp.mem[mp.opcode(5)]),0);
        } else {
          if (b==2) return (double)mp.reference.linear_atXYZC(cimg::mod((float)(x+mp.mem[mp.opcode(2)]),(float)mp.reference.width()),
                                                           cimg::mod((float)(y+mp.mem[mp.opcode(3)]),(float)mp.reference.height()),
                                                           cimg::mod((float)(z+mp.mem[mp.opcode(4)]),(float)mp.reference.depth()),
                                                           cimg::mod((float)(c+mp.mem[mp.opcode(5)]),(float)mp.reference.spectrum()));
          if (b==1) return (double)mp.reference.linear_atXYZC((float)(x+mp.mem[mp.opcode(2)]),
                                                           (float)(y+mp.mem[mp.opcode(3)]),
                                                           (float)(z+mp.mem[mp.opcode(4)]),
                                                           (float)(c+mp.mem[mp.opcode(5)]));
          return (double)mp.reference.linear_atXYZC((float)(x+mp.mem[mp.opcode(2)]),
                                                 (float)(y+mp.mem[mp.opcode(3)]),
                                                 (float)(z+mp.mem[mp.opcode(4)]),
                                                 (float)(c+mp.mem[mp.opcode(5)]),0);
        }
      }
      static double mp_min(_cimg_math_parser& mp) {
        double val = mp.mem[mp.opcode(2)];
        for (unsigned int i = 3; i<mp.opcode._height; ++i) val = cimg::min(val,mp.mem[mp.opcode(i)]);
        return val;
      }
      static double mp_max(_cimg_math_parser& mp) {
        double val = mp.mem[mp.opcode(2)];
        for (unsigned int i = 3; i<mp.opcode._height; ++i) val = cimg::max(val,mp.mem[mp.opcode(i)]);
        return val;
      }
      static double mp_med(_cimg_math_parser& mp) {
        CImg<doubleT> values(mp.opcode._height-2);
        double *p = values.data();
        for (unsigned int i = 2; i<mp.opcode._height; ++i) *(p++) = mp.mem[mp.opcode(i)];
        return values.median();
      }
      static double mp_kth(_cimg_math_parser& mp) {
        CImg<doubleT> values(mp.opcode._height-3);
        double *p = values.data();
        for (unsigned int i = 3; i<mp.opcode._height; ++i) *(p++) = mp.mem[mp.opcode(i)];
        int ind = (int)cimg::round(mp.mem[mp.opcode(2)]);
        if (ind<0) ind+=1+values.width();
        ind = cimg::max(1,cimg::min(values.width(),ind));
        return values.kth_smallest(ind-1);
      }
      static double mp_isnan(_cimg_math_parser& mp) {
        const double val = mp.mem[mp.opcode(2)];
        return cimg::type<double>::is_nan(val);
      }
      static double mp_isinf(_cimg_math_parser& mp) {
        const double val = mp.mem[mp.opcode(2)];
        return cimg::type<double>::is_inf(val);
      }
      static double mp_isint(_cimg_math_parser& mp) {
        const double val = mp.mem[mp.opcode(2)];
        return (double)(cimg::mod(val,1.0)==0);
      }
      static double mp_isbool(_cimg_math_parser& mp) {
        const double val = mp.mem[mp.opcode(2)];
        return (val==0.0 || val==1.0);
      }
      static double mp_rol(_cimg_math_parser& mp) {
        return cimg::rol(mp.mem[mp.opcode(2)],(unsigned int)mp.mem[mp.opcode(3)]);
      }
      static double mp_ror(_cimg_math_parser& mp) {
        return cimg::ror(mp.mem[mp.opcode(2)],(unsigned int)mp.mem[mp.opcode(3)]);
      }
      static double mp_lsl(_cimg_math_parser& mp) {
        return (long)mp.mem[mp.opcode(2)]<<(unsigned int)mp.mem[mp.opcode(3)];
      }
      static double mp_lsr(_cimg_math_parser& mp) {
        return (long)mp.mem[mp.opcode(2)]>>(unsigned int)mp.mem[mp.opcode(3)];
      }
      static double mp_sinc(_cimg_math_parser& mp) {
        return cimg::sinc(mp.mem[mp.opcode(2)]);
      }
      static double mp_im(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[0]:0;
      }
      static double mp_iM(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[1]:0;
      }
      static double mp_ia(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[2]:0;
      }
      static double mp_iv(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[3]:0;
      }
      static double mp_xm(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[4]:0;
      }
      static double mp_ym(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[5]:0;
      }
      static double mp_zm(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[6]:0;
      }
      static double mp_cm(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[7]:0;
      }
      static double mp_xM(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[8]:0;
      }
      static double mp_yM(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[9]:0;
      }
      static double mp_zM(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[10]:0;
      }
      static double mp_cM(_cimg_math_parser& mp) {
        if (!mp.reference_stats) mp.reference.get_stats().move_to(mp.reference_stats);
        return mp.reference_stats?mp.reference_stats[11]:0;
      }
      static double mp_arg(_cimg_math_parser& mp) {
        const int _ind = (int)mp.mem[mp.opcode(2)];
        const unsigned int nb_args = mp.opcode._height-2, ind = _ind<0?_ind+nb_args:(unsigned int)_ind;
        if (ind>=nb_args) return 0;
        return mp.mem[mp.opcode(ind+2)];
      }
      static double mp_int(_cimg_math_parser& mp) {
        return (double)(long)mp.mem[mp.opcode(2)];
      }
      static double mp_ioff(_cimg_math_parser& mp) {
        const unsigned long off = (unsigned long)mp.mem[mp.opcode(2)];
        if (off>=mp.reference.size()) return 0;
        return (double)mp.reference[off];
      }
      static double mp_joff(_cimg_math_parser& mp) {
        const int x = (int)mp.mem[9], y = (int)mp.mem[10], z = (int)mp.mem[11], c = (int)mp.mem[12];
        const unsigned long off = mp.reference.offset(x,y,z,c) + (unsigned long)(mp.mem[mp.opcode(2)]);
        if (off>=mp.reference.size()) return 0;
        return (double)mp.reference[off];
      }


      double operator()(const double x, const double y, const double z, const double c) {
        if (!mem) return 0;
        mem[9] = x; mem[10] = y; mem[11] = z; mem[12] = c;
        opcode._is_shared = true; opcode._width = opcode._depth = opcode._spectrum = 1;

        for (p_code = code._data; p_code<code.end(); ++p_code) {
          const CImg<longT> &op = *p_code;

          opcode._data = op._data; opcode._height = op._height;
          const unsigned int target = (unsigned int)opcode[1];
          mem[target] = (*(mp_func)((*this).opcode[0]))(*this);
        }
        return mem[result];
      }
    };
# 15088 "../src/CImg.h"
    CImg<T>& sqr() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T val = *ptrd; *ptrd = (T)(val*val); };
      return *this;
    }


    CImg<Tfloat> get_sqr() const {
      return CImg<Tfloat>(*this,false).sqr();
    }
# 15115 "../src/CImg.h"
    CImg<T>& sqrt() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::sqrt((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_sqrt() const {
      return CImg<Tfloat>(*this,false).sqrt();
    }
# 15136 "../src/CImg.h"
    CImg<T>& exp() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::exp((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_exp() const {
      return CImg<Tfloat>(*this,false).exp();
    }
# 15158 "../src/CImg.h"
    CImg<T>& log() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::log((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_log() const {
      return CImg<Tfloat>(*this,false).log();
    }
# 15180 "../src/CImg.h"
    CImg<T>& log2() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)cimg::log2((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_log2() const {
      return CImg<Tfloat>(*this,false).log2();
    }
# 15202 "../src/CImg.h"
    CImg<T>& log10() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::log10((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_log10() const {
      return CImg<Tfloat>(*this,false).log10();
    }
# 15223 "../src/CImg.h"
    CImg<T>& abs() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = cimg::abs(*ptrd);
      return *this;
    }


    CImg<Tfloat> get_abs() const {
      return CImg<Tfloat>(*this,false).abs();
    }
# 15249 "../src/CImg.h"
    CImg<T>& sign() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = cimg::sign(*ptrd);
      return *this;
    }


    CImg<Tfloat> get_sign() const {
      return CImg<Tfloat>(*this,false).sign();
    }
# 15271 "../src/CImg.h"
    CImg<T>& cos() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::cos((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_cos() const {
      return CImg<Tfloat>(*this,false).cos();
    }
# 15293 "../src/CImg.h"
    CImg<T>& sin() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::sin((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_sin() const {
      return CImg<Tfloat>(*this,false).sin();
    }
# 15316 "../src/CImg.h"
    CImg<T>& sinc() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)cimg::sinc((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_sinc() const {
      return CImg<Tfloat>(*this,false).sinc();
    }
# 15338 "../src/CImg.h"
    CImg<T>& tan() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::tan((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_tan() const {
      return CImg<Tfloat>(*this,false).tan();
    }
# 15360 "../src/CImg.h"
    CImg<T>& cosh() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::cosh((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_cosh() const {
      return CImg<Tfloat>(*this,false).cosh();
    }
# 15382 "../src/CImg.h"
    CImg<T>& sinh() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::sinh((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_sinh() const {
      return CImg<Tfloat>(*this,false).sinh();
    }
# 15404 "../src/CImg.h"
    CImg<T>& tanh() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::tanh((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_tanh() const {
      return CImg<Tfloat>(*this,false).tanh();
    }
# 15426 "../src/CImg.h"
    CImg<T>& acos() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::acos((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_acos() const {
      return CImg<Tfloat>(*this,false).acos();
    }
# 15448 "../src/CImg.h"
    CImg<T>& asin() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::asin((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_asin() const {
      return CImg<Tfloat>(*this,false).asin();
    }
# 15470 "../src/CImg.h"
    CImg<T>& atan() {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::atan((double)*ptrd);
      return *this;
    }


    CImg<Tfloat> get_atan() const {
      return CImg<Tfloat>(*this,false).atan();
    }
# 15501 "../src/CImg.h"
    template<typename t>
    CImg<T>& atan2(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return atan2(+img);
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)std::atan2((double)*ptrd,(double)*(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)std::atan2((double)*ptrd,(double)*(ptrs++));
      }
      return *this;
    }


    template<typename t>
    CImg<Tfloat> get_atan2(const CImg<t>& img) const {
      return CImg<Tfloat>(*this,false).atan2(img);
    }
# 15538 "../src/CImg.h"
    template<typename t>
    CImg<T>& mul(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return mul(+img);
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)(*ptrd * *(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)(*ptrd * *(ptrs++));
      }
      return *this;
    }


    template<typename t>
    CImg<typename cimg::superset<T,t>::type> get_mul(const CImg<t>& img) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false).mul(img);
    }





    template<typename t>
    CImg<T>& div(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return div(+img);
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)(*ptrd / *(ptrs++));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)(*ptrd / *(ptrs++));
      }
      return *this;
    }


    template<typename t>
    CImg<typename cimg::superset<T,t>::type> get_div(const CImg<t>& img) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false).div(img);
    }
# 15598 "../src/CImg.h"
    CImg<T>& pow(const double p) {
      if (is_empty()) return *this;
      if (p==-4) {



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T val = *ptrd; *ptrd = (T)(1.0/(val*val*val*val)); }
        return *this;
      }
      if (p==-3) {



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T val = *ptrd; *ptrd = (T)(1.0/(val*val*val)); }
        return *this;
      }
      if (p==-2) {



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T val = *ptrd; *ptrd = (T)(1.0/(val*val)); }
        return *this;
      }
      if (p==-1) {



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T val = *ptrd; *ptrd = (T)(1.0/val); }
        return *this;
      }
      if (p==-0.5) {



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T val = *ptrd; *ptrd = (T)(1/std::sqrt((double)val)); }
        return *this;
      }
      if (p==0) return fill(1);
      if (p==0.5) return sqrt();
      if (p==1) return *this;
      if (p==2) return sqr();
      if (p==3) {



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T val = *ptrd; *ptrd = val*val*val; }
        return *this;
      }
      if (p==4) {



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T val = *ptrd; *ptrd = val*val*val*val; }
        return *this;
      }



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)std::pow((double)*ptrd,p);
      return *this;
    }


    CImg<Tfloat> get_pow(const double p) const {
      return CImg<Tfloat>(*this,false).pow(p);
    }





    CImg<T>& pow(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"pow");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)std::pow((double)*ptrd,mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>')
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)std::pow((double)*ptrd,mp(x,y,z,c)); ++ptrd; }
        else {
# 15694 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)std::pow((double)*ptrd,mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        CImg<Tfloat> values(_width,_height,_depth,_spectrum);
        try {
          values.fill(expression,true);
        } catch (CImgException&) {
          cimg::exception_mode() = omode;
          values.load(expression);
        }
        pow(values);
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    CImg<Tfloat> get_pow(const char *const expression) const {
      return CImg<Tfloat>(*this,false).pow(expression);
    }





    template<typename t>
    CImg<T>& pow(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return pow(+img);
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)std::pow((double)*ptrd,(double)(*(ptrs++)));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)std::pow((double)*ptrd,(double)(*(ptrs++)));
      }
      return *this;
    }


    template<typename t>
    CImg<Tfloat> get_pow(const CImg<t>& img) const {
      return CImg<Tfloat>(*this,false).pow(img);
    }





    CImg<T>& rol(const unsigned int n=1) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)cimg::rol(*ptrd,n);
      return *this;
    }


    CImg<T> get_rol(const unsigned int n=1) const {
      return (+*this).rol(n);
    }





    CImg<T>& rol(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"rol");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<')
          for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)cimg::rol(*ptrd,(unsigned int)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>')
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::rol(*ptrd,(unsigned int)mp(x,y,z,c)); ++ptrd; }
        else {
# 15787 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::rol(*ptrd,(unsigned int)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        CImg<Tfloat> values(_width,_height,_depth,_spectrum);
        try {
          values.fill(expression,true);
        } catch (CImgException&) {
          cimg::exception_mode() = omode;
          values.load(expression);
        }
        rol(values);
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    CImg<T> get_rol(const char *const expression) const {
      return (+*this).rol(expression);
    }





    template<typename t>
    CImg<T>& rol(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return rol(+img);
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)cimg::rol(*ptrd,(unsigned int)(*(ptrs++)));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)cimg::rol(*ptrd,(unsigned int)(*(ptrs++)));
      }
      return *this;
    }


    template<typename t>
    CImg<T> get_rol(const CImg<t>& img) const {
      return (+*this).rol(img);
    }





    CImg<T>& ror(const unsigned int n=1) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)cimg::ror(*ptrd,n);
      return *this;
    }


    CImg<T> get_ror(const unsigned int n=1) const {
      return (+*this).ror(n);
    }





    CImg<T>& ror(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"ror");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<')
          for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)cimg::ror(*ptrd,(unsigned int)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>')
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::ror(*ptrd,(unsigned int)mp(x,y,z,c)); ++ptrd; }
        else {
# 15880 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::ror(*ptrd,(unsigned int)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        CImg<Tfloat> values(_width,_height,_depth,_spectrum);
        try {
          values.fill(expression,true);
        } catch (CImgException&) {
          cimg::exception_mode() = omode;
          values.load(expression);
        }
        ror(values);
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    CImg<T> get_ror(const char *const expression) const {
      return (+*this).ror(expression);
    }





    template<typename t>
    CImg<T>& ror(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return ror(+img);
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = (T)cimg::ror(*ptrd,(unsigned int)(*(ptrs++)));
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)cimg::ror(*ptrd,(unsigned int)(*(ptrs++)));
      }
      return *this;
    }


    template<typename t>
    CImg<T> get_ror(const CImg<t>& img) const {
      return (+*this).ror(img);
    }







    CImg<T>& min(const T val) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = cimg::min(*ptrd,val);
      return *this;
    }


    CImg<T> get_min(const T val) const {
      return (+*this).min(val);
    }







    template<typename t>
    CImg<T>& min(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return min(+img);
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = cimg::min((T)*(ptrs++),*ptrd);
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = cimg::min((T)*(ptrs++),*ptrd);
      }
      return *this;
    }


    template<typename t>
    CImg<typename cimg::superset<T,t>::type> get_min(const CImg<t>& img) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false).min(img);
    }







    CImg<T>& min(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"min");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)cimg::min(*ptrd,(T)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::min(*ptrd,(T)mp(x,y,z,c)); ++ptrd; }
        else {
# 16001 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::min(*ptrd,(T)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        CImg<T> values(_width,_height,_depth,_spectrum);
        try {
          values.fill(expression,true);
        } catch (CImgException&) {
          cimg::exception_mode() = omode;
          values.load(expression);
        }
        min(values);
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    CImg<Tfloat> get_min(const char *const expression) const {
      return CImg<Tfloat>(*this,false).min(expression);
    }







    CImg<T>& max(const T val) {
      if (is_empty()) return *this;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = cimg::max(*ptrd,val);
      return *this;
    }


    CImg<T> get_max(const T val) const {
      return (+*this).max(val);
    }







    template<typename t>
    CImg<T>& max(const CImg<t>& img) {
      const unsigned long siz = size(), isiz = img.size();
      if (siz && isiz) {
        if (is_overlapped(img)) return max(+img);
        T *ptrd = _data, *const ptre = _data + siz;
        if (siz>isiz) for (unsigned long n = siz/isiz; n; --n)
          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)
            *ptrd = cimg::max((T)*(ptrs++),*ptrd);
        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = cimg::max((T)*(ptrs++),*ptrd);
      }
      return *this;
    }


    template<typename t>
    CImg<typename cimg::superset<T,t>::type> get_max(const CImg<t>& img) const {
      return CImg<typename cimg::superset<T,t>::type>(*this,false).max(img);
    }







    CImg<T>& max(const char *const expression) {
      if (is_empty()) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"max");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) { *ptrd = (T)cimg::max(*ptrd,(T)mp(x,y,z,c)); --ptrd; }
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::max(*ptrd,(T)mp(x,y,z,c)); ++ptrd; }
        else {
# 16098 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { *ptrd = (T)cimg::max(*ptrd,(T)mp(x,y,z,c)); ++ptrd; }
        }
      } catch (CImgException&) {
        CImg<T> values(_width,_height,_depth,_spectrum);
        try {
          values.fill(expression,true);
        } catch (CImgException&) {
          cimg::exception_mode() = omode;
          values.load(expression);
        }
        max(values);
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    CImg<Tfloat> get_max(const char *const expression) const {
      return CImg<Tfloat>(*this,false).max(expression);
    }




    T& min() {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "min(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      T *ptr_min = _data;
      T min_value = *ptr_min;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;
    }


    const T& min() const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "min(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;
    }




    T& max() {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "max(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      T *ptr_max = _data;
      T max_value = *ptr_max;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) if (*ptrs>max_value) max_value = *(ptr_max=ptrs);
      return *ptr_max;
    }


    const T& max() const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "max(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      const T *ptr_max = _data;
      T max_value = *ptr_max;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) if (*ptrs>max_value) max_value = *(ptr_max=ptrs);
      return *ptr_max;
    }





    template<typename t>
    T& min_max(t& max_val) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "min_max(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      T *ptr_min = _data;
      T min_value = *ptr_min, max_value = min_value;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) {
        const T val = *ptrs;
        if (val<min_value) { min_value = val; ptr_min = ptrs; }
        if (val>max_value) max_value = val;
      }
      max_val = (t)max_value;
      return *ptr_min;
    }


    template<typename t>
    const T& min_max(t& max_val) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "min_max(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      const T *ptr_min = _data;
      T min_value = *ptr_min, max_value = min_value;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) {
        const T val = *ptrs;
        if (val<min_value) { min_value = val; ptr_min = ptrs; }
        if (val>max_value) max_value = val;
      }
      max_val = (t)max_value;
      return *ptr_min;
    }





    template<typename t>
    T& max_min(t& min_val) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "max_min(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      T *ptr_max = _data;
      T max_value = *ptr_max, min_value = max_value;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) {
        const T val = *ptrs;
        if (val>max_value) { max_value = val; ptr_max = ptrs; }
        if (val<min_value) min_value = val;
      }
      min_val = (t)min_value;
      return *ptr_max;
    }


    template<typename t>
    const T& max_min(t& min_val) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "max_min(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      const T *ptr_max = _data;
      T max_value = *ptr_max, min_value = max_value;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) {
        const T val = *ptrs;
        if (val>max_value) { max_value = val; ptr_max = ptrs; }
        if (val<min_value) min_value = val;
      }
      min_val = (t)min_value;
      return *ptr_max;
    }





    T kth_smallest(const unsigned int k) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "kth_smallest(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      CImg<T> arr(*this);
      unsigned int l = 0, ir = size() - 1;
      for (;;) {
        if (ir<=l+1) {
          if (ir==l+1 && arr[ir]<arr[l]) cimg::swap(arr[l],arr[ir]);
          return arr[k];
        } else {
          const unsigned int mid = (l + ir)>>1;
          cimg::swap(arr[mid],arr[l+1]);
          if (arr[l]>arr[ir]) cimg::swap(arr[l],arr[ir]);
          if (arr[l+1]>arr[ir]) cimg::swap(arr[l+1],arr[ir]);
          if (arr[l]>arr[l+1]) cimg::swap(arr[l],arr[l+1]);
          unsigned int i = l + 1, j = ir;
          const T pivot = arr[l+1];
          for (;;) {
            do ++i; while (arr[i]<pivot);
            do --j; while (arr[j]>pivot);
            if (j<i) break;
            cimg::swap(arr[i],arr[j]);
          }
          arr[l+1] = arr[j];
          arr[j] = pivot;
          if (j>=k) ir = j - 1;
          if (j<=k) l = i;
        }
      }
    }




    T median() const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "median(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      const unsigned int s = size();
      const T res = kth_smallest(s>>1);
      return (s%2)?res:((res+kth_smallest((s>>1)-1))/2);
    }




    Tdouble sum() const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "sum(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      Tdouble res = 0;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) res+=(Tdouble)*ptrs;
      return res;
    }




    Tdouble mean() const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "mean(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      Tdouble res = 0;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) res+=(Tdouble)*ptrs;
      return res/size();
    }
# 16336 "../src/CImg.h"
    Tdouble variance(const unsigned int variance_method=1) const {
      Tdouble foo;
      return variance_mean(variance_method,foo);
    }






    template<typename t>
    Tdouble variance_mean(const unsigned int variance_method, t& mean) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "variance_mean(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      Tdouble variance = 0, average = 0;
      const unsigned long siz = size();
      switch (variance_method) {
      case 0 :{
        Tdouble S = 0, S2 = 0;
        for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) { const Tdouble val = (Tdouble)*ptrs; S+=val; S2+=val*val; }
        variance = (S2 - S*S/siz)/siz;
        average = S;
      } break;
      case 1 : {
        Tdouble S = 0, S2 = 0;
        for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) { const Tdouble val = (Tdouble)*ptrs; S+=val; S2+=val*val; }
        variance = siz>1?(S2 - S*S/siz)/(siz - 1):0;
        average = S;
      } break;
      case 2 : {
        CImg<Tfloat> buf(*this,false);
        buf.sort();
        const unsigned long siz2 = siz>>1;
        const Tdouble med_i = (double)buf[siz2];
        for (Tfloat *ptrs = (buf)._data, *_maxptrs = (buf)._data + (buf).size(); ptrs<_maxptrs; ++ptrs) {
          const Tdouble val = (Tdouble)*ptrs; *ptrs = (Tfloat)cimg::abs(val - med_i); average+=val;
        }
        buf.sort();
        const Tdouble sig = (Tdouble)(1.4828*buf[siz2]);
        variance = sig*sig;
      } break;
      default : {
        CImg<Tfloat> buf(*this,false);
        const unsigned long siz2 = siz>>1;
        for (Tfloat *ptrs = (buf)._data, *_maxptrs = (buf)._data + (buf).size(); ptrs<_maxptrs; ++ptrs) {
          const Tdouble val = (Tdouble)*ptrs; (*ptrs)=(Tfloat)((*ptrs)*val); average+=val;
        }
        buf.sort();
        Tdouble a = 0;
        const Tfloat *ptrs = buf._data;
        for (unsigned long j = 0; j<siz2; ++j) a+=(Tdouble)*(ptrs++);
        const Tdouble sig = (Tdouble)(2.6477*std::sqrt(a/siz2));
        variance = sig*sig;
      }
      }
      mean = (t)(average/siz);
      return variance>0?variance:0;
    }
# 16407 "../src/CImg.h"
    Tdouble variance_noise(const unsigned int variance_method=2) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "variance_noise(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const unsigned long siz = size();
      if (!siz || !_data) return 0;
      if (variance_method>1) {
        CImg<Tdouble> tmp(*this);
        if (_depth==1) {
          const Tdouble cste = 1.0/std::sqrt(20.0);



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            T I[9]; T& Ipp = I[0]; T& Icp = I[1]; T& Inp = I[2]; T& Ipc = I[3]; T& Icc = I[4]; T& Inc = I[5]; T& Ipn = I[6]; T& Icn = I[7]; T& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
            for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (T)(*this)(0,y,0,c)), (I[6] = I[7] = (T)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,0,c)), (I[5] = (T)(*this)(_n1x,y,0,c)), (I[8] = (T)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
              tmp(x,y,c) = cste*((Tdouble)Inc + (Tdouble)Ipc + (Tdouble)Icn +
                                 (Tdouble)Icp - 4*(Tdouble)Icc);
            }
          }
        } else {
          const Tdouble cste = 1.0/std::sqrt(42.0);



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            T I[27]; T& Ippp = I[0]; T& Icpp = I[1]; T& Inpp = I[2]; T& Ipcp = I[3]; T& Iccp = I[4]; T& Incp = I[5]; T& Ipnp = I[6]; T& Icnp = I[7]; T& Innp = I[8]; T& Ippc = I[9]; T& Icpc = I[10]; T& Inpc = I[11]; T& Ipcc = I[12]; T& Iccc = I[13]; T& Incc = I[14]; T& Ipnc = I[15]; T& Icnc = I[16]; T& Innc = I[17]; T& Ippn = I[18]; T& Icpn = I[19]; T& Inpn = I[20]; T& Ipcn = I[21]; T& Iccn = I[22]; T& Incn = I[23]; T& Ipnn = I[24]; T& Icnn = I[25]; T& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
            for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (T)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (T)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (T)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (T)(*this)(0,y,z,c)), (I[15] = I[16] = (T)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (T)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (T)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (T)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (T)(*this)(_n1x,y,_p1z,c)), (I[8] = (T)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (T)(*this)(_n1x,_p1y,z,c)), (I[14] = (T)(*this)(_n1x,y,z,c)), (I[17] = (T)(*this)(_n1x,_n1y,z,c)), (I[20] = (T)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (T)(*this)(_n1x,y,_n1z,c)), (I[26] = (T)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
              tmp(x,y,z,c) = cste*(
                                   (Tdouble)Incc + (Tdouble)Ipcc + (Tdouble)Icnc + (Tdouble)Icpc +
                                   (Tdouble)Iccn + (Tdouble)Iccp - 6*(Tdouble)Iccc);
            }
          }
        }
        return tmp.variance(variance_method);
      }


      Tdouble variance = 0, S = 0, S2 = 0;
      if (_depth==1) {
        const Tdouble cste = 1.0/std::sqrt(20.0);
        T I[9]; T& Ipp = I[0]; T& Icp = I[1]; T& Inp = I[2]; T& Ipc = I[3]; T& Icc = I[4]; T& Inc = I[5]; T& Ipn = I[6]; T& Icn = I[7]; T& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (T)(*this)(0,y,0,c)), (I[6] = I[7] = (T)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,0,c)), (I[5] = (T)(*this)(_n1x,y,0,c)), (I[8] = (T)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
          const Tdouble val = cste*((Tdouble)Inc + (Tdouble)Ipc +
                                    (Tdouble)Icn + (Tdouble)Icp - 4*(Tdouble)Icc);
          S+=val; S2+=val*val;
        }
      } else {
        const Tdouble cste = 1.0/std::sqrt(42.0);
        T I[27]; T& Ippp = I[0]; T& Icpp = I[1]; T& Inpp = I[2]; T& Ipcp = I[3]; T& Iccp = I[4]; T& Incp = I[5]; T& Ipnp = I[6]; T& Icnp = I[7]; T& Innp = I[8]; T& Ippc = I[9]; T& Icpc = I[10]; T& Inpc = I[11]; T& Ipcc = I[12]; T& Iccc = I[13]; T& Incc = I[14]; T& Ipnc = I[15]; T& Icnc = I[16]; T& Innc = I[17]; T& Ippn = I[18]; T& Icpn = I[19]; T& Inpn = I[20]; T& Ipcn = I[21]; T& Iccn = I[22]; T& Incn = I[23]; T& Ipnn = I[24]; T& Icnn = I[25]; T& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (T)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (T)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (T)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (T)(*this)(0,y,z,c)), (I[15] = I[16] = (T)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (T)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (T)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (T)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (T)(*this)(_n1x,y,_p1z,c)), (I[8] = (T)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (T)(*this)(_n1x,_p1y,z,c)), (I[14] = (T)(*this)(_n1x,y,z,c)), (I[17] = (T)(*this)(_n1x,_n1y,z,c)), (I[20] = (T)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (T)(*this)(_n1x,y,_n1z,c)), (I[26] = (T)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
          const Tdouble val = cste *
            ((Tdouble)Incc + (Tdouble)Ipcc + (Tdouble)Icnc +
             (Tdouble)Icpc +
             (Tdouble)Iccn + (Tdouble)Iccp - 6*(Tdouble)Iccc);
          S+=val; S2+=val*val;
        }
      }
      if (variance_method) variance = siz>1?(S2 - S*S/siz)/(siz - 1):0;
      else variance = (S2 - S*S/siz)/siz;
      return variance>0?variance:0;
    }





    template<typename t>
    Tdouble MSE(const CImg<t>& img) const {
      if (img.size()!=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "MSE(): Instance and specified image (%u,%u,%u,%u,%p) have different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    img._width,img._height,img._depth,img._spectrum,img._data);
      Tdouble vMSE = 0;
      const t* ptr2 = img._data;
      for (T *ptr1 = (*this)._data, *_maxptr1 = (*this)._data + (*this).size(); ptr1<_maxptr1; ++ptr1) {
        const Tdouble diff = (Tdouble)*ptr1 - (Tdouble)*(ptr2++);
        vMSE+=diff*diff;
      }
      const unsigned long siz = img.size();
      if (siz) vMSE/=siz;
      return vMSE;
    }






    template<typename t>
    Tdouble PSNR(const CImg<t>& img, const Tdouble max_value=255) const {
      const Tdouble vMSE = (Tdouble)std::sqrt(MSE(img));
      return (vMSE!=0)?(Tdouble)(20*std::log10(max_value/vMSE)):(Tdouble)(cimg::type<Tdouble>::max());
    }
# 16513 "../src/CImg.h"
    double eval(const char *const expression,
                const double x=0, const double y=0, const double z=0, const double c=0) const {
      if (!expression) return 0;
      return _cimg_math_parser(*this,expression,"eval")(x,y,z,c);
    }






    template<typename t>
    CImg<doubleT> eval(const char *const expression, const CImg<t>& xyzc) const {
      CImg<doubleT> res(1,xyzc.size()/4);
      if (!expression) return res.fill(0);
      _cimg_math_parser mp(*this,expression,"eval");
# 16541 "../src/CImg.h"
      const t *ps = xyzc._data;
      for (double *pd = (res)._data, *_maxpd = (res)._data + (res).size(); pd<_maxpd; ++pd) {
        const double x = (double)*(ps++), y = (double)*(ps++), z = (double)*(ps++), c = (double)*(ps++);
        *pd = mp(x,y,z,c);
      }

      return res;
    }






    CImg<Tdouble> get_stats(const unsigned int variance_method=1) const {
      if (is_empty()) return CImg<doubleT>();
      const unsigned long siz = size();
      const T *const odata = _data;
      const T *pm = odata, *pM = odata;
      Tdouble S = 0, S2 = 0;
      T m = *pm, M = m;
      for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) {
        const T val = *ptrs;
        const Tdouble _val = (Tdouble)val;
        if (val<m) { m = val; pm = ptrs; }
        if (val>M) { M = val; pM = ptrs; }
        S+=_val;
        S2+=_val*_val;
      }
      const Tdouble
        mean_value = S/siz,
        _variance_value = variance_method==0?(S2 - S*S/siz)/siz:
        (variance_method==1?(siz>1?(S2 - S*S/siz)/(siz - 1):0):
         variance(variance_method)),
        variance_value = _variance_value>0?_variance_value:0;
      int
        xm = 0, ym = 0, zm = 0, cm = 0,
        xM = 0, yM = 0, zM = 0, cM = 0;
      contains(*pm,xm,ym,zm,cm);
      contains(*pM,xM,yM,zM,cM);
      return CImg<Tdouble>(1,12).fill((Tdouble)m,(Tdouble)M,mean_value,variance_value,
                                      (Tdouble)xm,(Tdouble)ym,(Tdouble)zm,(Tdouble)cm,
                                      (Tdouble)xM,(Tdouble)yM,(Tdouble)zM,(Tdouble)cM);
    }


    CImg<T>& stats(const unsigned int variance_method=1) {
      return get_stats(variance_method).move_to(*this);
    }
# 16605 "../src/CImg.h"
    Tdouble magnitude(const int magnitude_type=2) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "magnitude(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      Tdouble res = 0;
      switch (magnitude_type) {
      case -1 : {
        for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) { const Tdouble val = (Tdouble)cimg::abs(*ptrs); if (val>res) res = val; }
      } break;
      case 1 : {
        for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) res+=(Tdouble)cimg::abs(*ptrs);
      } break;
      default : {
        for (T *ptrs = (*this)._data, *_maxptrs = (*this)._data + (*this).size(); ptrs<_maxptrs; ++ptrs) res+=(Tdouble)cimg::sqr(*ptrs);
        res = (Tdouble)std::sqrt(res);
      }
      }
      return res;
    }




    Tdouble trace() const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "trace(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      Tdouble res = 0;
      for (int k = 0; k<(int)((*this)._width); ++k) res+=(Tdouble)(*this)(k,k);
      return res;
    }




    Tdouble det() const {
      if (is_empty() || _width!=_height || _depth!=1 || _spectrum!=1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "det(): Instance is not a square matrix.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      switch (_width) {
      case 1 : return (Tdouble)((*this)(0,0));
      case 2 : return (Tdouble)((*this)(0,0))*(Tdouble)((*this)(1,1)) - (Tdouble)((*this)(0,1))*(Tdouble)((*this)(1,0));
      case 3 : {
        const Tdouble
          a = (Tdouble)_data[0], d = (Tdouble)_data[1], g = (Tdouble)_data[2],
          b = (Tdouble)_data[3], e = (Tdouble)_data[4], h = (Tdouble)_data[5],
          c = (Tdouble)_data[6], f = (Tdouble)_data[7], i = (Tdouble)_data[8];
        return i*a*e - a*h*f - i*b*d + b*g*f + c*d*h - c*g*e;
      }
      default : {
        CImg<Tfloat> lu(*this);
        CImg<uintT> indx;
        bool d;
        lu._LU(indx,d);
        Tdouble res = d?(Tdouble)1:(Tdouble)-1;
        for (int i = 0; i<(int)((lu)._width); ++i) res*=lu(i,i);
        return res;
      }
      }
    }





    template<typename t>
    Tdouble dot(const CImg<t>& img) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "dot(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (!img)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "dot(): Empty specified image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const unsigned int nb = cimg::min(size(),img.size());
      Tdouble res = 0;
      for (unsigned int off = 0; off<nb; ++off) res+=(Tdouble)_data[off]*(Tdouble)img[off];
      return res;
    }







    CImg<T> get_vector_at(const unsigned int x, const unsigned int y=0, const unsigned int z=0) const {
      CImg<T> res;
      if (res._height!=_spectrum) res.assign(1,_spectrum);
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      const T *ptrs = data(x,y,z);
      T *ptrd = res._data;
      for (int c = 0; c<(int)((*this)._spectrum); ++c) { *(ptrd++) = *ptrs; ptrs+=whd; }
      return res;
    }
# 16714 "../src/CImg.h"
    CImg<T> get_matrix_at(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) const {
      const int n = (int)std::sqrt((double)_spectrum);
      const T *ptrs = data(x,y,z,0);
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      CImg<T> res(n,n);
      T *ptrd = res._data;
      for (int c = 0; c<(int)((*this)._spectrum); ++c) { *(ptrd++) = *ptrs; ptrs+=whd; }
      return res;
    }







    CImg<T> get_tensor_at(const unsigned int x, const unsigned int y=0, const unsigned int z=0) const {
      const T *ptrs = data(x,y,z,0);
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      if (_spectrum==6) return tensor(*ptrs,*(ptrs+whd),*(ptrs+2*whd),*(ptrs+3*whd),*(ptrs+4*whd),*(ptrs+5*whd));
      if (_spectrum==3) return tensor(*ptrs,*(ptrs+whd),*(ptrs+2*whd));
      return tensor(*ptrs);
    }
# 16745 "../src/CImg.h"
    template<typename t>
    CImg<T>& set_vector_at(const CImg<t>& vec, const unsigned int x, const unsigned int y=0, const unsigned int z=0) {
      if (x<_width && y<_height && z<_depth) {
        const t *ptrs = vec._data;
        const unsigned long whd = (unsigned long)_width*_height*_depth;
        T *ptrd = data(x,y,z);
        for (unsigned int k = cimg::min((unsigned int)vec.size(),_spectrum); k; --k) {
          *ptrd = (T)*(ptrs++); ptrd+=whd;
        }
      }
      return *this;
    }
# 16765 "../src/CImg.h"
    template<typename t>
    CImg<T>& set_matrix_at(const CImg<t>& mat, const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) {
      return set_vector_at(mat,x,y,z);
    }
# 16777 "../src/CImg.h"
    template<typename t>
    CImg<T>& set_tensor_at(const CImg<t>& ten, const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) {
      T *ptrd = data(x,y,z,0);
      const unsigned long siz = (unsigned long)_width*_height*_depth;
      if (ten._height==2) {
        *ptrd = (T)ten[0]; ptrd+=siz;
        *ptrd = (T)ten[1]; ptrd+=siz;
        *ptrd = (T)ten[3];
      }
      else {
        *ptrd = (T)ten[0]; ptrd+=siz;
        *ptrd = (T)ten[1]; ptrd+=siz;
        *ptrd = (T)ten[2]; ptrd+=siz;
        *ptrd = (T)ten[4]; ptrd+=siz;
        *ptrd = (T)ten[5]; ptrd+=siz;
        *ptrd = (T)ten[8];
      }
      return *this;
    }





    CImg<T>& vector() {
      return unroll('y');
    }


    CImg<T> get_vector() const {
      return get_unroll('y');
    }




    CImg<T>& matrix() {
      const unsigned long siz = size();
      switch (siz) {
      case 1 : break;
      case 4 : _width = _height = 2; break;
      case 9 : _width = _height = 3; break;
      case 16 : _width = _height = 4; break;
      case 25 : _width = _height = 5; break;
      case 36 : _width = _height = 6; break;
      case 49 : _width = _height = 7; break;
      case 64 : _width = _height = 8; break;
      case 81 : _width = _height = 9; break;
      case 100 : _width = _height = 10; break;
      default : {
        unsigned long i = 11, i2 = i*i;
        while (i2<siz) { i2+=2*i + 1; ++i; }
        if (i2==siz) _width = _height = i;
        else throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                         "matrix(): Invalid instance size %u (should be a square integer).",
                                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                         siz);
      }
      }
      return *this;
    }


    CImg<T> get_matrix() const {
      return (+*this).matrix();
    }




    CImg<T>& tensor() {
      return get_tensor().move_to(*this);
    }


    CImg<T> get_tensor() const {
      CImg<T> res;
      const unsigned long siz = size();
      switch (siz) {
      case 1 : break;
      case 3 :
        res.assign(2,2);
        res(0,0) = (*this)(0);
        res(1,0) = res(0,1) = (*this)(1);
        res(1,1) = (*this)(2);
        break;
      case 6 :
        res.assign(3,3);
        res(0,0) = (*this)(0);
        res(1,0) = res(0,1) = (*this)(1);
        res(2,0) = res(0,2) = (*this)(2);
        res(1,1) = (*this)(3);
        res(2,1) = res(1,2) = (*this)(4);
        res(2,2) = (*this)(5);
        break;
      default :
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "tensor(): Invalid instance size (does not define a 1x1, 2x2 or 3x3 tensor).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      }
      return res;
    }





    CImg<T>& diagonal() {
      return get_diagonal().move_to(*this);
    }


    CImg<T> get_diagonal() const {
      if (is_empty()) return *this;
      CImg<T> res(size(),size(),1,1,0);
      for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) res(off,off) = (*this)(off);
      return res;
    }






    CImg<T>& identity_matrix() {
      return identity_matrix(cimg::max(_width,_height)).move_to(*this);
    }


    CImg<T> get_identity_matrix() const {
      return identity_matrix(cimg::max(_width,_height));
    }






    CImg<T>& sequence(const T a0, const T a1) {
      if (is_empty()) return *this;
      const unsigned int siz = size() - 1;
      T* ptr = _data;
      if (siz) {
        const Tdouble delta = (Tdouble)a1 - (Tdouble)a0;
        for (unsigned long l = 0, _maxl = (*this).size(); l<_maxl; ++l) *(ptr++) = (T)(a0 + delta*l/siz);
      } else *ptr = a0;
      return *this;
    }


    CImg<T> get_sequence(const T a0, const T a1) const {
      return (+*this).sequence(a0,a1);
    }





    CImg<T>& transpose() {
      if (_width==1) { _width = _height; _height = 1; return *this; }
      if (_height==1) { _height = _width; _width = 1; return *this; }
      if (_width==_height) {
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = y; x<width(); ++x) cimg::swap((*this)(x,y,z,c),(*this)(y,x,z,c));
        return *this;
      }
      return get_transpose().move_to(*this);
    }


    CImg<T> get_transpose() const {
      return get_permute_axes("yxzc");
    }






    template<typename t>
    CImg<T>& cross(const CImg<t>& img) {
      if (_width!=1 || _height<3 || img._width!=1 || img._height<3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "cross(): Instance and/or specified image (%u,%u,%u,%u,%p) are not 3d vectors.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    img._width,img._height,img._depth,img._spectrum,img._data);

      const T x = (*this)[0], y = (*this)[1], z = (*this)[2];
      (*this)[0] = (T)(y*img[2] - z*img[1]);
      (*this)[1] = (T)(z*img[0] - x*img[2]);
      (*this)[2] = (T)(x*img[1] - y*img[0]);
      return *this;
    }


    template<typename t>
    CImg<typename cimg::superset<T,t>::type> get_cross(const CImg<t>& img) const {
      return CImg<typename cimg::superset<T,t>::type>(*this).cross(img);
    }







    CImg<T>& invert(const bool use_LU=true) {
      if (_width!=_height || _depth!=1 || _spectrum!=1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "invert(): Instance is not a square matrix.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
# 17010 "../src/CImg.h"
      const double dete = _width>3?-1.0:det();
      if (dete!=0.0 && _width==2) {
        const double
          a = _data[0], c = _data[1],
          b = _data[2], d = _data[3];
        _data[0] = (T)(d/dete); _data[1] = (T)(-c/dete);
        _data[2] = (T)(-b/dete); _data[3] = (T)(a/dete);
      } else if (dete!=0.0 && _width==3) {
        const double
          a = _data[0], d = _data[1], g = _data[2],
          b = _data[3], e = _data[4], h = _data[5],
          c = _data[6], f = _data[7], i = _data[8];
        _data[0] = (T)((i*e-f*h)/dete), _data[1] = (T)((g*f-i*d)/dete), _data[2] = (T)((d*h-g*e)/dete);
        _data[3] = (T)((h*c-i*b)/dete), _data[4] = (T)((i*a-c*g)/dete), _data[5] = (T)((g*b-a*h)/dete);
        _data[6] = (T)((b*f-e*c)/dete), _data[7] = (T)((d*c-a*f)/dete), _data[8] = (T)((a*e-d*b)/dete);
      } else {
        if (use_LU) {
          CImg<Tfloat> A(*this), indx, col(1,_width);
          bool d;
          A._LU(indx,d);
          for (int j = 0; j<(int)((*this)._width); ++j) {
            col.fill(0);
            col(j) = 1;
            col._solve(A,indx);
            for (int i = 0; i<(int)((*this)._width); ++i) (*this)(j,i) = (T)col(i);
          }
        } else {
          CImg<Tfloat> U(_width,_width), S(1,_width), V(_width,_width);
          SVD(U,S,V,false);
          U.transpose();
          for (int k = 0; k<(int)((S)._height); ++k) if (S[k]!=0) S[k]=1/S[k];
          S.diagonal();
          *this = V*S*U;
        }
      }

      return *this;
    }


    CImg<Tfloat> get_invert(const bool use_LU=true) const {
      return CImg<Tfloat>(*this,false).invert(use_LU);
    }




    CImg<T>& pseudoinvert() {
      return get_pseudoinvert().move_to(*this);
    }


    CImg<Tfloat> get_pseudoinvert() const {
      CImg<Tfloat> U, S, V;
      SVD(U,S,V);
      const Tfloat tolerance = (sizeof(Tfloat)<=4?5.96e-8f:1.11e-16f)*cimg::max(_width,_height)*S.max();
      for (int x = 0; x<(int)((V)._width); ++x) {
        const Tfloat s = S(x), invs = s>tolerance?1/s:(Tfloat)0;
        for (int y = 0; y<(int)((V)._height); ++y) V(x,y)*=invs;
      }
      return V*U.transpose();
    }






    template<typename t>
    CImg<T>& solve(const CImg<t>& A) {
      if (_width!=1 || _depth!=1 || _spectrum!=1 || _height!=A._height || A._depth!=1 || A._spectrum!=1)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "solve(): Instance and specified matrix (%u,%u,%u,%u,%p) have "
                                    "incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    A._width,A._height,A._depth,A._spectrum,A._data);
      typedef typename cimg::superset2<T,t,float>::type Ttfloat;
      if (A._width==A._height) {
# 17115 "../src/CImg.h"
        CImg<Ttfloat> lu(A,false);
        CImg<Ttfloat> indx;
        bool d;
        lu._LU(indx,d);
        _solve(lu,indx);

      } else {
# 17147 "../src/CImg.h"
        assign(A.get_pseudoinvert()*(*this));

      }
      return *this;
    }


    template<typename t>
    CImg<typename cimg::superset2<T,t,float>::type> get_solve(const CImg<t>& A) const {
      return CImg<typename cimg::superset2<T,t,float>::type>(*this,false).solve(A);
    }

    template<typename t, typename ti>
    CImg<T>& _solve(const CImg<t>& A, const CImg<ti>& indx) {
      typedef typename cimg::superset2<T,t,float>::type Ttfloat;
      const int N = size();
      int ii = -1;
      Ttfloat sum;
      for (int i = 0; i<N; ++i) {
        const int ip = (int)indx[i];
        Ttfloat sum = (*this)(ip);
        (*this)(ip) = (*this)(i);
        if (ii>=0) for (int j = ii; j<=i-1; ++j) sum-=A(j,i)*(*this)(j);
        else if (sum!=0) ii = i;
        (*this)(i) = (T)sum;
      }
      for (int i = N - 1; i>=0; --i) {
        sum = (*this)(i);
        for (int j = i + 1; j<N; ++j) sum-=A(j,i)*(*this)(j);
        (*this)(i) = (T)(sum/A(i,i));
      }
      return *this;
    }
# 17188 "../src/CImg.h"
    template<typename t>
    CImg<T>& solve_tridiagonal(const CImg<t>& A) {
      const unsigned int siz = (int)size();
      if (A._width!=3 || A._height!=siz)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "solve_tridiagonal(): Instance and tridiagonal matrix "
                                    "(%u,%u,%u,%u,%p) have incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    A._width,A._height,A._depth,A._spectrum,A._data);
      typedef typename cimg::superset2<T,t,float>::type Ttfloat;
      const Ttfloat epsilon = 1e-4f;
      CImg<Ttfloat> B = A.get_column(1), V(*this,false);
      for (int i = 1; i<(int)siz; ++i) {
        const Ttfloat m = A(0,i)/(B[i-1]?B[i-1]:epsilon);
        B[i] -= m*A(2,i-1);
        V[i] -= m*V[i-1];
      }
      (*this)[siz-1] = (T)(V[siz-1]/(B[siz-1]?B[siz-1]:epsilon));
      for (int i = (int)siz - 2; i>=0; --i) (*this)[i] = (T)((V[i] - A(2,i)*(*this)[i+1])/(B[i]?B[i]:epsilon));
      return *this;
    }


    template<typename t>
    CImg<typename cimg::superset2<T,t,float>::type> get_solve_tridiagonal(const CImg<t>& A) const {
      return CImg<typename cimg::superset2<T,t,float>::type>(*this,false).solve_tridiagonal(A);
    }






    template<typename t>
    const CImg<T>& eigen(CImg<t>& val, CImg<t> &vec) const {
      if (is_empty()) { val.assign(); vec.assign(); }
      else {
        if (_width!=_height || _depth>1 || _spectrum>1)
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "eigen(): Instance is not a square matrix.",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

        if (val.size()<(unsigned long)_width) val.assign(1,_width);
        if (vec.size()<(unsigned long)_width*_width) vec.assign(_width,_width);
        switch (_width) {
        case 1 : { val[0] = (t)(*this)[0]; vec[0] = (t)1; } break;
        case 2 : {
          const double a = (*this)[0], b = (*this)[1], c = (*this)[2], d = (*this)[3], e = a + d;
          double f = e*e - 4*(a*d - b*c);
          if (f<0)
            cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                       "eigen(): Complex eigenvalues found.",
                       _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

          f = std::sqrt(f);
          const double l1 = 0.5*(e-f), l2 = 0.5*(e+f);
          const double theta1 = std::atan2(l2-a,b), theta2 = std::atan2(l1-a,b);
          val[0] = (t)l2;
          val[1] = (t)l1;
          vec(0,0) = (t)std::cos(theta1);
          vec(0,1) = (t)std::sin(theta1);
          vec(1,0) = (t)std::cos(theta2);
          vec(1,1) = (t)std::sin(theta2);
        } break;
        default :
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "eigen(): Eigenvalues computation of general matrices is limited "
                                      "to 2x2 matrices.",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
        }
      }
      return *this;
    }





    CImgList<Tfloat> get_eigen() const {
      CImgList<Tfloat> res(2);
      eigen(res[0],res[1]);
      return res;
    }






    template<typename t>
    const CImg<T>& symmetric_eigen(CImg<t>& val, CImg<t>& vec) const {
      if (is_empty()) { val.assign(); vec.assign(); }
      else {
# 17304 "../src/CImg.h"
        if (_width!=_height || _depth>1 || _spectrum>1)
          throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "eigen(): Instance is not a square matrix.",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

        val.assign(1,_width);
        if (vec._data) vec.assign(_width,_width);
        if (_width<3) {
          eigen(val,vec);
          if (_width==2) { vec[1] = -vec[2]; vec[3] = vec[0]; }
          return *this;
        }
        CImg<t> V(_width,_width);
        SVD(vec,val,V,false);

        bool is_ambiguous = false;
        float eig = 0;
        for (int p = 0; p<(int)((val)._height); ++p) {
          if (val[p]>eig) eig = (float)val[p];
          t scal = 0;
          for (int y = 0; y<(int)((vec)._height); ++y) scal+=vec(p,y)*V(p,y);
          if (cimg::abs(scal)<0.9f) is_ambiguous = true;
          if (scal<0) val[p] = -val[p];
        }
        if (is_ambiguous) {
          ++(eig*=2);
          SVD(vec,val,V,false,40,eig);
          val-=eig;
        }
        CImg<intT> permutations;
        CImg<t> tmp(_width);
        val.sort(permutations,false);
        for (int k = 0; k<(int)((vec)._height); ++k) {
          for (int y = 0; y<(int)((permutations)._height); ++y) tmp(y) = vec(permutations(y),k);
          std::memcpy(vec.data(0,k),tmp._data,sizeof(t)*_width);
        }

      }
      return *this;
    }






    CImgList<Tfloat> get_symmetric_eigen() const {
      CImgList<Tfloat> res(2);
      symmetric_eigen(res[0],res[1]);
      return res;
    }






    template<typename t>
    CImg<T>& sort(CImg<t>& permutations, const bool is_increasing=true) {
      permutations.assign(_width,_height,_depth,_spectrum);
      if (is_empty()) return *this;
      for (unsigned long off = 0, _maxoff = (permutations).size(); off<_maxoff; ++off) permutations[off] = (t)off;
      return _quicksort(0,size()-1,permutations,is_increasing,true);
    }


    template<typename t>
    CImg<T> get_sort(CImg<t>& permutations, const bool is_increasing=true) const {
      return (+*this).sort(permutations,is_increasing);
    }
# 17385 "../src/CImg.h"
    CImg<T>& sort(const bool is_increasing=true, const char axis=0) {
      if (is_empty()) return *this;
      CImg<uintT> perm;
      switch (cimg::uncase(axis)) {
      case 0 :
        _quicksort(0,size()-1,perm,is_increasing,false);
        break;
      case 'x' : {
        perm.assign(_width);
        get_crop(0,0,0,0,_width-1,0,0,0).sort(perm,is_increasing);
        CImg<T> img(*this,false);
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) (*this)(x,y,z,c) = img(perm[x],y,z,c);
      } break;
      case 'y' : {
        perm.assign(_height);
        get_crop(0,0,0,0,0,_height-1,0,0).sort(perm,is_increasing);
        CImg<T> img(*this,false);
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) (*this)(x,y,z,c) = img(x,perm[y],z,c);
      } break;
      case 'z' : {
        perm.assign(_depth);
        get_crop(0,0,0,0,0,0,_depth-1,0).sort(perm,is_increasing);
        CImg<T> img(*this,false);
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) (*this)(x,y,z,c) = img(x,y,perm[z],c);
      } break;
      case 'c' : {
        perm.assign(_spectrum);
        get_crop(0,0,0,0,0,0,0,_spectrum-1).sort(perm,is_increasing);
        CImg<T> img(*this,false);
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) (*this)(x,y,z,c) = img(x,y,z,perm[c]);
      } break;
      default :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "sort(): Invalid specified axis '%c' "
                                    "(should be { x | y | z | c }).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),axis);
      }
      return *this;
    }


    CImg<T> get_sort(const bool is_increasing=true, const char axis=0) const {
      return (+*this).sort(is_increasing,axis);
    }

    template<typename t>
    CImg<T>& _quicksort(const int indm, const int indM, CImg<t>& permutations,
                        const bool is_increasing, const bool is_permutations) {
      if (indm<indM) {
        const int mid = (indm + indM)/2;
        if (is_increasing) {
          if ((*this)[indm]>(*this)[mid]) {
            cimg::swap((*this)[indm],(*this)[mid]);
            if (is_permutations) cimg::swap(permutations[indm],permutations[mid]);
          }
          if ((*this)[mid]>(*this)[indM]) {
            cimg::swap((*this)[indM],(*this)[mid]);
            if (is_permutations) cimg::swap(permutations[indM],permutations[mid]);
          }
          if ((*this)[indm]>(*this)[mid]) {
            cimg::swap((*this)[indm],(*this)[mid]);
            if (is_permutations) cimg::swap(permutations[indm],permutations[mid]);
          }
        } else {
          if ((*this)[indm]<(*this)[mid]) {
            cimg::swap((*this)[indm],(*this)[mid]);
            if (is_permutations) cimg::swap(permutations[indm],permutations[mid]);
          }
          if ((*this)[mid]<(*this)[indM]) {
            cimg::swap((*this)[indM],(*this)[mid]);
            if (is_permutations) cimg::swap(permutations[indM],permutations[mid]);
          }
          if ((*this)[indm]<(*this)[mid]) {
            cimg::swap((*this)[indm],(*this)[mid]);
            if (is_permutations) cimg::swap(permutations[indm],permutations[mid]);
          }
        }
        if (indM - indm>=3) {
          const T pivot = (*this)[mid];
          int i = indm, j = indM;
          if (is_increasing) {
            do {
              while ((*this)[i]<pivot) ++i;
              while ((*this)[j]>pivot) --j;
              if (i<=j) {
                if (is_permutations) cimg::swap(permutations[i],permutations[j]);
                cimg::swap((*this)[i++],(*this)[j--]);
              }
            } while (i<=j);
          } else {
            do {
              while ((*this)[i]>pivot) ++i;
              while ((*this)[j]<pivot) --j;
              if (i<=j) {
                if (is_permutations) cimg::swap(permutations[i],permutations[j]);
                cimg::swap((*this)[i++],(*this)[j--]);
              }
            } while (i<=j);
          }
          if (indm<j) _quicksort(indm,j,permutations,is_increasing,is_permutations);
          if (i<indM) _quicksort(i,indM,permutations,is_increasing,is_permutations);
        }
      }
      return *this;
    }
# 17509 "../src/CImg.h"
    template<typename t>
    const CImg<T>& SVD(CImg<t>& U, CImg<t>& S, CImg<t>& V, const bool sorting=true,
                       const unsigned int max_iteration=40, const float lambda=0) const {
      if (is_empty()) { U.assign(); S.assign(); V.assign(); }
      else {
        U = *this;
        if (lambda!=0) {
          const unsigned int delta = cimg::min(U._width,U._height);
          for (unsigned int i = 0; i<delta; ++i) U(i,i) = (t)(U(i,i) + lambda);
        }
        if (S.size()<_width) S.assign(1,_width);
        if (V._width<_width || V._height<_height) V.assign(_width,_width);
        CImg<t> rv1(_width);
        t anorm = 0, c, f, g = 0, h, s, scale = 0;
        int l = 0, nm = 0;

        for (int i = 0; i<(int)((U)._width); ++i) {
          l = i+1; rv1[i] = scale*g; g = s = scale = 0;
          if (i<height()) {
            for (int k = i; k<height(); ++k) scale+= cimg::abs(U(i,k));
            if (scale) {
              for (int k = i; k<height(); ++k) { U(i,k)/=scale; s+= U(i,k)*U(i,k); }
              f = U(i,i); g = (t)((f>=0?-1:1)*std::sqrt(s)); h=f*g-s; U(i,i) = f-g;
              for (int j = l; j<width(); ++j) {
                s = 0;
                for (int k=i; k<height(); ++k) s+= U(i,k)*U(j,k);
                f = s/h;
                for (int k = i; k<height(); ++k) U(j,k)+= f*U(i,k);
              }
              for (int k = i; k<height(); ++k) U(i,k)*= scale;
            }
          }
          S[i]=scale*g;

          g = s = scale = 0;
          if (i<height() && i!=width()-1) {
            for (int k = l; k<width(); ++k) scale+=cimg::abs(U(k,i));
            if (scale) {
              for (int k = l; k<width(); ++k) { U(k,i)/= scale; s+= U(k,i)*U(k,i); }
              f = U(l,i); g = (t)((f>=0?-1:1)*std::sqrt(s)); h = f*g-s; U(l,i) = f-g;
              for (int k = l; k<width(); ++k) rv1[k]=U(k,i)/h;
              for (int j = l; j<height(); ++j) {
                s = 0;
                for (int k = l; k<width(); ++k) s+= U(k,j)*U(k,i);
                for (int k = l; k<width(); ++k) U(k,j)+= s*rv1[k];
              }
              for (int k = l; k<width(); ++k) U(k,i)*= scale;
            }
          }
          anorm = (t)cimg::max((float)anorm,(float)(cimg::abs(S[i])+cimg::abs(rv1[i])));
        }

        for (int i = width()-1; i>=0; --i) {
          if (i<width()-1) {
            if (g) {
              for (int j = l; j<width(); ++j) V(i,j) =(U(j,i)/U(l,i))/g;
              for (int j = l; j<width(); ++j) {
                s = 0;
                for (int k = l; k<width(); ++k) s+= U(k,i)*V(j,k);
                for (int k = l; k<width(); ++k) V(j,k)+= s*V(i,k);
              }
            }
            for (int j = l; j<width(); ++j) V(j,i) = V(i,j) = (t)0.0;
          }
          V(i,i) = (t)1.0; g = rv1[i]; l = i;
        }

        for (int i = cimg::min(width(),height())-1; i>=0; --i) {
          l = i+1; g = S[i];
          for (int j = l; j<width(); ++j) U(j,i) = 0;
          if (g) {
            g = 1/g;
            for (int j = l; j<width(); ++j) {
              s = 0; for (int k = l; k<height(); ++k) s+= U(i,k)*U(j,k);
              f = (s/U(i,i))*g;
              for (int k = i; k<height(); ++k) U(j,k)+= f*U(i,k);
            }
            for (int j = i; j<height(); ++j) U(i,j)*= g;
          } else for (int j = i; j<height(); ++j) U(i,j) = 0;
          ++U(i,i);
        }

        for (int k = width()-1; k>=0; --k) {
          for (unsigned int its = 0; its<max_iteration; ++its) {
            bool flag = true;
            for (l = k; l>=1; --l) {
              nm = l-1;
              if ((cimg::abs(rv1[l])+anorm)==anorm) { flag = false; break; }
              if ((cimg::abs(S[nm])+anorm)==anorm) break;
            }
            if (flag) {
              c = 0; s = 1;
              for (int i = l; i<=k; ++i) {
                f = s*rv1[i]; rv1[i] = c*rv1[i];
                if ((cimg::abs(f)+anorm)==anorm) break;
                g = S[i]; h = (t)cimg::_pythagore(f,g); S[i] = h; h = 1/h; c = g*h; s = -f*h;
                for (int j = 0; j<(int)((U)._height); ++j) { const t y = U(nm,j), z = U(i,j); U(nm,j) = y*c + z*s; U(i,j) = z*c - y*s; }
              }
            }

            const t z = S[k];
            if (l==k) { if (z<0) { S[k] = -z; for (int j = 0; j<(int)((U)._width); ++j) V(k,j) = -V(k,j); } break; }
            nm = k-1;
            t x = S[l], y = S[nm];
            g = rv1[nm]; h = rv1[k];
            f = ((y-z)*(y+z)+(g-h)*(g+h))/cimg::max((t)1e-25,2*h*y);
            g = (t)cimg::_pythagore(f,1.0);
            f = ((x-z)*(x+z)+h*((y/(f + (f>=0?g:-g)))-h))/cimg::max((t)1e-25,x);
            c = s = 1;
            for (int j = l; j<=nm; ++j) {
              const int i = j+1;
              g = rv1[i]; h = s*g; g = c*g;
              t y = S[i];
              t z = (t)cimg::_pythagore(f,h);
              rv1[j] = z; c = f/cimg::max((t)1e-25,z); s = h/cimg::max((t)1e-25,z);
              f = x*c+g*s; g = g*c-x*s; h = y*s; y*=c;
              for (int jj = 0; jj<(int)((U)._width); ++jj) { const t x = V(j,jj), z = V(i,jj); V(j,jj) = x*c + z*s; V(i,jj) = z*c - x*s; }
              z = (t)cimg::_pythagore(f,h); S[j] = z;
              if (z) { z = 1/cimg::max((t)1e-25,z); c = f*z; s = h*z; }
              f = c*g+s*y; x = c*y-s*g;
              for (int jj = 0; jj<(int)((U)._height); ++jj) { const t y = U(j,jj); z = U(i,jj); U(j,jj) = y*c + z*s; U(i,jj) = z*c - y*s; }
            }
            rv1[l] = 0; rv1[k]=f; S[k]=x;
          }
        }

        if (sorting) {
          CImg<intT> permutations;
          CImg<t> tmp(_width);
          S.sort(permutations,false);
          for (int k = 0; k<(int)((U)._height); ++k) {
            for (int y = 0; y<(int)((permutations)._height); ++y) tmp(y) = U(permutations(y),k);
            std::memcpy(U.data(0,k),tmp._data,sizeof(t)*_width);
          }
          for (int k = 0; k<(int)((V)._height); ++k) {
            for (int y = 0; y<(int)((permutations)._height); ++y) tmp(y) = V(permutations(y),k);
            std::memcpy(V.data(0,k),tmp._data,sizeof(t)*_width);
          }
        }
      }
      return *this;
    }






    CImgList<Tfloat> get_SVD(const bool sorting=true,
                             const unsigned int max_iteration=40, const float lambda=0) const {
      CImgList<Tfloat> res(3);
      SVD(res[0],res[1],res[2],sorting,max_iteration,lambda);
      return res;
    }


    template<typename t>
    CImg<T>& _LU(CImg<t>& indx, bool& d) {
      const int N = width();
      int imax = 0;
      CImg<Tfloat> vv(N);
      indx.assign(N);
      d = true;
      for (int i = 0; i<(int)((*this)._width); ++i) {
        Tfloat vmax = 0;
        for (int j = 0; j<(int)((*this)._width); ++j) {
          const Tfloat tmp = cimg::abs((*this)(j,i));
          if (tmp>vmax) vmax = tmp;
        }
        if (vmax==0) { indx.fill(0); return fill(0); }
        vv[i] = 1/vmax;
      }
      for (int j = 0; j<(int)((*this)._width); ++j) {
        for (int i = 0; i<j; ++i) {
          Tfloat sum=(*this)(j,i);
          for (int k = 0; k<i; ++k) sum-=(*this)(k,i)*(*this)(j,k);
          (*this)(j,i) = (T)sum;
        }
        Tfloat vmax = 0;
        for (int i = j; i<width(); ++i) {
          Tfloat sum=(*this)(j,i);
          for (int k = 0; k<j; ++k) sum-=(*this)(k,i)*(*this)(j,k);
          (*this)(j,i) = (T)sum;
          const Tfloat tmp = vv[i]*cimg::abs(sum);
          if (tmp>=vmax) { vmax=tmp; imax=i; }
        }
        if (j!=imax) {
          for (int k = 0; k<(int)((*this)._width); ++k) cimg::swap((*this)(k,imax),(*this)(k,j));
          d =!d;
          vv[imax] = vv[j];
        }
        indx[j] = (t)imax;
        if ((*this)(j,j)==0) (*this)(j,j) = (T)1e-20;
        if (j<N) {
          const Tfloat tmp = 1/(Tfloat)(*this)(j,j);
          for (int i=j+1; i<N; ++i) (*this)(j,i) = (T)((*this)(j,i)*tmp);
        }
      }
      return *this;
    }
# 17721 "../src/CImg.h"
    template<typename tf, typename t>
    static CImg<T> dijkstra(const tf& distance, const unsigned int nb_nodes,
                            const unsigned int starting_node, const unsigned int ending_node,
                            CImg<t>& previous_node) {
      if (starting_node>=nb_nodes)
        throw CImgArgumentException("CImg<%s>::dijkstra(): Specified indice of starting node %u is higher "
                                    "than number of nodes %u.",
                                    pixel_type(),starting_node,nb_nodes);
      CImg<T> dist(1,nb_nodes,1,1,cimg::type<T>::max());
      dist(starting_node) = 0;
      previous_node.assign(1,nb_nodes,1,1,(t)-1);
      previous_node(starting_node) = (t)starting_node;
      CImg<uintT> Q(nb_nodes);
      for (int u = 0; u<(int)((Q)._width); ++u) Q(u) = u;
      cimg::swap(Q(starting_node),Q(0));
      unsigned int sizeQ = nb_nodes;
      while (sizeQ) {

        const unsigned int umin = Q(0);
        if (umin==ending_node) sizeQ = 0;
        else {
          const T dmin = dist(umin);
          const T infty = cimg::type<T>::max();
          for (unsigned int q = 1; q<sizeQ; ++q) {
            const unsigned int v = Q(q);
            const T d = (T)distance(v,umin);
            if (d<infty) {
              const T alt = dmin + d;
              if (alt<dist(v)) {
                dist(v) = alt;
                previous_node(v) = (t)umin;
                const T distpos = dist(Q(q));
                for (unsigned int pos = q, par = 0; pos && distpos<dist(Q(par=(pos+1)/2-1)); pos=par)
                  cimg::swap(Q(pos),Q(par));
              }
            }
          }

          Q(0) = Q(--sizeQ);
          const T distpos = dist(Q(0));
          for (unsigned int pos = 0, left = 0, right = 0;
               ((right=2*(pos+1),(left=right-1))<sizeQ && distpos>dist(Q(left))) ||
                 (right<sizeQ && distpos>dist(Q(right)));) {
            if (right<sizeQ) {
              if (dist(Q(left))<dist(Q(right))) { cimg::swap(Q(pos),Q(left)); pos = left; }
              else { cimg::swap(Q(pos),Q(right)); pos = right; }
            } else { cimg::swap(Q(pos),Q(left)); pos = left; }
          }
        }
      }
      return dist;
    }


    template<typename tf, typename t>
    static CImg<T> dijkstra(const tf& distance, const unsigned int nb_nodes,
                            const unsigned int starting_node, const unsigned int ending_node=~0U) {
      CImg<uintT> foo;
      return dijkstra(distance,nb_nodes,starting_node,ending_node,foo);
    }
# 17791 "../src/CImg.h"
    template<typename t>
    CImg<T>& dijkstra(const unsigned int starting_node, const unsigned int ending_node,
                      CImg<t>& previous_node) {
      return get_dijkstra(starting_node,ending_node,previous_node).move_to(*this);
    }


    template<typename t>
    CImg<T> get_dijkstra(const unsigned int starting_node, const unsigned int ending_node,
                         CImg<t>& previous_node) const {
      if (_width!=_height || _depth!=1 || _spectrum!=1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "dijkstra(): Instance is not a graph adjacency matrix.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      return dijkstra(*this,_width,starting_node,ending_node,previous_node);
    }


    CImg<T>& dijkstra(const unsigned int starting_node, const unsigned int ending_node=~0U) {
      return get_dijkstra(starting_node,ending_node).move_to(*this);
    }


    CImg<Tfloat> get_dijkstra(const unsigned int starting_node, const unsigned int ending_node=~0U) const {
      CImg<uintT> foo;
      return get_dijkstra(starting_node,ending_node,foo);
    }






    static CImg<T> string(const char *const str, const bool is_last_zero=true, const bool is_shared=false) {
      if (!str) return CImg<T>();
      return CImg<T>(str,(unsigned int)std::strlen(str)+(is_last_zero?1:0),1,1,1,is_shared);
    }





    static CImg<T> vector(const T& a0) {
      CImg<T> r(1,1);
      r[0] = a0;
      return r;
    }






    static CImg<T> vector(const T& a0, const T& a1) {
      CImg<T> r(1,2); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1;
      return r;
    }







    static CImg<T> vector(const T& a0, const T& a1, const T& a2) {
      CImg<T> r(1,3); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2;
      return r;
    }
# 17870 "../src/CImg.h"
    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3) {
      CImg<T> r(1,4); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3, const T& a4) {
      CImg<T> r(1,5); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3; *(ptr++) = a4;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3, const T& a4, const T& a5) {
      CImg<T> r(1,6); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3; *(ptr++) = a4; *(ptr++) = a5;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6) {
      CImg<T> r(1,7); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7) {
      CImg<T> r(1,8); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8) {
      CImg<T> r(1,9); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8, const T& a9) {
      CImg<T> r(1,10); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8; *(ptr++) = a9;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8, const T& a9, const T& a10) {
      CImg<T> r(1,11); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8; *(ptr++) = a9; *(ptr++) = a10;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8, const T& a9, const T& a10, const T& a11) {
      CImg<T> r(1,12); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8; *(ptr++) = a9; *(ptr++) = a10; *(ptr++) = a11;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8, const T& a9, const T& a10, const T& a11,
                          const T& a12) {
      CImg<T> r(1,13); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8; *(ptr++) = a9; *(ptr++) = a10; *(ptr++) = a11;
      *(ptr++) = a12;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8, const T& a9, const T& a10, const T& a11,
                          const T& a12, const T& a13) {
      CImg<T> r(1,14); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8; *(ptr++) = a9; *(ptr++) = a10; *(ptr++) = a11;
      *(ptr++) = a12; *(ptr++) = a13;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8, const T& a9, const T& a10, const T& a11,
                          const T& a12, const T& a13, const T& a14) {
      CImg<T> r(1,15); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8; *(ptr++) = a9; *(ptr++) = a10; *(ptr++) = a11;
      *(ptr++) = a12; *(ptr++) = a13; *(ptr++) = a14;
      return r;
    }


    static CImg<T> vector(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8, const T& a9, const T& a10, const T& a11,
                          const T& a12, const T& a13, const T& a14, const T& a15) {
      CImg<T> r(1,16); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8; *(ptr++) = a9; *(ptr++) = a10; *(ptr++) = a11;
      *(ptr++) = a12; *(ptr++) = a13; *(ptr++) = a14; *(ptr++) = a15;
      return r;
    }






    static CImg<T> matrix(const T& a0) {
      return vector(a0);
    }
# 18020 "../src/CImg.h"
    static CImg<T> matrix(const T& a0, const T& a1,
                          const T& a2, const T& a3) {
      CImg<T> r(2,2); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1;
      *(ptr++) = a2; *(ptr++) = a3;
      return r;
    }
# 18040 "../src/CImg.h"
    static CImg<T> matrix(const T& a0, const T& a1, const T& a2,
                          const T& a3, const T& a4, const T& a5,
                          const T& a6, const T& a7, const T& a8) {
      CImg<T> r(3,3); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2;
      *(ptr++) = a3; *(ptr++) = a4; *(ptr++) = a5;
      *(ptr++) = a6; *(ptr++) = a7; *(ptr++) = a8;
      return r;
    }


    static CImg<T> matrix(const T& a0, const T& a1, const T& a2, const T& a3,
                          const T& a4, const T& a5, const T& a6, const T& a7,
                          const T& a8, const T& a9, const T& a10, const T& a11,
                          const T& a12, const T& a13, const T& a14, const T& a15) {
      CImg<T> r(4,4); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3;
      *(ptr++) = a4; *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7;
      *(ptr++) = a8; *(ptr++) = a9; *(ptr++) = a10; *(ptr++) = a11;
      *(ptr++) = a12; *(ptr++) = a13; *(ptr++) = a14; *(ptr++) = a15;
      return r;
    }


    static CImg<T> matrix(const T& a0, const T& a1, const T& a2, const T& a3, const T& a4,
                          const T& a5, const T& a6, const T& a7, const T& a8, const T& a9,
                          const T& a10, const T& a11, const T& a12, const T& a13, const T& a14,
                          const T& a15, const T& a16, const T& a17, const T& a18, const T& a19,
                          const T& a20, const T& a21, const T& a22, const T& a23, const T& a24) {
      CImg<T> r(5,5); T *ptr = r._data;
      *(ptr++) = a0; *(ptr++) = a1; *(ptr++) = a2; *(ptr++) = a3; *(ptr++) = a4;
      *(ptr++) = a5; *(ptr++) = a6; *(ptr++) = a7; *(ptr++) = a8; *(ptr++) = a9;
      *(ptr++) = a10; *(ptr++) = a11; *(ptr++) = a12; *(ptr++) = a13; *(ptr++) = a14;
      *(ptr++) = a15; *(ptr++) = a16; *(ptr++) = a17; *(ptr++) = a18; *(ptr++) = a19;
      *(ptr++) = a20; *(ptr++) = a21; *(ptr++) = a22; *(ptr++) = a23; *(ptr++) = a24;
      return r;
    }






    static CImg<T> tensor(const T& a0) {
      return matrix(a0);
    }


    static CImg<T> tensor(const T& a0, const T& a1, const T& a2) {
      return matrix(a0,a1,a1,a2);
    }


    static CImg<T> tensor(const T& a0, const T& a1, const T& a2, const T& a3, const T& a4, const T& a5) {
      return matrix(a0,a1,a2,a1,a3,a4,a2,a4,a5);
    }


    static CImg<T> diagonal(const T& a0) {
      return matrix(a0);
    }


    static CImg<T> diagonal(const T& a0, const T& a1) {
      return matrix(a0,0,0,a1);
    }


    static CImg<T> diagonal(const T& a0, const T& a1, const T& a2) {
      return matrix(a0,0,0,0,a1,0,0,0,a2);
    }


    static CImg<T> diagonal(const T& a0, const T& a1, const T& a2, const T& a3) {
      return matrix(a0,0,0,0,0,a1,0,0,0,0,a2,0,0,0,0,a3);
    }


    static CImg<T> diagonal(const T& a0, const T& a1, const T& a2, const T& a3, const T& a4) {
      return matrix(a0,0,0,0,0,0,a1,0,0,0,0,0,a2,0,0,0,0,0,a3,0,0,0,0,0,a4);
    }





    static CImg<T> identity_matrix(const unsigned int N) {
      CImg<T> res(N,N,1,1,0);
      for (int x = 0; x<(int)((res)._width); ++x) res(x,x) = 1;
      return res;
    }







    static CImg<T> sequence(const unsigned int N, const T a0, const T a1) {
      if (N) return CImg<T>(1,N).sequence(a0,a1);
      return CImg<T>();
    }
# 18151 "../src/CImg.h"
    static CImg<T> rotation_matrix(const float x, const float y, const float z, const float w,
                                   const bool is_quaternion=false) {
      float X,Y,Z,W;
      if (!is_quaternion) {
        const float norm = (float)std::sqrt(x*x + y*y + z*z),
          nx = norm>0?x/norm:0,
          ny = norm>0?y/norm:0,
          nz = norm>0?z/norm:1,
          nw = norm>0?w:0,
          sina = (float)std::sin(nw/2),
          cosa = (float)std::cos(nw/2);
        X = nx*sina;
        Y = ny*sina;
        Z = nz*sina;
        W = cosa;
      } else {
        const float norm = (float)std::sqrt(x*x + y*y + z*z + w*w);
        if (norm>0) { X = x/norm; Y = y/norm; Z = z/norm; W = w/norm; }
        else { X = Y = Z = 0; W = 1; }
      }
      const float xx = X*X, xy = X*Y, xz = X*Z, xw = X*W, yy = Y*Y, yz = Y*Z, yw = Y*W, zz = Z*Z, zw = Z*W;
      return CImg<T>::matrix((T)(1-2*(yy+zz)), (T)(2*(xy+zw)), (T)(2*(xz-yw)),
                             (T)(2*(xy-zw)), (T)(1-2*(xx+zz)), (T)(2*(yz+xw)),
                             (T)(2*(xz+yw)), (T)(2*(yz-xw)), (T)(1-2*(xx+yy)));
    }
# 18188 "../src/CImg.h"
    CImg<T>& fill(const T val) {
      if (is_empty()) return *this;
      if (val && sizeof(T)!=1) for (T *ptrd = (*this)._data, *_maxptrd = (*this)._data + (*this).size(); ptrd<_maxptrd; ++ptrd) *ptrd = val;
      else std::memset(_data,(int)val,sizeof(T)*size());
      return *this;
    }


    CImg<T> get_fill(const T val) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val);
    }






    CImg<T>& fill(const T val0, const T val1) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-1;
      for (ptrd = _data; ptrd<ptre; ) { *(ptrd++) = val0; *(ptrd++) = val1; }
      if (ptrd!=ptre+1) *(ptrd++) = val0;
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-2;
      for (ptrd = _data; ptrd<ptre; ) { *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; }
      ptre+=2;
      switch (ptre - ptrd) {
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-3;
      for (ptrd = _data; ptrd<ptre; ) { *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; }
      ptre+=3;
      switch (ptre - ptrd) {
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-4;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4;
      }
      ptre+=4;
      switch (ptre - ptrd) {
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-5;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4; *(ptrd++) = val5;
      }
      ptre+=5;
      switch (ptre - ptrd) {
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-6;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4; *(ptrd++) = val5;
        *(ptrd++) = val6;
      }
      ptre+=6;
      switch (ptre - ptrd) {
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5,
                     const T val6) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5,
                  const T val6, const T val7) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-7;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3;
        *(ptrd++) = val4; *(ptrd++) = val5; *(ptrd++) = val6; *(ptrd++) = val7;
      }
      ptre+=7;
      switch (ptre - ptrd) {
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                  const T val7, const T val8) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-8;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2;
        *(ptrd++) = val3; *(ptrd++) = val4; *(ptrd++) = val5;
        *(ptrd++) = val6; *(ptrd++) = val7; *(ptrd++) = val8;
      }
      ptre+=8;
      switch (ptre - ptrd) {
      case 8 : *(--ptre) = val7;
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7, const T val8) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                  const T val7, const T val8, const T val9) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-9;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4;
        *(ptrd++) = val5; *(ptrd++) = val6; *(ptrd++) = val7; *(ptrd++) = val8; *(ptrd++) = val9;
      }
      ptre+=9;
      switch (ptre - ptrd) {
      case 9 : *(--ptre) = val8;
      case 8 : *(--ptre) = val7;
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7, const T val8, const T val9) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                  const T val7, const T val8, const T val9, const T val10) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-10;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4;
        *(ptrd++) = val5; *(ptrd++) = val6; *(ptrd++) = val7; *(ptrd++) = val8; *(ptrd++) = val9;
        *(ptrd++) = val10;
      }
      ptre+=10;
      switch (ptre - ptrd) {
      case 10 : *(--ptre) = val9;
      case 9 : *(--ptre) = val8;
      case 8 : *(--ptre) = val7;
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7, const T val8, const T val9, const T val10) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                  const T val7, const T val8, const T val9, const T val10, const T val11) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-11;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4; *(ptrd++) = val5;
        *(ptrd++) = val6; *(ptrd++) = val7; *(ptrd++) = val8; *(ptrd++) = val9; *(ptrd++) = val10; *(ptrd++) = val11;
      }
      ptre+=11;
      switch (ptre - ptrd) {
      case 11 : *(--ptre) = val10;
      case 10 : *(--ptre) = val9;
      case 9 : *(--ptre) = val8;
      case 8 : *(--ptre) = val7;
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7, const T val8, const T val9, const T val10, const T val11) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,
                                                           val11);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                  const T val7, const T val8, const T val9, const T val10, const T val11, const T val12) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-12;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4; *(ptrd++) = val5;
        *(ptrd++) = val6; *(ptrd++) = val7; *(ptrd++) = val8; *(ptrd++) = val9; *(ptrd++) = val10; *(ptrd++) = val11;
        *(ptrd++) = val12;
      }
      ptre+=12;
      switch (ptre - ptrd) {
      case 12 : *(--ptre) = val11;
      case 11 : *(--ptre) = val10;
      case 10 : *(--ptre) = val9;
      case 9 : *(--ptre) = val8;
      case 8 : *(--ptre) = val7;
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7, const T val8, const T val9, const T val10, const T val11, const T val12) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,
                                                           val11,val12);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                  const T val7, const T val8, const T val9, const T val10, const T val11, const T val12,
                  const T val13) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-13;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4; *(ptrd++) = val5;
        *(ptrd++) = val6; *(ptrd++) = val7; *(ptrd++) = val8; *(ptrd++) = val9; *(ptrd++) = val10; *(ptrd++) = val11;
        *(ptrd++) = val12; *(ptrd++) = val13;
      }
      ptre+=13;
      switch (ptre - ptrd) {
      case 13 : *(--ptre) = val12;
      case 12 : *(--ptre) = val11;
      case 11 : *(--ptre) = val10;
      case 10 : *(--ptre) = val9;
      case 9 : *(--ptre) = val8;
      case 8 : *(--ptre) = val7;
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7, const T val8, const T val9, const T val10, const T val11, const T val12,
                     const T val13) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,
                                                           val11,val12,val13);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                  const T val7, const T val8, const T val9, const T val10, const T val11, const T val12,
                  const T val13, const T val14) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-14;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4; *(ptrd++) = val5;
        *(ptrd++) = val6; *(ptrd++) = val7; *(ptrd++) = val8; *(ptrd++) = val9; *(ptrd++) = val10; *(ptrd++) = val11;
        *(ptrd++) = val12; *(ptrd++) = val13; *(ptrd++) = val14;
      }
      ptre+=14;
      switch (ptre - ptrd) {
      case 14 : *(--ptre) = val13;
      case 13 : *(--ptre) = val12;
      case 12 : *(--ptre) = val11;
      case 11 : *(--ptre) = val10;
      case 10 : *(--ptre) = val9;
      case 9 : *(--ptre) = val8;
      case 8 : *(--ptre) = val7;
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7, const T val8, const T val9, const T val10, const T val11, const T val12,
                     const T val13, const T val14) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,
                                                           val11,val12,val13,val14);
    }


    CImg<T>& fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                  const T val7, const T val8, const T val9, const T val10, const T val11, const T val12,
                  const T val13, const T val14, const T val15) {
      if (is_empty()) return *this;
      T *ptrd, *ptre = end()-15;
      for (ptrd = _data; ptrd<ptre; ) {
        *(ptrd++) = val0; *(ptrd++) = val1; *(ptrd++) = val2; *(ptrd++) = val3; *(ptrd++) = val4; *(ptrd++) = val5;
        *(ptrd++) = val6; *(ptrd++) = val7; *(ptrd++) = val8; *(ptrd++) = val9; *(ptrd++) = val10; *(ptrd++) = val11;
        *(ptrd++) = val12; *(ptrd++) = val13; *(ptrd++) = val14; *(ptrd++) = val15;
      }
      ptre+=15;
      switch (ptre - ptrd) {
      case 15 : *(--ptre) = val14;
      case 14 : *(--ptre) = val13;
      case 13 : *(--ptre) = val12;
      case 12 : *(--ptre) = val11;
      case 11 : *(--ptre) = val10;
      case 10 : *(--ptre) = val9;
      case 9 : *(--ptre) = val8;
      case 8 : *(--ptre) = val7;
      case 7 : *(--ptre) = val6;
      case 6 : *(--ptre) = val5;
      case 5 : *(--ptre) = val4;
      case 4 : *(--ptre) = val3;
      case 3 : *(--ptre) = val2;
      case 2 : *(--ptre) = val1;
      case 1 : *(--ptre) = val0;
      }
      return *this;
    }


    CImg<T> get_fill(const T val0, const T val1, const T val2, const T val3, const T val4, const T val5, const T val6,
                     const T val7, const T val8, const T val9, const T val10, const T val11, const T val12,
                     const T val13, const T val14, const T val15) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,
                                                           val11,val12,val13,val14,val15);
    }






    CImg<T>& fill(const char *const expression, const bool repeat_flag) {
      if (is_empty() || !expression || !*expression) return *this;
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
        const CImg<T> _base = cimg::_is_self_expr(expression)?+*this:CImg<T>(), &base = _base?_base:*this;
        _cimg_math_parser mp(base,expression+(*expression=='>' || *expression=='<'?1:0),"fill");
        T *ptrd = *expression=='<'?end()-1:_data;
        if (*expression=='<') for (int c = (int)((*this)._spectrum)-1; c>=0; --c) for (int z = (int)((*this)._depth)-1; z>=0; --z) for (int y = (int)((*this)._height)-1; y>=0; --y) for (int x = (int)((*this)._width)-1; x>=0; --x) *(ptrd--) = (T)mp(x,y,z,c);
        else if (*expression=='>') for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) *(ptrd++) = (T)mp(x,y,z,c);
        else {
# 18660 "../src/CImg.h"
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) *(ptrd++) = (T)mp(x,y,z,c);
        }
      } catch (CImgException& e) {
        char item[16384] = { 0 }, sep = 0;
        const char *nexpression = expression;
        unsigned long nb = 0;
        const unsigned long siz = size();
        T *ptrd = _data;
        for (double val = 0; *nexpression && nb<siz; ++nb) {
          sep = 0;
          const int err = std::sscanf(nexpression,"%4095[ \n\t0-9.e+-]%c",item,&sep);
          if (err>0 && std::sscanf(item,"%lf",&val)==1) {
            nexpression+=std::strlen(item) + (err>1?1:0);
            *(ptrd++) = (T)val;
          } else break;
        }
        cimg::exception_mode() = omode;
        if (nb<siz && (sep || *nexpression))
          throw CImgArgumentException(e.what(),pixel_type(),expression);
        if (repeat_flag && nb && nb<siz)
          for (T *ptrs = _data, *const ptre = _data + siz; ptrd<ptre; ++ptrs) *(ptrd++) = *ptrs;
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    CImg<T> get_fill(const char *const values, const bool repeat_values) const {
      return (+*this).fill(values,repeat_values);
    }







    template<typename t>
    CImg<T>& fill(const CImg<t>& values, const bool repeat_values=true) {
      if (is_empty() || !values) return *this;
      T *ptrd = _data, *ptre = ptrd + size();
      for (t *ptrs = values._data, *ptrs_end = ptrs + values.size(); ptrs<ptrs_end && ptrd<ptre; ++ptrs)
        *(ptrd++) = (T)*ptrs;
      if (repeat_values && ptrd<ptre) for (T *ptrs = _data; ptrd<ptre; ++ptrs) *(ptrd++) = *ptrs;
      return *this;
    }


    template<typename t>
    CImg<T> get_fill(const CImg<t>& values, const bool repeat_values=true) const {
      return repeat_values?CImg<T>(_width,_height,_depth,_spectrum).fill(values,repeat_values):
        (+*this).fill(values,repeat_values);
    }
# 18721 "../src/CImg.h"
    CImg<T>& fillX(const unsigned int y, const unsigned int z, const unsigned int c, const int a0, ...) {




      if (y<_height && z<_depth && c<_spectrum) { va_list ap; __builtin_va_start(ap,a0); T *ptrd = data(0,y,z,c); *ptrd = (T)a0; for (unsigned long k = 1; k<_width; ++k) { ptrd+=1; *ptrd = (T)__builtin_va_arg(ap,int); } __builtin_va_end(ap); };
      return *this;
    }


    CImg<T>& fillX(const unsigned int y, const unsigned int z, const unsigned int c, const double a0, ...) {
      if (y<_height && z<_depth && c<_spectrum) { va_list ap; __builtin_va_start(ap,a0); T *ptrd = data(0,y,z,c); *ptrd = (T)a0; for (unsigned long k = 1; k<_width; ++k) { ptrd+=1; *ptrd = (T)__builtin_va_arg(ap,double); } __builtin_va_end(ap); };
      return *this;
    }
# 18743 "../src/CImg.h"
    CImg<T>& fillY(const unsigned int x, const unsigned int z, const unsigned int c, const int a0, ...) {
      if (x<_width && z<_depth && c<_spectrum) { va_list ap; __builtin_va_start(ap,a0); T *ptrd = data(x,0,z,c); *ptrd = (T)a0; for (unsigned long k = 1; k<_height; ++k) { ptrd+=_width; *ptrd = (T)__builtin_va_arg(ap,int); } __builtin_va_end(ap); };
      return *this;
    }


    CImg<T>& fillY(const unsigned int x, const unsigned int z, const unsigned int c, const double a0, ...) {
      if (x<_width && z<_depth && c<_spectrum) { va_list ap; __builtin_va_start(ap,a0); T *ptrd = data(x,0,z,c); *ptrd = (T)a0; for (unsigned long k = 1; k<_height; ++k) { ptrd+=_width; *ptrd = (T)__builtin_va_arg(ap,double); } __builtin_va_end(ap); };
      return *this;
    }
# 18761 "../src/CImg.h"
    CImg<T>& fillZ(const unsigned int x, const unsigned int y, const unsigned int c, const int a0, ...) {
      const unsigned long wh = (unsigned long)_width*_height;
      if (x<_width && y<_height && c<_spectrum) { va_list ap; __builtin_va_start(ap,a0); T *ptrd = data(x,y,0,c); *ptrd = (T)a0; for (unsigned long k = 1; k<_depth; ++k) { ptrd+=wh; *ptrd = (T)__builtin_va_arg(ap,int); } __builtin_va_end(ap); };
      return *this;
    }


    CImg<T>& fillZ(const unsigned int x, const unsigned int y, const unsigned int c, const double a0, ...) {
      const unsigned long wh = (unsigned long)_width*_height;
      if (x<_width && y<_height && c<_spectrum) { va_list ap; __builtin_va_start(ap,a0); T *ptrd = data(x,y,0,c); *ptrd = (T)a0; for (unsigned long k = 1; k<_depth; ++k) { ptrd+=wh; *ptrd = (T)__builtin_va_arg(ap,double); } __builtin_va_end(ap); };
      return *this;
    }
# 18781 "../src/CImg.h"
    CImg<T>& fillC(const unsigned int x, const unsigned int y, const unsigned int z, const int a0, ...) {
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      if (x<_width && y<_height && z<_depth) { va_list ap; __builtin_va_start(ap,a0); T *ptrd = data(x,y,z,0); *ptrd = (T)a0; for (unsigned long k = 1; k<_spectrum; ++k) { ptrd+=whd; *ptrd = (T)__builtin_va_arg(ap,int); } __builtin_va_end(ap); };
      return *this;
    }


    CImg<T>& fillC(const unsigned int x, const unsigned int y, const unsigned int z, const double a0, ...) {
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      if (x<_width && y<_height && z<_depth) { va_list ap; __builtin_va_start(ap,a0); T *ptrd = data(x,y,z,0); *ptrd = (T)a0; for (unsigned long k = 1; k<_spectrum; ++k) { ptrd+=whd; *ptrd = (T)__builtin_va_arg(ap,double); } __builtin_va_end(ap); };
      return *this;
    }







    CImg<T>& discard(const T value) {
      return get_discard(value).move_to(*this);
    }


    CImg<T> get_discard(const T value) const {
      CImg<T> res(1,size());
      T *pd = res._data;
      for (const T *ps = _data, *const pse = end(); ps<pse; ++ps)
        if (*ps!=value) *(pd++) = *ps;
      if (pd==res._data) return CImg<T>();
      return res.resize(1,pd-res._data,1,1,-1);
    }







    template<typename t>
    CImg<T>& discard(const CImg<t>& values) {
      return get_discard(values).move_to(*this);
    }


    template<typename t>
    CImg<T> get_discard(const CImg<t>& values) const {
      if (!values) return *this;
      if (values.size()==1) return get_discard(*values);
      CImg<T> res(1,size());
      T *pd = res._data;
      const t *const pve = values.end();
      for (const T *ps = _data, *const pse = end(); ps<pse; ) {
        const T *_ps = ps;
        const t *pv = values._data;
        while (_ps<pse && pv<pve) { if (*(_ps++)!=(T)*pv) break; ++pv; }
        if (pv!=pve) {
          const unsigned int l = _ps - ps;
          if (l==1) *(pd++) = *ps; else { std::memcpy(pd,ps,sizeof(T)*l); pd+=l; }
        }
        ps = _ps;
      }
      if (pd==res._data) return CImg<T>();
      return res.resize(1,pd-res._data,1,1,-1);
    }




    CImg<T>& invert_endianness() {
      cimg::invert_endianness(_data,size());
      return *this;
    }


    CImg<T> get_invert_endianness() const {
      return (+*this).invert_endianness();
    }







    CImg<T>& rand(const T val_min, const T val_max) {
      const float delta = (float)val_max - (float)val_min;
      for (T *ptrd = (*this)._data, *_maxptrd = (*this)._data + (*this).size(); ptrd<_maxptrd; ++ptrd) *ptrd = (T)(val_min + cimg::rand()*delta);
      return *this;
    }


    CImg<T> get_rand(const T val_min, const T val_max) const {
      return (+*this).rand(val_min,val_max);
    }
# 18885 "../src/CImg.h"
    CImg<T>& round(const double y=1, const int rounding_type=0) {
      if (y>0)



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = cimg::round(*ptrd,y,rounding_type);
      return *this;
    }


    CImg<T> get_round(const double y=1, const unsigned int rounding_type=0) const {
      return (+*this).round(y,rounding_type);
    }
# 18917 "../src/CImg.h"
    CImg<T>& noise(const double sigma, const unsigned int noise_type=0) {
      if (!is_empty()) {
        const Tfloat vmin = (Tfloat)cimg::type<T>::min(), vmax = (Tfloat)cimg::type<T>::max();
        Tfloat nsigma = (Tfloat)sigma, m = 0, M = 0;
        if (nsigma==0 && noise_type!=3) return *this;
        if (nsigma<0 || noise_type==2) m = (Tfloat)min_max(M);
        if (nsigma<0) nsigma = (Tfloat)(-nsigma*(M-m)/100.0);
        switch (noise_type) {
        case 0 : {
          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) {
            Tfloat val = (Tfloat)(*ptrd + nsigma*cimg::grand());
            if (val>vmax) val = vmax;
            if (val<vmin) val = vmin;
            *ptrd = (T)val;
          }
        } break;
        case 1 : {
          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) {
            Tfloat val = (Tfloat)(*ptrd + nsigma*cimg::crand());
            if (val>vmax) val = vmax;
            if (val<vmin) val = vmin;
            *ptrd = (T)val;
          }
        } break;
        case 2 : {
          if (nsigma<0) nsigma = -nsigma;
          if (M==m) { m = 0; M = (Tfloat)(cimg::type<T>::is_float()?1:cimg::type<T>::max()); }
          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) if (cimg::rand()*100<nsigma) *ptrd = (T)(cimg::rand()<0.5?M:m);
        } break;

        case 3 : {
          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)cimg::prand(*ptrd);
        } break;

        case 4 : {
          const Tfloat sqrt2 = (Tfloat)std::sqrt(2.0);
          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) {
            const Tfloat
              val0 = (Tfloat)*ptrd/sqrt2,
              re = (Tfloat)(val0 + nsigma*cimg::grand()),
              im = (Tfloat)(val0 + nsigma*cimg::grand());
            Tfloat val = (Tfloat)std::sqrt(re*re + im*im);
            if (val>vmax) val = vmax;
            if (val<vmin) val = vmin;
            *ptrd = (T)val;
          }
        } break;
        default :
          throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "noise(): Invalid specified noise type %d "
                                      "(should be { 0=gaussian | 1=uniform | 2=salt&Pepper | 3=poisson }).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      noise_type);
        }
      }
      return *this;
    }


    CImg<T> get_noise(const double sigma, const unsigned int noise_type=0) const {
      return (+*this).noise(sigma,noise_type);
    }
# 18991 "../src/CImg.h"
    CImg<T>& normalize(const T min_value, const T max_value) {
      if (is_empty()) return *this;
      const T a = min_value<max_value?min_value:max_value, b = min_value<max_value?max_value:min_value;
      T m, M = max_min(m);
      const Tfloat fm = (Tfloat)m, fM = (Tfloat)M;
      if (m==M) return fill(min_value);
      if (m!=a || M!=b)



        for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (T)((*ptrd-fm)/(fM-fm)*(b-a)+a);
      return *this;
    }


    CImg<Tfloat> get_normalize(const T min_value, const T max_value) const {
      return CImg<Tfloat>(*this,false).normalize((Tfloat)min_value,(Tfloat)max_value);
    }
# 19019 "../src/CImg.h"
    CImg<T>& normalize() {
      const unsigned long whd = (unsigned long)_width*_height*_depth;



      for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
        T *ptrd = data(0,y,z,0);
        for (int x = 0; x<(int)((*this)._width); ++x) {
          const T *ptrs = ptrd;
          float n = 0;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) { n+=cimg::sqr((float)*ptrs); ptrs+=whd; }
          n = (float)std::sqrt(n);
          T *_ptrd = ptrd++;
          if (n>0) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *_ptrd = (T)(*_ptrd/n); _ptrd+=whd; }
          else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *_ptrd = (T)0; _ptrd+=whd; }
        }
      }
      return *this;
    }


    CImg<Tfloat> get_normalize() const {
      return CImg<Tfloat>(*this,false).normalize();
    }
# 19054 "../src/CImg.h"
    CImg<T>& norm(const int norm_type=2) {
      if (_spectrum==1) return abs();
      return get_norm(norm_type).move_to(*this);
    }


    CImg<Tfloat> get_norm(const int norm_type=2) const {
      if (is_empty()) return *this;
      if (_spectrum==1) return get_abs();
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      CImg<Tfloat> res(_width,_height,_depth);
      switch (norm_type) {
      case -1 : {



        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
          const unsigned long off = offset(0,y,z);
          const T *ptrs = _data + off;
          Tfloat *ptrd = res._data + off;
          for (int x = 0; x<(int)((*this)._width); ++x) {
            Tfloat n = 0;
            const T *_ptrs = ptrs++;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { const Tfloat val = (Tfloat)cimg::abs(*_ptrs); if (val>n) n = val; _ptrs+=whd; }
            *(ptrd++) = n;
          }
        }
      } break;
      case 1 : {



        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
          const unsigned long off = offset(0,y,z);
          const T *ptrs = _data + off;
          Tfloat *ptrd = res._data + off;
          for (int x = 0; x<(int)((*this)._width); ++x) {
            Tfloat n = 0;
            const T *_ptrs = ptrs++;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { n+=cimg::abs(*_ptrs); _ptrs+=whd; }
            *(ptrd++) = n;
          }
        }
      } break;
      default : {



        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
          const unsigned long off = offset(0,y,z);
          const T *ptrs = _data + off;
          Tfloat *ptrd = res._data + off;
          for (int x = 0; x<(int)((*this)._width); ++x) {
            Tfloat n = 0;
            const T *_ptrs = ptrs++;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { n+=cimg::sqr((Tfloat)*_ptrs); _ptrs+=whd; }
            *(ptrd++) = (Tfloat)std::sqrt((Tfloat)n);
          }
        }
      }
      }
      return res;
    }
# 19129 "../src/CImg.h"
    CImg<T>& cut(const T min_value, const T max_value) {
      if (is_empty()) return *this;
      const T a = min_value<max_value?min_value:max_value, b = min_value<max_value?max_value:min_value;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = (*ptrd<a)?a:((*ptrd>b)?b:*ptrd);
      return *this;
    }


    CImg<T> get_cut(const T min_value, const T max_value) const {
      return (+*this).cut(min_value,max_value);
    }
# 19155 "../src/CImg.h"
    CImg<T>& quantize(const unsigned int nb_levels, const bool keep_range=true) {
      if (!nb_levels)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "quantize(): Invalid quantization request with 0 values.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      if (is_empty()) return *this;
      Tfloat m, M = (Tfloat)max_min(m), range = M - m;
      if (range>0) {
        if (keep_range)



          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) {
            const unsigned int val = (unsigned int)((*ptrd-m)*nb_levels/range);
            *ptrd = (T)(m + cimg::min(val,nb_levels-1)*range/nb_levels);
          } else



          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) {
            const unsigned int val = (unsigned int)((*ptrd-m)*nb_levels/range);
            *ptrd = (T)cimg::min(val,nb_levels-1);
          }
      }
      return *this;
    }


    CImg<T> get_quantize(const unsigned int n, const bool keep_range=true) const {
      return (+*this).quantize(n,keep_range);
    }
# 19200 "../src/CImg.h"
    CImg<T>& threshold(const T value, const bool soft_threshold=false, const bool strict_threshold=false) {
      if (is_empty()) return *this;
      if (strict_threshold) {
        if (soft_threshold)



          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) { const T v = *ptrd; *ptrd = v>value?(T)(v-value):v<-(float)value?(T)(v+value):(T)0; }
        else



          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = *ptrd>value?(T)1:(T)0;
      } else {
        if (soft_threshold)



          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) {
            const T v = *ptrd; *ptrd = v>=value?(T)(v-value):v<=-(float)value?(T)(v+value):(T)0;
          }
        else



          for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) *ptrd = *ptrd>=value?(T)1:(T)0;
      }
      return *this;
    }


    CImg<T> get_threshold(const T value, const bool soft_threshold=false, const bool strict_threshold=false) const {
      return (+*this).threshold(value,soft_threshold,strict_threshold);
    }
# 19253 "../src/CImg.h"
    CImg<T>& histogram(const unsigned int nb_levels, const T min_value, const T max_value) {
      return get_histogram(nb_levels,min_value,max_value).move_to(*this);
    }


    CImg<T>& histogram(const unsigned int nb_levels) {
      return get_histogram(nb_levels).move_to(*this);
    }


    CImg<ulongT> get_histogram(const unsigned int nb_levels, const T min_value, const T max_value) const {
      if (!nb_levels || is_empty()) return CImg<ulongT>();
      T vmin = min_value<max_value?min_value:max_value, vmax = min_value<max_value?max_value:min_value;
      CImg<ulongT> res(nb_levels,1,1,1,0);
      for (T *ptrs = (*this)._data + (*this).size() - 1; ptrs>=(*this)._data; --ptrs) {
        const T val = *ptrs;
        if (val>=vmin && val<=vmax) ++res[val==vmax?nb_levels-1:(unsigned int)((val-vmin)*nb_levels/(vmax-vmin))];
      }
      return res;
    }


    CImg<ulongT> get_histogram(const unsigned int nb_levels) const {
      if (!nb_levels || is_empty()) return CImg<ulongT>();
      T vmax = 0, vmin = min_max(vmax);
      return get_histogram(nb_levels,vmin,vmax);
    }
# 19295 "../src/CImg.h"
    CImg<T>& equalize(const unsigned int nb_levels, const T min_value, const T max_value) {
      if (!nb_levels || is_empty()) return *this;
      T vmin = min_value<max_value?min_value:max_value, vmax = min_value<max_value?max_value:min_value;
      CImg<ulongT> hist = get_histogram(nb_levels,vmin,vmax);
      unsigned long cumul = 0;
      for (int pos = 0; pos<(int)((hist)._width); ++pos) { cumul+=hist[pos]; hist[pos] = cumul; }
      if (!cumul) cumul = 1;



      for (T *ptrd = (*this)._data + (*this).size() - 1; ptrd>=(*this)._data; --ptrd) {
        const int pos = (int)((*ptrd-vmin)*(nb_levels-1)/(vmax-vmin));
        if (pos>=0 && pos<(int)nb_levels) *ptrd = (T)(vmin + (vmax-vmin)*hist[pos]/cumul);
      }
      return *this;
    }


    CImg<T>& equalize(const unsigned int nb_levels) {
      if (!nb_levels || is_empty()) return *this;
      T vmax = 0, vmin = min_max(vmax);
      return equalize(nb_levels,vmin,vmax);
    }


    CImg<T> get_equalize(const unsigned int nblevels, const T val_min, const T val_max) const {
      return (+*this).equalize(nblevels,val_min,val_max);
    }


    CImg<T> get_equalize(const unsigned int nblevels) const {
      return (+*this).equalize(nblevels);
    }
# 19344 "../src/CImg.h"
    template<typename t>
    CImg<T>& index(const CImg<t>& colormap, const float dithering=1, const bool map_indexes=false) {
      return get_index(colormap,dithering,map_indexes).move_to(*this);
    }


    template<typename t>
    CImg<typename CImg<t>::Tuint>
    get_index(const CImg<t>& colormap, const float dithering=1, const bool map_indexes=true) const {
      if (colormap._spectrum!=_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "index(): Instance and specified colormap (%u,%u,%u,%u,%p) "
                                    "have incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    colormap._width,colormap._height,colormap._depth,colormap._spectrum,colormap._data);

      typedef typename CImg<t>::Tuint tuint;
      if (is_empty()) return CImg<tuint>();
      const unsigned long
        whd = (unsigned long)_width*_height*_depth,
        pwhd = (unsigned long)colormap._width*colormap._height*colormap._depth;
      CImg<tuint> res(_width,_height,_depth,map_indexes?_spectrum:1);
      tuint *ptrd = res._data;
      if (dithering>0) {
        const float ndithering = (dithering<0?0:dithering>1?1:dithering)/16;
        Tfloat valm = 0, valM = (Tfloat)max_min(valm);
        if (valm==valM && valm>=0 && valM<=255) { valm = 0; valM = 255; }
        CImg<Tfloat> cache = get_crop(-1,0,0,0,_width,1,0,_spectrum-1);
        Tfloat *cache_current = cache.data(1,0,0,0), *cache_next = cache.data(1,1,0,0);
        const unsigned long cwhd = (unsigned long)cache._width*cache._height*cache._depth;
        switch (_spectrum) {
        case 1 : {
          for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            if (y<height()-2) {
              Tfloat *ptrc0 = cache_next; const T *ptrs0 = data(0,y+1,z,0);
              for (int x = 0; x<(int)((*this)._width); ++x) *(ptrc0++) = (Tfloat)*(ptrs0++);
            }
            Tfloat *ptrs0 = cache_current, *ptrsn0 = cache_next;
            for (int x = 0; x<(int)((*this)._width); ++x) {
              const Tfloat _val0 = (Tfloat)*ptrs0, val0 = _val0<valm?valm:_val0>valM?valM:_val0;
              Tfloat distmin = cimg::type<Tfloat>::max(); const t *ptrmin0 = colormap._data;
              for (const t *ptrp0 = colormap._data, *ptrp_end = ptrp0 + pwhd; ptrp0<ptrp_end; ) {
                const Tfloat pval0 = (Tfloat)*(ptrp0++) - val0, dist = pval0*pval0;
                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
              }
              const Tfloat err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering;
              *ptrs0+=7*err0; *(ptrsn0-1)+=3*err0; *(ptrsn0++)+=5*err0; *ptrsn0+=err0;
              if (map_indexes) *(ptrd++) = (tuint)*ptrmin0; else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
            }
            cimg::swap(cache_current,cache_next);
          }
        } break;
        case 2 : {
          tuint *ptrd1 = ptrd + whd;
          for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            if (y<height()-2) {
              Tfloat *ptrc0 = cache_next, *ptrc1 = ptrc0 + cwhd;
              const T *ptrs0 = data(0,y+1,z,0), *ptrs1 = ptrs0 + whd;
              for (int x = 0; x<(int)((*this)._width); ++x) { *(ptrc0++) = (Tfloat)*(ptrs0++); *(ptrc1++) = (Tfloat)*(ptrs1++); }
            }
            Tfloat
              *ptrs0 = cache_current, *ptrs1 = ptrs0 + cwhd,
              *ptrsn0 = cache_next, *ptrsn1 = ptrsn0 + cwhd;
            for (int x = 0; x<(int)((*this)._width); ++x) {
              const Tfloat
                _val0 = (Tfloat)*ptrs0, val0 = _val0<valm?valm:_val0>valM?valM:_val0,
                _val1 = (Tfloat)*ptrs1, val1 = _val1<valm?valm:_val1>valM?valM:_val1;
              Tfloat distmin = cimg::type<Tfloat>::max(); const t *ptrmin0 = colormap._data;
              for (const t *ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd, *ptrp_end = ptrp1; ptrp0<ptrp_end; ) {
                const Tfloat
                  pval0 = (Tfloat)*(ptrp0++) - val0, pval1 = (Tfloat)*(ptrp1++) - val1,
                  dist = pval0*pval0 + pval1*pval1;
                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
              }
              const t *const ptrmin1 = ptrmin0 + pwhd;
              const Tfloat
                err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering,
                err1 = ((*(ptrs1++)=val1) - (Tfloat)*ptrmin1)*ndithering;
              *ptrs0+=7*err0; *ptrs1+=7*err1;
              *(ptrsn0-1)+=3*err0; *(ptrsn1-1)+=3*err1;
              *(ptrsn0++)+=5*err0; *(ptrsn1++)+=5*err1;
              *ptrsn0+=err0; *ptrsn1+=err1;
              if (map_indexes) { *(ptrd++) = (tuint)*ptrmin0; *(ptrd1++) = (tuint)*ptrmin1; }
              else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
            }
            cimg::swap(cache_current,cache_next);
          }
        } break;
        case 3 : {
          tuint *ptrd1 = ptrd + whd, *ptrd2 = ptrd1 + whd;
          for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            if (y<height()-2) {
              Tfloat *ptrc0 = cache_next, *ptrc1 = ptrc0 + cwhd, *ptrc2 = ptrc1 + cwhd;
              const T *ptrs0 = data(0,y+1,z,0), *ptrs1 = ptrs0 + whd, *ptrs2 = ptrs1 + whd;
              for (int x = 0; x<(int)((*this)._width); ++x) {
                *(ptrc0++) = (Tfloat)*(ptrs0++); *(ptrc1++) = (Tfloat)*(ptrs1++); *(ptrc2++) = (Tfloat)*(ptrs2++);
              }
            }
            Tfloat
              *ptrs0 = cache_current, *ptrs1 = ptrs0 + cwhd, *ptrs2 = ptrs1 + cwhd,
              *ptrsn0 = cache_next, *ptrsn1 = ptrsn0 + cwhd, *ptrsn2 = ptrsn1 + cwhd;
            for (int x = 0; x<(int)((*this)._width); ++x) {
              const Tfloat
                _val0 = (Tfloat)*ptrs0, val0 = _val0<valm?valm:_val0>valM?valM:_val0,
                _val1 = (Tfloat)*ptrs1, val1 = _val1<valm?valm:_val1>valM?valM:_val1,
                _val2 = (Tfloat)*ptrs2, val2 = _val2<valm?valm:_val2>valM?valM:_val2;
              Tfloat distmin = cimg::type<Tfloat>::max(); const t *ptrmin0 = colormap._data;
              for (const t *ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd, *ptrp2 = ptrp1 + pwhd,
                     *ptrp_end = ptrp1; ptrp0<ptrp_end; ) {
                const Tfloat
                  pval0 = (Tfloat)*(ptrp0++) - val0,
                  pval1 = (Tfloat)*(ptrp1++) - val1,
                  pval2 = (Tfloat)*(ptrp2++) - val2,
                  dist = pval0*pval0 + pval1*pval1 + pval2*pval2;
                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
              }
              const t *const ptrmin1 = ptrmin0 + pwhd, *const ptrmin2 = ptrmin1 + pwhd;
              const Tfloat
                err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering,
                err1 = ((*(ptrs1++)=val1) - (Tfloat)*ptrmin1)*ndithering,
                err2 = ((*(ptrs2++)=val2) - (Tfloat)*ptrmin2)*ndithering;

              *ptrs0+=7*err0; *ptrs1+=7*err1; *ptrs2+=7*err2;
              *(ptrsn0-1)+=3*err0; *(ptrsn1-1)+=3*err1; *(ptrsn2-1)+=3*err2;
              *(ptrsn0++)+=5*err0; *(ptrsn1++)+=5*err1; *(ptrsn2++)+=5*err2;
              *ptrsn0+=err0; *ptrsn1+=err1; *ptrsn2+=err2;

              if (map_indexes) {
                *(ptrd++) = (tuint)*ptrmin0; *(ptrd1++) = (tuint)*ptrmin1; *(ptrd2++) = (tuint)*ptrmin2;
              } else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
            }
            cimg::swap(cache_current,cache_next);
          }
        } break;
        default :
          for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            if (y<height()-2) {
              Tfloat *ptrc = cache_next;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                Tfloat *_ptrc = ptrc; const T *_ptrs = data(0,y+1,z,c);
                for (int x = 0; x<(int)((*this)._width); ++x) *(_ptrc++) = (Tfloat)*(_ptrs++);
                ptrc+=cwhd;
              }
            }
            Tfloat *ptrs = cache_current, *ptrsn = cache_next;
            for (int x = 0; x<(int)((*this)._width); ++x) {
              Tfloat distmin = cimg::type<Tfloat>::max(); const t *ptrmin = colormap._data;
              for (const t *ptrp = colormap._data, *ptrp_end = ptrp + pwhd; ptrp<ptrp_end; ++ptrp) {
                Tfloat dist = 0; Tfloat *_ptrs = ptrs; const t *_ptrp = ptrp;
                for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                  const Tfloat _val = *_ptrs, val = _val<valm?valm:_val>valM?valM:_val;
                  dist+=cimg::sqr((*_ptrs=val) - (Tfloat)*_ptrp); _ptrs+=cwhd; _ptrp+=pwhd;
                }
                if (dist<distmin) { ptrmin = ptrp; distmin = dist; }
              }
              const t *_ptrmin = ptrmin; Tfloat *_ptrs = ptrs++, *_ptrsn = (ptrsn++)-1;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const Tfloat err = (*(_ptrs++) - (Tfloat)*_ptrmin)*ndithering;
                *_ptrs+=7*err; *(_ptrsn++)+=3*err; *(_ptrsn++)+=5*err; *_ptrsn+=err;
                _ptrmin+=pwhd; _ptrs+=cwhd-1; _ptrsn+=cwhd-2;
              }
              if (map_indexes) {
                tuint *_ptrd = ptrd++;
                for (int c = 0; c<(int)((*this)._spectrum); ++c) { *_ptrd = (tuint)*ptrmin; _ptrd+=whd; ptrmin+=pwhd; }
              }
              else *(ptrd++) = (tuint)(ptrmin - colormap._data);
            }
            cimg::swap(cache_current,cache_next);
          }
        }
      } else {
        switch (_spectrum) {
        case 1 : {



          for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            tuint *ptrd = res.data(0,y,z);
            for (const T *ptrs0 = data(0,y,z), *ptrs_end = ptrs0 + _width; ptrs0<ptrs_end; ) {
              const Tfloat val0 = (Tfloat)*(ptrs0++);
              Tfloat distmin = cimg::type<Tfloat>::max(); const t *ptrmin0 = colormap._data;
              for (const t *ptrp0 = colormap._data, *ptrp_end = ptrp0 + pwhd; ptrp0<ptrp_end; ) {
                const Tfloat pval0 = (Tfloat)*(ptrp0++) - val0, dist = pval0*pval0;
                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
              }
              if (map_indexes) *(ptrd++) = (tuint)*ptrmin0; else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
            }
          }
        } break;
        case 2 : {



          for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            tuint *ptrd = res.data(0,y,z), *ptrd1 = ptrd + whd;
            for (const T *ptrs0 = data(0,y,z), *ptrs1 = ptrs0 + whd, *ptrs_end = ptrs0 + _width; ptrs0<ptrs_end; ) {
              const Tfloat val0 = (Tfloat)*(ptrs0++), val1 = (Tfloat)*(ptrs1++);
              Tfloat distmin = cimg::type<Tfloat>::max(); const t *ptrmin0 = colormap._data;
              for (const t *ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd, *ptrp_end = ptrp1; ptrp0<ptrp_end; ) {
                const Tfloat
                  pval0 = (Tfloat)*(ptrp0++) - val0, pval1 = (Tfloat)*(ptrp1++) - val1,
                  dist = pval0*pval0 + pval1*pval1;
                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
              }
              if (map_indexes) { *(ptrd++) = (tuint)*ptrmin0; *(ptrd1++) = (tuint)*(ptrmin0 + pwhd); }
              else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
            }
          }
        } break;
        case 3 : {



          for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            tuint *ptrd = res.data(0,y,z), *ptrd1 = ptrd + whd, *ptrd2 = ptrd1 + whd;
            for (const T *ptrs0 = data(0,y,z), *ptrs1 = ptrs0 + whd, *ptrs2 = ptrs1 + whd,
                   *ptrs_end = ptrs0 + _width; ptrs0<ptrs_end; ) {
              const Tfloat val0 = (Tfloat)*(ptrs0++), val1 = (Tfloat)*(ptrs1++), val2 = (Tfloat)*(ptrs2++);
              Tfloat distmin = cimg::type<Tfloat>::max(); const t *ptrmin0 = colormap._data;
              for (const t *ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd, *ptrp2 = ptrp1 + pwhd,
                     *ptrp_end = ptrp1; ptrp0<ptrp_end; ) {
                const Tfloat
                  pval0 = (Tfloat)*(ptrp0++) - val0,
                  pval1 = (Tfloat)*(ptrp1++) - val1,
                  pval2 = (Tfloat)*(ptrp2++) - val2,
                  dist = pval0*pval0 + pval1*pval1 + pval2*pval2;
                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
              }
              if (map_indexes) {
                *(ptrd++) = (tuint)*ptrmin0;
                *(ptrd1++) = (tuint)*(ptrmin0 + pwhd);
                *(ptrd2++) = (tuint)*(ptrmin0 + 2*pwhd);
              } else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
            }
          }
        } break;
        default :



          for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            tuint *ptrd = res.data(0,y,z);
            for (const T *ptrs = data(0,y,z), *ptrs_end = ptrs + _width; ptrs<ptrs_end; ++ptrs) {
              Tfloat distmin = cimg::type<Tfloat>::max(); const t *ptrmin = colormap._data;
              for (const t *ptrp = colormap._data, *ptrp_end = ptrp + pwhd; ptrp<ptrp_end; ++ptrp) {
                Tfloat dist = 0; const T *_ptrs = ptrs; const t *_ptrp = ptrp;
                for (int c = 0; c<(int)((*this)._spectrum); ++c) { dist+=cimg::sqr((Tfloat)*_ptrs - (Tfloat)*_ptrp); _ptrs+=whd; _ptrp+=pwhd; }
                if (dist<distmin) { ptrmin = ptrp; distmin = dist; }
              }
              if (map_indexes) {
                tuint *_ptrd = ptrd++;
                for (int c = 0; c<(int)((*this)._spectrum); ++c) { *_ptrd = (tuint)*ptrmin; _ptrd+=whd; ptrmin+=pwhd; }
              }
              else *(ptrd++) = (tuint)(ptrmin - colormap._data);
            }
          }
        }
      }
      return res;
    }
# 19619 "../src/CImg.h"
    template<typename t>
    CImg<T>& map(const CImg<t>& colormap, const unsigned int boundary_conditions=0) {
      return get_map(colormap,boundary_conditions).move_to(*this);
    }


    template<typename t>
    CImg<t> get_map(const CImg<t>& colormap, const unsigned int boundary_conditions=0) const {
      if (_spectrum!=1 && colormap._spectrum!=1)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "map(): Instance and specified colormap (%u,%u,%u,%u,%p) "
                                    "have incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    colormap._width,colormap._height,colormap._depth,colormap._spectrum,colormap._data);

      const unsigned long
        whd = (unsigned long)_width*_height*_depth,
        pwhd = (unsigned long)colormap._width*colormap._height*colormap._depth;
      CImg<t> res(_width,_height,_depth,colormap._spectrum==1?_spectrum:colormap._spectrum);
      switch (colormap._spectrum) {

      case 1 : {
        const T *ptrs = _data;
        switch (boundary_conditions) {
        case 2 :
          for (t *ptrd = (res)._data, *_maxptrd = (res)._data + (res).size(); ptrd<_maxptrd; ++ptrd) {
            const unsigned long ind = (unsigned long)*(ptrs++);
            *ptrd = colormap[ind%pwhd];
          } break;
        case 1 :
          for (t *ptrd = (res)._data, *_maxptrd = (res)._data + (res).size(); ptrd<_maxptrd; ++ptrd) {
            const long ind = (long)*(ptrs++);
            *ptrd = colormap[ind<0?0:ind>=(long)pwhd?pwhd-1:ind];
          } break;
        default :
          for (t *ptrd = (res)._data, *_maxptrd = (res)._data + (res).size(); ptrd<_maxptrd; ++ptrd) {
            const unsigned long ind = (unsigned long)*(ptrs++);
            *ptrd = ind<pwhd?colormap[ind]:(t)0;
          }
        }
      } break;

      case 2 : {
        switch (boundary_conditions) {
        case 2 : {
          const t *const ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd;
          t *ptrd0 = res._data, *ptrd1 = ptrd0 + whd;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const unsigned long _ind = (unsigned long)*(ptrs++), ind = _ind%pwhd;
            *(ptrd0++) = ptrp0[ind]; *(ptrd1++) = ptrp1[ind];
          }
        } break;
        case 1 : {
          const t *const ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd;
          t *ptrd0 = res._data, *ptrd1 = ptrd0 + whd;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const long _ind = (long)*(ptrs++), ind = _ind<0?0:_ind>=(long)pwhd?pwhd-1:_ind;
            *(ptrd0++) = ptrp0[ind]; *(ptrd1++) = ptrp1[ind];
          }
        } break;
        default : {
          const t *const ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd;
          t *ptrd0 = res._data, *ptrd1 = ptrd0 + whd;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const unsigned long ind = (unsigned long)*(ptrs++);
            const bool is_in = ind<pwhd;
            *(ptrd0++) = is_in?ptrp0[ind]:(t)0; *(ptrd1++) = is_in?ptrp1[ind]:(t)0;
          }
        }
        }
      } break;

      case 3 : {
        switch (boundary_conditions) {
        case 2 : {
          const t *const ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd, *ptrp2 = ptrp1 + pwhd;
          t *ptrd0 = res._data, *ptrd1 = ptrd0 + whd, *ptrd2 = ptrd1 + whd;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const unsigned long _ind = (unsigned long)*(ptrs++), ind = _ind%pwhd;
            *(ptrd0++) = ptrp0[ind]; *(ptrd1++) = ptrp1[ind]; *(ptrd2++) = ptrp2[ind];
          }
        } break;
        case 1 : {
          const t *const ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd, *ptrp2 = ptrp1 + pwhd;
          t *ptrd0 = res._data, *ptrd1 = ptrd0 + whd, *ptrd2 = ptrd1 + whd;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const long _ind = (long)*(ptrs++), ind = _ind<0?0:_ind>=(long)pwhd?pwhd-1:_ind;
            *(ptrd0++) = ptrp0[ind]; *(ptrd1++) = ptrp1[ind]; *(ptrd2++) = ptrp2[ind];
          }
        } break;
        default : {
          const t *const ptrp0 = colormap._data, *ptrp1 = ptrp0 + pwhd, *ptrp2 = ptrp1 + pwhd;
          t *ptrd0 = res._data, *ptrd1 = ptrd0 + whd, *ptrd2 = ptrd1 + whd;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const unsigned long ind = (unsigned long)*(ptrs++);
            const bool is_in = ind<pwhd;
            *(ptrd0++) = is_in?ptrp0[ind]:(t)0; *(ptrd1++) = is_in?ptrp1[ind]:(t)0; *(ptrd2++) = is_in?ptrp2[ind]:(t)0;
          }
        }
        }
      } break;

      default : {
        switch (boundary_conditions) {
        case 2 : {
          t *ptrd = res._data;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const unsigned long _ind = (unsigned long)*(ptrs++), ind = _ind%pwhd;
            const t *ptrp = colormap._data + ind;
            t *_ptrd = ptrd++; for (int c = 0; c<(int)((res)._spectrum); ++c) { *_ptrd = *ptrp; _ptrd+=whd; ptrp+=pwhd; }
          }
        } break;
        case 1 : {
          t *ptrd = res._data;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const long _ind = (long)*(ptrs++), ind = _ind<0?0:_ind>=(long)pwhd?pwhd-1:_ind;
            const t *ptrp = colormap._data + ind;
            t *_ptrd = ptrd++; for (int c = 0; c<(int)((res)._spectrum); ++c) { *_ptrd = *ptrp; _ptrd+=whd; ptrp+=pwhd; }
          }
        } break;
        default : {
          t *ptrd = res._data;
          for (const T *ptrs = _data, *ptrs_end = ptrs + whd; ptrs<ptrs_end; ) {
            const unsigned long ind = (unsigned long)*(ptrs++);
            const bool is_in = ind<pwhd;
            if (is_in) {
              const t *ptrp = colormap._data + ind;
              t *_ptrd = ptrd++; for (int c = 0; c<(int)((res)._spectrum); ++c) { *_ptrd = *ptrp; _ptrd+=whd; ptrp+=pwhd; }
            } else {
              t *_ptrd = ptrd++; for (int c = 0; c<(int)((res)._spectrum); ++c) { *_ptrd = (t)0; _ptrd+=whd; }
            }
          }
        }
        }
      }
      }
      return res;
    }
# 19769 "../src/CImg.h"
    CImg<T>& label(const bool is_high_connectivity=false, const Tfloat tolerance=0) {
      return get_label(is_high_connectivity,tolerance).move_to(*this);
    }


    CImg<unsigned long> get_label(const bool is_high_connectivity=false,
                                  const Tfloat tolerance=0) const {
      if (is_empty()) return CImg<unsigned long>();


      int dx[13], dy[13], dz[13], nb = 0;
      dx[nb]=1; dy[nb] = 0; dz[nb++]=0;
      dx[nb]=0; dy[nb] = 1; dz[nb++]=0;
      if (is_high_connectivity) {
        dx[nb]=1; dy[nb] = 1; dz[nb++]=0;
        dx[nb]=1; dy[nb] = -1; dz[nb++]=0;
      }
      if (_depth>1) {
        dx[nb]=0; dy[nb] = 0; dz[nb++]=1;
        if (is_high_connectivity) {
          dx[nb]=1; dy[nb] = 1; dz[nb++]=-1;
          dx[nb]=1; dy[nb] = 0; dz[nb++]=-1;
          dx[nb]=1; dy[nb] = -1; dz[nb++]=-1;
          dx[nb]=0; dy[nb] = 1; dz[nb++]=-1;

          dx[nb]=0; dy[nb] = 1; dz[nb++]=1;
          dx[nb]=1; dy[nb] = -1; dz[nb++]=1;
          dx[nb]=1; dy[nb] = 0; dz[nb++]=1;
          dx[nb]=1; dy[nb] = 1; dz[nb++]=1;
        }
      }
      return _get_label(nb,dx,dy,dz,tolerance);
    }






    template<typename t>
    CImg<T>& label(const CImg<t>& connectivity_mask, const Tfloat tolerance=0) {
      return get_label(connectivity_mask,tolerance).move_to(*this);
    }


    template<typename t>
    CImg<unsigned long> get_label(const CImg<t>& connectivity_mask,
                                  const Tfloat tolerance=0) const {
      int nb = 0;
      for (t *ptr = (connectivity_mask)._data, *_maxptr = (connectivity_mask)._data + (connectivity_mask).size(); ptr<_maxptr; ++ptr) if (*ptr) ++nb;
      CImg<intT> dx(nb,1,1,1,0), dy(nb,1,1,1,0), dz(nb,1,1,1,0);
      nb = 0;
      for (int z = 0; z<(int)((connectivity_mask)._depth); ++z) for (int y = 0; y<(int)((connectivity_mask)._height); ++y) for (int x = 0; x<(int)((connectivity_mask)._width); ++x) if ((x || y || z) &&
                                               connectivity_mask(x,y,z)) {
        dx[nb] = x; dy[nb] = y; dz[nb++] = z;
      }
      return _get_label(nb,dx,dy,dz,tolerance);
    }

    CImg<unsigned long> _get_label(const unsigned int nb, const int
                                   *const dx, const int *const dy, const int *const dz,
                                   const Tfloat tolerance) const {
      CImg<unsigned long> res(_width,_height,_depth,_spectrum);
      for (int c = 0; c<(int)((*this)._spectrum); ++c) {
        CImg<unsigned long> _res = res.get_shared_channel(c);


        unsigned long *ptr = _res.data();
        for (unsigned long p = 0, _maxp = (_res).size(); p<_maxp; ++p) *(ptr++) = p;


        for (unsigned int n = 0; n<nb; ++n) {
          const int _dx = dx[n], _dy = dy[n], _dz = dz[n];
          if (_dx || _dy || _dz) {
            const int
              x0 = _dx<0?-_dx:0,
              x1 = _dx<0?_width:_width - _dx,
              y0 = _dy<0?-_dy:0,
              y1 = _dy<0?_height:_height - _dy,
              z0 = _dz<0?-_dz:0,
              z1 = _dz<0?_depth:_depth - _dz;
            const long wh = (long)_width*_height, offset = (long)_dz*wh + (long)_dy*_width + _dx;
            for (long z = z0, nz = z0 + _dz, pz = z0*wh; z<z1; ++z, ++nz, pz+=wh) {
              for (long y = y0, ny = y0 + _dy, py = y0*_width + pz; y<y1; ++y, ++ny, py+=_width) {
                for (long x = x0, nx = x0 + _dx, p = x0 + py; x<x1; ++x, ++nx, ++p) {
                  if ((Tfloat)cimg::abs((*this)(x,y,z,c,wh)-(*this)(nx,ny,nz,c,wh))<=tolerance) {
                    const long q = p + offset;
                    unsigned long x, y;
                    for (x = p<q?q:p, y = p<q?p:q; x!=y && _res[x]!=x; ) { x = _res[x]; if (x<y) cimg::swap(x,y); }
                    if (x!=y) _res[x] = y;
                    for (unsigned long _p = p; _p!=y; ) { const unsigned long h = _res[_p]; _res[_p] = y; _p = h; }
                    for (unsigned long _q = q; _q!=y; ) { const unsigned long h = _res[_q]; _res[_q] = y; _q = h; }
                  }
                }
              }
            }
          }
        }


        unsigned long counter = 0;
        ptr = _res.data();
        for (unsigned long p = 0, _maxp = (_res).size(); p<_maxp; ++p) { *ptr = *ptr==p?counter++:_res[*ptr]; ++ptr; }
      }
      return res;
    }


    CImg<T>& _system_strescape() {



      CImgList<T> list;
      const T *ptrs = _data;
      for (T *p = (*this)._data, *_maxp = (*this)._data + (*this).size(); p<_maxp; ++p) switch ((int)*p) {
        case '\\' : if (p!=ptrs) CImg<T>(ptrs,(unsigned int)(p-ptrs),1,1,1,false). move_to(list); CImg<T>("\\\\",(unsigned int)std::strlen("\\\\"),1,1,1,false).move_to(list); ptrs = p+1; break;
        case '\"' : if (p!=ptrs) CImg<T>(ptrs,(unsigned int)(p-ptrs),1,1,1,false). move_to(list); CImg<T>("\\\"",(unsigned int)std::strlen("\\\""),1,1,1,false).move_to(list); ptrs = p+1; break;
        case '!' : if (p!=ptrs) CImg<T>(ptrs,(unsigned int)(p-ptrs),1,1,1,false). move_to(list); CImg<T>("\"\\!\"",(unsigned int)std::strlen("\"\\!\""),1,1,1,false).move_to(list); ptrs = p+1; break;
        case '`' : if (p!=ptrs) CImg<T>(ptrs,(unsigned int)(p-ptrs),1,1,1,false). move_to(list); CImg<T>("\\`",(unsigned int)std::strlen("\\`"),1,1,1,false).move_to(list); ptrs = p+1; break;
        case '$' : if (p!=ptrs) CImg<T>(ptrs,(unsigned int)(p-ptrs),1,1,1,false). move_to(list); CImg<T>("\\$",(unsigned int)std::strlen("\\$"),1,1,1,false).move_to(list); ptrs = p+1; break;
      }
      if (ptrs<end()) CImg<T>(ptrs,(unsigned int)(end()-ptrs),1,1,1,false).move_to(list);
      return (list>'x').move_to(*this);
    }
# 19906 "../src/CImg.h"
    static const CImg<Tuchar>& default_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,256,1,3);
        for (unsigned int index = 0, r = 16; r<256; r+=32)
          for (unsigned int g = 16; g<256; g+=32)
            for (unsigned int b = 32; b<256; b+=64) {
              colormap(0,index,0) = (Tuchar)r;
              colormap(0,index,1) = (Tuchar)g;
              colormap(0,index++,2) = (Tuchar)b;
            }
      }
      cimg::mutex(8,0);
      return colormap;
    }






    static const CImg<Tuchar>& HSV_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        CImg<Tint> tmp(1,256,1,3,1);
        tmp.get_shared_channel(0).sequence(0,359);
        colormap = tmp.HSVtoRGB();
      }
      cimg::mutex(8,0);
      return colormap;
    }






    static const CImg<Tuchar>& lines_LUT256() {
      static const unsigned char pal[] = {
        217,62,88,75,1,237,240,12,56,160,165,116,1,1,204,2,15,248,148,185,133,141,46,246,222,116,16,5,207,226,
        17,114,247,1,214,53,238,0,95,55,233,235,109,0,17,54,33,0,90,30,3,0,94,27,19,0,68,212,166,130,0,15,7,119,
        238,2,246,198,0,3,16,10,13,2,25,28,12,6,2,99,18,141,30,4,3,140,12,4,30,233,7,10,0,136,35,160,168,184,20,
        233,0,1,242,83,90,56,180,44,41,0,6,19,207,5,31,214,4,35,153,180,75,21,76,16,202,218,22,17,2,136,71,74,
        81,251,244,148,222,17,0,234,24,0,200,16,239,15,225,102,230,186,58,230,110,12,0,7,129,249,22,241,37,219,
        1,3,254,210,3,212,113,131,197,162,123,252,90,96,209,60,0,17,0,180,249,12,112,165,43,27,229,77,40,195,12,
        87,1,210,148,47,80,5,9,1,137,2,40,57,205,244,40,8,252,98,0,40,43,206,31,187,0,180,1,69,70,227,131,108,0,
        223,94,228,35,248,243,4,16,0,34,24,2,9,35,73,91,12,199,51,1,249,12,103,131,20,224,2,70,32,
        233,1,165,3,8,154,246,233,196,5,0,6,183,227,247,195,208,36,0,0,226,160,210,198,69,153,210,1,23,8,192,2,4,
        137,1,0,52,2,249,241,129,0,0,234,7,238,71,7,32,15,157,157,252,158,2,250,6,13,30,11,162,0,199,21,11,27,224,
        4,157,20,181,111,187,218,3,0,11,158,230,196,34,223,22,248,135,254,210,157,219,0,117,239,3,255,4,227,5,247,
        11,4,3,188,111,11,105,195,2,0,14,1,21,219,192,0,183,191,113,241,1,12,17,248,0,48,7,19,1,254,212,0,239,246,
        0,23,0,250,165,194,194,17,3,253,0,24,6,0,141,167,221,24,212,2,235,243,0,0,205,1,251,133,204,28,4,6,1,10,
        141,21,74,12,236,254,228,19,1,0,214,1,186,13,13,6,13,16,27,209,6,216,11,207,251,59,32,9,155,23,19,235,143,
        116,6,213,6,75,159,23,6,0,228,4,10,245,249,1,7,44,234,4,102,174,0,19,239,103,16,15,18,8,214,22,4,47,244,
        255,8,0,251,173,1,212,252,250,251,252,6,0,29,29,222,233,246,5,149,0,182,180,13,151,0,203,183,0,35,149,0,
        235,246,254,78,9,17,203,73,11,195,0,3,5,44,0,0,237,5,106,6,130,16,214,20,168,247,168,4,207,11,5,1,232,251,
        129,210,116,231,217,223,214,27,45,38,4,177,186,249,7,215,172,16,214,27,249,230,236,2,34,216,217,0,175,30,
        243,225,244,182,20,212,2,226,21,255,20,0,2,13,62,13,191,14,76,64,20,121,4,118,0,216,1,147,0,2,210,1,215,
        95,210,236,225,184,46,0,248,24,11,1,9,141,250,243,9,221,233,160,11,147,2,55,8,23,12,253,9,0,54,0,231,6,3,
        141,8,2,246,9,180,5,11,8,227,8,43,110,242,1,130,5,97,36,10,6,219,86,133,11,108,6,1,5,244,67,19,28,0,174,
        154,16,127,149,252,188,196,196,228,244,9,249,0,0,0,37,170,32,250,0,73,255,23,3,224,234,38,195,198,0,255,87,
        33,221,174,31,3,0,189,228,6,153,14,144,14,108,197,0,9,206,245,254,3,16,253,178,248,0,95,125,8,0,3,168,21,
        23,168,19,50,240,244,185,0,1,144,10,168,31,82,1,13 };
      static const CImg<Tuchar> colormap(pal,1,256,1,3,false);
      return colormap;
    }






    static const CImg<Tuchar>& hot_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,4,1,3,0);
        colormap[1] = colormap[2] = colormap[3] = colormap[6] = colormap[7] = colormap[11] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }






    static const CImg<Tuchar>& cool_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) colormap.assign(1,2,1,3).fill(0,255,255,0,255,255).resize(1,256,1,3,3);
      cimg::mutex(8,0);
      return colormap;
    }






    static const CImg<Tuchar>& jet_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,4,1,3,0);
        colormap[2] = colormap[3] = colormap[5] = colormap[6] = colormap[8] = colormap[9] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }






    static const CImg<Tuchar>& flag_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,4,1,3,0);
        colormap[0] = colormap[1] = colormap[5] = colormap[9] = colormap[10] = 255;
        colormap.resize(1,256,1,3,0,2);
      }
      cimg::mutex(8,0);
      return colormap;
    }






    static const CImg<Tuchar>& cube_LUT256() {
      static CImg<Tuchar> colormap;
      cimg::mutex(8);
      if (!colormap) {
        colormap.assign(1,8,1,3,0);
        colormap[1] = colormap[3] = colormap[5] = colormap[7] =
          colormap[10] = colormap[11] = colormap[12] = colormap[13] =
          colormap[20] = colormap[21] = colormap[22] = colormap[23] = 255;
        colormap.resize(1,256,1,3,3);
      }
      cimg::mutex(8,0);
      return colormap;
    }


    CImg<T>& sRGBtoRGB() {
      for (T *ptr = (*this)._data, *_maxptr = (*this)._data + (*this).size(); ptr<_maxptr; ++ptr) {
        const Tfloat
          sval = (Tfloat)*ptr,
          nsval = (sval<0?0:sval>255?255:sval)/255,
          val = (Tfloat)(nsval<=0.04045f?nsval/12.92f:std::pow((nsval+0.055f)/(1.055f),2.4f));
        *ptr = (T)(val*255);
      }
      return *this;
    }


    CImg<Tfloat> get_sRGBtoRGB() const {
      return CImg<Tfloat>(*this,false).sRGBtoRGB();
    }


    CImg<T>& RGBtosRGB() {
      for (T *ptr = (*this)._data, *_maxptr = (*this)._data + (*this).size(); ptr<_maxptr; ++ptr) {
        const Tfloat
          val = (Tfloat)*ptr,
          nval = (val<0?0:val>255?255:val)/255,
          sval = (Tfloat)(nval<=0.0031308f?nval*12.92f:1.055f*std::pow(nval,0.416667f)-0.055f);
        *ptr = (T)(sval*255);
      }
      return *this;
    }


    CImg<Tfloat> get_RGBtosRGB() const {
      return CImg<Tfloat>(*this,false).RGBtosRGB();
    }


    CImg<T>& RGBtoHSV() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "RGBtoHSV(): Instance is not a RGB image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          R = (Tfloat)*p1,
          G = (Tfloat)*p2,
          B = (Tfloat)*p3,
          nR = (R<0?0:(R>255?255:R))/255,
          nG = (G<0?0:(G>255?255:G))/255,
          nB = (B<0?0:(B>255?255:B))/255,
          m = cimg::min(nR,nG,nB),
          M = cimg::max(nR,nG,nB);
        Tfloat H = 0, S = 0;
        if (M!=m) {
          const Tfloat
            f = (nR==m)?(nG-nB):((nG==m)?(nB-nR):(nR-nG)),
            i = (Tfloat)((nR==m)?3:((nG==m)?5:1));
          H = (i-f/(M-m));
          if (H>=6) H-=6;
          H*=60;
          S = (M-m)/M;
        }
        *(p1++) = (T)H;
        *(p2++) = (T)S;
        *(p3++) = (T)M;
      }
      return *this;
    }


    CImg<Tfloat> get_RGBtoHSV() const {
      return CImg<Tfloat>(*this,false).RGBtoHSV();
    }


    CImg<T>& HSVtoRGB() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "HSVtoRGB(): Instance is not a HSV image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        Tfloat
          H = (Tfloat)*p1,
          S = (Tfloat)*p2,
          V = (Tfloat)*p3,
          R = 0, G = 0, B = 0;
        if (H==0 && S==0) R = G = B = V;
        else {
          H/=60;
          const int i = (int)std::floor(H);
          const Tfloat
            f = (i&1)?(H - i):(1 - H + i),
            m = V*(1 - S),
            n = V*(1 - S*f);
          switch (i) {
          case 6 :
          case 0 : R = V; G = n; B = m; break;
          case 1 : R = n; G = V; B = m; break;
          case 2 : R = m; G = V; B = n; break;
          case 3 : R = m; G = n; B = V; break;
          case 4 : R = n; G = m; B = V; break;
          case 5 : R = V; G = m; B = n; break;
          }
        }
        R*=255; G*=255; B*=255;
        *(p1++) = (T)(R<0?0:(R>255?255:R));
        *(p2++) = (T)(G<0?0:(G>255?255:G));
        *(p3++) = (T)(B<0?0:(B>255?255:B));
      }
      return *this;
    }


    CImg<Tuchar> get_HSVtoRGB() const {
      return CImg<Tuchar>(*this,false).HSVtoRGB();
    }


    CImg<T>& RGBtoHSL() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "RGBtoHSL(): Instance is not a RGB image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          R = (Tfloat)*p1,
          G = (Tfloat)*p2,
          B = (Tfloat)*p3,
          nR = (R<0?0:(R>255?255:R))/255,
          nG = (G<0?0:(G>255?255:G))/255,
          nB = (B<0?0:(B>255?255:B))/255,
          m = cimg::min(nR,nG,nB),
          M = cimg::max(nR,nG,nB),
          L = (m + M)/2;
        Tfloat H = 0, S = 0;
        if (M==m) H = S = 0;
        else {
          const Tfloat
            f = (nR==m)?(nG-nB):((nG==m)?(nB-nR):(nR-nG)),
            i = (nR==m)?3.0f:((nG==m)?5.0f:1.0f);
          H = (i-f/(M-m));
          if (H>=6) H-=6;
          H*=60;
          S = (2*L<=1)?((M-m)/(M+m)):((M-m)/(2-M-m));
        }
        *(p1++) = (T)H;
        *(p2++) = (T)S;
        *(p3++) = (T)L;
      }
      return *this;
    }


    CImg<Tfloat> get_RGBtoHSL() const {
      return CImg< Tfloat>(*this,false).RGBtoHSL();
    }


    CImg<T>& HSLtoRGB() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "HSLtoRGB(): Instance is not a HSL image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          H = (Tfloat)*p1,
          S = (Tfloat)*p2,
          L = (Tfloat)*p3,
          q = 2*L<1?L*(1+S):(L+S-L*S),
          p = 2*L-q,
          h = H/360,
          tr = h + 1.0f/3,
          tg = h,
          tb = h - 1.0f/3,
          ntr = tr<0?tr+1:(tr>1?tr-1:tr),
          ntg = tg<0?tg+1:(tg>1?tg-1:tg),
          ntb = tb<0?tb+1:(tb>1?tb-1:tb),
          R = 255*(6*ntr<1?p+(q-p)*6*ntr:(2*ntr<1?q:(3*ntr<2?p+(q-p)*6*(2.0f/3-ntr):p))),
          G = 255*(6*ntg<1?p+(q-p)*6*ntg:(2*ntg<1?q:(3*ntg<2?p+(q-p)*6*(2.0f/3-ntg):p))),
          B = 255*(6*ntb<1?p+(q-p)*6*ntb:(2*ntb<1?q:(3*ntb<2?p+(q-p)*6*(2.0f/3-ntb):p)));
        *(p1++) = (T)(R<0?0:(R>255?255:R));
        *(p2++) = (T)(G<0?0:(G>255?255:G));
        *(p3++) = (T)(B<0?0:(B>255?255:B));
      }
      return *this;
    }


    CImg<Tuchar> get_HSLtoRGB() const {
      return CImg<Tuchar>(*this,false).HSLtoRGB();
    }


    CImg<T>& RGBtoHSI() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "RGBtoHSI(): Instance is not a RGB image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          R = (Tfloat)*p1,
          G = (Tfloat)*p2,
          B = (Tfloat)*p3,
          nR = (R<0?0:(R>255?255:R))/255,
          nG = (G<0?0:(G>255?255:G))/255,
          nB = (B<0?0:(B>255?255:B))/255,
          m = cimg::min(nR,nG,nB),
          theta = (Tfloat)(std::acos(0.5f*((nR-nG)+(nR-nB))/std::sqrt(std::pow(nR-nG,2)+(nR-nB)*(nG-nB)))*180/cimg::PI),
          sum = nR + nG + nB;
        Tfloat H = 0, S = 0, I = 0;
        if (theta>0) H = (nB<=nG)?theta:360-theta;
        if (sum>0) S = 1 - 3/sum*m;
        I = sum/3;
        *(p1++) = (T)H;
        *(p2++) = (T)S;
        *(p3++) = (T)I;
      }
      return *this;
    }


    CImg<Tfloat> get_RGBtoHSI() const {
      return CImg<Tfloat>(*this,false).RGBtoHSI();
    }


    CImg<T>& HSItoRGB() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "HSItoRGB(): Instance is not a HSI image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        Tfloat
          H = (Tfloat)*p1,
          S = (Tfloat)*p2,
          I = (Tfloat)*p3,
          a = I*(1-S),
          R = 0, G = 0, B = 0;
        if (H<120) {
          B = a;
          R = (Tfloat)(I*(1+S*std::cos(H*cimg::PI/180)/std::cos((60-H)*cimg::PI/180)));
          G = 3*I-(R+B);
        } else if (H<240) {
          H-=120;
          R = a;
          G = (Tfloat)(I*(1+S*std::cos(H*cimg::PI/180)/std::cos((60-H)*cimg::PI/180)));
          B = 3*I-(R+G);
        } else {
          H-=240;
          G = a;
          B = (Tfloat)(I*(1+S*std::cos(H*cimg::PI/180)/std::cos((60-H)*cimg::PI/180)));
          R = 3*I-(G+B);
        }
        R*=255; G*=255; B*=255;
        *(p1++) = (T)(R<0?0:(R>255?255:R));
        *(p2++) = (T)(G<0?0:(G>255?255:G));
        *(p3++) = (T)(B<0?0:(B>255?255:B));
      }
      return *this;
    }


    CImg<Tfloat> get_HSItoRGB() const {
      return CImg< Tuchar>(*this,false).HSItoRGB();
    }


    CImg<T>& RGBtoYCbCr() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "RGBtoYCbCr(): Instance is not a RGB image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          R = (Tfloat)*p1,
          G = (Tfloat)*p2,
          B = (Tfloat)*p3,
          Y = (66*R + 129*G + 25*B + 128)/256 + 16,
          Cb = (-38*R - 74*G + 112*B + 128)/256 + 128,
          Cr = (112*R - 94*G - 18*B + 128)/256 + 128;
        *(p1++) = (T)(Y<0?0:(Y>255?255:Y));
        *(p2++) = (T)(Cb<0?0:(Cb>255?255:Cb));
        *(p3++) = (T)(Cr<0?0:(Cr>255?255:Cr));
      }
      return *this;
    }


    CImg<Tuchar> get_RGBtoYCbCr() const {
      return CImg<Tuchar>(*this,false).RGBtoYCbCr();
    }


    CImg<T>& YCbCrtoRGB() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "YCbCrtoRGB(): Instance is not a YCbCr image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          Y = (Tfloat)*p1 - 16,
          Cb = (Tfloat)*p2 - 128,
          Cr = (Tfloat)*p3 - 128,
          R = (298*Y + 409*Cr + 128)/256,
          G = (298*Y - 100*Cb - 208*Cr + 128)/256,
          B = (298*Y + 516*Cb + 128)/256;
        *(p1++) = (T)(R<0?0:(R>255?255:R));
        *(p2++) = (T)(G<0?0:(G>255?255:G));
        *(p3++) = (T)(B<0?0:(B>255?255:B));
      }
      return *this;
    }


    CImg<Tuchar> get_YCbCrtoRGB() const {
      return CImg<Tuchar>(*this,false).YCbCrtoRGB();
    }


    CImg<T>& RGBtoYUV() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "RGBtoYUV(): Instance is not a RGB image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          R = (Tfloat)*p1/255,
          G = (Tfloat)*p2/255,
          B = (Tfloat)*p3/255,
          Y = 0.299f*R + 0.587f*G + 0.114f*B;
        *(p1++) = (T)Y;
        *(p2++) = (T)(0.492f*(B-Y));
        *(p3++) = (T)(0.877*(R-Y));
      }
      return *this;
    }


    CImg<Tfloat> get_RGBtoYUV() const {
      return CImg<Tfloat>(*this,false).RGBtoYUV();
    }


    CImg<T>& YUVtoRGB() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "YUVtoRGB(): Instance is not a YUV image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          Y = (Tfloat)*p1,
          U = (Tfloat)*p2,
          V = (Tfloat)*p3,
          R = (Y + 1.140f*V)*255,
          G = (Y - 0.395f*U - 0.581f*V)*255,
          B = (Y + 2.032f*U)*255;
        *(p1++) = (T)(R<0?0:(R>255?255:R));
        *(p2++) = (T)(G<0?0:(G>255?255:G));
        *(p3++) = (T)(B<0?0:(B>255?255:B));
      }
      return *this;
    }


    CImg<Tuchar> get_YUVtoRGB() const {
      return CImg< Tuchar>(*this,false).YUVtoRGB();
    }


    CImg<T>& RGBtoCMY() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "RGBtoCMY(): Instance is not a RGB image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          R = (Tfloat)*p1,
          G = (Tfloat)*p2,
          B = (Tfloat)*p3,
          C = 255 - R,
          M = 255 - G,
          Y = 255 - B;
        *(p1++) = (T)(C<0?0:(C>255?255:C));
        *(p2++) = (T)(M<0?0:(M>255?255:M));
        *(p3++) = (T)(Y<0?0:(Y>255?255:Y));
      }
      return *this;
    }


    CImg<Tuchar> get_RGBtoCMY() const {
      return CImg<Tfloat>(*this,false).RGBtoCMY();
    }


    CImg<T>& CMYtoRGB() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "CMYtoRGB(): Instance is not a CMY image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          C = (Tfloat)*p1,
          M = (Tfloat)*p2,
          Y = (Tfloat)*p3,
          R = 255 - C,
          G = 255 - M,
          B = 255 - Y;
        *(p1++) = (T)(R<0?0:(R>255?255:R));
        *(p2++) = (T)(G<0?0:(G>255?255:G));
        *(p3++) = (T)(B<0?0:(B>255?255:B));
      }
      return *this;
    }


    CImg<Tuchar> get_CMYtoRGB() const {
      return CImg<Tuchar>(*this,false).CMYtoRGB();
    }


    CImg<T>& CMYtoCMYK() {
      return get_CMYtoCMYK().move_to(*this);
    }


    CImg<Tuchar> get_CMYtoCMYK() const {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "CMYtoCMYK(): Instance is not a CMY image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      CImg<Tfloat> res(_width,_height,_depth,4);
      const T *ps1 = data(0,0,0,0), *ps2 = data(0,0,0,1), *ps3 = data(0,0,0,2);
      Tfloat *pd1 = res.data(0,0,0,0), *pd2 = res.data(0,0,0,1), *pd3 = res.data(0,0,0,2), *pd4 = res.data(0,0,0,3);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        Tfloat
          C = (Tfloat)*(ps1++),
          M = (Tfloat)*(ps2++),
          Y = (Tfloat)*(ps3++),
          K = cimg::min(C,M,Y);
        if (K>=255) C = M = Y = 0;
        else { const Tfloat K1 = 255 - K; C = 255*(C - K)/K1; M = 255*(M - K)/K1; Y = 255*(Y - K)/K1; }
        *(pd1++) = (Tfloat)(C<0?0:(C>255?255:C));
        *(pd2++) = (Tfloat)(M<0?0:(M>255?255:M));
        *(pd3++) = (Tfloat)(Y<0?0:(Y>255?255:Y));
        *(pd4++) = (Tfloat)(K<0?0:(K>255?255:K));
      }
      return res;
    }


    CImg<T>& CMYKtoCMY() {
      return get_CMYKtoCMY().move_to(*this);
    }


    CImg<Tfloat> get_CMYKtoCMY() const {
      if (_spectrum!=4)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "CMYKtoCMY(): Instance is not a CMYK image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      CImg<Tfloat> res(_width,_height,_depth,3);
      const T *ps1 = data(0,0,0,0), *ps2 = data(0,0,0,1), *ps3 = data(0,0,0,2), *ps4 = data(0,0,0,3);
      Tfloat *pd1 = res.data(0,0,0,0), *pd2 = res.data(0,0,0,1), *pd3 = res.data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          C = (Tfloat)*(ps1++),
          M = (Tfloat)*(ps2++),
          Y = (Tfloat)*(ps3++),
          K = (Tfloat)*(ps4++),
          K1 = 1 - K/255,
          nC = C*K1 + K,
          nM = M*K1 + K,
          nY = Y*K1 + K;
        *(pd1++) = (Tfloat)(nC<0?0:(nC>255?255:nC));
        *(pd2++) = (Tfloat)(nM<0?0:(nM>255?255:nM));
        *(pd3++) = (Tfloat)(nY<0?0:(nY>255?255:nY));
      }
      return res;
    }





    CImg<T>& RGBtoXYZ() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "RGBtoXYZ(): Instance is not a RGB image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          R = (Tfloat)*p1/255,
          G = (Tfloat)*p2/255,
          B = (Tfloat)*p3/255;
        *(p1++) = (T)(0.412453f*R + 0.357580f*G + 0.180423f*B);
        *(p2++) = (T)(0.212671f*R + 0.715160f*G + 0.072169f*B);
        *(p3++) = (T)(0.019334f*R + 0.119193f*G + 0.950227f*B);
      }
      return *this;
    }


    CImg<Tfloat> get_RGBtoXYZ() const {
      return CImg<Tfloat>(*this,false).RGBtoXYZ();
    }


    CImg<T>& XYZtoRGB() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "XYZtoRGB(): Instance is not a XYZ image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          X = (Tfloat)*p1*255,
          Y = (Tfloat)*p2*255,
          Z = (Tfloat)*p3*255,
          R = 3.240479f*X - 1.537150f*Y - 0.498535f*Z,
          G = -0.969256f*X + 1.875992f*Y + 0.041556f*Z,
          B = 0.055648f*X - 0.204043f*Y + 1.057311f*Z;
        *(p1++) = (T)(R<0?0:(R>255?255:R));
        *(p2++) = (T)(G<0?0:(G>255?255:G));
        *(p3++) = (T)(B<0?0:(B>255?255:B));
      }
      return *this;
    }


    CImg<Tuchar> get_XYZtoRGB() const {
      return CImg<Tuchar>(*this,false).XYZtoRGB();
    }


    CImg<T>& XYZtoLab() {


      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "XYZtoLab(): Instance is not a XYZ image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const Tfloat
        Xn = (Tfloat)(0.412453f + 0.357580f + 0.180423f),
        Yn = (Tfloat)(0.212671f + 0.715160f + 0.072169f),
        Zn = (Tfloat)(0.019334f + 0.119193f + 0.950227f);
      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          X = (Tfloat)*p1,
          Y = (Tfloat)*p2,
          Z = (Tfloat)*p3,
          XXn = X/Xn, YYn = Y/Yn, ZZn = Z/Zn,
          fX = (Tfloat)((XXn)>=0.008856f?(std::pow(XXn,(Tfloat)1/3)):(7.787f*(XXn)+16.0f/116)),
          fY = (Tfloat)((YYn)>=0.008856f?(std::pow(YYn,(Tfloat)1/3)):(7.787f*(YYn)+16.0f/116)),
          fZ = (Tfloat)((ZZn)>=0.008856f?(std::pow(ZZn,(Tfloat)1/3)):(7.787f*(ZZn)+16.0f/116));
        *(p1++) = (T)cimg::max(0.0f,116*fY - 16);
        *(p2++) = (T)(500*(fX - fY));
        *(p3++) = (T)(200*(fY - fZ));
      }
      return *this;
    }


    CImg<Tfloat> get_XYZtoLab() const {
      return CImg<Tfloat>(*this,false).XYZtoLab();
    }


    CImg<T>& LabtoXYZ() {


      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "LabtoXYZ(): Instance is not a Lab image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const Tfloat
        Xn = (Tfloat)(0.412453f + 0.357580f + 0.180423f),
        Yn = (Tfloat)(0.212671f + 0.715160f + 0.072169f),
        Zn = (Tfloat)(0.019334f + 0.119193f + 0.950227f);
      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          L = (Tfloat)*p1,
          a = (Tfloat)*p2,
          b = (Tfloat)*p3,
          cY = (L + 16)/116,
          Y = (Tfloat)(Yn*((cY)>=0.206893f?((cY)*(cY)*(cY)):(((cY)-16.0f/116)/7.787f))),
          pY = (Tfloat)std::pow(Y/Yn,(Tfloat)1/3),
          cX = a/500 + pY,
          X = Xn*cX*cX*cX,
          cZ = pY - b/200,
          Z = Zn*cZ*cZ*cZ;
        *(p1++) = (T)(X);
        *(p2++) = (T)(Y);
        *(p3++) = (T)(Z);
      }
      return *this;
    }


    CImg<Tfloat> get_LabtoXYZ() const {
      return CImg<Tfloat>(*this,false).LabtoXYZ();
    }


    CImg<T>& XYZtoxyY() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "XYZtoxyY(): Instance is not a XYZ image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
          X = (Tfloat)*p1,
          Y = (Tfloat)*p2,
          Z = (Tfloat)*p3,
          sum = (X+Y+Z),
          nsum = sum>0?sum:1;
        *(p1++) = (T)(X/nsum);
        *(p2++) = (T)(Y/nsum);
        *(p3++) = (T)Y;
      }
      return *this;
    }


    CImg<Tfloat> get_XYZtoxyY() const {
      return CImg<Tfloat>(*this,false).XYZtoxyY();
    }


    CImg<T>& xyYtoXYZ() {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "xyYtoXYZ(): Instance is not a xyY image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);
      for (unsigned long N = (unsigned long)_width*_height*_depth; N; --N) {
        const Tfloat
         px = (Tfloat)*p1,
         py = (Tfloat)*p2,
         Y = (Tfloat)*p3,
         ny = py>0?py:1;
        *(p1++) = (T)(px*Y/ny);
        *(p2++) = (T)Y;
        *(p3++) = (T)((1-px-py)*Y/ny);
      }
      return *this;
    }


    CImg<Tfloat> get_xyYtoXYZ() const {
      return CImg<Tfloat>(*this,false).xyYtoXYZ();
    }


    CImg<T>& RGBtoLab() {
      return RGBtoXYZ().XYZtoLab();
    }


    CImg<Tfloat> get_RGBtoLab() const {
      return CImg<Tfloat>(*this,false).RGBtoLab();
    }


    CImg<T>& LabtoRGB() {
      return LabtoXYZ().XYZtoRGB();
    }


    CImg<Tuchar> get_LabtoRGB() const {
      return CImg<Tuchar>(*this,false).LabtoRGB();
    }


    CImg<T>& RGBtoxyY() {
      return RGBtoXYZ().XYZtoxyY();
    }


    CImg<Tfloat> get_RGBtoxyY() const {
      return CImg<Tfloat>(*this,false).RGBtoxyY();
    }


    CImg<T>& xyYtoRGB() {
      return xyYtoXYZ().XYZtoRGB();
    }


    CImg<Tuchar> get_xyYtoRGB() const {
      return CImg<Tuchar>(*this,false).xyYtoRGB();
    }


    CImg<T>& RGBtoCMYK() {
      return RGBtoCMY().CMYtoCMYK();
    }


    CImg<Tfloat> get_RGBtoCMYK() const {
      return CImg<Tfloat>(*this,false).RGBtoCMYK();
    }


    CImg<T>& CMYKtoRGB() {
      return CMYKtoCMY().CMYtoRGB();
    }


    CImg<Tuchar> get_CMYKtoRGB() const {
      return CImg<Tuchar>(*this,false).CMYKtoRGB();
    }





    CImg<T>& RGBtoBayer() {
      return get_RGBtoBayer().move_to(*this);
    }


    CImg<T> get_RGBtoBayer() const {
      if (_spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "RGBtoBayer(): Instance is not a RGB image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      CImg<T> res(_width,_height,_depth,1);
      const T *ptr_r = data(0,0,0,0), *ptr_g = data(0,0,0,1), *ptr_b = data(0,0,0,2);
      T *ptrd = res._data;
      for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
        if (y%2) {
          if (x%2) *(ptrd++) = *ptr_b;
          else *(ptrd++) = *ptr_g;
        } else {
          if (x%2) *(ptrd++) = *ptr_g;
          else *(ptrd++) = *ptr_r;
        }
        ++ptr_r; ++ptr_g; ++ptr_b;
      }
      return res;
    }


    CImg<T>& BayertoRGB(const unsigned int interpolation_type=3) {
      return get_BayertoRGB(interpolation_type).move_to(*this);
    }


    CImg<Tuchar> get_BayertoRGB(const unsigned int interpolation_type=3) const {
      if (_spectrum!=1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "BayertoRGB(): Instance is not a Bayer image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      CImg<Tuchar> res(_width,_height,_depth,3);
      T I[9]; T& Ipp = I[0]; T& Icp = I[1]; T& Inp = I[2]; T& Ipc = I[3]; T& Icc = I[4]; T& Inc = I[5]; T& Ipn = I[6]; T& Icn = I[7]; T& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
      Tuchar *ptr_r = res.data(0,0,0,0), *ptr_g = res.data(0,0,0,1), *ptr_b = res.data(0,0,0,2);
      switch (interpolation_type) {
      case 3 : {
        T R[9]; T& Rpp = R[0]; T& Rcp = R[1]; T& Rnp = R[2]; T& Rpc = R[3]; T& Rcc = R[4]; T& Rnc = R[5]; T& Rpn = R[6]; T& Rcn = R[7]; T& Rnn = R[8]; Rpp = Rcp = Rnp = Rpc = Rcc = Rnc = Rpn = Rcn = Rnn = 0;
        T G[9]; T& Gpp = G[0]; T& Gcp = G[1]; T& Gnp = G[2]; T& Gpc = G[3]; T& Gcc = G[4]; T& Gnc = G[5]; T& Gpn = G[6]; T& Gcn = G[7]; T& Gnn = G[8]; Gpp = Gcp = Gnp = Gpc = Gcc = Gnc = Gpn = Gcn = Gnn = 0;
        T B[9]; T& Bpp = B[0]; T& Bcp = B[1]; T& Bnp = B[2]; T& Bpc = B[3]; T& Bcc = B[4]; T& Bnc = B[5]; T& Bpn = B[6]; T& Bcn = B[7]; T& Bnn = B[8]; Bpp = Bcp = Bnp = Bpc = Bcc = Bnc = Bpn = Bcn = Bnn = 0;
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          const int _p1x = x?x-1:1, _p1y = y?y-1:1, _n1x = x<width()-1?x+1:x-1, _n1y = y<height()-1?y+1:y-1;
          I[0] = (T)(*this)(_p1x,_p1y,z,0), I[1] = (T)(*this)(x,_p1y,z,0), I[2] = (T)(*this)(_n1x,_p1y,z,0), I[3] = (T)(*this)(_p1x,y,z,0), I[4] = (T)(*this)(x,y,z,0), I[5] = (T)(*this)(_n1x,y,z,0), I[6] = (T)(*this)(_p1x,_n1y,z,0), I[7] = (T)(*this)(x,_n1y,z,0), I[8] = (T)(*this)(_n1x,_n1y,z,0);
          if (y%2) {
            if (x%2) {
              const Tfloat
                alpha = cimg::sqr((Tfloat)Inc - Ipc),
                beta = cimg::sqr((Tfloat)Icn - Icp),
                cx = 1/(1+alpha), cy = 1/(1+beta);
              *ptr_g = (Tuchar)((cx*(Inc+Ipc) + cy*(Icn+Icp))/(2*(cx+cy)));
            } else *ptr_g = (Tuchar)Icc;
          } else {
            if (x%2) *ptr_g = (Tuchar)Icc;
            else {
              const Tfloat
                alpha = cimg::sqr((Tfloat)Inc - Ipc),
                beta = cimg::sqr((Tfloat)Icn - Icp),
                cx = 1/(1+alpha), cy = 1/(1+beta);
              *ptr_g = (Tuchar)((cx*(Inc+Ipc) + cy*(Icn+Icp))/(2*(cx+cy)));
            }
          }
          ++ptr_g;
        }
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          const int _p1x = x?x-1:1, _p1y = y?y-1:1, _n1x = x<width()-1?x+1:x-1, _n1y = y<height()-1?y+1:y-1;
          I[0] = (T)(*this)(_p1x,_p1y,z,0), I[1] = (T)(*this)(x,_p1y,z,0), I[2] = (T)(*this)(_n1x,_p1y,z,0), I[3] = (T)(*this)(_p1x,y,z,0), I[4] = (T)(*this)(x,y,z,0), I[5] = (T)(*this)(_n1x,y,z,0), I[6] = (T)(*this)(_p1x,_n1y,z,0), I[7] = (T)(*this)(x,_n1y,z,0), I[8] = (T)(*this)(_n1x,_n1y,z,0);
          G[0] = (T)(res)(_p1x,_p1y,z,1), G[1] = (T)(res)(x,_p1y,z,1), G[2] = (T)(res)(_n1x,_p1y,z,1), G[3] = (T)(res)(_p1x,y,z,1), G[4] = (T)(res)(x,y,z,1), G[5] = (T)(res)(_n1x,y,z,1), G[6] = (T)(res)(_p1x,_n1y,z,1), G[7] = (T)(res)(x,_n1y,z,1), G[8] = (T)(res)(_n1x,_n1y,z,1);
          if (y%2) {
            if (x%2) *ptr_b = (Tuchar)Icc;
            else { *ptr_r = (Tuchar)((Icn+Icp)/2); *ptr_b = (Tuchar)((Inc+Ipc)/2); }
          } else {
            if (x%2) { *ptr_r = (Tuchar)((Inc+Ipc)/2); *ptr_b = (Tuchar)((Icn+Icp)/2); }
            else *ptr_r = (Tuchar)Icc;
          }
          ++ptr_r; ++ptr_b;
        }
        ptr_r = res.data(0,0,0,0);
        ptr_g = res.data(0,0,0,1);
        ptr_b = res.data(0,0,0,2);
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          const int _p1x = x?x-1:1, _p1y = y?y-1:1, _n1x = x<width()-1?x+1:x-1, _n1y = y<height()-1?y+1:y-1;
          R[0] = (T)(res)(_p1x,_p1y,z,0), R[1] = (T)(res)(x,_p1y,z,0), R[2] = (T)(res)(_n1x,_p1y,z,0), R[3] = (T)(res)(_p1x,y,z,0), R[4] = (T)(res)(x,y,z,0), R[5] = (T)(res)(_n1x,y,z,0), R[6] = (T)(res)(_p1x,_n1y,z,0), R[7] = (T)(res)(x,_n1y,z,0), R[8] = (T)(res)(_n1x,_n1y,z,0);
          G[0] = (T)(res)(_p1x,_p1y,z,1), G[1] = (T)(res)(x,_p1y,z,1), G[2] = (T)(res)(_n1x,_p1y,z,1), G[3] = (T)(res)(_p1x,y,z,1), G[4] = (T)(res)(x,y,z,1), G[5] = (T)(res)(_n1x,y,z,1), G[6] = (T)(res)(_p1x,_n1y,z,1), G[7] = (T)(res)(x,_n1y,z,1), G[8] = (T)(res)(_n1x,_n1y,z,1);
          B[0] = (T)(res)(_p1x,_p1y,z,2), B[1] = (T)(res)(x,_p1y,z,2), B[2] = (T)(res)(_n1x,_p1y,z,2), B[3] = (T)(res)(_p1x,y,z,2), B[4] = (T)(res)(x,y,z,2), B[5] = (T)(res)(_n1x,y,z,2), B[6] = (T)(res)(_p1x,_n1y,z,2), B[7] = (T)(res)(x,_n1y,z,2), B[8] = (T)(res)(_n1x,_n1y,z,2);
          if (y%2) {
            if (x%2) {
              const float
                alpha = (float)cimg::sqr(Rnc-Rpc),
                beta = (float)cimg::sqr(Rcn-Rcp),
                cx = 1/(1+alpha), cy = 1/(1+beta);
              *ptr_r = (Tuchar)((cx*(Rnc+Rpc) + cy*(Rcn+Rcp))/(2*(cx+cy)));
            }
          } else {
            if (!(x%2)) {
              const float
                alpha = (float)cimg::sqr(Bnc-Bpc),
                beta = (float)cimg::sqr(Bcn-Bcp),
                cx = 1/(1+alpha), cy = 1/(1+beta);
              *ptr_b = (Tuchar)((cx*(Bnc+Bpc) + cy*(Bcn+Bcp))/(2*(cx+cy)));
            }
          }
          ++ptr_r; ++ptr_g; ++ptr_b;
        }
      } break;
      case 2 : {
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          const int _p1x = x?x-1:1, _p1y = y?y-1:1, _n1x = x<width()-1?x+1:x-1, _n1y = y<height()-1?y+1:y-1;
          I[0] = (T)(*this)(_p1x,_p1y,z,0), I[1] = (T)(*this)(x,_p1y,z,0), I[2] = (T)(*this)(_n1x,_p1y,z,0), I[3] = (T)(*this)(_p1x,y,z,0), I[4] = (T)(*this)(x,y,z,0), I[5] = (T)(*this)(_n1x,y,z,0), I[6] = (T)(*this)(_p1x,_n1y,z,0), I[7] = (T)(*this)(x,_n1y,z,0), I[8] = (T)(*this)(_n1x,_n1y,z,0);
          if (y%2) {
            if (x%2) {
              *ptr_r = (Tuchar)((Ipp+Inn+Ipn+Inp)/4); *ptr_g = (Tuchar)((Inc+Ipc+Icn+Icp)/4); *ptr_b = (Tuchar)Icc;
            } else { *ptr_r = (Tuchar)((Icp+Icn)/2); *ptr_g = (Tuchar)Icc; *ptr_b = (Tuchar)((Inc+Ipc)/2); }
          } else {
            if (x%2) { *ptr_r = (Tuchar)((Ipc+Inc)/2); *ptr_g = (Tuchar)Icc; *ptr_b = (Tuchar)((Icn+Icp)/2); }
            else {
              *ptr_r = (Tuchar)Icc; *ptr_g = (Tuchar)((Inc+Ipc+Icn+Icp)/4); *ptr_b = (Tuchar)((Ipp+Inn+Ipn+Inp)/4);
            }
          }
          ++ptr_r; ++ptr_g; ++ptr_b;
        }
      } break;
      case 1 : {
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          const int _p1x = x?x-1:1, _p1y = y?y-1:1, _n1x = x<width()-1?x+1:x-1, _n1y = y<height()-1?y+1:y-1;
          I[0] = (T)(*this)(_p1x,_p1y,z,0), I[1] = (T)(*this)(x,_p1y,z,0), I[2] = (T)(*this)(_n1x,_p1y,z,0), I[3] = (T)(*this)(_p1x,y,z,0), I[4] = (T)(*this)(x,y,z,0), I[5] = (T)(*this)(_n1x,y,z,0), I[6] = (T)(*this)(_p1x,_n1y,z,0), I[7] = (T)(*this)(x,_n1y,z,0), I[8] = (T)(*this)(_n1x,_n1y,z,0);
          if (y%2) {
            if (x%2) {
              *ptr_r = (Tuchar)cimg::min(Ipp,Inn,Ipn,Inp);
              *ptr_g = (Tuchar)cimg::min(Inc,Ipc,Icn,Icp);
              *ptr_b = (Tuchar)Icc;
            } else { *ptr_r = (Tuchar)cimg::min(Icn,Icp); *ptr_g = (Tuchar)Icc; *ptr_b = (Tuchar)cimg::min(Inc,Ipc); }
          } else {
            if (x%2) { *ptr_r = (Tuchar)cimg::min(Inc,Ipc); *ptr_g = (Tuchar)Icc; *ptr_b = (Tuchar)cimg::min(Icn,Icp); }
            else {
              *ptr_r = (Tuchar)Icc;
              *ptr_g = (Tuchar)cimg::min(Inc,Ipc,Icn,Icp);
              *ptr_b = (Tuchar)cimg::min(Ipp,Inn,Ipn,Inp);
            }
          }
          ++ptr_r; ++ptr_g; ++ptr_b;
        }
      } break;
      default : {
        const T *ptrs = _data;
        res.fill(0);
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          const T val = *(ptrs++);
          if (y%2) { if (x%2) *ptr_b = val; else *ptr_g = val; } else { if (x%2) *ptr_g = val; else *ptr_r = val; }
          ++ptr_r; ++ptr_g; ++ptr_b;
        }
      }
      }
      return res;
    }
# 20978 "../src/CImg.h"
    static float _cimg_lanczos(const float x) {
      if (x<=-2 || x>=2) return 0;
      const float a = (float)cimg::PI*x, b = 0.5f*a;
      return (float)(x?std::sin(a)*std::sin(b)/(a*b):1);
    }
# 21006 "../src/CImg.h"
    CImg<T>& resize(const int size_x, const int size_y=-100,
                    const int size_z=-100, const int size_c=-100,
                    const int interpolation_type=1, const unsigned int boundary_conditions=0,
                    const float centering_x = 0, const float centering_y = 0,
                    const float centering_z = 0, const float centering_c = 0) {
      if (!size_x || !size_y || !size_z || !size_c) return assign();
      const unsigned int
        _sx = (unsigned int)(size_x<0?-size_x*width()/100:size_x),
        _sy = (unsigned int)(size_y<0?-size_y*height()/100:size_y),
        _sz = (unsigned int)(size_z<0?-size_z*depth()/100:size_z),
        _sc = (unsigned int)(size_c<0?-size_c*spectrum()/100:size_c),
        sx = _sx?_sx:1, sy = _sy?_sy:1, sz = _sz?_sz:1, sc = _sc?_sc:1;
      if (sx==_width && sy==_height && sz==_depth && sc==_spectrum) return *this;
      if (is_empty()) return assign(sx,sy,sz,sc,(T)0);
      if (interpolation_type==-1 && sx*sy*sz*sc==size()) {
        _width = sx; _height = sy; _depth = sz; _spectrum = sc;
        return *this;
      }
      return get_resize(sx,sy,sz,sc,interpolation_type,boundary_conditions,
                        centering_x,centering_y,centering_z,centering_c).move_to(*this);
    }


    CImg<T> get_resize(const int size_x, const int size_y = -100,
                       const int size_z = -100, const int size_c = -100,
                       const int interpolation_type=1, const unsigned int boundary_conditions=0,
                       const float centering_x = 0, const float centering_y = 0,
                       const float centering_z = 0, const float centering_c = 0) const {
      if (centering_x<0 || centering_x>1 || centering_y<0 || centering_y>1 ||
          centering_z<0 || centering_z>1 || centering_c<0 || centering_c>1)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "resize(): Specified centering arguments (%g,%g,%g,%g) are outside range [0,1].",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    centering_x,centering_y,centering_z,centering_c);

      if (!size_x || !size_y || !size_z || !size_c) return CImg<T>();
      const unsigned int
        _sx = (unsigned int)(size_x<0?-size_x*width()/100:size_x),
        _sy = (unsigned int)(size_y<0?-size_y*height()/100:size_y),
        _sz = (unsigned int)(size_z<0?-size_z*depth()/100:size_z),
        _sc = (unsigned int)(size_c<0?-size_c*spectrum()/100:size_c),
        sx = _sx?_sx:1, sy = _sy?_sy:1, sz = _sz?_sz:1, sc = _sc?_sc:1;
      if (sx==_width && sy==_height && sz==_depth && sc==_spectrum) return +*this;
      if (is_empty()) return CImg<T>(sx,sy,sz,sc,0);

      CImg<T> res;
      switch (interpolation_type) {



      case -1 :
        std::memcpy(res.assign(sx,sy,sz,sc,0)._data,_data,sizeof(T)*cimg::min(size(),sx*sy*sz*sc));
        break;



      case 0 : {
        const int
          xc = (int)(centering_x*((int)sx - width())),
          yc = (int)(centering_y*((int)sy - height())),
          zc = (int)(centering_z*((int)sz - depth())),
          cc = (int)(centering_c*((int)sc - spectrum()));

        switch (boundary_conditions) {
        case 2 : {
          res.assign(sx,sy,sz,sc);
          const int
            x0 = ((int)xc%width()) - width(),
            y0 = ((int)yc%height()) - height(),
            z0 = ((int)zc%depth()) - depth(),
            c0 = ((int)cc%spectrum()) - spectrum();



          for (int c = c0; c<(int)sc; c+=spectrum())
            for (int z = z0; z<(int)sz; z+=depth())
              for (int y = y0; y<(int)sy; y+=height())
                for (int x = x0; x<(int)sx; x+=width())
                  res.draw_image(x,y,z,c,*this);
        } break;
        case 1 : {
          res.assign(sx,sy,sz,sc).draw_image(xc,yc,zc,cc,*this);
          CImg<T> sprite;
          if (xc>0) {
            res.get_crop(xc,yc,zc,cc,xc,yc+height()-1,zc+depth()-1,cc+spectrum()-1).move_to(sprite);
            for (int x = xc-1; x>=0; --x) res.draw_image(x,yc,zc,cc,sprite);
          }
          if (xc+width()<(int)sx) {
            res.get_crop(xc+width()-1,yc,zc,cc,xc+width()-1,yc+height()-1,zc+depth()-1,cc+spectrum()-1).move_to(sprite);
            for (int x = xc+width(); x<(int)sx; ++x) res.draw_image(x,yc,zc,cc,sprite);
          }
          if (yc>0) {
            res.get_crop(0,yc,zc,cc,sx-1,yc,zc+depth()-1,cc+spectrum()-1).move_to(sprite);
            for (int y = yc-1; y>=0; --y) res.draw_image(0,y,zc,cc,sprite);
          }
          if (yc+height()<(int)sy) {
            res.get_crop(0,yc+height()-1,zc,cc,sx-1,yc+height()-1,zc+depth()-1,cc+spectrum()-1).move_to(sprite);
            for (int y = yc+height(); y<(int)sy; ++y) res.draw_image(0,y,zc,cc,sprite);
          }
          if (zc>0) {
            res.get_crop(0,0,zc,cc,sx-1,sy-1,zc,cc+spectrum()-1).move_to(sprite);
            for (int z = zc-1; z>=0; --z) res.draw_image(0,0,z,cc,sprite);
          }
          if (zc+depth()<(int)sz) {
            res.get_crop(0,0,zc+depth()-1,cc,sx-1,sy-1,zc+depth()-1,cc+spectrum()-1).move_to(sprite);
            for (int z = zc+depth(); z<(int)sz; ++z) res.draw_image(0,0,z,cc,sprite);
          }
          if (cc>0) {
            res.get_crop(0,0,0,cc,sx-1,sy-1,sz-1,cc).move_to(sprite);
            for (int c = cc-1; c>=0; --c) res.draw_image(0,0,0,c,sprite);
          }
          if (cc+spectrum()<(int)sc) {
            res.get_crop(0,0,0,cc+spectrum()-1,sx-1,sy-1,sz-1,cc+spectrum()-1).move_to(sprite);
            for (int c = cc+spectrum(); c<(int)sc; ++c) res.draw_image(0,0,0,c,sprite);
          }
        } break;
        default :
          res.assign(sx,sy,sz,sc,0).draw_image(xc,yc,zc,cc,*this);
        }
        break;
      } break;



      case 1 : {
        res.assign(sx,sy,sz,sc);
        CImg<ulongT> off_x(sx), off_y(sy+1), off_z(sz+1), off_c(sc+1);
        const unsigned long
          wh = (unsigned long)_width*_height,
          whd = (unsigned long)_width*_height*_depth,
          sxy = (unsigned long)sx*sy,
          sxyz = (unsigned long)sx*sy*sz;
        if (sx==_width) off_x.fill(1);
        else {
          unsigned long *poff_x = off_x._data, curr = 0;
          for (int x = 0; x<(int)((res)._width); ++x) { const unsigned long old = curr; curr = ((x+1LU)*_width/sx); *(poff_x++) = curr - old; }
        }
        if (sy==_height) off_y.fill(_width);
        else {
          unsigned long *poff_y = off_y._data, curr = 0;
          for (int y = 0; y<(int)((res)._height); ++y) {
            const unsigned long old = curr;
            curr = ((y+1LU)*_height/sy);
            *(poff_y++) = _width*(curr - old);
          }
          *poff_y = 0;
        }
        if (sz==_depth) off_z.fill(wh);
        else {
          unsigned long *poff_z = off_z._data, curr = 0;
          for (int z = 0; z<(int)((res)._depth); ++z) {
            const unsigned long old = curr;
            curr = ((z+1LU)*_depth/sz);
            *(poff_z++) = wh*(curr - old);
          }
          *poff_z = 0;
        }
        if (sc==_spectrum) off_c.fill(whd);
        else {
          unsigned long *poff_c = off_c._data, curr = 0;
          for (int c = 0; c<(int)((res)._spectrum); ++c) {
            const unsigned long old = curr;
            curr = ((c+1LU)*_spectrum/sc);
            *(poff_c++) = whd*(curr - old);
          }
          *poff_c = 0;
        }

        T *ptrd = res._data;
        const T* ptrc = _data;
        const unsigned long *poff_c = off_c._data;
        for (unsigned int c = 0; c<sc; ) {
          const T *ptrz = ptrc;
          const unsigned long *poff_z = off_z._data;
          for (unsigned int z = 0; z<sz; ) {
            const T *ptry = ptrz;
            const unsigned long *poff_y = off_y._data;
            for (unsigned int y = 0; y<sy; ) {
              const T *ptrx = ptry;
              const unsigned long *poff_x = off_x._data;
              for (int x = 0; x<(int)((res)._width); ++x) { *(ptrd++) = *ptrx; ptrx+=*(poff_x++); }
              ++y;
              unsigned long dy = *(poff_y++);
              for (;!dy && y<dy; std::memcpy(ptrd,ptrd - sx,sizeof(T)*sx), ++y, ptrd+=sx, dy = *(poff_y++)) {}
              ptry+=dy;
            }
            ++z;
            unsigned long dz = *(poff_z++);
            for (;!dz && z<dz; std::memcpy(ptrd,ptrd-sxy,sizeof(T)*sxy), ++z, ptrd+=sxy, dz = *(poff_z++)) {}
            ptrz+=dz;
          }
          ++c;
          unsigned long dc = *(poff_c++);
          for (;!dc && c<dc; std::memcpy(ptrd,ptrd-sxyz,sizeof(T)*sxyz), ++c, ptrd+=sxyz, dc = *(poff_c++)) {}
          ptrc+=dc;
        }
      } break;



      case 2 : {
        bool instance_first = true;
        if (sx!=_width) {
          CImg<Tfloat> tmp(sx,_height,_depth,_spectrum,0);
          for (unsigned int a = _width*sx, b = _width, c = sx, s = 0, t = 0; a; ) {
            const unsigned int d = cimg::min(b,c);
            a-=d; b-=d; c-=d;
            for (int v = 0; v<(int)((tmp)._spectrum); ++v) for (int z = 0; z<(int)((tmp)._depth); ++z) for (int y = 0; y<(int)((tmp)._height); ++y) tmp(t,y,z,v)+=(Tfloat)(*this)(s,y,z,v)*d;
            if (!b) {
              for (int v = 0; v<(int)((tmp)._spectrum); ++v) for (int z = 0; z<(int)((tmp)._depth); ++z) for (int y = 0; y<(int)((tmp)._height); ++y) tmp(t,y,z,v)/=_width;
              ++t;
              b = _width;
            }
            if (!c) { ++s; c = sx; }
          }
          tmp.move_to(res);
          instance_first = false;
        }
        if (sy!=_height) {
          CImg<Tfloat> tmp(sx,sy,_depth,_spectrum,0);
          for (unsigned int a = _height*sy, b = _height, c = sy, s = 0, t = 0; a; ) {
            const unsigned int d = cimg::min(b,c);
            a-=d; b-=d; c-=d;
            if (instance_first)
              for (int v = 0; v<(int)((tmp)._spectrum); ++v) for (int z = 0; z<(int)((tmp)._depth); ++z) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,t,z,v)+=(Tfloat)(*this)(x,s,z,v)*d;
            else
              for (int v = 0; v<(int)((tmp)._spectrum); ++v) for (int z = 0; z<(int)((tmp)._depth); ++z) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,t,z,v)+=(Tfloat)res(x,s,z,v)*d;
            if (!b) {
              for (int v = 0; v<(int)((tmp)._spectrum); ++v) for (int z = 0; z<(int)((tmp)._depth); ++z) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,t,z,v)/=_height;
              ++t;
              b = _height;
            }
            if (!c) { ++s; c = sy; }
          }
          tmp.move_to(res);
          instance_first = false;
        }
        if (sz!=_depth) {
          CImg<Tfloat> tmp(sx,sy,sz,_spectrum,0);
          for (unsigned int a = _depth*sz, b = _depth, c = sz, s = 0, t = 0; a; ) {
            const unsigned int d = cimg::min(b,c);
            a-=d; b-=d; c-=d;
            if (instance_first)
              for (int v = 0; v<(int)((tmp)._spectrum); ++v) for (int y = 0; y<(int)((tmp)._height); ++y) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,y,t,v)+=(Tfloat)(*this)(x,y,s,v)*d;
            else
              for (int v = 0; v<(int)((tmp)._spectrum); ++v) for (int y = 0; y<(int)((tmp)._height); ++y) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,y,t,v)+=(Tfloat)res(x,y,s,v)*d;
            if (!b) {
              for (int v = 0; v<(int)((tmp)._spectrum); ++v) for (int y = 0; y<(int)((tmp)._height); ++y) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,y,t,v)/=_depth;
              ++t;
              b = _depth;
            }
            if (!c) { ++s; c = sz; }
          }
          tmp.move_to(res);
          instance_first = false;
        }
        if (sc!=_spectrum) {
          CImg<Tfloat> tmp(sx,sy,sz,sc,0);
          for (unsigned int a = _spectrum*sc, b = _spectrum, c = sc, s = 0, t = 0; a; ) {
            const unsigned int d = cimg::min(b,c);
            a-=d; b-=d; c-=d;
            if (instance_first)
              for (int z = 0; z<(int)((tmp)._depth); ++z) for (int y = 0; y<(int)((tmp)._height); ++y) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,y,z,t)+=(Tfloat)(*this)(x,y,z,s)*d;
            else
              for (int z = 0; z<(int)((tmp)._depth); ++z) for (int y = 0; y<(int)((tmp)._height); ++y) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,y,z,t)+=(Tfloat)res(x,y,z,s)*d;
            if (!b) {
              for (int z = 0; z<(int)((tmp)._depth); ++z) for (int y = 0; y<(int)((tmp)._height); ++y) for (int x = 0; x<(int)((tmp)._width); ++x) tmp(x,y,z,t)/=_spectrum;
              ++t;
              b = _spectrum;
            }
            if (!c) { ++s; c = sc; }
          }
          tmp.move_to(res);
          instance_first = false;
        }
      } break;



      case 3 : {
        CImg<uintT> off(cimg::max(sx,sy,sz,sc));
        CImg<floatT> foff(off._width);
        CImg<T> resx, resy, resz, resc;

        if (sx!=_width) {
          if (_width==1) get_resize(sx,_height,_depth,_spectrum,1).move_to(resx);
          else {
            if (_width>sx) get_resize(sx,_height,_depth,_spectrum,2).move_to(resx);
            else {
              const float fx = (!boundary_conditions && sx>_width)?(sx>1?(_width-1.0f)/(sx-1):0):(float)_width/sx;
              resx.assign(sx,_height,_depth,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int x = 0; x<(int)((resx)._width); ++x) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fx;
                *(poff++) = (unsigned int)curr - (unsigned int)old;
              }



              for (int c = 0; c<(int)((resx)._spectrum); ++c) for (int z = 0; z<(int)((resx)._depth); ++z) for (int y = 0; y<(int)((resx)._height); ++y) {
                const T *ptrs = data(0,y,z,c), *const ptrsmax = ptrs + (_width-1);
                T *ptrd = resx.data(0,y,z,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int x = 0; x<(int)((resx)._width); ++x) {
                  const float alpha = *(pfoff++);
                  const T val1 = *ptrs, val2 = ptrs<ptrsmax?*(ptrs+1):val1;
                  *(ptrd++) = (T)((1-alpha)*val1 + alpha*val2);
                  ptrs+=*(poff++);
                }
              }
            }
          }
        } else resx.assign(*this,true);

        if (sy!=_height) {
          if (_height==1) resx.get_resize(sx,sy,_depth,_spectrum,1).move_to(resy);
          else {
            if (_height>sy) resx.get_resize(sx,sy,_depth,_spectrum,2).move_to(resy);
            else {
              const float fy = (!boundary_conditions && sy>_height)?(sy>1?(_height-1.0f)/(sy-1):0):(float)_height/sy;
              resy.assign(sx,sy,_depth,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int y = 0; y<(int)((resy)._height); ++y) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fy;
                *(poff++) = sx*((unsigned int)curr-(unsigned int)old);
              }



              for (int c = 0; c<(int)((resy)._spectrum); ++c) for (int z = 0; z<(int)((resy)._depth); ++z) for (int x = 0; x<(int)((resy)._width); ++x) {
                const T *ptrs = resx.data(x,0,z,c), *const ptrsmax = ptrs + (_height-1)*sx;
                T *ptrd = resy.data(x,0,z,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int y = 0; y<(int)((resy)._height); ++y) {
                  const float alpha = *(pfoff++);
                  const T val1 = *ptrs, val2 = ptrs<ptrsmax?*(ptrs+sx):val1;
                  *ptrd = (T)((1-alpha)*val1 + alpha*val2);
                  ptrd+=sx;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resx.assign();
        } else resy.assign(resx,true);

        if (sz!=_depth) {
          if (_depth==1) resy.get_resize(sx,sy,sz,_spectrum,1).move_to(resz);
          else {
            if (_depth>sz) resy.get_resize(sx,sy,sz,_spectrum,2).move_to(resz);
            else {
              const float fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth-1.0f)/(sz-1):0):(float)_depth/sz;
              const unsigned int sxy = sx*sy;
              resz.assign(sx,sy,sz,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int z = 0; z<(int)((resz)._depth); ++z) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fz;
                *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
              }



              for (int c = 0; c<(int)((resz)._spectrum); ++c) for (int y = 0; y<(int)((resz)._height); ++y) for (int x = 0; x<(int)((resz)._width); ++x) {
                const T *ptrs = resy.data(x,y,0,c), *const ptrsmax = ptrs + (_depth-1)*sxy;
                T *ptrd = resz.data(x,y,0,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int z = 0; z<(int)((resz)._depth); ++z) {
                  const float alpha = *(pfoff++);
                  const T val1 = *ptrs, val2 = ptrs<ptrsmax?*(ptrs+sxy):val1;
                  *ptrd = (T)((1-alpha)*val1 + alpha*val2);
                  ptrd+=sxy;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resy.assign();
        } else resz.assign(resy,true);

        if (sc!=_spectrum) {
          if (_spectrum==1) resz.get_resize(sx,sy,sz,sc,1).move_to(resc);
          else {
            if (_spectrum>sc) resz.get_resize(sx,sy,sz,sc,2).move_to(resc);
            else {
              const float fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum-1.0f)/(sc-1):0):
                (float)_spectrum/sc;
              const unsigned int sxyz = sx*sy*sz;
              resc.assign(sx,sy,sz,sc);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int c = 0; c<(int)((resc)._spectrum); ++c) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fc;
                *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
              }



              for (int z = 0; z<(int)((resc)._depth); ++z) for (int y = 0; y<(int)((resc)._height); ++y) for (int x = 0; x<(int)((resc)._width); ++x) {
                const T *ptrs = resz.data(x,y,z,0), *const ptrsmax = ptrs + (_spectrum-1)*sxyz;
                T *ptrd = resc.data(x,y,z,0);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int c = 0; c<(int)((resc)._spectrum); ++c) {
                  const float alpha = *(pfoff++);
                  const T val1 = *ptrs, val2 = ptrs<ptrsmax?*(ptrs+sxyz):val1;
                  *ptrd = (T)((1-alpha)*val1 + alpha*val2);
                  ptrd+=sxyz;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resz.assign();
        } else resc.assign(resz,true);
        return resc._is_shared?(resz._is_shared?(resy._is_shared?(resx._is_shared?(+(*this)):resx):resy):resz):resc;
      } break;



      case 4 : {
        CImg<T> resx, resy, resz, resc;
        if (sx!=_width) {
          if (sx<_width) get_resize(sx,_height,_depth,_spectrum,1).move_to(resx);
          else {
            resx.assign(sx,_height,_depth,_spectrum,0);
            const int dx = sx*2, dy = width()*2;
            int err = (int)(dy + centering_x*(sx*dy/width() - dy)), xs = 0;
            for (int x = 0; x<(int)((resx)._width); ++x) if ((err-=dy)<=0) {
              for (int c = 0; c<(int)((resx)._spectrum); ++c) for (int z = 0; z<(int)((resx)._depth); ++z) for (int y = 0; y<(int)((resx)._height); ++y) resx(x,y,z,c) = (*this)(xs,y,z,c);
              ++xs;
              err+=dx;
            }
          }
        } else resx.assign(*this,true);

        if (sy!=_height) {
          if (sy<_height) resx.get_resize(sx,sy,_depth,_spectrum,1).move_to(resy);
          else {
            resy.assign(sx,sy,_depth,_spectrum,0);
            const int dx = sy*2, dy = height()*2;
            int err = (int)(dy + centering_y*(sy*dy/height() - dy)), ys = 0;
            for (int y = 0; y<(int)((resy)._height); ++y) if ((err-=dy)<=0) {
              for (int c = 0; c<(int)((resy)._spectrum); ++c) for (int z = 0; z<(int)((resy)._depth); ++z) for (int x = 0; x<(int)((resy)._width); ++x) resy(x,y,z,c) = resx(x,ys,z,c);
              ++ys;
              err+=dx;
            }
          }
          resx.assign();
        } else resy.assign(resx,true);

        if (sz!=_depth) {
          if (sz<_depth) resy.get_resize(sx,sy,sz,_spectrum,1).move_to(resz);
          else {
            resz.assign(sx,sy,sz,_spectrum,0);
            const int dx = sz*2, dy = depth()*2;
            int err = (int)(dy + centering_z*(sz*dy/depth() - dy)), zs = 0;
            for (int z = 0; z<(int)((resz)._depth); ++z) if ((err-=dy)<=0) {
              for (int c = 0; c<(int)((resz)._spectrum); ++c) for (int y = 0; y<(int)((resz)._height); ++y) for (int x = 0; x<(int)((resz)._width); ++x) resz(x,y,z,c) = resy(x,y,zs,c);
              ++zs;
              err+=dx;
            }
          }
          resy.assign();
        } else resz.assign(resy,true);

        if (sc!=_spectrum) {
          if (sc<_spectrum) resz.get_resize(sx,sy,sz,sc,1).move_to(resc);
          else {
            resc.assign(sx,sy,sz,sc,0);
            const int dx = sc*2, dy = spectrum()*2;
            int err = (int)(dy + centering_c*(sc*dy/spectrum() - dy)), cs = 0;
            for (int c = 0; c<(int)((resc)._spectrum); ++c) if ((err-=dy)<=0) {
              for (int z = 0; z<(int)((resc)._depth); ++z) for (int y = 0; y<(int)((resc)._height); ++y) for (int x = 0; x<(int)((resc)._width); ++x) resc(x,y,z,c) = resz(x,y,z,cs);
              ++cs;
              err+=dx;
            }
          }
          resz.assign();
        } else resc.assign(resz,true);

        return resc._is_shared?(resz._is_shared?(resy._is_shared?(resx._is_shared?(+(*this)):resx):resy):resz):resc;
      } break;



      case 5 : {
        const Tfloat vmin = (Tfloat)cimg::type<T>::min(), vmax = (Tfloat)cimg::type<T>::max();
        CImg<uintT> off(cimg::max(sx,sy,sz,sc));
        CImg<floatT> foff(off._width);
        CImg<T> resx, resy, resz, resc;

        if (sx!=_width) {
          if (_width==1) get_resize(sx,_height,_depth,_spectrum,1).move_to(resx);
          else {
            if (_width>sx) get_resize(sx,_height,_depth,_spectrum,2).move_to(resx);
            else {
              const float fx = (!boundary_conditions && sx>_width)?(sx>1?(_width-1.0f)/(sx-1):0):(float)_width/sx;
              resx.assign(sx,_height,_depth,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int x = 0; x<(int)((resx)._width); ++x) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fx;
                *(poff++) = (unsigned int)curr - (unsigned int)old;
              }



              for (int c = 0; c<(int)((resx)._spectrum); ++c) for (int z = 0; z<(int)((resx)._depth); ++z) for (int y = 0; y<(int)((resx)._height); ++y) {
                const T *const ptrs0 = data(0,y,z,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_width-2);
                T *ptrd = resx.data(0,y,z,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int x = 0; x<(int)((resx)._width); ++x) {
                  const float t = *(pfoff++);
                  const Tfloat
                    val1 = (Tfloat)*ptrs,
                    val0 = ptrs>ptrs0?(Tfloat)*(ptrs-1):val1,
                    val2 = ptrs<=ptrsmax?(Tfloat)*(ptrs+1):val1,
                    val3 = ptrs<ptrsmax?(Tfloat)*(ptrs+2):val2,
                    val = val1 + 0.5f*(t*(-val0+val2) + t*t*(2*val0-5*val1+4*val2-val3) +
                                       t*t*t*(-val0+3*val1-3*val2+val3));
                  *(ptrd++) = (T)(val<vmin?vmin:val>vmax?vmax:val);
                  ptrs+=*(poff++);
                }
              }
            }
          }
        } else resx.assign(*this,true);

        if (sy!=_height) {
          if (_height==1) resx.get_resize(sx,sy,_depth,_spectrum,1).move_to(resy);
          else {
            if (_height>sy) resx.get_resize(sx,sy,_depth,_spectrum,2).move_to(resy);
            else {
              const float fy = (!boundary_conditions && sy>_height)?(sy>1?(_height-1.0f)/(sy-1):0):(float)_height/sy;
              resy.assign(sx,sy,_depth,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int y = 0; y<(int)((resy)._height); ++y) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fy;
                *(poff++) = sx*((unsigned int)curr-(unsigned int)old);
              }



              for (int c = 0; c<(int)((resy)._spectrum); ++c) for (int z = 0; z<(int)((resy)._depth); ++z) for (int x = 0; x<(int)((resy)._width); ++x) {
                const T *const ptrs0 = resx.data(x,0,z,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_height-2)*sx;
                T *ptrd = resy.data(x,0,z,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int y = 0; y<(int)((resy)._height); ++y) {
                  const float t = *(pfoff++);
                  const Tfloat
                    val1 = (Tfloat)*ptrs,
                    val0 = ptrs>ptrs0?(Tfloat)*(ptrs-sx):val1,
                    val2 = ptrs<=ptrsmax?(Tfloat)*(ptrs+sx):val1,
                    val3 = ptrs<ptrsmax?(Tfloat)*(ptrs+2*sx):val2,
                    val = val1 + 0.5f*(t*(-val0+val2) + t*t*(2*val0-5*val1+4*val2-val3) +
                                       t*t*t*(-val0+3*val1-3*val2+val3));
                  *ptrd = (T)(val<vmin?vmin:val>vmax?vmax:val);
                  ptrd+=sx;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resx.assign();
        } else resy.assign(resx,true);

        if (sz!=_depth) {
          if (_depth==1) resy.get_resize(sx,sy,sz,_spectrum,1).move_to(resz);
          else {
            if (_depth>sz) resy.get_resize(sx,sy,sz,_spectrum,2).move_to(resz);
            else {
              const float fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth-1.0f)/(sz-1):0):(float)_depth/sz;
              const unsigned int sxy = sx*sy;
              resz.assign(sx,sy,sz,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int z = 0; z<(int)((resz)._depth); ++z) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fz;
                *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
              }



              for (int c = 0; c<(int)((resz)._spectrum); ++c) for (int y = 0; y<(int)((resz)._height); ++y) for (int x = 0; x<(int)((resz)._width); ++x) {
                const T *const ptrs0 = resy.data(x,y,0,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_depth-2)*sxy;
                T *ptrd = resz.data(x,y,0,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int z = 0; z<(int)((resz)._depth); ++z) {
                  const float t = *(pfoff++);
                  const Tfloat
                    val1 = (Tfloat)*ptrs,
                    val0 = ptrs>ptrs0?(Tfloat)*(ptrs-sxy):val1,
                    val2 = ptrs<=ptrsmax?(Tfloat)*(ptrs+sxy):val1,
                    val3 = ptrs<ptrsmax?(Tfloat)*(ptrs+2*sxy):val2,
                    val = val1 + 0.5f*(t*(-val0+val2) + t*t*(2*val0-5*val1+4*val2-val3) +
                                       t*t*t*(-val0+3*val1-3*val2+val3));
                  *ptrd = (T)(val<vmin?vmin:val>vmax?vmax:val);
                  ptrd+=sxy;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resy.assign();
        } else resz.assign(resy,true);

        if (sc!=_spectrum) {
          if (_spectrum==1) resz.get_resize(sx,sy,sz,sc,1).move_to(resc);
          else {
            if (_spectrum>sc) resz.get_resize(sx,sy,sz,sc,2).move_to(resc);
            else {
              const float fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum-1.0f)/(sc-1):0):
                (float)_spectrum/sc;
              const unsigned int sxyz = sx*sy*sz;
              resc.assign(sx,sy,sz,sc);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int c = 0; c<(int)((resc)._spectrum); ++c) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fc;
                *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
              }



              for (int z = 0; z<(int)((resc)._depth); ++z) for (int y = 0; y<(int)((resc)._height); ++y) for (int x = 0; x<(int)((resc)._width); ++x) {
                const T *const ptrs0 = resz.data(x,y,z,0), *ptrs = ptrs0, *const ptrsmax = ptrs + (_spectrum-2)*sxyz;
                T *ptrd = resc.data(x,y,z,0);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int c = 0; c<(int)((resc)._spectrum); ++c) {
                  const float t = *(pfoff++);
                  const Tfloat
                    val1 = (Tfloat)*ptrs,
                    val0 = ptrs>ptrs0?(Tfloat)*(ptrs-sxyz):val1,
                    val2 = ptrs<=ptrsmax?(Tfloat)*(ptrs+sxyz):val1,
                    val3 = ptrs<ptrsmax?(Tfloat)*(ptrs+2*sxyz):val2,
                    val = val1 + 0.5f*(t*(-val0+val2) + t*t*(2*val0-5*val1+4*val2-val3) +
                                       t*t*t*(-val0+3*val1-3*val2+val3));
                  *ptrd = (T)(val<vmin?vmin:val>vmax?vmax:val);
                  ptrd+=sxyz;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resz.assign();
        } else resc.assign(resz,true);

        return resc._is_shared?(resz._is_shared?(resy._is_shared?(resx._is_shared?(+(*this)):resx):resy):resz):resc;
      } break;



      case 6 : {
        const Tfloat vmin = (Tfloat)cimg::type<T>::min(), vmax = (Tfloat)cimg::type<T>::max();
        CImg<uintT> off(cimg::max(sx,sy,sz,sc));
        CImg<floatT> foff(off._width);
        CImg<T> resx, resy, resz, resc;

        if (sx!=_width) {
          if (_width==1) get_resize(sx,_height,_depth,_spectrum,1).move_to(resx);
          else {
            if (_width>sx) get_resize(sx,_height,_depth,_spectrum,2).move_to(resx);
            else {
              const float fx = (!boundary_conditions && sx>_width)?(sx>1?(_width-1.0f)/(sx-1):0):(float)_width/sx;
              resx.assign(sx,_height,_depth,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int x = 0; x<(int)((resx)._width); ++x) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fx;
                *(poff++) = (unsigned int)curr - (unsigned int)old;
              }



              for (int c = 0; c<(int)((resx)._spectrum); ++c) for (int z = 0; z<(int)((resx)._depth); ++z) for (int y = 0; y<(int)((resx)._height); ++y) {
                const T *const ptrs0 = data(0,y,z,c), *ptrs = ptrs0, *const ptrsmin = ptrs0 + 1,
                  *const ptrsmax = ptrs0 + (_width-2);
                T *ptrd = resx.data(0,y,z,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int x = 0; x<(int)((resx)._width); ++x) {
                  const float
                    t = *(pfoff++),
                    w0 = _cimg_lanczos(t+2),
                    w1 = _cimg_lanczos(t+1),
                    w2 = _cimg_lanczos(t),
                    w3 = _cimg_lanczos(t-1),
                    w4 = _cimg_lanczos(t-2);
                  const Tfloat
                    val2 = (Tfloat)*ptrs,
                    val1 = ptrs>=ptrsmin?(Tfloat)*(ptrs-1):val2,
                    val0 = ptrs>ptrsmin?(Tfloat)*(ptrs-2):val1,
                    val3 = ptrs<=ptrsmax?(Tfloat)*(ptrs+1):val2,
                    val4 = ptrs<ptrsmax?(Tfloat)*(ptrs+2):val3,
                    val = (val0*w0 + val1*w1 + val2*w2 + val3*w3 + val4*w4)/(w1 + w2 + w3 + w4);
                  *(ptrd++) = (T)(val<vmin?vmin:val>vmax?vmax:val);
                  ptrs+=*(poff++);
                }
              }
            }
          }
        } else resx.assign(*this,true);

        if (sy!=_height) {
          if (_height==1) resx.get_resize(sx,sy,_depth,_spectrum,1).move_to(resy);
          else {
            if (_height>sy) resx.get_resize(sx,sy,_depth,_spectrum,2).move_to(resy);
            else {
              const float fy = (!boundary_conditions && sy>_height)?(sy>1?(_height-1.0f)/(sy-1):0):(float)_height/sy;
              resy.assign(sx,sy,_depth,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int y = 0; y<(int)((resy)._height); ++y) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fy;
                *(poff++) = sx*((unsigned int)curr-(unsigned int)old);
              }



              for (int c = 0; c<(int)((resy)._spectrum); ++c) for (int z = 0; z<(int)((resy)._depth); ++z) for (int x = 0; x<(int)((resy)._width); ++x) {
                const T *const ptrs0 = resx.data(x,0,z,c), *ptrs = ptrs0, *const ptrsmin = ptrs0 + sx,
                  *const ptrsmax = ptrs0 + (_height-2)*sx;
                T *ptrd = resy.data(x,0,z,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int y = 0; y<(int)((resy)._height); ++y) {
                  const float
                    t = *(pfoff++),
                    w0 = _cimg_lanczos(t+2),
                    w1 = _cimg_lanczos(t+1),
                    w2 = _cimg_lanczos(t),
                    w3 = _cimg_lanczos(t-1),
                    w4 = _cimg_lanczos(t-2);
                  const Tfloat
                    val2 = (Tfloat)*ptrs,
                    val1 = ptrs>=ptrsmin?(Tfloat)*(ptrs-sx):val2,
                    val0 = ptrs>ptrsmin?(Tfloat)*(ptrs-2*sx):val1,
                    val3 = ptrs<=ptrsmax?(Tfloat)*(ptrs+sx):val2,
                    val4 = ptrs<ptrsmax?(Tfloat)*(ptrs+2*sx):val3,
                    val = (val0*w0 + val1*w1 + val2*w2 + val3*w3 + val4*w4)/(w1 + w2 + w3 + w4);
                  *ptrd = (T)(val<vmin?vmin:val>vmax?vmax:val);
                  ptrd+=sx;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resx.assign();
        } else resy.assign(resx,true);

        if (sz!=_depth) {
          if (_depth==1) resy.get_resize(sx,sy,sz,_spectrum,1).move_to(resz);
          else {
            if (_depth>sz) resy.get_resize(sx,sy,sz,_spectrum,2).move_to(resz);
            else {
              const float fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth-1.0f)/(sz-1):0):(float)_depth/sz;
              const unsigned int sxy = sx*sy;
              resz.assign(sx,sy,sz,_spectrum);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int z = 0; z<(int)((resz)._depth); ++z) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fz;
                *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
              }



              for (int c = 0; c<(int)((resz)._spectrum); ++c) for (int y = 0; y<(int)((resz)._height); ++y) for (int x = 0; x<(int)((resz)._width); ++x) {
                const T *const ptrs0 = resy.data(x,y,0,c), *ptrs = ptrs0, *const ptrsmin = ptrs0 + sxy,
                  *const ptrsmax = ptrs0 + (_depth-2)*sxy;
                T *ptrd = resz.data(x,y,0,c);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int z = 0; z<(int)((resz)._depth); ++z) {
                  const float
                    t = *(pfoff++),
                    w0 = _cimg_lanczos(t+2),
                    w1 = _cimg_lanczos(t+1),
                    w2 = _cimg_lanczos(t),
                    w3 = _cimg_lanczos(t-1),
                    w4 = _cimg_lanczos(t-2);
                  const Tfloat
                    val2 = (Tfloat)*ptrs,
                    val1 = ptrs>=ptrsmin?(Tfloat)*(ptrs-sxy):val2,
                    val0 = ptrs>ptrsmin?(Tfloat)*(ptrs-2*sxy):val1,
                    val3 = ptrs<=ptrsmax?(Tfloat)*(ptrs+sxy):val2,
                    val4 = ptrs<ptrsmax?(Tfloat)*(ptrs+2*sxy):val3,
                    val = (val0*w0 + val1*w1 + val2*w2 + val3*w3 + val4*w4)/(w1 + w2 + w3 + w4);
                  *ptrd = (T)(val<vmin?vmin:val>vmax?vmax:val);
                  ptrd+=sxy;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resy.assign();
        } else resz.assign(resy,true);

        if (sc!=_spectrum) {
          if (_spectrum==1) resz.get_resize(sx,sy,sz,sc,1).move_to(resc);
          else {
            if (_spectrum>sc) resz.get_resize(sx,sy,sz,sc,2).move_to(resc);
            else {
              const float fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum-1.0f)/(sc-1):0):
                (float)_spectrum/sc;
              const unsigned int sxyz = sx*sy*sz;
              resc.assign(sx,sy,sz,sc);
              float curr = 0, old = 0;
              unsigned int *poff = off._data;
              float *pfoff = foff._data;
              for (int c = 0; c<(int)((resc)._spectrum); ++c) {
                *(pfoff++) = curr - (unsigned int)curr;
                old = curr;
                curr+=fc;
                *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
              }



              for (int z = 0; z<(int)((resc)._depth); ++z) for (int y = 0; y<(int)((resc)._height); ++y) for (int x = 0; x<(int)((resc)._width); ++x) {
                const T *const ptrs0 = resz.data(x,y,z,0), *ptrs = ptrs0, *const ptrsmin = ptrs0 + sxyz,
                  *const ptrsmax = ptrs + (_spectrum-2)*sxyz;
                T *ptrd = resc.data(x,y,z,0);
                const unsigned int *poff = off._data;
                const float *pfoff = foff._data;
                for (int c = 0; c<(int)((resc)._spectrum); ++c) {
                  const float
                    t = *(pfoff++),
                    w0 = _cimg_lanczos(t+2),
                    w1 = _cimg_lanczos(t+1),
                    w2 = _cimg_lanczos(t),
                    w3 = _cimg_lanczos(t-1),
                    w4 = _cimg_lanczos(t-2);
                  const Tfloat
                    val2 = (Tfloat)*ptrs,
                    val1 = ptrs>=ptrsmin?(Tfloat)*(ptrs-sxyz):val2,
                    val0 = ptrs>ptrsmin?(Tfloat)*(ptrs-2*sxyz):val1,
                    val3 = ptrs<=ptrsmax?(Tfloat)*(ptrs+sxyz):val2,
                    val4 = ptrs<ptrsmax?(Tfloat)*(ptrs+2*sxyz):val3,
                    val = (val0*w0 + val1*w1 + val2*w2 + val3*w3 + val4*w4)/(w1 + w2 + w3 + w4);
                  *ptrd = (T)(val<vmin?vmin:val>vmax?vmax:val);
                  ptrd+=sxyz;
                  ptrs+=*(poff++);
                }
              }
            }
          }
          resz.assign();
        } else resc.assign(resz,true);

        return resc._is_shared?(resz._is_shared?(resy._is_shared?(resx._is_shared?(+(*this)):resx):resy):resz):resc;
      } break;



      default :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "resize(): Invalid specified interpolation %d "
                                    "(should be { -1=raw | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | "
                                    "5=cubic | 6=lanczos }).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    interpolation_type);
      }
      return res;
    }
# 21926 "../src/CImg.h"
    template<typename t>
    CImg<T>& resize(const CImg<t>& src,
                    const int interpolation_type=1, const unsigned int boundary_conditions=0,
                    const float centering_x = 0, const float centering_y = 0,
                    const float centering_z = 0, const float centering_c = 0) {
      return resize(src._width,src._height,src._depth,src._spectrum,interpolation_type,boundary_conditions,
                    centering_x,centering_y,centering_z,centering_c);
    }


    template<typename t>
    CImg<T> get_resize(const CImg<t>& src,
                       const int interpolation_type=1, const unsigned int boundary_conditions=0,
                       const float centering_x = 0, const float centering_y = 0,
                       const float centering_z = 0, const float centering_c = 0) const {
      return get_resize(src._width,src._height,src._depth,src._spectrum,interpolation_type,boundary_conditions,
                        centering_x,centering_y,centering_z,centering_c);
    }
# 21955 "../src/CImg.h"
    CImg<T>& resize(const CImgDisplay& disp,
                    const int interpolation_type=1, const unsigned int boundary_conditions=0,
                    const float centering_x = 0, const float centering_y = 0,
                    const float centering_z = 0, const float centering_c = 0) {
      return resize(disp.width(),disp.height(),_depth,_spectrum,interpolation_type,boundary_conditions,
                    centering_x,centering_y,centering_z,centering_c);
    }


    CImg<T> get_resize(const CImgDisplay& disp,
                       const int interpolation_type=1, const unsigned int boundary_conditions=0,
                       const float centering_x = 0, const float centering_y = 0,
                       const float centering_z = 0, const float centering_c = 0) const {
      return get_resize(disp.width(),disp.height(),_depth,_spectrum,interpolation_type,boundary_conditions,
                        centering_x,centering_y,centering_z,centering_c);
    }


    CImg<T>& resize_halfXY() {
      return get_resize_halfXY().move_to(*this);
    }


    CImg<T> get_resize_halfXY() const {
      if (is_empty()) return *this;
      const Tfloat mask[9] = { 0.07842776544f, 0.1231940459f, 0.07842776544f,
                              0.1231940459f, 0.1935127547f, 0.1231940459f,
                              0.07842776544f, 0.1231940459f, 0.07842776544f };
      T I[9] = { 0 };
      CImg<T> res(_width/2,_height/2,_depth,_spectrum);
      T *ptrd = res._data;
      for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (T)(*this)(0,y,z,c)), (I[6] = I[7] = (T)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,z,c)), (I[5] = (T)(*this)(_n1x,y,z,c)), (I[8] = (T)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x)
        if (x%2 && y%2) *(ptrd++) = (T)
                          (I[0]*mask[0] + I[1]*mask[1] + I[2]*mask[2] +
                           I[3]*mask[3] + I[4]*mask[4] + I[5]*mask[5] +
                           I[6]*mask[6] + I[7]*mask[7] + I[8]*mask[8]);
      return res;
    }






    CImg<T>& resize_doubleXY() {
      return get_resize_doubleXY().move_to(*this);
    }


    CImg<T> get_resize_doubleXY() const {
# 22029 "../src/CImg.h"
      if (is_empty()) return *this;
      CImg<T> res(_width<<1,_height<<1,_depth,_spectrum);
      T I[9]; T& Ipp = I[0]; T& Icp = I[1]; T& Inp = I[2]; T& Ipc = I[3]; T& Icc = I[4]; T& Inc = I[5]; T& Ipn = I[6]; T& Icn = I[7]; T& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
      for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
        T
          *ptrd1 = res.data(0,0,z,c),
          *ptrd2 = ptrd1 + res._width;
        for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y, ptrd1+=(res)._width, ptrd2+=(res)._width) for (int x = 0, _p1x = 0, _n1x = (int)( (I[1] = (T)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (T)(*this)(0,y,z,c)), (I[7] = (T)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,z,c)), (I[5] = (T)(*this)(_n1x,y,z,c)), (I[8] = (T)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[1] = I[2], I[3] = I[4], I[4] = I[5], I[7] = I[8], _p1x = x++, ++_n1x) {
          if (Icp!=Icn && Ipc!=Inc) {
            *(ptrd1++) = Ipc==Icp?Ipc:Icc;
            *(ptrd1++) = Icp==Inc?Inc:Icc;
            *(ptrd2++) = Ipc==Icn?Ipc:Icc;
            *(ptrd2++) = Icn==Inc?Inc:Icc;
          } else { *(ptrd1++) = Icc; *(ptrd1++) = Icc; *(ptrd2++) = Icc; *(ptrd2++) = Icc; }
        }
      }
      return res;
    }






    CImg<T>& resize_tripleXY() {
      return get_resize_tripleXY().move_to(*this);
    }


    CImg<T> get_resize_tripleXY() const {
# 22083 "../src/CImg.h"
      if (is_empty()) return *this;
      CImg<T> res(3*_width,3*_height,_depth,_spectrum);
      T I[9]; T& Ipp = I[0]; T& Icp = I[1]; T& Inp = I[2]; T& Ipc = I[3]; T& Icc = I[4]; T& Inc = I[5]; T& Ipn = I[6]; T& Icn = I[7]; T& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
      for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
        T
          *ptrd1 = res.data(0,0,z,c),
          *ptrd2 = ptrd1 + res._width,
          *ptrd3 = ptrd2 + res._width;
        for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y, ptrd1+=2*(res)._width, ptrd2+=2*(res)._width, ptrd3+=2*(res)._width) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (T)(*this)(0,y,z,c)), (I[6] = I[7] = (T)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,z,c)), (I[5] = (T)(*this)(_n1x,y,z,c)), (I[8] = (T)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
          if (Icp != Icn && Ipc != Inc) {
            *(ptrd1++) = Ipc==Icp?Ipc:Icc;
            *(ptrd1++) = (Ipc==Icp && Icc!=Inp) || (Icp==Inc && Icc!=Ipp)?Icp:Icc;
            *(ptrd1++) = Icp==Inc?Inc:Icc;
            *(ptrd2++) = (Ipc==Icp && Icc!=Ipn) || (Ipc==Icn && Icc!=Ipp)?Ipc:Icc;
            *(ptrd2++) = Icc;
            *(ptrd2++) = (Icp==Inc && Icc!=Inn) || (Icn==Inc && Icc!=Inp)?Inc:Icc;
            *(ptrd3++) = Ipc==Icn?Ipc:Icc;
            *(ptrd3++) = (Ipc==Icn && Icc!=Inn) || (Icn==Inc && Icc!=Ipn)?Icn:Icc;
            *(ptrd3++) = Icn==Inc?Inc:Icc;
          } else {
            *(ptrd1++) = Icc; *(ptrd1++) = Icc; *(ptrd1++) = Icc;
            *(ptrd2++) = Icc; *(ptrd2++) = Icc; *(ptrd2++) = Icc;
            *(ptrd3++) = Icc; *(ptrd3++) = Icc; *(ptrd3++) = Icc;
          }
        }
      }
      return res;
    }





    CImg<T>& mirror(const char axis) {
      if (is_empty()) return *this;
      T *pf, *pb, *buf = 0;
      switch (cimg::uncase(axis)) {
      case 'x' : {
        pf = _data; pb = data(_width-1);
        const unsigned int width2 = _width/2;
        for (unsigned int yzv = 0; yzv<_height*_depth*_spectrum; ++yzv) {
          for (unsigned int x = 0; x<width2; ++x) { const T val = *pf; *(pf++) = *pb; *(pb--) = val; }
          pf+=_width - width2;
          pb+=_width + width2;
        }
      } break;
      case 'y' : {
        buf = new T[_width];
        pf = _data; pb = data(0,_height-1);
        const unsigned int height2 = _height/2;
        for (unsigned int zv = 0; zv<_depth*_spectrum; ++zv) {
          for (unsigned int y = 0; y<height2; ++y) {
            std::memcpy(buf,pf,_width*sizeof(T));
            std::memcpy(pf,pb,_width*sizeof(T));
            std::memcpy(pb,buf,_width*sizeof(T));
            pf+=_width;
            pb-=_width;
          }
          pf+=(unsigned long)_width*(_height - height2);
          pb+=(unsigned long)_width*(_height + height2);
        }
      } break;
      case 'z' : {
        buf = new T[(unsigned long)_width*_height];
        pf = _data; pb = data(0,0,_depth-1);
        const unsigned int depth2 = _depth/2;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) {
          for (unsigned int z = 0; z<depth2; ++z) {
            std::memcpy(buf,pf,_width*_height*sizeof(T));
            std::memcpy(pf,pb,_width*_height*sizeof(T));
            std::memcpy(pb,buf,_width*_height*sizeof(T));
            pf+=(unsigned long)_width*_height;
            pb-=(unsigned long)_width*_height;
          }
          pf+=(unsigned long)_width*_height*(_depth - depth2);
          pb+=(unsigned long)_width*_height*(_depth + depth2);
        }
      } break;
      case 'c' : {
        buf = new T[(unsigned long)_width*_height*_depth];
        pf = _data; pb = data(0,0,0,_spectrum-1);
        const unsigned int _spectrum2 = _spectrum/2;
        for (unsigned int v = 0; v<_spectrum2; ++v) {
          std::memcpy(buf,pf,_width*_height*_depth*sizeof(T));
          std::memcpy(pf,pb,_width*_height*_depth*sizeof(T));
          std::memcpy(pb,buf,_width*_height*_depth*sizeof(T));
          pf+=(unsigned long)_width*_height*_depth;
          pb-=(unsigned long)_width*_height*_depth;
        }
      } break;
      default :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "mirror(): Invalid specified axis '%c'.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    axis);
      }
      delete[] buf;
      return *this;
    }


    CImg<T> get_mirror(const char axis) const {
      return (+*this).mirror(axis);
    }






    CImg<T>& mirror(const char *const axes) {
      for (const char *s = axes; *s; s++) mirror(*s);
      return *this;
    }


    CImg<T> get_mirror(const char *const axes) const {
      return (+*this).mirror(axes);
    }
# 22216 "../src/CImg.h"
    CImg<T>& shift(const int delta_x, const int delta_y=0, const int delta_z=0, const int delta_c=0,
                   const int boundary_conditions=0) {
      if (is_empty()) return *this;
      if (delta_x)
        switch (boundary_conditions) {
        case 0 :
          if (cimg::abs(delta_x)>=width()) return fill(0);
          if (delta_x<0) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            std::memmove(data(0,y,z,c),data(-delta_x,y,z,c),(_width+delta_x)*sizeof(T));
            std::memset(data(_width+delta_x,y,z,c),0,-delta_x*sizeof(T));
          } else for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            std::memmove(data(delta_x,y,z,c),data(0,y,z,c),(_width-delta_x)*sizeof(T));
            std::memset(data(0,y,z,c),0,delta_x*sizeof(T));
          }
          break;
        case 1 :
          if (delta_x<0) {
            const int ndelta_x = (-delta_x>=width())?width()-1:-delta_x;
            if (!ndelta_x) return *this;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
              std::memmove(data(0,y,z,c),data(ndelta_x,y,z,c),(_width-ndelta_x)*sizeof(T));
              T *ptrd = data(_width-1,y,z,c);
              const T val = *ptrd;
              for (int l = 0; l<ndelta_x-1; ++l) *(--ptrd) = val;
            }
          } else {
            const int ndelta_x = (delta_x>=width())?width()-1:delta_x;
            if (!ndelta_x) return *this;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
              std::memmove(data(ndelta_x,y,z,c),data(0,y,z,c),(_width-ndelta_x)*sizeof(T));
              T *ptrd = data(0,y,z,c);
              const T val = *ptrd;
              for (int l = 0; l<ndelta_x-1; ++l) *(++ptrd) = val;
            }
          }
          break;
        default : {
          const int ml = cimg::mod(-delta_x,width()), ndelta_x = (ml<=width()/2)?ml:(ml-width());
          if (!ndelta_x) return *this;
          T *const buf = new T[cimg::abs(ndelta_x)];
          if (ndelta_x>0) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            std::memcpy(buf,data(0,y,z,c),ndelta_x*sizeof(T));
            std::memmove(data(0,y,z,c),data(ndelta_x,y,z,c),(_width-ndelta_x)*sizeof(T));
            std::memcpy(data(_width-ndelta_x,y,z,c),buf,ndelta_x*sizeof(T));
          } else for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
            std::memcpy(buf,data(_width+ndelta_x,y,z,c),-ndelta_x*sizeof(T));
            std::memmove(data(-ndelta_x,y,z,c),data(0,y,z,c),(_width+ndelta_x)*sizeof(T));
            std::memcpy(data(0,y,z,c),buf,-ndelta_x*sizeof(T));
          }
          delete[] buf;
        }
        }

      if (delta_y)
        switch (boundary_conditions) {
        case 0 :
          if (cimg::abs(delta_y)>=height()) return fill(0);
          if (delta_y<0) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
            std::memmove(data(0,0,z,c),data(0,-delta_y,z,c),_width*(_height+delta_y)*sizeof(T));
            std::memset(data(0,_height+delta_y,z,c),0,-delta_y*_width*sizeof(T));
          } else for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
            std::memmove(data(0,delta_y,z,c),data(0,0,z,c),_width*(_height-delta_y)*sizeof(T));
            std::memset(data(0,0,z,c),0,delta_y*_width*sizeof(T));
          }
          break;
        case 1 :
          if (delta_y<0) {
            const int ndelta_y = (-delta_y>=height())?height()-1:-delta_y;
            if (!ndelta_y) return *this;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
              std::memmove(data(0,0,z,c),data(0,ndelta_y,z,c),_width*(_height-ndelta_y)*sizeof(T));
              T *ptrd = data(0,_height-ndelta_y,z,c), *ptrs = data(0,_height-1,z,c);
              for (int l = 0; l<ndelta_y-1; ++l) { std::memcpy(ptrd,ptrs,_width*sizeof(T)); ptrd+=_width; }
            }
          } else {
            const int ndelta_y = (delta_y>=height())?height()-1:delta_y;
            if (!ndelta_y) return *this;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
              std::memmove(data(0,ndelta_y,z,c),data(0,0,z,c),_width*(_height-ndelta_y)*sizeof(T));
              T *ptrd = data(0,1,z,c), *ptrs = data(0,0,z,c);
              for (int l = 0; l<ndelta_y-1; ++l) { std::memcpy(ptrd,ptrs,_width*sizeof(T)); ptrd+=_width; }
            }
          }
          break;
        default : {
          const int ml = cimg::mod(-delta_y,height()), ndelta_y = (ml<=height()/2)?ml:(ml-height());
          if (!ndelta_y) return *this;
          T *const buf = new T[(unsigned long)_width*cimg::abs(ndelta_y)];
          if (ndelta_y>0) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
            std::memcpy(buf,data(0,0,z,c),_width*ndelta_y*sizeof(T));
            std::memmove(data(0,0,z,c),data(0,ndelta_y,z,c),_width*(_height-ndelta_y)*sizeof(T));
            std::memcpy(data(0,_height-ndelta_y,z,c),buf,_width*ndelta_y*sizeof(T));
          } else for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
            std::memcpy(buf,data(0,_height+ndelta_y,z,c),-ndelta_y*_width*sizeof(T));
            std::memmove(data(0,-ndelta_y,z,c),data(0,0,z,c),_width*(_height+ndelta_y)*sizeof(T));
            std::memcpy(data(0,0,z,c),buf,-ndelta_y*_width*sizeof(T));
          }
          delete[] buf;
        }
        }

      if (delta_z)
        switch (boundary_conditions) {
        case 0 :
          if (cimg::abs(delta_z)>=depth()) return fill(0);
          if (delta_z<0) for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            std::memmove(data(0,0,0,c),data(0,0,-delta_z,c),_width*_height*(_depth+delta_z)*sizeof(T));
            std::memset(data(0,0,_depth+delta_z,c),0,_width*_height*(-delta_z)*sizeof(T));
          } else for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            std::memmove(data(0,0,delta_z,c),data(0,0,0,c),_width*_height*(_depth-delta_z)*sizeof(T));
            std::memset(data(0,0,0,c),0,delta_z*_width*_height*sizeof(T));
          }
          break;
        case 1 :
          if (delta_z<0) {
            const int ndelta_z = (-delta_z>=depth())?depth()-1:-delta_z;
            if (!ndelta_z) return *this;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              std::memmove(data(0,0,0,c),data(0,0,ndelta_z,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
              T *ptrd = data(0,0,_depth-ndelta_z,c), *ptrs = data(0,0,_depth-1,c);
              for (int l = 0; l<ndelta_z-1; ++l) {
                std::memcpy(ptrd,ptrs,_width*_height*sizeof(T)); ptrd+=(unsigned long)_width*_height;
              }
            }
          } else {
            const int ndelta_z = (delta_z>=depth())?depth()-1:delta_z;
            if (!ndelta_z) return *this;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              std::memmove(data(0,0,ndelta_z,c),data(0,0,0,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
              T *ptrd = data(0,0,1,c), *ptrs = data(0,0,0,c);
              for (int l = 0; l<ndelta_z-1; ++l) {
                std::memcpy(ptrd,ptrs,_width*_height*sizeof(T)); ptrd+=(unsigned long)_width*_height;
              }
            }
          }
          break;
        default : {
          const int ml = cimg::mod(-delta_z,depth()), ndelta_z = (ml<=depth()/2)?ml:(ml-depth());
          if (!ndelta_z) return *this;
          T *const buf = new T[(unsigned long)_width*_height*cimg::abs(ndelta_z)];
          if (ndelta_z>0) for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            std::memcpy(buf,data(0,0,0,c),_width*_height*ndelta_z*sizeof(T));
            std::memmove(data(0,0,0,c),data(0,0,ndelta_z,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
            std::memcpy(data(0,0,_depth-ndelta_z,c),buf,_width*_height*ndelta_z*sizeof(T));
          } else for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            std::memcpy(buf,data(0,0,_depth+ndelta_z,c),-ndelta_z*_width*_height*sizeof(T));
            std::memmove(data(0,0,-ndelta_z,c),data(0,0,0,c),_width*_height*(_depth+ndelta_z)*sizeof(T));
            std::memcpy(data(0,0,0,c),buf,-ndelta_z*_width*_height*sizeof(T));
          }
          delete[] buf;
        }
        }

      if (delta_c)
        switch (boundary_conditions) {
        case 0 :
          if (cimg::abs(delta_c)>=spectrum()) return fill(0);
          if (delta_c<0) {
            std::memmove(_data,data(0,0,0,-delta_c),_width*_height*_depth*(_spectrum+delta_c)*sizeof(T));
            std::memset(data(0,0,0,_spectrum+delta_c),0,_width*_height*_depth*(-delta_c)*sizeof(T));
          } else {
            std::memmove(data(0,0,0,delta_c),_data,_width*_height*_depth*(_spectrum-delta_c)*sizeof(T));
            std::memset(_data,0,delta_c*_width*_height*_depth*sizeof(T));
          }
          break;
        case 1 :
          if (delta_c<0) {
            const int ndelta_c = (-delta_c>=spectrum())?spectrum()-1:-delta_c;
            if (!ndelta_c) return *this;
            std::memmove(_data,data(0,0,0,ndelta_c),_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
            T *ptrd = data(0,0,0,_spectrum-ndelta_c), *ptrs = data(0,0,0,_spectrum-1);
            for (int l = 0; l<ndelta_c-1; ++l) {
              std::memcpy(ptrd,ptrs,_width*_height*_depth*sizeof(T)); ptrd+=(unsigned long)_width*_height*_depth;
            }
          } else {
            const int ndelta_c = (delta_c>=spectrum())?spectrum()-1:delta_c;
            if (!ndelta_c) return *this;
            std::memmove(data(0,0,0,ndelta_c),_data,_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
            T *ptrd = data(0,0,0,1);
            for (int l = 0; l<ndelta_c-1; ++l) {
              std::memcpy(ptrd,_data,_width*_height*_depth*sizeof(T)); ptrd+=(unsigned long)_width*_height*_depth;
            }
          }
          break;
        default : {
          const int ml = cimg::mod(-delta_c,spectrum()), ndelta_c = (ml<=spectrum()/2)?ml:(ml-spectrum());
          if (!ndelta_c) return *this;
          T *const buf = new T[(unsigned long)_width*_height*_depth*cimg::abs(ndelta_c)];
          if (ndelta_c>0) {
            std::memcpy(buf,_data,_width*_height*_depth*ndelta_c*sizeof(T));
            std::memmove(_data,data(0,0,0,ndelta_c),_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
            std::memcpy(data(0,0,0,_spectrum-ndelta_c),buf,_width*_height*_depth*ndelta_c*sizeof(T));
          } else {
            std::memcpy(buf,data(0,0,0,_spectrum+ndelta_c),-ndelta_c*_width*_height*_depth*sizeof(T));
            std::memmove(data(0,0,0,-ndelta_c),_data,_width*_height*_depth*(_spectrum+ndelta_c)*sizeof(T));
            std::memcpy(_data,buf,-ndelta_c*_width*_height*_depth*sizeof(T));
          }
          delete[] buf;
        }
        }
      return *this;
    }


    CImg<T> get_shift(const int delta_x, const int delta_y=0, const int delta_z=0, const int delta_c=0,
                          const int boundary_conditions=0) const {
      return (+*this).shift(delta_x,delta_y,delta_z,delta_c,boundary_conditions);
    }






    CImg<T>& permute_axes(const char *const order) {
      return get_permute_axes(order).move_to(*this);
    }


    CImg<T> get_permute_axes(const char *const order) const {
      const T foo = (T)0;
      return _get_permute_axes(order,foo);
    }

    template<typename t>
    CImg<t> _get_permute_axes(const char *const permut, const t&) const {
      if (is_empty() || !permut) return CImg<t>(*this,false);
      CImg<t> res;
      const T* ptrs = _data;
      if (!cimg::strncasecmp(permut,"xyzc",4)) return +*this;
      if (!cimg::strncasecmp(permut,"xycz",4)) {
        res.assign(_width,_height,_spectrum,_depth);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(x,y,c,z,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"xzyc",4)) {
        res.assign(_width,_depth,_height,_spectrum);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(x,z,y,c,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"xzcy",4)) {
        res.assign(_width,_depth,_spectrum,_height);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(x,z,c,y,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"xcyz",4)) {
        res.assign(_width,_spectrum,_height,_depth);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(x,c,y,z,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"xczy",4)) {
        res.assign(_width,_spectrum,_depth,_height);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(x,c,z,y,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"yxzc",4)) {
        res.assign(_height,_width,_depth,_spectrum);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(y,x,z,c,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"yxcz",4)) {
        res.assign(_height,_width,_spectrum,_depth);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(y,x,c,z,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"yzxc",4)) {
        res.assign(_height,_depth,_width,_spectrum);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(y,z,x,c,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"yzcx",4)) {
        res.assign(_height,_depth,_spectrum,_width);
        switch (_width) {
        case 1 : {
          t *ptr_r = res.data(0,0,0,0);
          for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
            *(ptr_r++) = (t)*(ptrs++);
          }
        } break;
        case 2 : {
          t *ptr_r = res.data(0,0,0,0), *ptr_g = res.data(0,0,0,1);
          for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
            *(ptr_r++) = (t)*(ptrs++); *(ptr_g++) = (t)*(ptrs++);
          }
        } break;
        case 3 : {
          t *ptr_r = res.data(0,0,0,0), *ptr_g = res.data(0,0,0,1), *ptr_b = res.data(0,0,0,2);
          for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
            *(ptr_r++) = (t)*(ptrs++); *(ptr_g++) = (t)*(ptrs++); *(ptr_b++) = (t)*(ptrs++);
          }
        } break;
        case 4 : {
          t *ptr_r = res.data(0,0,0,0), *ptr_g = res.data(0,0,0,1), *ptr_b = res.data(0,0,0,2), *ptr_a = res.data(0,0,0,3);
          for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
            *(ptr_r++) = (t)*(ptrs++); *(ptr_g++) = (t)*(ptrs++); *(ptr_b++) = (t)*(ptrs++); *(ptr_a++) = (t)*(ptrs++);
          }
        } break;
        default : {
          const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(y,z,c,x,wh,whd) = *(ptrs++);
          return res;
        }
        }
      }
      if (!cimg::strncasecmp(permut,"ycxz",4)) {
        res.assign(_height,_spectrum,_width,_depth);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(y,c,x,z,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"yczx",4)) {
        res.assign(_height,_spectrum,_depth,_width);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(y,c,z,x,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"zxyc",4)) {
        res.assign(_depth,_width,_height,_spectrum);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(z,x,y,c,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"zxcy",4)) {
        res.assign(_depth,_width,_spectrum,_height);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(z,x,c,y,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"zyxc",4)) {
        res.assign(_depth,_height,_width,_spectrum);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(z,y,x,c,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"zycx",4)) {
        res.assign(_depth,_height,_spectrum,_width);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(z,y,c,x,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"zcxy",4)) {
        res.assign(_depth,_spectrum,_width,_height);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(z,c,x,y,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"zcyx",4)) {
        res.assign(_depth,_spectrum,_height,_width);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(z,c,y,x,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"cxyz",4)) {
        res.assign(_spectrum,_width,_height,_depth);
        switch (_spectrum) {
        case 1 : {
          const T *ptr_r = data(0,0,0,0);
          t *ptrd = res._data;
          for (unsigned long siz = (unsigned long)_width*_height*_depth; siz; --siz) *(ptrd++) = (t)*(ptr_r++);
        } break;
        case 2 : {
          const T *ptr_r = data(0,0,0,0), *ptr_g = data(0,0,0,1);
          t *ptrd = res._data;
          for (unsigned long siz = (unsigned long)_width*_height*_depth; siz; --siz) {
            *(ptrd++) = (t)*(ptr_r++); *(ptrd++) = (t)*(ptr_g++);
          }
        } break;
        case 3 : {
          const T *ptr_r = data(0,0,0,0), *ptr_g = data(0,0,0,1), *ptr_b = data(0,0,0,2);
          t *ptrd = res._data;
          for (unsigned long siz = (unsigned long)_width*_height*_depth; siz; --siz) {
            *(ptrd++) = (t)*(ptr_r++); *(ptrd++) = (t)*(ptr_g++); *(ptrd++) = (t)*(ptr_b++);
          }
        } break;
        case 4 : {
          const T *ptr_r = data(0,0,0,0), *ptr_g = data(0,0,0,1), *ptr_b = data(0,0,0,2), *ptr_a = data(0,0,0,3);
          t *ptrd = res._data;
          for (unsigned long siz = (unsigned long)_width*_height*_depth; siz; --siz) {
            *(ptrd++) = (t)*(ptr_r++); *(ptrd++) = (t)*(ptr_g++); *(ptrd++) = (t)*(ptr_b++); *(ptrd++) = (t)*(ptr_a++);
          }
        } break;
        default : {
          const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(c,x,y,z,wh,whd) = (t)*(ptrs++);
        }
        }
      }
      if (!cimg::strncasecmp(permut,"cxzy",4)) {
        res.assign(_spectrum,_width,_depth,_height);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(c,x,z,y,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"cyxz",4)) {
        res.assign(_spectrum,_height,_width,_depth);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(c,y,x,z,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"cyzx",4)) {
        res.assign(_spectrum,_height,_depth,_width);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(c,y,z,x,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"czxy",4)) {
        res.assign(_spectrum,_depth,_width,_height);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(c,z,x,y,wh,whd) = (t)*(ptrs++);
      }
      if (!cimg::strncasecmp(permut,"czyx",4)) {
        res.assign(_spectrum,_depth,_height,_width);
        const unsigned long wh = (unsigned long)res._width*res._height, whd = wh*res._depth;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) res(c,z,y,x,wh,whd) = (t)*(ptrs++);
      }
      if (!res)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "permute_axes(): Invalid specified permutation '%s'.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    permut);
      return res;
    }





    CImg<T>& unroll(const char axis) {
      const unsigned int siz = size();
      if (siz) switch (axis) {
      case 'x' : _width = siz; _height = _depth = _spectrum = 1; break;
      case 'y' : _height = siz; _width = _depth = _spectrum = 1; break;
      case 'z' : _depth = siz; _width = _height = _spectrum = 1; break;
      default : _spectrum = siz; _width = _height = _depth = 1;
      }
      return *this;
    }


    CImg<T> get_unroll(const char axis) const {
      return (+*this).unroll(axis);
    }
# 22655 "../src/CImg.h"
    CImg<T>& rotate(const float angle, const unsigned int interpolation=1, const unsigned int boundary=0) {
      const float nangle = cimg::mod(angle,360.0f);
      if (nangle==0.0f) return *this;
      return get_rotate(angle,interpolation,boundary).move_to(*this);
    }


    CImg<T> get_rotate(const float angle, const unsigned int interpolation=1, const unsigned int boundary=0) const {
      if (is_empty()) return *this;
      CImg<T> res;
      const float nangle = cimg::mod(angle,360.0f);
      if (boundary!=1 && cimg::mod(nangle,90.0f)==0) {
        const int wm1 = width() - 1, hm1 = height() - 1;
        const int iangle = (int)nangle/90;
        switch (iangle) {
        case 1 : {
          res.assign(_height,_width,_depth,_spectrum);
          T *ptrd = res._data;
          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(y,hm1-x,z,c);
        } break;
        case 2 : {
          res.assign(_width,_height,_depth,_spectrum);
          T *ptrd = res._data;
          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(wm1-x,hm1-y,z,c);
        } break;
        case 3 : {
          res.assign(_height,_width,_depth,_spectrum);
          T *ptrd = res._data;
          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(wm1-y,x,z,c);
        } break;
        default :
          return *this;
        }
      } else {
        const Tfloat vmin = (Tfloat)cimg::type<T>::min(), vmax = (Tfloat)cimg::type<T>::max();
        const float
          rad = (float)(nangle*cimg::PI/180.0),
          ca = (float)std::cos(rad),
          sa = (float)std::sin(rad),
          ux = cimg::abs(_width*ca), uy = cimg::abs(_width*sa),
          vx = cimg::abs(_height*sa), vy = cimg::abs(_height*ca),
          w2 = 0.5f*_width, h2 = 0.5f*_height,
          dw2 = 0.5f*(ux+vx), dh2 = 0.5f*(uy+vy);
        res.assign((int)(ux+vx),(int)(uy+vy),_depth,_spectrum);
        switch (boundary) {
        case 0 : {
          switch (interpolation) {
          case 2 : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
              const Tfloat val = cubic_atXY(w2 + (x-dw2)*ca + (y-dh2)*sa,h2 - (x-dw2)*sa + (y-dh2)*ca,z,c,0);
              res(x,y,z,c) = (T)(val<vmin?vmin:val>vmax?vmax:val);
            }
          } break;
          case 1 : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
              res(x,y,z,c) = (T)linear_atXY(w2 + (x-dw2)*ca + (y-dh2)*sa,h2 - (x-dw2)*sa + (y-dh2)*ca,z,c,0);
          } break;
          default : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
              res(x,y,z,c) = atXY((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),(int)(h2 - (x-dw2)*sa + (y-dh2)*ca),z,c,0);
          }
          }
        } break;
        case 1 : {
          switch (interpolation) {
          case 2 : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
              const Tfloat val = _cubic_atXY(w2 + (x-dw2)*ca + (y-dh2)*sa,h2 - (x-dw2)*sa + (y-dh2)*ca,z,c);
              res(x,y,z,c) = (T)(val<vmin?vmin:val>vmax?vmax:val);
            }
          } break;
          case 1 : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
              res(x,y,z,c) = (T)_linear_atXY(w2 + (x-dw2)*ca + (y-dh2)*sa,h2 - (x-dw2)*sa + (y-dh2)*ca,z,c);
          } break;
          default : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
              res(x,y,z,c) = _atXY((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),(int)(h2 - (x-dw2)*sa + (y-dh2)*ca),z,c);
          }
          }
        } break;
        case 2 : {
          switch (interpolation) {
          case 2 : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
              const Tfloat val = _cubic_atXY(cimg::mod(w2 + (x-dw2)*ca + (y-dh2)*sa,(float)width()),
                                             cimg::mod(h2 - (x-dw2)*sa + (y-dh2)*ca,(float)height()),z,c);
              res(x,y,z,c) = (T)(val<vmin?vmin:val>vmax?vmax:val);
            }
          } break;
          case 1 : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
              res(x,y,z,c) = (T)_linear_atXY(cimg::mod(w2 + (x-dw2)*ca + (y-dh2)*sa,(float)width()),
                                             cimg::mod(h2 - (x-dw2)*sa + (y-dh2)*ca,(float)height()),z,c);
          } break;
          default : {



            for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
              res(x,y,z,c) = (*this)(cimg::mod((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),width()),
                                     cimg::mod((int)(h2 - (x-dw2)*sa + (y-dh2)*ca),height()),z,c);
          }
          }
        } break;
        default :
          throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "rotate(): Invalid specified border conditions %d "
                                      "(should be { 0=dirichlet | 1=neumann | 2=periodic }).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      boundary);
        }
      }
      return res;
    }
# 22804 "../src/CImg.h"
    CImg<T>& rotate(const float angle, const float cx, const float cy, const float zoom,
                    const unsigned int interpolation=1, const unsigned int boundary=3) {
      return get_rotate(angle,cx,cy,zoom,interpolation,boundary).move_to(*this);
    }


    CImg<T> get_rotate(const float angle, const float cx, const float cy, const float zoom,
                       const unsigned int interpolation=1, const unsigned int boundary=3) const {
      if (interpolation>2)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "rotate(): Invalid specified interpolation type %d "
                                    "(should be { 0=none | 1=linear | 2=cubic }).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    interpolation);
      if (is_empty()) return *this;
      CImg<T> res(_width,_height,_depth,_spectrum);
      const Tfloat vmin = (Tfloat)cimg::type<T>::min(), vmax = (Tfloat)cimg::type<T>::max();
      const float
        rad = (float)((angle*cimg::PI)/180.0),
        ca = (float)std::cos(rad)/zoom,
        sa = (float)std::sin(rad)/zoom;
      switch (boundary) {
      case 0 : {
        switch (interpolation) {
        case 2 : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
            const Tfloat val = cubic_atXY(cx + (x-cx)*ca + (y-cy)*sa,cy - (x-cx)*sa + (y-cy)*ca,z,c,0);
            res(x,y,z,c) = (T)(val<vmin?vmin:val>vmax?vmax:val);
          }
        } break;
        case 1 : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
            res(x,y,z,c) = (T)linear_atXY(cx + (x-cx)*ca + (y-cy)*sa,cy - (x-cx)*sa + (y-cy)*ca,z,c,0);
        } break;
        default : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
            res(x,y,z,c) = atXY((int)(cx + (x-cx)*ca + (y-cy)*sa),(int)(cy - (x-cx)*sa + (y-cy)*ca),z,c,0);
        }
        }
      } break;
      case 1 : {
        switch (interpolation) {
        case 2 : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
            const Tfloat val = _cubic_atXY(cx + (x-cx)*ca + (y-cy)*sa,cy - (x-cx)*sa + (y-cy)*ca,z,c);
            res(x,y,z,c) = (T)(val<vmin?vmin:val>vmax?vmax:val);
          }
        } break;
        case 1 : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
            res(x,y,z,c) = (T)_linear_atXY(cx + (x-cx)*ca + (y-cy)*sa,cy - (x-cx)*sa + (y-cy)*ca,z,c);
        } break;
        default : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
            res(x,y,z,c) = _atXY((int)(cx + (x-cx)*ca + (y-cy)*sa),(int)(cy - (x-cx)*sa + (y-cy)*ca),z,c);
        }
        }
      } break;
      case 2 : {
        switch (interpolation) {
        case 2 : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
            const Tfloat val = _cubic_atXY(cimg::mod(cx + (x-cx)*ca + (y-cy)*sa,(float)width()),
                                           cimg::mod(cy - (x-cx)*sa + (y-cy)*ca,(float)height()),z,c);
            res(x,y,z,c) = (T)(val<vmin?vmin:val>vmax?vmax:val);
          }
        } break;
        case 1 : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
            res(x,y,z,c) = (T)_linear_atXY(cimg::mod(cx + (x-cx)*ca + (y-cy)*sa,(float)width()),
                                           cimg::mod(cy - (x-cx)*sa + (y-cy)*ca,(float)height()),z,c);
        } break;
        default : {



          for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x)
            res(x,y,z,c) = (*this)(cimg::mod((int)(cx + (x-cx)*ca + (y-cy)*sa),width()),
                                    cimg::mod((int)(cy - (x-cx)*sa + (y-cy)*ca),height()),z,c);
        }
        }
      } break;
      default :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "rotate(): Invalid specified border conditions %d "
                                    "(should be { 0=dirichlet | 1=neumann | 2=periodic }).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    boundary);
      }
      return res;
    }
# 22927 "../src/CImg.h"
    template<typename t>
    CImg<T>& warp(const CImg<t>& warp, const bool is_relative=false,
                  const unsigned int interpolation=1, const unsigned int boundary_conditions=0) {
      return get_warp(warp,is_relative,interpolation,boundary_conditions).move_to(*this);
    }


    template<typename t>
    CImg<T> get_warp(const CImg<t>& warp, const bool is_relative=false,
                     const unsigned int interpolation=1, const unsigned int boundary_conditions=0) const {
      if (is_empty() || !warp) return *this;
      if (is_relative && !is_sameXYZ(warp))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "warp(): Instance and specified relative warping field (%u,%u,%u,%u,%p) "
                                    "have different XYZ dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    warp._width,warp._height,warp._depth,warp._spectrum,warp._data);

      CImg<T> res(warp._width,warp._height,warp._depth,_spectrum);

      if (warp._spectrum==1) {
        if (is_relative) {
          if (interpolation==2) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atX(cimg::mod(x - (float)*(ptrs0++),(float)_width),y,z,c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atX(x - (float)*(ptrs0++),y,z,c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)cubic_atX(x - (float)*(ptrs0++),y,z,c,0);
              }
          } else if (interpolation==1) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atX(cimg::mod(x - (float)*(ptrs0++),(float)_width),y,z,c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atX(x - (float)*(ptrs0++),y,z,c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)linear_atX(x - (float)*(ptrs0++),y,z,c,0);
              }
          } else {
            if (boundary_conditions==2)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(cimg::mod(x - (int)*(ptrs0++),(int)_width),y,z,c);
              }
            else if (boundary_conditions==1)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = _atX(x - (int)*(ptrs0++),y,z,c);
              }
            else
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = atX(x - (int)*(ptrs0++),y,z,c,0);
              }
          }
        } else {
          if (interpolation==2) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atX(cimg::mod((float)*(ptrs0++),(float)_width),0,0,c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atX((float)*(ptrs0++),0,0,c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)cubic_atX((float)*(ptrs0++),0,0,c,0);
              }
          } else if (interpolation==1) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atX(cimg::mod((float)*(ptrs0++),(float)_width),0,0,c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atX((float)*(ptrs0++),0,0,c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)linear_atX((float)*(ptrs0++),0,0,c,0);
              }
          } else {
            if (boundary_conditions==2)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(cimg::mod((int)*(ptrs0++),(int)_width),0,0,c);
              }
            else if (boundary_conditions==1)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = _atX((int)*(ptrs0++),0,0,c);
              }
            else
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = atX((int)*(ptrs0++),0,0,c,0);
              }
          }
        }

      } else if (warp._spectrum==2) {
        if (is_relative) {
          if (interpolation==2) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atXY(cimg::mod(x - (float)*(ptrs0++),(float)_width),
                                                            cimg::mod(y - (float)*(ptrs1++),(float)_height),z,c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atXY(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)cubic_atXY(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c,0);
              }
          } else if (interpolation==1) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atXY(cimg::mod(x - (float)*(ptrs0++),(float)_width),
                                                             cimg::mod(y - (float)*(ptrs1++),(float)_height),z,c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atXY(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)linear_atXY(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c,0);
              }
          } else {
            if (boundary_conditions==2)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(cimg::mod(x - (int)*(ptrs0++),(int)_width),
                                                     cimg::mod(y - (int)*(ptrs1++),(int)_height),z,c);
              }
            else if (boundary_conditions==1)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = _atXY(x - (int)*(ptrs0++),y - (int)*(ptrs1++),z,c);
              }
            else
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = atXY(x - (int)*(ptrs0++),y - (int)*(ptrs1++),z,c,0);
              }
          }
        } else {
          if (interpolation==2) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atXY(cimg::mod((float)*(ptrs0++),(float)_width),
                                                            cimg::mod((float)*(ptrs1++),(float)_height),0,c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atXY((float)*(ptrs0++),(float)*(ptrs1++),0,c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)cubic_atXY((float)*(ptrs0++),(float)*(ptrs1++),0,c,0);
              }
          } else if (interpolation==1) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atXY(cimg::mod((float)*(ptrs0++),(float)_width),
                                                             cimg::mod((float)*(ptrs1++),(float)_height),0,c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atXY((float)*(ptrs0++),(float)*(ptrs1++),0,c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)linear_atXY((float)*(ptrs0++),(float)*(ptrs1++),0,c,0);
              }
          } else {
            if (boundary_conditions==2)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(cimg::mod((int)*(ptrs0++),(int)_width),
                                                     cimg::mod((int)*(ptrs1++),(int)_height),0,c);
              }
            else if (boundary_conditions==1)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = _atXY((int)*(ptrs0++),(int)*(ptrs1++),0,c);
              }
            else
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1); T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = atXY((int)*(ptrs0++),(int)*(ptrs1++),0,c,0);
              }
          }
        }

      } else if (warp._spectrum==3) {
        if (is_relative) {
          if (interpolation==2) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atXYZ(cimg::mod(x - (float)*(ptrs0++),(float)_width),
                                                             cimg::mod(y - (float)*(ptrs1++),(float)_height),
                                                             cimg::mod(z - (float)*(ptrs2++),(float)_depth),c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x)
                  *(ptrd++) = (T)_cubic_atXYZ(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x)
                  *(ptrd++) = (T)cubic_atXYZ(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c,0);
              }
          } else if (interpolation==1) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atXYZ(cimg::mod(x - (float)*(ptrs0++),(float)_width),
                                                              cimg::mod(y - (float)*(ptrs1++),(float)_height),
                                                              cimg::mod(z - (float)*(ptrs2++),(float)_depth),c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x)
                  *(ptrd++) = (T)_linear_atXYZ(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x)
                  *(ptrd++) = (T)linear_atXYZ(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c,0);
              }
          } else {
            if (boundary_conditions==2)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(cimg::mod(x - (int)*(ptrs0++),(int)_width),
                                                     cimg::mod(y - (int)*(ptrs1++),(int)_height),
                                                     cimg::mod(z - (int)*(ptrs2++),(int)_depth),c);
              }
            else if (boundary_conditions==1)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = _atXYZ(x - (int)*(ptrs0++),y - (int)*(ptrs1++),z - (int)*(ptrs2++),c);
              }
            else
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = atXYZ(x - (int)*(ptrs0++),y - (int)*(ptrs1++),z - (int)*(ptrs2++),c,0);
              }
          }
        } else {
          if (interpolation==2) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atXYZ(cimg::mod((float)*(ptrs0++),(float)_width),
                                                             cimg::mod((float)*(ptrs1++),(float)_height),
                                                             cimg::mod((float)*(ptrs2++),(float)_depth),c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_cubic_atXYZ((float)*(ptrs0++),(float)*(ptrs1++),(float)*(ptrs2++),c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)cubic_atXYZ((float)*(ptrs0++),(float)*(ptrs1++),(float)*(ptrs2++),c,0);
              }
          } else if (interpolation==1) {
            if (boundary_conditions==2)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atXYZ(cimg::mod((float)*(ptrs0++),(float)_width),
                                                              cimg::mod((float)*(ptrs1++),(float)_height),
                                                              cimg::mod((float)*(ptrs2++),(float)_depth),c);
              }
            else if (boundary_conditions==1)



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)_linear_atXYZ((float)*(ptrs0++),(float)*(ptrs1++),(float)*(ptrs2++),c);
              }
            else



              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (T)linear_atXYZ((float)*(ptrs0++),(float)*(ptrs1++),(float)*(ptrs2++),c,0);
              }
          } else {
            if (boundary_conditions==2)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = (*this)(cimg::mod((int)*(ptrs0++),(int)_width),
                                                     cimg::mod((int)*(ptrs1++),(int)_height),
                                                     cimg::mod((int)*(ptrs2++),(int)_depth),c);
              }
            else if (boundary_conditions==1)
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = _atXYZ((int)*(ptrs0++),(int)*(ptrs1++),(int)*(ptrs2++),c);
              }
            else
              for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) {
                const t *ptrs0 = warp.data(0,y,z,0), *ptrs1 = warp.data(0,y,z,1), *ptrs2 = warp.data(0,y,z,2);
                T *ptrd = res.data(0,y,z,c);
                for (int x = 0; x<(int)((res)._width); ++x) *(ptrd++) = atXYZ((int)*(ptrs0++),(int)*(ptrs1++),(int)*(ptrs2++),c,0);
              }
          }
        }
      }
      return res;
    }







    CImg<T> get_projections2d(const unsigned int x0, const unsigned int y0, const unsigned int z0) const {
      if (is_empty() || _depth<2) return +*this;
      const unsigned int
        _x0 = (x0>=_width)?_width - 1:x0,
        _y0 = (y0>=_height)?_height - 1:y0,
        _z0 = (z0>=_depth)?_depth - 1:z0;
      const CImg<T>
        img_xy = get_crop(0,0,_z0,0,_width-1,_height-1,_z0,_spectrum-1),
        img_zy = get_crop(_x0,0,0,0,_x0,_height-1,_depth-1,_spectrum-1).permute_axes("xzyc").
        resize(_depth,_height,1,-100,-1),
        img_xz = get_crop(0,_y0,0,0,_width-1,_y0,_depth-1,_spectrum-1).resize(_width,_depth,1,-100,-1);
      return CImg<T>(_width + _depth,_height + _depth,1,_spectrum,cimg::min(img_xy.min(),img_zy.min(),img_xz.min())).
        draw_image(0,0,img_xy).draw_image(img_xy._width,0,img_zy).
        draw_image(0,img_xy._height,img_xz);
    }


    CImg<T>& projections2d(const unsigned int x0, const unsigned int y0, const unsigned int z0) {
      if (_depth<2) return *this;
      return get_projections2d(x0,y0,z0).move_to(*this);
    }
# 23447 "../src/CImg.h"
    CImg<T>& crop(const int x0, const int y0, const int z0, const int c0,
                  const int x1, const int y1, const int z1, const int c1,
                  const bool boundary_conditions=false) {
      return get_crop(x0,y0,z0,c0,x1,y1,z1,c1,boundary_conditions).move_to(*this);
    }


    CImg<T> get_crop(const int x0, const int y0, const int z0, const int c0,
                     const int x1, const int y1, const int z1, const int c1,
                     const bool boundary_conditions=false) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "crop(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      const int
        nx0 = x0<x1?x0:x1, nx1 = x0^x1^nx0,
        ny0 = y0<y1?y0:y1, ny1 = y0^y1^ny0,
        nz0 = z0<z1?z0:z1, nz1 = z0^z1^nz0,
        nc0 = c0<c1?c0:c1, nc1 = c0^c1^nc0;
      CImg<T> res(1U + nx1 - nx0,1U + ny1 - ny0,1U + nz1 - nz0,1U + nc1 - nc0);
      if (nx0<0 || nx1>=width() || ny0<0 || ny1>=height() || nz0<0 || nz1>=depth() || nc0<0 || nc1>=spectrum()) {
        if (boundary_conditions) for (int c = 0; c<(int)((res)._spectrum); ++c) for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) res(x,y,z,c) = _atXYZC(nx0+x,ny0+y,nz0+z,nc0+c);
        else res.fill(0).draw_image(-nx0,-ny0,-nz0,-nc0,*this);
      } else res.draw_image(-nx0,-ny0,-nz0,-nc0,*this);
      return res;
    }


    CImg<T>& crop(const int x0, const int y0, const int z0,
                  const int x1, const int y1, const int z1,
                  const bool boundary_conditions=false) {
      return crop(x0,y0,z0,0,x1,y1,z1,_spectrum-1,boundary_conditions);
    }


    CImg<T> get_crop(const int x0, const int y0, const int z0,
                     const int x1, const int y1, const int z1,
                     const bool boundary_conditions=false) const {
      return get_crop(x0,y0,z0,0,x1,y1,z1,_spectrum-1,boundary_conditions);
    }


    CImg<T>& crop(const int x0, const int y0,
                  const int x1, const int y1,
                  const bool boundary_conditions=false) {
      return crop(x0,y0,0,0,x1,y1,_depth - 1,_spectrum - 1,boundary_conditions);
    }


    CImg<T> get_crop(const int x0, const int y0,
                     const int x1, const int y1,
                     const bool boundary_conditions=false) const {
      return get_crop(x0,y0,0,0,x1,y1,_depth - 1,_spectrum - 1,boundary_conditions);
    }


    CImg<T>& crop(const int x0, const int x1, const bool boundary_conditions=false) {
      return crop(x0,0,0,0,x1,_height-1,_depth-1,_spectrum-1,boundary_conditions);
    }


    CImg<T> get_crop(const int x0, const int x1, const bool boundary_conditions=false) const {
      return get_crop(x0,0,0,0,x1,_height-1,_depth-1,_spectrum-1,boundary_conditions);
    }


    CImg<T>& autocrop(const T value, const char *const axes="czyx") {
      if (is_empty()) return *this;
      for (const char *s = axes; *s; ++s) {
        const char axis = cimg::uncase(*s);
        const CImg<intT> coords = _autocrop(value,axis);
        if (coords[0]==-1 && coords[1]==-1) return assign();
        else switch (axis) {
        case 'x' : {
          const int x0 = coords[0], x1 = coords[1];
          if (x0>=0 && x1>=0) crop(x0,x1);
        } break;
        case 'y' : {
          const int y0 = coords[0], y1 = coords[1];
          if (y0>=0 && y1>=0) crop(0,y0,_width-1,y1);
        } break;
        case 'z' : {
          const int z0 = coords[0], z1 = coords[1];
          if (z0>=0 && z1>=0) crop(0,0,z0,_width-1,_height-1,z1);
        } break;
        default : {
          const int c0 = coords[0], c1 = coords[1];
          if (c0>=0 && c1>=0) crop(0,0,0,c0,_width-1,_height-1,_depth-1,c1);
        }
        }
      }
      return *this;
    }


    CImg<T> get_autocrop(const T value, const char *const axes="czyx") const {
      return (+*this).autocrop(value,axes);
    }






    CImg<T>& autocrop(const T *const color=0, const char *const axes="zyx") {
      if (is_empty()) return *this;
      if (!color) {
        const CImg<T> col1 = get_vector_at(0,0,0);
        const unsigned int w = _width, h = _height, d = _depth, s = _spectrum;
        autocrop(col1,axes);
        if (_width==w && _height==h && _depth==d && _spectrum==s) {
          const CImg<T> col2 = get_vector_at(w-1,h-1,d-1);
          autocrop(col2,axes);
        }
        return *this;
      }
      for (const char *s = axes; *s; ++s) {
        const char axis = cimg::uncase(*s);
        switch (axis) {
        case 'x' : {
          int x0 = width(), x1 = -1;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'x');
            const int nx0 = coords[0], nx1 = coords[1];
            if (nx0>=0 && nx1>=0) { x0 = cimg::min(x0,nx0); x1 = cimg::max(x1,nx1); }
          }
          if (x0==width() && x1==-1) return assign(); else crop(x0,x1);
        } break;
        case 'y' : {
          int y0 = height(), y1 = -1;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'y');
            const int ny0 = coords[0], ny1 = coords[1];
            if (ny0>=0 && ny1>=0) { y0 = cimg::min(y0,ny0); y1 = cimg::max(y1,ny1); }
          }
          if (y0==height() && y1==-1) return assign(); else crop(0,y0,_width-1,y1);
        } break;
        default : {
          int z0 = depth(), z1 = -1;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'z');
            const int nz0 = coords[0], nz1 = coords[1];
            if (nz0>=0 && nz1>=0) { z0 = cimg::min(z0,nz0); z1 = cimg::max(z1,nz1); }
          }
          if (z0==depth() && z1==-1) return assign(); else crop(0,0,z0,_width-1,_height-1,z1);
        }
        }
      }
      return *this;
    }


    CImg<T> get_autocrop(const T *const color=0, const char *const axes="zyx") const {
      return (+*this).autocrop(color,axes);
    }


    template<typename t> CImg<T>& autocrop(const CImg<t>& color, const char *const axes="zyx") {
      return get_autocrop(color,axes).move_to(*this);
    }


    template<typename t> CImg<T> get_autocrop(const CImg<t>& color, const char *const axes="zyx") const {
      return get_autocrop(color._data,axes);
    }

    CImg<intT> _autocrop(const T value, const char axis) const {
      CImg<intT> res;
      switch (cimg::uncase(axis)) {
      case 'x' : {
        int x0 = -1, x1 = -1;
        for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y)
          if ((*this)(x,y,z,c)!=value) { x0 = x; x = width(); y = height(); z = depth(); c = spectrum(); }
        if (x0>=0) {
          for (int x = width()-1; x>=0; --x) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y)
            if ((*this)(x,y,z,c)!=value) { x1 = x; x = 0; y = height(); z = depth(); c = spectrum(); }
        }
        res = CImg<intT>::vector(x0,x1);
      } break;
      case 'y' : {
        int y0 = -1, y1 = -1;
        for (int y = 0; y<(int)((*this)._height); ++y) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x)
          if ((*this)(x,y,z,c)!=value) { y0 = y; x = width(); y = height(); z = depth(); c = spectrum(); }
        if (y0>=0) {
          for (int y = height()-1; y>=0; --y) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x)
            if ((*this)(x,y,z,c)!=value) { y1 = y; x = width(); y = 0; z = depth(); c = spectrum(); }
        }
        res = CImg<intT>::vector(y0,y1);
      } break;
      case 'z' : {
        int z0 = -1, z1 = -1;
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x)
          if ((*this)(x,y,z,c)!=value) { z0 = z; x = width(); y = height(); z = depth(); c = spectrum(); }
        if (z0>=0) {
          for (int z = depth()-1; z>=0; --z) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x)
            if ((*this)(x,y,z,c)!=value) { z1 = z; x = width(); y = height(); z = 0; c = spectrum(); }
        }
        res = CImg<intT>::vector(z0,z1);
      } break;
      default : {
        int c0 = -1, c1 = -1;
        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x)
          if ((*this)(x,y,z,c)!=value) { c0 = c; x = width(); y = height(); z = depth(); c = spectrum(); }
        if (c0>=0) {
          for (int c = spectrum()-1; c>=0; --c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x)
            if ((*this)(x,y,z,c)!=value) { c1 = c; x = width(); y = height(); z = depth(); c = 0; }
        }
        res = CImg<intT>::vector(c0,c1);
      }
      }
      return res;
    }





    CImg<T> get_column(const int x0) const {
      return get_columns(x0,x0);
    }


    CImg<T>& column(const int x0) {
      return columns(x0,x0);
    }






    CImg<T>& columns(const int x0, const int x1) {
      return get_columns(x0,x1).move_to(*this);
    }


    CImg<T> get_columns(const int x0, const int x1) const {
      return get_crop(x0,0,0,0,x1,height()-1,depth()-1,spectrum()-1);
    }


    CImg<T> get_row(const int y0) const {
      return get_rows(y0,y0);
    }





    CImg<T>& row(const int y0) {
      return rows(y0,y0);
    }






    CImg<T> get_rows(const int y0, const int y1) const {
      return get_crop(0,y0,0,0,width()-1,y1,depth()-1,spectrum()-1);
    }


    CImg<T>& rows(const int y0, const int y1) {
      return get_rows(y0,y1).move_to(*this);
    }





    CImg<T> get_slice(const int z0) const {
      return get_slices(z0,z0);
    }


    CImg<T>& slice(const int z0) {
      return slices(z0,z0);
    }






    CImg<T> get_slices(const int z0, const int z1) const {
      return get_crop(0,0,z0,0,width()-1,height()-1,z1,spectrum()-1);
    }


    CImg<T>& slices(const int z0, const int z1) {
      return get_slices(z0,z1).move_to(*this);
    }





    CImg<T> get_channel(const int c0) const {
      return get_channels(c0,c0);
    }


    CImg<T>& channel(const int c0) {
      return channels(c0,c0);
    }






    CImg<T> get_channels(const int c0, const int c1) const {
      return get_crop(0,0,0,c0,width()-1,height()-1,depth()-1,c1);
    }


    CImg<T>& channels(const int c0, const int c1) {
      return get_channels(c0,c1).move_to(*this);
    }


    CImg<floatT> get_streamline(const float x, const float y, const float z,
                                const float L=256, const float dl=0.1f,
                                const unsigned int interpolation_type=2, const bool is_backward_tracking=false,
                                const bool is_oriented_only=false) const {
      if (_spectrum!=2 && _spectrum!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "streamline(): Instance is not a 2d or 3d vector field.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (_spectrum==2) {
        if (is_oriented_only) {
          typename CImg<T>::_functor4d_streamline2d_oriented func(*this);
          return streamline(func,x,y,z,L,dl,interpolation_type,is_backward_tracking,true,
                            0,0,0,_width-1.0f,_height-1.0f,0.0f);
        } else {
          typename CImg<T>::_functor4d_streamline2d_directed func(*this);
          return streamline(func,x,y,z,L,dl,interpolation_type,is_backward_tracking,false,
                            0,0,0,_width-1.0f,_height-1.0f,0.0f);
        }
      }
      if (is_oriented_only) {
        typename CImg<T>::_functor4d_streamline3d_oriented func(*this);
        return streamline(func,x,y,z,L,dl,interpolation_type,is_backward_tracking,true,
                          0,0,0,_width-1.0f,_height-1.0f,_depth-1.0f);
      }
      typename CImg<T>::_functor4d_streamline3d_directed func(*this);
      return streamline(func,x,y,z,L,dl,interpolation_type,is_backward_tracking,false,
                        0,0,0,_width-1.0f,_height-1.0f,_depth-1.0f);
    }
# 23817 "../src/CImg.h"
    template<typename tfunc>
    static CImg<floatT> streamline(const tfunc& func,
                                   const float x, const float y, const float z,
                                   const float L=256, const float dl=0.1f,
                                   const unsigned int interpolation_type=2, const bool is_backward_tracking=false,
                                   const bool is_oriented_only=false,
                                   const float x0=0, const float y0=0, const float z0=0,
                                   const float x1=0, const float y1=0, const float z1=0) {
      if (dl<=0)
        throw CImgArgumentException("CImg<%s>::streamline(): Invalid specified integration length %g "
                                    "(should be >0).",
                                    pixel_type(),
                                    dl);

      const bool is_bounded = (x0!=x1 || y0!=y1 || z0!=z1);
      if (L<=0 || (is_bounded && (x<x0 || x>x1 || y<y0 || y>y1 || z<z0 || z>z1))) return CImg<floatT>();
      const unsigned int size_L = (unsigned int)cimg::round(L/dl+1);
      CImg<floatT> coordinates(size_L,3);
      const float dl2 = dl/2;
      float
        *ptr_x = coordinates.data(0,0),
        *ptr_y = coordinates.data(0,1),
        *ptr_z = coordinates.data(0,2),
        pu = (float)(dl*func(x,y,z,0)),
        pv = (float)(dl*func(x,y,z,1)),
        pw = (float)(dl*func(x,y,z,2)),
        X = x, Y = y, Z = z;

      switch (interpolation_type) {
      case 0 : {
        for (int l = 0; l<(int)((coordinates)._width); ++l) {
          *(ptr_x++) = X; *(ptr_y++) = Y; *(ptr_z++) = Z;
          const int
            xi = (int)(X>0?X+0.5f:X-0.5f),
            yi = (int)(Y>0?Y+0.5f:Y-0.5f),
            zi = (int)(Z>0?Z+0.5f:Z-0.5f);
          float
            u = (float)(dl*func((float)xi,(float)yi,(float)zi,0)),
            v = (float)(dl*func((float)xi,(float)yi,(float)zi,1)),
            w = (float)(dl*func((float)xi,(float)yi,(float)zi,2));
          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
          if (is_bounded && (X<x0 || X>x1 || Y<y0 || Y>y1 || Z<z0 || Z>z1)) break;
        }
      } break;
      case 1 : {
        for (int l = 0; l<(int)((coordinates)._width); ++l) {
          *(ptr_x++) = X; *(ptr_y++) = Y; *(ptr_z++) = Z;
          float
            u = (float)(dl*func(X,Y,Z,0)),
            v = (float)(dl*func(X,Y,Z,1)),
            w = (float)(dl*func(X,Y,Z,2));
          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
          if (is_bounded && (X<x0 || X>x1 || Y<y0 || Y>y1 || Z<z0 || Z>z1)) break;
        }
      } break;
      case 2 : {
        for (int l = 0; l<(int)((coordinates)._width); ++l) {
          *(ptr_x++) = X; *(ptr_y++) = Y; *(ptr_z++) = Z;
          float
            u0 = (float)(dl2*func(X,Y,Z,0)),
            v0 = (float)(dl2*func(X,Y,Z,1)),
            w0 = (float)(dl2*func(X,Y,Z,2));
          if (is_oriented_only && u0*pu + v0*pv + w0*pw<0) { u0 = -u0; v0 = -v0; w0 = -w0; }
          float
            u = (float)(dl*func(X+u0,Y+v0,Z+w0,0)),
            v = (float)(dl*func(X+u0,Y+v0,Z+w0,1)),
            w = (float)(dl*func(X+u0,Y+v0,Z+w0,2));
          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
          if (is_bounded && (X<x0 || X>x1 || Y<y0 || Y>y1 || Z<z0 || Z>z1)) break;
        }
      } break;
      default : {
        for (int x = 0; x<(int)((coordinates)._width); ++x) {
          *(ptr_x++) = X; *(ptr_y++) = Y; *(ptr_z++) = Z;
          float
            u0 = (float)(dl2*func(X,Y,Z,0)),
            v0 = (float)(dl2*func(X,Y,Z,1)),
            w0 = (float)(dl2*func(X,Y,Z,2));
          if (is_oriented_only && u0*pu + v0*pv + w0*pw<0) { u0 = -u0; v0 = -v0; w0 = -w0; }
          float
            u1 = (float)(dl2*func(X+u0,Y+v0,Z+w0,0)),
            v1 = (float)(dl2*func(X+u0,Y+v0,Z+w0,1)),
            w1 = (float)(dl2*func(X+u0,Y+v0,Z+w0,2));
          if (is_oriented_only && u1*pu + v1*pv + w1*pw<0) { u1 = -u1; v1 = -v1; w1 = -w1; }
          float
            u2 = (float)(dl2*func(X+u1,Y+v1,Z+w1,0)),
            v2 = (float)(dl2*func(X+u1,Y+v1,Z+w1,1)),
            w2 = (float)(dl2*func(X+u1,Y+v1,Z+w1,2));
          if (is_oriented_only && u2*pu + v2*pv + w2*pw<0) { u2 = -u2; v2 = -v2; w2 = -w2; }
          float
            u3 = (float)(dl2*func(X+u2,Y+v2,Z+w2,0)),
            v3 = (float)(dl2*func(X+u2,Y+v2,Z+w2,1)),
            w3 = (float)(dl2*func(X+u2,Y+v2,Z+w2,2));
          if (is_oriented_only && u2*pu + v2*pv + w2*pw<0) { u3 = -u3; v3 = -v3; w3 = -w3; }
          const float
            u = (u0 + u3)/3 + (u1 + u2)/1.5f,
            v = (v0 + v3)/3 + (v1 + v2)/1.5f,
            w = (w0 + w3)/3 + (w1 + w2)/1.5f;
          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
          if (is_bounded && (X<x0 || X>x1 || Y<y0 || Y>y1 || Z<z0 || Z>z1)) break;
        }
      }
      }
      if (ptr_x!=coordinates.data(0,1)) coordinates.resize((int)(ptr_x-coordinates.data()),3,1,1,0);
      return coordinates;
    }


    static CImg<floatT> streamline(const char *const expression,
                                   const float x, const float y, const float z,
                                   const float L=256, const float dl=0.1f,
                                   const unsigned int interpolation_type=2, const bool is_backward_tracking=true,
                                   const bool is_oriented_only=false,
                                   const float x0=0, const float y0=0, const float z0=0,
                                   const float x1=0, const float y1=0, const float z1=0) {
      _functor4d_streamline_expr func(expression);
      return streamline(func,x,y,z,L,dl,interpolation_type,is_backward_tracking,is_oriented_only,x0,y0,z0,x1,y1,z1);
    }

    struct _functor4d_streamline2d_directed {
      const CImg<T>& ref;
      _functor4d_streamline2d_directed(const CImg<T>& pref):ref(pref) {}
      float operator()(const float x, const float y, const float z, const unsigned int c) const {
        return c<2?(float)ref._linear_atXY(x,y,(int)z,c):0;
      }
    };

    struct _functor4d_streamline3d_directed {
      const CImg<T>& ref;
      _functor4d_streamline3d_directed(const CImg<T>& pref):ref(pref) {}
      float operator()(const float x, const float y, const float z, const unsigned int c) const {
        return (float)ref._linear_atXYZ(x,y,z,c);
      }
    };

    struct _functor4d_streamline2d_oriented {
      const CImg<T>& ref;
      CImg<floatT> *pI;
      _functor4d_streamline2d_oriented(const CImg<T>& pref):ref(pref),pI(0) { pI = new CImg<floatT>(2,2,1,2); }
      ~_functor4d_streamline2d_oriented() { delete pI; }
      float operator()(const float x, const float y, const float z, const unsigned int c) const {

        int
          xi = (int)x - (x>=0?0:1), nxi = xi + 1,
          yi = (int)y - (y>=0?0:1), nyi = yi + 1,
          zi = (int)z;
        const float
          dx = x - xi,
          dy = y - yi;
        if (c==0) {
          CImg<floatT>& I = *pI;
          if (xi<0) xi = 0; if (nxi<0) nxi = 0;
          if (xi>=ref.width()) xi = ref.width()-1; if (nxi>=ref.width()) nxi = ref.width()-1;
          if (yi<0) yi = 0; if (nyi<0) nyi = 0;
          if (yi>=ref.height()) yi = ref.height()-1; if (nyi>=ref.height()) nyi = ref.height()-1;
          I(0,0,0) = (float)ref(xi,yi,zi,0); I(0,0,1) = (float)ref(xi,yi,zi,1);
          I(1,0,0) = (float)ref(nxi,yi,zi,0); I(1,0,1) = (float)ref(nxi,yi,zi,1);
          I(1,1,0) = (float)ref(nxi,nyi,zi,0); I(1,1,1) = (float)ref(nxi,nyi,zi,1);
          I(0,1,0) = (float)ref(xi,nyi,zi,0); I(0,1,1) = (float)ref(xi,nyi,zi,1);
          if (I(1,0,0)*I(0,0,0)+I(1,0,1)*I(0,0,1)<0) { I(1,0,0) = -I(1,0,0); I(1,0,1) = -I(1,0,1); }; if (I(1,1,0)*I(0,0,0)+I(1,1,1)*I(0,0,1)<0) { I(1,1,0) = -I(1,1,0); I(1,1,1) = -I(1,1,1); }; if (I(0,1,0)*I(0,0,0)+I(0,1,1)*I(0,0,1)<0) { I(0,1,0) = -I(0,1,0); I(0,1,1) = -I(0,1,1); };
        }
        return c<2?(float)pI->_linear_atXY(dx,dy,0,c):0;
      }
    };

    struct _functor4d_streamline3d_oriented {
      const CImg<T>& ref;
      CImg<floatT> *pI;
      _functor4d_streamline3d_oriented(const CImg<T>& pref):ref(pref),pI(0) { pI = new CImg<floatT>(2,2,2,3); }
      ~_functor4d_streamline3d_oriented() { delete pI; }
      float operator()(const float x, const float y, const float z, const unsigned int c) const {


        int
          xi = (int)x - (x>=0?0:1), nxi = xi + 1,
          yi = (int)y - (y>=0?0:1), nyi = yi + 1,
          zi = (int)z - (z>=0?0:1), nzi = zi + 1;
        const float
          dx = x - xi,
          dy = y - yi,
          dz = z - zi;
        if (c==0) {
          CImg<floatT>& I = *pI;
          if (xi<0) xi = 0; if (nxi<0) nxi = 0;
          if (xi>=ref.width()) xi = ref.width()-1; if (nxi>=ref.width()) nxi = ref.width()-1;
          if (yi<0) yi = 0; if (nyi<0) nyi = 0;
          if (yi>=ref.height()) yi = ref.height()-1; if (nyi>=ref.height()) nyi = ref.height()-1;
          if (zi<0) zi = 0; if (nzi<0) nzi = 0;
          if (zi>=ref.depth()) zi = ref.depth()-1; if (nzi>=ref.depth()) nzi = ref.depth()-1;
          I(0,0,0,0) = (float)ref(xi,yi,zi,0); I(0,0,0,1) = (float)ref(xi,yi,zi,1);
          I(0,0,0,2) = (float)ref(xi,yi,zi,2); I(1,0,0,0) = (float)ref(nxi,yi,zi,0);
          I(1,0,0,1) = (float)ref(nxi,yi,zi,1); I(1,0,0,2) = (float)ref(nxi,yi,zi,2);
          I(1,1,0,0) = (float)ref(nxi,nyi,zi,0); I(1,1,0,1) = (float)ref(nxi,nyi,zi,1);
          I(1,1,0,2) = (float)ref(nxi,nyi,zi,2); I(0,1,0,0) = (float)ref(xi,nyi,zi,0);
          I(0,1,0,1) = (float)ref(xi,nyi,zi,1); I(0,1,0,2) = (float)ref(xi,nyi,zi,2);
          I(0,0,1,0) = (float)ref(xi,yi,nzi,0); I(0,0,1,1) = (float)ref(xi,yi,nzi,1);
          I(0,0,1,2) = (float)ref(xi,yi,nzi,2); I(1,0,1,0) = (float)ref(nxi,yi,nzi,0);
          I(1,0,1,1) = (float)ref(nxi,yi,nzi,1); I(1,0,1,2) = (float)ref(nxi,yi,nzi,2);
          I(1,1,1,0) = (float)ref(nxi,nyi,nzi,0); I(1,1,1,1) = (float)ref(nxi,nyi,nzi,1);
          I(1,1,1,2) = (float)ref(nxi,nyi,nzi,2); I(0,1,1,0) = (float)ref(xi,nyi,nzi,0);
          I(0,1,1,1) = (float)ref(xi,nyi,nzi,1); I(0,1,1,2) = (float)ref(xi,nyi,nzi,2);
          if (I(1,0,0,0)*I(0,0,0,0)+I(1,0,0,1)*I(0,0,0,1)+I(1,0,0,2)*I(0,0,0,2)<0) { I(1,0,0,0) = -I(1,0,0,0); I(1,0,0,1) = -I(1,0,0,1); I(1,0,0,2) = -I(1,0,0,2); }; if (I(1,1,0,0)*I(0,0,0,0)+I(1,1,0,1)*I(0,0,0,1)+I(1,1,0,2)*I(0,0,0,2)<0) { I(1,1,0,0) = -I(1,1,0,0); I(1,1,0,1) = -I(1,1,0,1); I(1,1,0,2) = -I(1,1,0,2); }; if (I(0,1,0,0)*I(0,0,0,0)+I(0,1,0,1)*I(0,0,0,1)+I(0,1,0,2)*I(0,0,0,2)<0) { I(0,1,0,0) = -I(0,1,0,0); I(0,1,0,1) = -I(0,1,0,1); I(0,1,0,2) = -I(0,1,0,2); };
          if (I(0,0,1,0)*I(0,0,0,0)+I(0,0,1,1)*I(0,0,0,1)+I(0,0,1,2)*I(0,0,0,2)<0) { I(0,0,1,0) = -I(0,0,1,0); I(0,0,1,1) = -I(0,0,1,1); I(0,0,1,2) = -I(0,0,1,2); }; if (I(1,0,1,0)*I(0,0,0,0)+I(1,0,1,1)*I(0,0,0,1)+I(1,0,1,2)*I(0,0,0,2)<0) { I(1,0,1,0) = -I(1,0,1,0); I(1,0,1,1) = -I(1,0,1,1); I(1,0,1,2) = -I(1,0,1,2); }; if (I(1,1,1,0)*I(0,0,0,0)+I(1,1,1,1)*I(0,0,0,1)+I(1,1,1,2)*I(0,0,0,2)<0) { I(1,1,1,0) = -I(1,1,1,0); I(1,1,1,1) = -I(1,1,1,1); I(1,1,1,2) = -I(1,1,1,2); }; if (I(0,1,1,0)*I(0,0,0,0)+I(0,1,1,1)*I(0,0,0,1)+I(0,1,1,2)*I(0,0,0,2)<0) { I(0,1,1,0) = -I(0,1,1,0); I(0,1,1,1) = -I(0,1,1,1); I(0,1,1,2) = -I(0,1,1,2); };
        }
        return (float)pI->_linear_atXYZ(dx,dy,dz,c);
      }
    };

    struct _functor4d_streamline_expr {
      _cimg_math_parser *mp;
      ~_functor4d_streamline_expr() { delete mp; }
      _functor4d_streamline_expr(const char *const expr):mp(0) {
        mp = new _cimg_math_parser(CImg<T>::empty(),expr,"streamline");
      }
      float operator()(const float x, const float y, const float z, const unsigned int c) const {
        return (float)(*mp)(x,y,z,c);
      }
    };
# 24047 "../src/CImg.h"
    CImg<T> get_shared_points(const unsigned int x0, const unsigned int x1,
                              const unsigned int y0=0, const unsigned int z0=0, const unsigned int c0=0) {
      const unsigned int beg = (unsigned int)offset(x0,y0,z0,c0), end = offset(x1,y0,z0,c0);
      if (beg>end || beg>=size() || end>=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_shared_points(): Invalid request of a shared-memory subset (%u->%u,%u,%u,%u).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    x0,x1,y0,z0,c0);

      return CImg<T>(_data+beg,x1-x0+1,1,1,1,true);
    }


    const CImg<T> get_shared_points(const unsigned int x0, const unsigned int x1,
                                    const unsigned int y0=0, const unsigned int z0=0, const unsigned int c0=0) const {
      const unsigned int beg = (unsigned int)offset(x0,y0,z0,c0), end = offset(x1,y0,z0,c0);
      if (beg>end || beg>=size() || end>=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_shared_points(): Invalid request of a shared-memory subset (%u->%u,%u,%u,%u).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    x0,x1,y0,z0,c0);

      return CImg<T>(_data+beg,x1-x0+1,1,1,1,true);
    }
# 24079 "../src/CImg.h"
    CImg<T> get_shared_rows(const unsigned int y0, const unsigned int y1,
                             const unsigned int z0=0, const unsigned int c0=0) {
      const unsigned int beg = offset(0,y0,z0,c0), end = offset(0,y1,z0,c0);
      if (beg>end || beg>=size() || end>=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_shared_rows(): Invalid request of a shared-memory subset "
                                    "(0->%u,%u->%u,%u,%u).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    _width-1,y0,y1,z0,c0);

      return CImg<T>(_data+beg,_width,y1-y0+1,1,1,true);
    }


    const CImg<T> get_shared_rows(const unsigned int y0, const unsigned int y1,
                                   const unsigned int z0=0, const unsigned int c0=0) const {
      const unsigned int beg = offset(0,y0,z0,c0), end = offset(0,y1,z0,c0);
      if (beg>end || beg>=size() || end>=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_shared_rows(): Invalid request of a shared-memory subset "
                                    "(0->%u,%u->%u,%u,%u).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    _width-1,y0,y1,z0,c0);

      return CImg<T>(_data+beg,_width,y1-y0+1,1,1,true);
    }







    CImg<T> get_shared_row(const unsigned int y0, const unsigned int z0=0, const unsigned int c0=0) {
      return get_shared_rows(y0,y0,z0,c0);
    }


    const CImg<T> get_shared_row(const unsigned int y0, const unsigned int z0=0, const unsigned int c0=0) const {
      return get_shared_rows(y0,y0,z0,c0);
    }







    CImg<T> get_shared_slices(const unsigned int z0, const unsigned int z1, const unsigned int c0=0) {
      const unsigned int beg = offset(0,0,z0,c0), end = offset(0,0,z1,c0);
      if (beg>end || beg>=size() || end>=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_shared_slices(): Invalid request of a shared-memory subset "
                                    "(0->%u,0->%u,%u->%u,%u).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    _width-1,_height-1,z0,z1,c0);

      return CImg<T>(_data+beg,_width,_height,z1-z0+1,1,true);
    }


    const CImg<T> get_shared_slices(const unsigned int z0, const unsigned int z1, const unsigned int c0=0) const {
      const unsigned int beg = offset(0,0,z0,c0), end = offset(0,0,z1,c0);
      if (beg>end || beg>=size() || end>=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_shared_slices(): Invalid request of a shared-memory subset "
                                    "(0->%u,0->%u,%u->%u,%u).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    _width-1,_height-1,z0,z1,c0);

      return CImg<T>(_data+beg,_width,_height,z1-z0+1,1,true);
    }






    CImg<T> get_shared_slice(const unsigned int z0, const unsigned int c0=0) {
      return get_shared_slices(z0,z0,c0);
    }


    const CImg<T> get_shared_slice(const unsigned int z0, const unsigned int c0=0) const {
      return get_shared_slices(z0,z0,c0);
    }






    CImg<T> get_shared_channels(const unsigned int c0, const unsigned int c1) {
      const unsigned int beg = offset(0,0,0,c0), end = offset(0,0,0,c1);
      if (beg>end || beg>=size() || end>=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_shared_channels(): Invalid request of a shared-memory subset "
                                    "(0->%u,0->%u,0->%u,%u->%u).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    _width-1,_height-1,_depth-1,c0,c1);

      return CImg<T>(_data+beg,_width,_height,_depth,c1-c0+1,true);
    }


    const CImg<T> get_shared_channels(const unsigned int c0, const unsigned int c1) const {
      const unsigned int beg = offset(0,0,0,c0), end = offset(0,0,0,c1);
      if (beg>end || beg>=size() || end>=size())
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_shared_channels(): Invalid request of a shared-memory subset "
                                    "(0->%u,0->%u,0->%u,%u->%u).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    _width-1,_height-1,_depth-1,c0,c1);

      return CImg<T>(_data+beg,_width,_height,_depth,c1-c0+1,true);
    }





    CImg<T> get_shared_channel(const unsigned int c0) {
      return get_shared_channels(c0,c0);
    }


    const CImg<T> get_shared_channel(const unsigned int c0) const {
      return get_shared_channels(c0,c0);
    }


    CImg<T> get_shared() {
      return CImg<T>(_data,_width,_height,_depth,_spectrum,true);
    }


    const CImg<T> get_shared() const {
      return CImg<T>(_data,_width,_height,_depth,_spectrum,true);
    }
# 24228 "../src/CImg.h"
    CImgList<T> get_split(const char axis, const int nb=0) const {
      CImgList<T> res;
      if (is_empty()) return res;
      const char _axis = cimg::uncase(axis);

      if (nb<=0) {
        const unsigned int dp = (unsigned int)(nb?-nb:1);
        switch (_axis) {
        case 'x': {
          if (_width>dp) {
            res.assign(_width/dp+(_width%dp?1:0),1,1);
            const unsigned int pe = _width - dp;



            for (unsigned int p = 0; p<pe; p+=dp)
              get_crop(p,0,0,0,p+dp-1,_height-1,_depth-1,_spectrum-1).move_to(res[p/dp]);
            get_crop((res._width-1)*dp,0,0,0,_width-1,_height-1,_depth-1,_spectrum-1).move_to(res.back());
          } else res.assign(*this);
        } break;
        case 'y': {
          if (_height>dp) {
            res.assign(_height/dp+(_height%dp?1:0),1,1);
            const unsigned int pe = _height - dp;



            for (unsigned int p = 0; p<pe; p+=dp)
              get_crop(0,p,0,0,_width-1,p+dp-1,_depth-1,_spectrum-1).move_to(res[p/dp]);
            get_crop(0,(res._width-1)*dp,0,0,_width-1,_height-1,_depth-1,_spectrum-1).move_to(res.back());
          } else res.assign(*this);
        } break;
        case 'z': {
          if (_depth>dp) {
            res.assign(_depth/dp+(_depth%dp?1:0),1,1);
            const unsigned int pe = _depth - dp;



            for (unsigned int p = 0; p<pe; p+=dp)
              get_crop(0,0,p,0,_width-1,_height-1,p+dp-1,_spectrum-1).move_to(res[p/dp]);
            get_crop(0,0,(res._width-1)*dp,0,_width-1,_height-1,_depth-1,_spectrum-1).move_to(res.back());
          } else res.assign(*this);
        } break;
        default : {
          if (_spectrum>dp) {
            res.assign(_spectrum/dp+(_spectrum%dp?1:0),1,1);
            const unsigned int pe = _spectrum - dp;



            for (unsigned int p = 0; p<pe; p+=dp)
              get_crop(0,0,0,p,_width-1,_height-1,_depth-1,p+dp-1).move_to(res[p/dp]);
            get_crop(0,0,0,(res._width-1)*dp,_width-1,_height-1,_depth-1,_spectrum-1).move_to(res.back());
          } else res.assign(*this);
        }
        }
      } else {
        const unsigned int siz = _axis=='x'?_width:_axis=='y'?_height:_axis=='z'?_depth:_axis=='c'?_spectrum:0;
        if ((unsigned int)nb>siz)
          throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "get_split(): Instance cannot be split along %c-axis into %u blocs.",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      axis,nb);
        if (nb==1) res.assign(*this);
        else {
          int err = (int)siz;
          unsigned int _p = 0;
          switch (_axis) {
          case 'x' : {
            for (int p = 0; p<(int)((*this)._width); ++p) if ((err-=nb)<=0) {
              get_crop(_p,0,0,0,p,_height-1,_depth-1,_spectrum-1).move_to(res);
              err+=(int)siz;
              _p=p+1;
            }
          } break;
          case 'y' : {
            for (int p = 0; p<(int)((*this)._height); ++p) if ((err-=nb)<=0) {
              get_crop(0,_p,0,0,_width-1,p,_depth-1,_spectrum-1).move_to(res);
              err+=(int)siz;
              _p=p+1;
            }
          } break;
          case 'z' : {
            for (int p = 0; p<(int)((*this)._depth); ++p) if ((err-=nb)<=0) {
              get_crop(0,0,_p,0,_width-1,_height-1,p,_spectrum-1).move_to(res);
              err+=(int)siz;
              _p=p+1;
            }
          } break;
          default : {
            for (int p = 0; p<(int)((*this)._spectrum); ++p) if ((err-=nb)<=0) {
              get_crop(0,0,0,_p,_width-1,_height-1,_depth-1,p).move_to(res);
              err+=(int)siz;
              _p=p+1;
            }
          }
          }
        }
      }
      return res;
    }







    CImgList<T> get_split(const T value, const bool keep_values, const bool is_shared) const {
      CImgList<T> res;
      if (is_empty()) return res;
      for (const T *ps = _data, *_ps = ps, *const pe = end(); ps<pe; ) {
        while (_ps<pe && *_ps==value) ++_ps;
        unsigned int siz = _ps - ps;
        if (siz && keep_values) res.insert(CImg<T>(ps,1,siz,1,1,is_shared),~0U,is_shared);
        ps = _ps;
        while (_ps<pe && *_ps!=value) ++_ps;
        siz = _ps - ps;
        if (siz) res.insert(CImg<T>(ps,1,siz,1,1,is_shared),~0U,is_shared);
        ps = _ps;
      }
      return res;
    }







    template<typename t>
    CImgList<T> get_split(const CImg<t>& values, const bool keep_values, const bool is_shared) const {
      CImgList<T> res;
      if (is_empty()) return res;
      if (!values) return CImgList<T>(*this);
      if (values.size()==1) return get_split(*values,keep_values,is_shared);
      const t *pve = values.end();
      for (const T *ps = _data, *_ps = ps, *const pe = end(); ps<pe; ) {


        const t *pv = 0;
        do {
          pv = values._data;
          const T *__ps = _ps;
          while (__ps<pe && pv<pve && *__ps==(T)*pv) { ++__ps; ++pv; }
          if (pv==pve) _ps = __ps;
        } while (pv==pve);
        unsigned int siz = _ps - ps;
        if (siz && keep_values) res.insert(CImg<T>(ps,1,siz,1,1,is_shared),~0U,is_shared);
        ps = _ps;


        do {
          pv = values._data;
          while (_ps<pe && *_ps!=(T)*pv) ++_ps;
          if (_ps<pe) {
            const T *__ps = _ps + 1;
            ++pv;
            while (__ps<pe && pv<pve && *__ps==(T)*pv) { ++__ps; ++pv; }
            if (pv!=pve) _ps = __ps;
          }
        } while (_ps<pe && pv!=pve);


        siz = _ps - ps;
        if (siz) res.insert(CImg<T>(ps,1,siz,1,1,is_shared),~0U,is_shared);
        ps = _ps;
      }
      return res;
    }


    CImgList<T> get_split(const bool is_shared) const {
      CImgList<T> res;
      if (is_empty()) return res;
      T *p0 = _data, current = *p0;
      for (T *p = (*this)._data, *_maxp = (*this)._data + (*this).size(); p<_maxp; ++p) if (*p!=current) {
        res.insert(CImg<T>(p0,1,p-p0,1,1,is_shared),~0U,is_shared); p0 = p; current = *p;
      }
      res.insert(CImg<T>(p0,1,end()-p0,1,1,is_shared),~0U,is_shared);
      return res;
    }







    template<typename t>
    CImg<T>& append(const CImg<t>& img, const char axis='x', const float align=0) {
      if (is_empty()) return assign(img,false);
      if (!img) return *this;
      return CImgList<T>(*this,true).insert(img).get_append(axis,align).move_to(*this);
    }


    CImg<T>& append(const CImg<T>& img, const char axis='x', const float align=0) {
      if (is_empty()) return assign(img,false);
      if (!img) return *this;
      return CImgList<T>(*this,img,true).get_append(axis,align).move_to(*this);
    }


    template<typename t>
    CImg<typename cimg::superset<T,t>::type> get_append(const CImg<T>& img, const char axis='x', const float align=0) const {
      if (is_empty()) return +img;
      if (!img) return +*this;
      return CImgList<typename cimg::superset<T,t>::type>(*this,true).insert(img).get_append(axis,align);
    }


    CImg<T> get_append(const CImg<T>& img, const char axis='x', const float align=0) const {
      if (is_empty()) return +img;
      if (!img) return +*this;
      return CImgList<T>(*this,img,true).get_append(axis,align);
    }
# 24463 "../src/CImg.h"
    template<typename t>
    CImg<T>& correlate(const CImg<t>& mask, const unsigned int boundary_conditions=1, const bool is_normalized=false) {
      if (is_empty() || !mask) return *this;
      return get_correlate(mask,boundary_conditions,is_normalized).move_to(*this);
    }


    template<typename t>
    CImg<typename cimg::superset2<T,t,float>::type> get_correlate(const CImg<t>& mask, const unsigned int boundary_conditions=1,
                                      const bool is_normalized=false) const {
      if (is_empty() || !mask) return *this;
      typedef typename cimg::superset2<T,t,float>::type Ttfloat;
      CImg<Ttfloat> res(_width,_height,_depth,cimg::max(_spectrum,mask._spectrum));
      if (boundary_conditions && mask._width==mask._height &&
          ((mask._depth==1 && mask._width<=5) || (mask._depth==mask._width && mask._width<=3))) {

        Ttfloat *ptrd = res._data;
        switch (mask._depth) {
        case 3 : {
          T I[27] = { 0 };
          for (int c = 0; c<(int)((res)._spectrum); ++c) {
            const CImg<T> _img = get_shared_channel(c%_spectrum);
            const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
            if (is_normalized) {
              const Ttfloat _M = (Ttfloat)_mask.magnitude(2), M = _M*_M;
              for (int z = 0, _p1z = 0, _n1z = 1>=((_img)._depth)?(int)((_img)._depth)-1:1; _n1z<(int)((_img)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1; _n1y<(int)((_img)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(_img)(_p1x,_p1y,_p1z,0)), (I[3] = I[4] = (T)(_img)(0,y,_p1z,0)), (I[6] = I[7] = (T)(_img)(0,_n1y,_p1z,0)), (I[9] = I[10] = (T)(_img)(0,_p1y,z,0)), (I[12] = I[13] = (T)(_img)(0,y,z,0)), (I[15] = I[16] = (T)(_img)(0,_n1y,z,0)), (I[18] = I[19] = (T)(_img)(0,_p1y,_n1z,0)), (I[21] = I[22] = (T)(_img)(0,y,_n1z,0)), (I[24] = I[25] = (T)(_img)(0,_n1y,_n1z,0)), 1>=(_img)._width?(_img).width()-1:1); (_n1x<(_img).width() && ( (I[2] = (T)(_img)(_n1x,_p1y,_p1z,0)), (I[5] = (T)(_img)(_n1x,y,_p1z,0)), (I[8] = (T)(_img)(_n1x,_n1y,_p1z,0)), (I[11] = (T)(_img)(_n1x,_p1y,z,0)), (I[14] = (T)(_img)(_n1x,y,z,0)), (I[17] = (T)(_img)(_n1x,_n1y,z,0)), (I[20] = (T)(_img)(_n1x,_p1y,_n1z,0)), (I[23] = (T)(_img)(_n1x,y,_n1z,0)), (I[26] = (T)(_img)(_n1x,_n1y,_n1z,0)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
                const Ttfloat N = M*(I[ 0]*I[ 0] + I[ 1]*I[ 1] + I[ 2]*I[ 2] +
                                     I[ 3]*I[ 3] + I[ 4]*I[ 4] + I[ 5]*I[ 5] +
                                     I[ 6]*I[ 6] + I[ 7]*I[ 7] + I[ 8]*I[ 8] +
                                     I[ 9]*I[ 9] + I[10]*I[10] + I[11]*I[11] +
                                     I[12]*I[12] + I[13]*I[13] + I[14]*I[14] +
                                     I[15]*I[15] + I[16]*I[16] + I[17]*I[17] +
                                     I[18]*I[18] + I[19]*I[19] + I[20]*I[20] +
                                     I[21]*I[21] + I[22]*I[22] + I[23]*I[23] +
                                     I[24]*I[24] + I[25]*I[25] + I[26]*I[26]);
                *(ptrd++) = (Ttfloat)(N?(I[ 0]*_mask[ 0] + I[ 1]*_mask[ 1] + I[ 2]*_mask[ 2] +
                                         I[ 3]*_mask[ 3] + I[ 4]*_mask[ 4] + I[ 5]*_mask[ 5] +
                                         I[ 6]*_mask[ 6] + I[ 7]*_mask[ 7] + I[ 8]*_mask[ 8] +
                                         I[ 9]*_mask[ 9] + I[10]*_mask[10] + I[11]*_mask[11] +
                                         I[12]*_mask[12] + I[13]*_mask[13] + I[14]*_mask[14] +
                                         I[15]*_mask[15] + I[16]*_mask[16] + I[17]*_mask[17] +
                                         I[18]*_mask[18] + I[19]*_mask[19] + I[20]*_mask[20] +
                                         I[21]*_mask[21] + I[22]*_mask[22] + I[23]*_mask[23] +
                                         I[24]*_mask[24] + I[25]*_mask[25] + I[26]*_mask[26])/std::sqrt(N):0);
              }
            } else for (int z = 0, _p1z = 0, _n1z = 1>=((_img)._depth)?(int)((_img)._depth)-1:1; _n1z<(int)((_img)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1; _n1y<(int)((_img)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(_img)(_p1x,_p1y,_p1z,0)), (I[3] = I[4] = (T)(_img)(0,y,_p1z,0)), (I[6] = I[7] = (T)(_img)(0,_n1y,_p1z,0)), (I[9] = I[10] = (T)(_img)(0,_p1y,z,0)), (I[12] = I[13] = (T)(_img)(0,y,z,0)), (I[15] = I[16] = (T)(_img)(0,_n1y,z,0)), (I[18] = I[19] = (T)(_img)(0,_p1y,_n1z,0)), (I[21] = I[22] = (T)(_img)(0,y,_n1z,0)), (I[24] = I[25] = (T)(_img)(0,_n1y,_n1z,0)), 1>=(_img)._width?(_img).width()-1:1); (_n1x<(_img).width() && ( (I[2] = (T)(_img)(_n1x,_p1y,_p1z,0)), (I[5] = (T)(_img)(_n1x,y,_p1z,0)), (I[8] = (T)(_img)(_n1x,_n1y,_p1z,0)), (I[11] = (T)(_img)(_n1x,_p1y,z,0)), (I[14] = (T)(_img)(_n1x,y,z,0)), (I[17] = (T)(_img)(_n1x,_n1y,z,0)), (I[20] = (T)(_img)(_n1x,_p1y,_n1z,0)), (I[23] = (T)(_img)(_n1x,y,_n1z,0)), (I[26] = (T)(_img)(_n1x,_n1y,_n1z,0)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x)
                     *(ptrd++) = (Ttfloat)(I[ 0]*_mask[ 0] + I[ 1]*_mask[ 1] + I[ 2]*_mask[ 2] +
                                           I[ 3]*_mask[ 3] + I[ 4]*_mask[ 4] + I[ 5]*_mask[ 5] +
                                           I[ 6]*_mask[ 6] + I[ 7]*_mask[ 7] + I[ 8]*_mask[ 8] +
                                           I[ 9]*_mask[ 9] + I[10]*_mask[10] + I[11]*_mask[11] +
                                           I[12]*_mask[12] + I[13]*_mask[13] + I[14]*_mask[14] +
                                           I[15]*_mask[15] + I[16]*_mask[16] + I[17]*_mask[17] +
                                           I[18]*_mask[18] + I[19]*_mask[19] + I[20]*_mask[20] +
                                           I[21]*_mask[21] + I[22]*_mask[22] + I[23]*_mask[23] +
                                           I[24]*_mask[24] + I[25]*_mask[25] + I[26]*_mask[26]);
          }
        } break;
        case 2 : {
          T I[8] = { 0 };
          for (int c = 0; c<(int)((res)._spectrum); ++c) {
            const CImg<T> _img = get_shared_channel(c%_spectrum);
            const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
            if (is_normalized) {
              const Ttfloat _M = (Ttfloat)_mask.magnitude(2), M = _M*_M;
              for (int z = 0, _n1z = 1>=((_img)._depth)?(int)((_img)._depth)-1:1; _n1z<(int)((_img)._depth) || z==--_n1z; ++z, ++_n1z) for (int y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1; _n1y<(int)((_img)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = (int)( (I[0] = (T)(_img)(0,y,z,0)), (I[2] = (T)(_img)(0,_n1y,z,0)), (I[4] = (T)(_img)(0,y,_n1z,0)), (I[6] = (T)(_img)(0,_n1y,_n1z,0)), 1>=(_img)._width?(_img).width()-1:1); (_n1x<(_img).width() && ( (I[1] = (T)(_img)(_n1x,y,z,0)), (I[3] = (T)(_img)(_n1x,_n1y,z,0)), (I[5] = (T)(_img)(_n1x,y,_n1z,0)), (I[7] = (T)(_img)(_n1x,_n1y,_n1z,0)),1)) || x==--_n1x; I[0] = I[1], I[2] = I[3], I[4] = I[5], I[6] = I[7], ++x, ++_n1x) {
                const Ttfloat N = M*(I[0]*I[0] + I[1]*I[1] +
                                     I[2]*I[2] + I[3]*I[3] +
                                     I[4]*I[4] + I[5]*I[5] +
                                     I[6]*I[6] + I[7]*I[7]);
                *(ptrd++) = (Ttfloat)(N?(I[0]*_mask[0] + I[1]*_mask[1] +
                                         I[2]*_mask[2] + I[3]*_mask[3] +
                                         I[4]*_mask[4] + I[5]*_mask[5] +
                                         I[6]*_mask[6] + I[7]*_mask[7])/std::sqrt(N):0);
              }
            } else for (int z = 0, _n1z = 1>=((_img)._depth)?(int)((_img)._depth)-1:1; _n1z<(int)((_img)._depth) || z==--_n1z; ++z, ++_n1z) for (int y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1; _n1y<(int)((_img)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = (int)( (I[0] = (T)(_img)(0,y,z,0)), (I[2] = (T)(_img)(0,_n1y,z,0)), (I[4] = (T)(_img)(0,y,_n1z,0)), (I[6] = (T)(_img)(0,_n1y,_n1z,0)), 1>=(_img)._width?(_img).width()-1:1); (_n1x<(_img).width() && ( (I[1] = (T)(_img)(_n1x,y,z,0)), (I[3] = (T)(_img)(_n1x,_n1y,z,0)), (I[5] = (T)(_img)(_n1x,y,_n1z,0)), (I[7] = (T)(_img)(_n1x,_n1y,_n1z,0)),1)) || x==--_n1x; I[0] = I[1], I[2] = I[3], I[4] = I[5], I[6] = I[7], ++x, ++_n1x)
                     *(ptrd++) = (Ttfloat)(I[0]*_mask[0] + I[1]*_mask[1] +
                                           I[2]*_mask[2] + I[3]*_mask[3] +
                                           I[4]*_mask[4] + I[5]*_mask[5] +
                                           I[6]*_mask[6] + I[7]*_mask[7]);
          }
        } break;
        default :
        case 1 :
          switch (mask._width) {
          case 6 : {
            T I[36] = { 0 };
            for (int c = 0; c<(int)((res)._spectrum); ++c) {
              const CImg<T> _img = get_shared_channel(c%_spectrum);
              const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
              if (is_normalized) {
                const Ttfloat _M = (Ttfloat)_mask.magnitude(2), M = _M*_M;
                for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1, _n2y = 2>=((_img)._height)?(int)((_img)._height)-1:2, _n3y = 3>=((_img)._height)?(int)((_img)._height)-1:3; _n3y<(int)((_img)._height) || _n2y==--_n3y || _n1y==--_n2y || y==(_n3y = _n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=(_img)._width?(_img).width()-1:1, _n2x = 2>=(_img)._width?(_img).width()-1:2, _n3x = (int)( (I[0] = I[1] = I[2] = (T)(_img)(_p2x,_p2y,z,0)), (I[6] = I[7] = I[8] = (T)(_img)(0,_p1y,z,0)), (I[12] = I[13] = I[14] = (T)(_img)(0,y,z,0)), (I[18] = I[19] = I[20] = (T)(_img)(0,_n1y,z,0)), (I[24] = I[25] = I[26] = (T)(_img)(0,_n2y,z,0)), (I[30] = I[31] = I[32] = (T)(_img)(0,_n3y,z,0)), (I[3] = (T)(_img)(_n1x,_p2y,z,0)), (I[9] = (T)(_img)(_n1x,_p1y,z,0)), (I[15] = (T)(_img)(_n1x,y,z,0)), (I[21] = (T)(_img)(_n1x,_n1y,z,0)), (I[27] = (T)(_img)(_n1x,_n2y,z,0)), (I[33] = (T)(_img)(_n1x,_n3y,z,0)), (I[4] = (T)(_img)(_n2x,_p2y,z,0)), (I[10] = (T)(_img)(_n2x,_p1y,z,0)), (I[16] = (T)(_img)(_n2x,y,z,0)), (I[22] = (T)(_img)(_n2x,_n1y,z,0)), (I[28] = (T)(_img)(_n2x,_n2y,z,0)), (I[34] = (T)(_img)(_n2x,_n3y,z,0)), 3>=(_img)._width?(_img).width()-1:3); (_n3x<(_img).width() && ( (I[5] = (T)(_img)(_n3x,_p2y,z,0)), (I[11] = (T)(_img)(_n3x,_p1y,z,0)), (I[17] = (T)(_img)(_n3x,y,z,0)), (I[23] = (T)(_img)(_n3x,_n1y,z,0)), (I[29] = (T)(_img)(_n3x,_n2y,z,0)), (I[35] = (T)(_img)(_n3x,_n3y,z,0)),1)) || _n2x==--_n3x || _n1x==--_n2x || x==(_n3x = _n2x = --_n1x); I[0] = I[1], I[1] = I[2], I[2] = I[3], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[8] = I[9], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[14] = I[15], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[20] = I[21], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], I[26] = I[27], I[27] = I[28], I[28] = I[29], I[30] = I[31], I[31] = I[32], I[32] = I[33], I[33] = I[34], I[34] = I[35], _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x) {
                  const Ttfloat N = M*(I[ 0]*I[ 0] + I[ 1]*I[ 1] + I[ 2]*I[ 2] + I[ 3]*I[ 3] + I[ 4]*I[ 4] + I[ 5]*I[ 5] +
                                       I[ 6]*I[ 6] + I[ 7]*I[ 7] + I[ 8]*I[ 8] + I[ 9]*I[ 9] + I[10]*I[10] + I[11]*I[11] +
                                       I[12]*I[12] + I[13]*I[13] + I[14]*I[14] + I[15]*I[15] + I[16]*I[16] + I[17]*I[17] +
                                       I[18]*I[18] + I[19]*I[19] + I[20]*I[20] + I[21]*I[21] + I[22]*I[22] + I[23]*I[23] +
                                       I[24]*I[24] + I[25]*I[25] + I[26]*I[26] + I[27]*I[27] + I[28]*I[28] + I[29]*I[29] +
                                       I[30]*I[30] + I[31]*I[31] + I[32]*I[32] + I[33]*I[33] + I[34]*I[34] + I[35]*I[35]);
                  *(ptrd++) = (Ttfloat)(N?(I[ 0]*_mask[ 0] + I[ 1]*_mask[ 1] + I[ 2]*_mask[ 2] + I[ 3]*_mask[ 3] + I[ 4]*_mask[ 4] + I[ 5]*_mask[ 5] +
                                           I[ 6]*_mask[ 6] + I[ 7]*_mask[ 7] + I[ 8]*_mask[ 8] + I[ 9]*_mask[ 9] + I[10]*_mask[10] + I[11]*_mask[11] +
                                           I[12]*_mask[12] + I[13]*_mask[13] + I[14]*_mask[14] + I[15]*_mask[15] + I[16]*_mask[16] + I[17]*_mask[17] +
                                           I[18]*_mask[18] + I[19]*_mask[19] + I[20]*_mask[20] + I[21]*_mask[21] + I[22]*_mask[22] + I[23]*_mask[23] +
                                           I[24]*_mask[24] + I[25]*_mask[25] + I[26]*_mask[26] + I[27]*_mask[27] + I[28]*_mask[28] + I[29]*_mask[29] +
                                           I[30]*_mask[30] + I[31]*_mask[31] + I[32]*_mask[32] + I[33]*_mask[33] + I[34]*_mask[34] + I[35]*_mask[35])/std::sqrt(N):0);
                }
              } else for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1, _n2y = 2>=((_img)._height)?(int)((_img)._height)-1:2, _n3y = 3>=((_img)._height)?(int)((_img)._height)-1:3; _n3y<(int)((_img)._height) || _n2y==--_n3y || _n1y==--_n2y || y==(_n3y = _n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=(_img)._width?(_img).width()-1:1, _n2x = 2>=(_img)._width?(_img).width()-1:2, _n3x = (int)( (I[0] = I[1] = I[2] = (T)(_img)(_p2x,_p2y,z,0)), (I[6] = I[7] = I[8] = (T)(_img)(0,_p1y,z,0)), (I[12] = I[13] = I[14] = (T)(_img)(0,y,z,0)), (I[18] = I[19] = I[20] = (T)(_img)(0,_n1y,z,0)), (I[24] = I[25] = I[26] = (T)(_img)(0,_n2y,z,0)), (I[30] = I[31] = I[32] = (T)(_img)(0,_n3y,z,0)), (I[3] = (T)(_img)(_n1x,_p2y,z,0)), (I[9] = (T)(_img)(_n1x,_p1y,z,0)), (I[15] = (T)(_img)(_n1x,y,z,0)), (I[21] = (T)(_img)(_n1x,_n1y,z,0)), (I[27] = (T)(_img)(_n1x,_n2y,z,0)), (I[33] = (T)(_img)(_n1x,_n3y,z,0)), (I[4] = (T)(_img)(_n2x,_p2y,z,0)), (I[10] = (T)(_img)(_n2x,_p1y,z,0)), (I[16] = (T)(_img)(_n2x,y,z,0)), (I[22] = (T)(_img)(_n2x,_n1y,z,0)), (I[28] = (T)(_img)(_n2x,_n2y,z,0)), (I[34] = (T)(_img)(_n2x,_n3y,z,0)), 3>=(_img)._width?(_img).width()-1:3); (_n3x<(_img).width() && ( (I[5] = (T)(_img)(_n3x,_p2y,z,0)), (I[11] = (T)(_img)(_n3x,_p1y,z,0)), (I[17] = (T)(_img)(_n3x,y,z,0)), (I[23] = (T)(_img)(_n3x,_n1y,z,0)), (I[29] = (T)(_img)(_n3x,_n2y,z,0)), (I[35] = (T)(_img)(_n3x,_n3y,z,0)),1)) || _n2x==--_n3x || _n1x==--_n2x || x==(_n3x = _n2x = --_n1x); I[0] = I[1], I[1] = I[2], I[2] = I[3], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[8] = I[9], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[14] = I[15], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[20] = I[21], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], I[26] = I[27], I[27] = I[28], I[28] = I[29], I[30] = I[31], I[31] = I[32], I[32] = I[33], I[33] = I[34], I[34] = I[35], _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x)
                       *(ptrd++) = (Ttfloat)(I[ 0]*_mask[ 0] + I[ 1]*_mask[ 1] + I[ 2]*_mask[ 2] + I[ 3]*_mask[ 3] + I[ 4]*_mask[ 4] + I[ 5]*_mask[ 5] +
                                             I[ 6]*_mask[ 6] + I[ 7]*_mask[ 7] + I[ 8]*_mask[ 8] + I[ 9]*_mask[ 9] + I[10]*_mask[10] + I[11]*_mask[11] +
                                             I[12]*_mask[12] + I[13]*_mask[13] + I[14]*_mask[14] + I[15]*_mask[15] + I[16]*_mask[16] + I[17]*_mask[17] +
                                             I[18]*_mask[18] + I[19]*_mask[19] + I[20]*_mask[20] + I[21]*_mask[21] + I[22]*_mask[22] + I[23]*_mask[23] +
                                             I[24]*_mask[24] + I[25]*_mask[25] + I[26]*_mask[26] + I[27]*_mask[27] + I[28]*_mask[28] + I[29]*_mask[29] +
                                             I[30]*_mask[30] + I[31]*_mask[31] + I[32]*_mask[32] + I[33]*_mask[33] + I[34]*_mask[34] + I[35]*_mask[35]);
            }
          } break;
          case 5 : {
            T I[25] = { 0 };
            for (int c = 0; c<(int)((res)._spectrum); ++c) {
              const CImg<T> _img = get_shared_channel(c%_spectrum);
              const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
              if (is_normalized) {
                const Ttfloat _M = (Ttfloat)_mask.magnitude(2), M = _M*_M;
                for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1, _n2y = 2>=((_img)._height)?(int)((_img)._height)-1:2; _n2y<(int)((_img)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=(_img)._width?(_img).width()-1:1, _n2x = (int)( (I[0] = I[1] = I[2] = (T)(_img)(_p2x,_p2y,z,0)), (I[5] = I[6] = I[7] = (T)(_img)(0,_p1y,z,0)), (I[10] = I[11] = I[12] = (T)(_img)(0,y,z,0)), (I[15] = I[16] = I[17] = (T)(_img)(0,_n1y,z,0)), (I[20] = I[21] = I[22] = (T)(_img)(0,_n2y,z,0)), (I[3] = (T)(_img)(_n1x,_p2y,z,0)), (I[8] = (T)(_img)(_n1x,_p1y,z,0)), (I[13] = (T)(_img)(_n1x,y,z,0)), (I[18] = (T)(_img)(_n1x,_n1y,z,0)), (I[23] = (T)(_img)(_n1x,_n2y,z,0)), 2>=(_img)._width?(_img).width()-1:2); (_n2x<(_img).width() && ( (I[4] = (T)(_img)(_n2x,_p2y,z,0)), (I[9] = (T)(_img)(_n2x,_p1y,z,0)), (I[14] = (T)(_img)(_n2x,y,z,0)), (I[19] = (T)(_img)(_n2x,_n1y,z,0)), (I[24] = (T)(_img)(_n2x,_n2y,z,0)),1)) || _n1x==--_n2x || x==(_n2x = --_n1x); I[0] = I[1], I[1] = I[2], I[2] = I[3], I[3] = I[4], I[5] = I[6], I[6] = I[7], I[7] = I[8], I[8] = I[9], I[10] = I[11], I[11] = I[12], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[17] = I[18], I[18] = I[19], I[20] = I[21], I[21] = I[22], I[22] = I[23], I[23] = I[24], _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x) {
                  const Ttfloat N = M*(I[ 0]*I[ 0] + I[ 1]*I[ 1] + I[ 2]*I[ 2] + I[ 3]*I[ 3] + I[ 4]*I[ 4] +
                                       I[ 5]*I[ 5] + I[ 6]*I[ 6] + I[ 7]*I[ 7] + I[ 8]*I[ 8] + I[ 9]*I[ 9] +
                                       I[10]*I[10] + I[11]*I[11] + I[12]*I[12] + I[13]*I[13] + I[14]*I[14] +
                                       I[15]*I[15] + I[16]*I[16] + I[17]*I[17] + I[18]*I[18] + I[19]*I[19] +
                                       I[20]*I[20] + I[21]*I[21] + I[22]*I[22] + I[23]*I[23] + I[24]*I[24]);
                  *(ptrd++) = (Ttfloat)(N?(I[ 0]*_mask[ 0] + I[ 1]*_mask[ 1] + I[ 2]*_mask[ 2] + I[ 3]*_mask[ 3] + I[ 4]*_mask[ 4] +
                                           I[ 5]*_mask[ 5] + I[ 6]*_mask[ 6] + I[ 7]*_mask[ 7] + I[ 8]*_mask[ 8] + I[ 9]*_mask[ 9] +
                                           I[10]*_mask[10] + I[11]*_mask[11] + I[12]*_mask[12] + I[13]*_mask[13] + I[14]*_mask[14] +
                                           I[15]*_mask[15] + I[16]*_mask[16] + I[17]*_mask[17] + I[18]*_mask[18] + I[19]*_mask[19] +
                                           I[20]*_mask[20] + I[21]*_mask[21] + I[22]*_mask[22] + I[23]*_mask[23] + I[24]*_mask[24])/std::sqrt(N):0);
                }
              } else for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1, _n2y = 2>=((_img)._height)?(int)((_img)._height)-1:2; _n2y<(int)((_img)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=(_img)._width?(_img).width()-1:1, _n2x = (int)( (I[0] = I[1] = I[2] = (T)(_img)(_p2x,_p2y,z,0)), (I[5] = I[6] = I[7] = (T)(_img)(0,_p1y,z,0)), (I[10] = I[11] = I[12] = (T)(_img)(0,y,z,0)), (I[15] = I[16] = I[17] = (T)(_img)(0,_n1y,z,0)), (I[20] = I[21] = I[22] = (T)(_img)(0,_n2y,z,0)), (I[3] = (T)(_img)(_n1x,_p2y,z,0)), (I[8] = (T)(_img)(_n1x,_p1y,z,0)), (I[13] = (T)(_img)(_n1x,y,z,0)), (I[18] = (T)(_img)(_n1x,_n1y,z,0)), (I[23] = (T)(_img)(_n1x,_n2y,z,0)), 2>=(_img)._width?(_img).width()-1:2); (_n2x<(_img).width() && ( (I[4] = (T)(_img)(_n2x,_p2y,z,0)), (I[9] = (T)(_img)(_n2x,_p1y,z,0)), (I[14] = (T)(_img)(_n2x,y,z,0)), (I[19] = (T)(_img)(_n2x,_n1y,z,0)), (I[24] = (T)(_img)(_n2x,_n2y,z,0)),1)) || _n1x==--_n2x || x==(_n2x = --_n1x); I[0] = I[1], I[1] = I[2], I[2] = I[3], I[3] = I[4], I[5] = I[6], I[6] = I[7], I[7] = I[8], I[8] = I[9], I[10] = I[11], I[11] = I[12], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[17] = I[18], I[18] = I[19], I[20] = I[21], I[21] = I[22], I[22] = I[23], I[23] = I[24], _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x)
                       *(ptrd++) = (Ttfloat)(I[ 0]*_mask[ 0] + I[ 1]*_mask[ 1] + I[ 2]*_mask[ 2] + I[ 3]*_mask[ 3] + I[ 4]*_mask[ 4] +
                                             I[ 5]*_mask[ 5] + I[ 6]*_mask[ 6] + I[ 7]*_mask[ 7] + I[ 8]*_mask[ 8] + I[ 9]*_mask[ 9] +
                                             I[10]*_mask[10] + I[11]*_mask[11] + I[12]*_mask[12] + I[13]*_mask[13] + I[14]*_mask[14] +
                                             I[15]*_mask[15] + I[16]*_mask[16] + I[17]*_mask[17] + I[18]*_mask[18] + I[19]*_mask[19] +
                                             I[20]*_mask[20] + I[21]*_mask[21] + I[22]*_mask[22] + I[23]*_mask[23] + I[24]*_mask[24]);
            }
          } break;
          case 4 : {
            T I[16] = { 0 };
            for (int c = 0; c<(int)((res)._spectrum); ++c) {
              const CImg<T> _img = get_shared_channel(c%_spectrum);
              const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
              if (is_normalized) {
                const Ttfloat _M = (Ttfloat)_mask.magnitude(2), M = _M*_M;
                for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1, _n2y = 2>=((_img)._height)?(int)((_img)._height)-1:2; _n2y<(int)((_img)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p1x = 0, _n1x = 1>=(_img)._width?(_img).width()-1:1, _n2x = (int)( (I[0] = I[1] = (T)(_img)(_p1x,_p1y,z,0)), (I[4] = I[5] = (T)(_img)(0,y,z,0)), (I[8] = I[9] = (T)(_img)(0,_n1y,z,0)), (I[12] = I[13] = (T)(_img)(0,_n2y,z,0)), (I[2] = (T)(_img)(_n1x,_p1y,z,0)), (I[6] = (T)(_img)(_n1x,y,z,0)), (I[10] = (T)(_img)(_n1x,_n1y,z,0)), (I[14] = (T)(_img)(_n1x,_n2y,z,0)), 2>=(_img)._width?(_img).width()-1:2); (_n2x<(_img).width() && ( (I[3] = (T)(_img)(_n2x,_p1y,z,0)), (I[7] = (T)(_img)(_n2x,y,z,0)), (I[11] = (T)(_img)(_n2x,_n1y,z,0)), (I[15] = (T)(_img)(_n2x,_n2y,z,0)),1)) || _n1x==--_n2x || x==(_n2x = --_n1x); I[0] = I[1], I[1] = I[2], I[2] = I[3], I[4] = I[5], I[5] = I[6], I[6] = I[7], I[8] = I[9], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[14] = I[15], _p1x = x++, ++_n1x, ++_n2x) {
                  const Ttfloat N = M*(I[ 0]*I[ 0] + I[ 1]*I[ 1] + I[ 2]*I[ 2] + I[ 3]*I[ 3] +
                                       I[ 4]*I[ 4] + I[ 5]*I[ 5] + I[ 6]*I[ 6] + I[ 7]*I[ 7] +
                                       I[ 8]*I[ 8] + I[ 9]*I[ 9] + I[10]*I[10] + I[11]*I[11] +
                                       I[12]*I[12] + I[13]*I[13] + I[14]*I[14] + I[15]*I[15]);
                  *(ptrd++) = (Ttfloat)(N?(I[ 0]*_mask[ 0] + I[ 1]*_mask[ 1] + I[ 2]*_mask[ 2] + I[ 3]*_mask[ 3] +
                                           I[ 4]*_mask[ 4] + I[ 5]*_mask[ 5] + I[ 6]*_mask[ 6] + I[ 7]*_mask[ 7] +
                                           I[ 8]*_mask[ 8] + I[ 9]*_mask[ 9] + I[10]*_mask[10] + I[11]*_mask[11] +
                                           I[12]*_mask[12] + I[13]*_mask[13] + I[14]*_mask[14] + I[15]*_mask[15])/std::sqrt(N):0);
                }
              } else for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1, _n2y = 2>=((_img)._height)?(int)((_img)._height)-1:2; _n2y<(int)((_img)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p1x = 0, _n1x = 1>=(_img)._width?(_img).width()-1:1, _n2x = (int)( (I[0] = I[1] = (T)(_img)(_p1x,_p1y,z,0)), (I[4] = I[5] = (T)(_img)(0,y,z,0)), (I[8] = I[9] = (T)(_img)(0,_n1y,z,0)), (I[12] = I[13] = (T)(_img)(0,_n2y,z,0)), (I[2] = (T)(_img)(_n1x,_p1y,z,0)), (I[6] = (T)(_img)(_n1x,y,z,0)), (I[10] = (T)(_img)(_n1x,_n1y,z,0)), (I[14] = (T)(_img)(_n1x,_n2y,z,0)), 2>=(_img)._width?(_img).width()-1:2); (_n2x<(_img).width() && ( (I[3] = (T)(_img)(_n2x,_p1y,z,0)), (I[7] = (T)(_img)(_n2x,y,z,0)), (I[11] = (T)(_img)(_n2x,_n1y,z,0)), (I[15] = (T)(_img)(_n2x,_n2y,z,0)),1)) || _n1x==--_n2x || x==(_n2x = --_n1x); I[0] = I[1], I[1] = I[2], I[2] = I[3], I[4] = I[5], I[5] = I[6], I[6] = I[7], I[8] = I[9], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[14] = I[15], _p1x = x++, ++_n1x, ++_n2x)
                       *(ptrd++) = (Ttfloat)(I[ 0]*_mask[ 0] + I[ 1]*_mask[ 1] + I[ 2]*_mask[ 2] + I[ 3]*_mask[ 3] +
                                             I[ 4]*_mask[ 4] + I[ 5]*_mask[ 5] + I[ 6]*_mask[ 6] + I[ 7]*_mask[ 7] +
                                             I[ 8]*_mask[ 8] + I[ 9]*_mask[ 9] + I[10]*_mask[10] + I[11]*_mask[11] +
                                             I[12]*_mask[12] + I[13]*_mask[13] + I[14]*_mask[14] + I[15]*_mask[15]);
            }
          } break;
          case 3 : {
            T I[9] = { 0 };
            for (int c = 0; c<(int)((res)._spectrum); ++c) {
              const CImg<T> _img = get_shared_channel(c%_spectrum);
              const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
              if (is_normalized) {
                const Ttfloat _M = (Ttfloat)_mask.magnitude(2), M = _M*_M;
                for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1; _n1y<(int)((_img)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(_img)(_p1x,_p1y,z,0)), (I[3] = I[4] = (T)(_img)(0,y,z,0)), (I[6] = I[7] = (T)(_img)(0,_n1y,z,0)), 1>=(_img)._width?(_img).width()-1:1); (_n1x<(_img).width() && ( (I[2] = (T)(_img)(_n1x,_p1y,z,0)), (I[5] = (T)(_img)(_n1x,y,z,0)), (I[8] = (T)(_img)(_n1x,_n1y,z,0)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
                  const Ttfloat N = M*(I[0]*I[0] + I[1]*I[1] + I[2]*I[2] +
                                       I[3]*I[3] + I[4]*I[4] + I[5]*I[5] +
                                       I[6]*I[6] + I[7]*I[7] + I[8]*I[8]);
                  *(ptrd++) = (Ttfloat)(N?(I[0]*_mask[0] + I[1]*_mask[1] + I[2]*_mask[2] +
                                           I[3]*_mask[3] + I[4]*_mask[4] + I[5]*_mask[5] +
                                           I[6]*_mask[6] + I[7]*_mask[7] + I[8]*_mask[8])/std::sqrt(N):0);
                }
              } else for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _p1y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1; _n1y<(int)((_img)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(_img)(_p1x,_p1y,z,0)), (I[3] = I[4] = (T)(_img)(0,y,z,0)), (I[6] = I[7] = (T)(_img)(0,_n1y,z,0)), 1>=(_img)._width?(_img).width()-1:1); (_n1x<(_img).width() && ( (I[2] = (T)(_img)(_n1x,_p1y,z,0)), (I[5] = (T)(_img)(_n1x,y,z,0)), (I[8] = (T)(_img)(_n1x,_n1y,z,0)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x)
                       *(ptrd++) = (Ttfloat)(I[0]*_mask[0] + I[1]*_mask[1] + I[2]*_mask[2] +
                                             I[3]*_mask[3] + I[4]*_mask[4] + I[5]*_mask[5] +
                                             I[6]*_mask[6] + I[7]*_mask[7] + I[8]*_mask[8]);
            }
          } break;
          case 2 : {
            T I[4] = { 0 };
            for (int c = 0; c<(int)((res)._spectrum); ++c) {
              const CImg<T> _img = get_shared_channel(c%_spectrum);
              const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
              if (is_normalized) {
                const Ttfloat _M = (Ttfloat)_mask.magnitude(2), M = _M*_M;
                for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1; _n1y<(int)((_img)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = (int)( (I[0] = (T)(_img)(0,y,z,0)), (I[2] = (T)(_img)(0,_n1y,z,0)), 1>=(_img)._width?(_img).width()-1:1); (_n1x<(_img).width() && ( (I[1] = (T)(_img)(_n1x,y,z,0)), (I[3] = (T)(_img)(_n1x,_n1y,z,0)),1)) || x==--_n1x; I[0] = I[1], I[2] = I[3], ++x, ++_n1x) {
                  const Ttfloat N = M*(I[0]*I[0] + I[1]*I[1] +
                                       I[2]*I[2] + I[3]*I[3]);
                  *(ptrd++) = (Ttfloat)(N?(I[0]*_mask[0] + I[1]*_mask[1] +
                                           I[2]*_mask[2] + I[3]*_mask[3])/std::sqrt(N):0);
                }
              } else for (int z = 0; z<(int)((_img)._depth); ++z) for (int y = 0, _n1y = 1>=((_img)._height)?(int)((_img)._height)-1:1; _n1y<(int)((_img)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = (int)( (I[0] = (T)(_img)(0,y,z,0)), (I[2] = (T)(_img)(0,_n1y,z,0)), 1>=(_img)._width?(_img).width()-1:1); (_n1x<(_img).width() && ( (I[1] = (T)(_img)(_n1x,y,z,0)), (I[3] = (T)(_img)(_n1x,_n1y,z,0)),1)) || x==--_n1x; I[0] = I[1], I[2] = I[3], ++x, ++_n1x)
                       *(ptrd++) = (Ttfloat)(I[0]*_mask[0] + I[1]*_mask[1] +
                                             I[2]*_mask[2] + I[3]*_mask[3]);
            }
          } break;
          case 1 :
            if (is_normalized) res.fill(1);
            else for (int c = 0; c<(int)((res)._spectrum); ++c) {
                const CImg<T> _img = get_shared_channel(c%_spectrum);
                const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
                res.get_shared_channel(c).assign(_img)*=_mask[0];
              }
            break;
          }
        }
      } else {
        const int
          mx2 = mask.width()/2, my2 = mask.height()/2, mz2 = mask.depth()/2,
          mx1 = mx2 - 1 + (mask.width()%2), my1 = my2 - 1 + (mask.height()%2), mz1 = mz2 - 1 + (mask.depth()%2),
          mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2;



        for (int c = 0; c<(int)((res)._spectrum); ++c) {
          const CImg<T> _img = get_shared_channel(c%_spectrum);
          const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
          if (is_normalized) {
            const Ttfloat _M = (Ttfloat)_mask.magnitude(2), M = _M*_M;



            for (int z = mz1; z<mze; ++z)
              for (int y = my1; y<mye; ++y)
                for (int x = mx1; x<mxe; ++x) {
                  Ttfloat val = 0, N = 0;
                  for (int zm = -mz1; zm<=mz2; ++zm)
                    for (int ym = -my1; ym<=my2; ++ym)
                      for (int xm = -mx1; xm<=mx2; ++xm) {
                        const Ttfloat _val = (Ttfloat)_img(x+xm,y+ym,z+zm);
                        val+=_val*_mask(mx1+xm,my1+ym,mz1+zm);
                        N+=_val*_val;
                      }
                  N*=M;
                  res(x,y,z,c) = (Ttfloat)(N?val/std::sqrt(N):0);
                }
            if (boundary_conditions)



              for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
                for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                  Ttfloat val = 0, N = 0;
                  for (int zm = -mz1; zm<=mz2; ++zm)
                    for (int ym = -my1; ym<=my2; ++ym)
                      for (int xm = -mx1; xm<=mx2; ++xm) {
                        const Ttfloat _val = (Ttfloat)_img._atXYZ(x+xm,y+ym,z+zm);
                        val+=_val*_mask(mx1+xm,my1+ym,mz1+zm);
                        N+=_val*_val;
                      }
                  N*=M;
                  res(x,y,z,c) = (Ttfloat)(N?val/std::sqrt(N):0);
                }
            else



              for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
                for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                  Ttfloat val = 0, N = 0;
                  for (int zm = -mz1; zm<=mz2; ++zm)
                    for (int ym = -my1; ym<=my2; ++ym)
                      for (int xm = -mx1; xm<=mx2; ++xm) {
                        const Ttfloat _val = (Ttfloat)_img.atXYZ(x+xm,y+ym,z+zm,0,0);
                        val+=_val*_mask(mx1+xm,my1+ym,mz1+zm);
                        N+=_val*_val;
                      }
                  N*=M;
                  res(x,y,z,c) = (Ttfloat)(N?val/std::sqrt(N):0);
                }
          } else {



            for (int z = mz1; z<mze; ++z)
              for (int y = my1; y<mye; ++y)
                for (int x = mx1; x<mxe; ++x) {
                  Ttfloat val = 0;
                  for (int zm = -mz1; zm<=mz2; ++zm)
                    for (int ym = -my1; ym<=my2; ++ym)
                      for (int xm = -mx1; xm<=mx2; ++xm)
                        val+=_img(x+xm,y+ym,z+zm)*_mask(mx1+xm,my1+ym,mz1+zm);
                  res(x,y,z,c) = (Ttfloat)val;
                }
            if (boundary_conditions)



              for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
                for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                  Ttfloat val = 0;
                  for (int zm = -mz1; zm<=mz2; ++zm)
                    for (int ym = -my1; ym<=my2; ++ym)
                      for (int xm = -mx1; xm<=mx2; ++xm)
                        val+=_img._atXYZ(x+xm,y+ym,z+zm)*_mask(mx1+xm,my1+ym,mz1+zm);
                  res(x,y,z,c) = (Ttfloat)val;
                }
            else



              for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
                for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                  Ttfloat val = 0;
                  for (int zm = -mz1; zm<=mz2; ++zm)
                    for (int ym = -my1; ym<=my2; ++ym)
                      for (int xm = -mx1; xm<=mx2; ++xm)
                        val+=_img.atXYZ(x+xm,y+ym,z+zm,0,0)*_mask(mx1+xm,my1+ym,mz1+zm);
                  res(x,y,z,c) = (Ttfloat)val;
                }
          }
        }
      }
      return res;
    }
# 24796 "../src/CImg.h"
    template<typename t>
    CImg<T>& convolve(const CImg<t>& mask, const unsigned int boundary_conditions=1, const bool is_normalized=false) {
      if (is_empty() || !mask) return *this;
      return get_convolve(mask,boundary_conditions,is_normalized).move_to(*this);
    }


    template<typename t>
    CImg<typename cimg::superset2<T,t,float>::type> get_convolve(const CImg<t>& mask, const unsigned int boundary_conditions=1,
                                     const bool is_normalized=false) const {
      if (is_empty() || !mask) return *this;
      return get_correlate(CImg<t>(mask._data,mask.size(),1,1,1,true).get_mirror('x').
                           resize(mask,-1),boundary_conditions,is_normalized);
    }







    template<typename t>
    CImg<T>& erode(const CImg<t>& mask, const unsigned int boundary_conditions=1,
                   const bool is_normalized=false) {
      if (is_empty() || !mask) return *this;
      return get_erode(mask,boundary_conditions,is_normalized).move_to(*this);
    }


    template<typename t>
    CImg<typename cimg::superset<T,t>::type> get_erode(const CImg<t>& mask, const unsigned int boundary_conditions=1,
                             const bool is_normalized=false) const {
      if (is_empty() || !mask) return *this;
      typedef typename cimg::superset<T,t>::type Tt;
      CImg<Tt> res(_width,_height,_depth,cimg::max(_spectrum,mask._spectrum));
      const int
        mx2 = mask.width()/2, my2 = mask.height()/2, mz2 = mask.depth()/2,
        mx1 = mx2 - 1 + (mask.width()%2), my1 = my2 - 1 + (mask.height()%2), mz1 = mz2 - 1 + (mask.depth()%2),
        mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2;



      for (int c = 0; c<(int)((*this)._spectrum); ++c) {
        const CImg<T> _img = get_shared_channel(c%_spectrum);
        const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
        if (is_normalized) {



          for (int z = mz1; z<mze; ++z)
            for (int y = my1; y<mye; ++y)
              for (int x = mx1; x<mxe; ++x) {
                Tt min_val = cimg::type<Tt>::max();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const t mval = _mask(mx1+xm,my1+ym,mz1+zm);
                      const Tt cval = (Tt)(_img(x+xm,y+ym,z+zm) + mval);
                      if (mval && cval<min_val) min_val = cval;
                    }
                res(x,y,z,c) = min_val;
              }
          if (boundary_conditions)



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
              for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                Tt min_val = cimg::type<Tt>::max();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const t mval = _mask(mx1+xm,my1+ym,mz1+zm);
                      const Tt cval = (Tt)(_img._atXYZ(x+xm,y+ym,z+zm) + mval);
                      if (mval && cval<min_val) min_val = cval;
                    }
                res(x,y,z,c) = min_val;
              }
          else



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
              for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                Tt min_val = cimg::type<Tt>::max();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const t mval = _mask(mx1+xm,my1+ym,mz1+zm);
                      const Tt cval = (Tt)(_img.atXYZ(x+xm,y+ym,z+zm,0,0) + mval);
                      if (mval && cval<min_val) min_val = cval;
                    }
                res(x,y,z,c) = min_val;
              }

        } else {



          for (int z = mz1; z<mze; ++z)
            for (int y = my1; y<mye; ++y)
              for (int x = mx1; x<mxe; ++x) {
                Tt min_val = cimg::type<Tt>::max();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const Tt cval = (Tt)_img(x+xm,y+ym,z+zm);
                      if (_mask(mx1+xm,my1+ym,mz1+zm) && cval<min_val) min_val = cval;
                    }
                res(x,y,z,c) = min_val;
              }
          if (boundary_conditions)



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
              for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                Tt min_val = cimg::type<Tt>::max();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const T cval = (Tt)_img._atXYZ(x+xm,y+ym,z+zm);
                      if (_mask(mx1+xm,my1+ym,mz1+zm) && cval<min_val) min_val = cval;
                    }
                res(x,y,z,c) = min_val;
              }
          else



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
              for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                Tt min_val = cimg::type<Tt>::max();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const T cval = (Tt)_img.atXYZ(x+xm,y+ym,z+zm,0,0);
                      if (_mask(mx1+xm,my1+ym,mz1+zm) && cval<min_val) min_val = cval;
                    }
                res(x,y,z,c) = min_val;
              }
        }
      }
      return res;
    }







    CImg<T>& erode(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) {
      if (is_empty() || (sx==1 && sy==1 && sz==1)) return *this;
      if (sx>1 && _width>1) {
        const int L = width(), off = 1, s = (int)sx, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1, s2 = _s2>L?L:_s2;
        CImg<T> buf(L);



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
          T *const ptrdb = buf._data, *ptrd = buf._data, *const ptrde = buf._data + L - 1;
          const T *const ptrsb = data(0,y,z,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
          T cur = *ptrs; ptrs+=off; bool is_first = true;
          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
            const T val = *ptrs; ptrs+=off; if (val<=cur) { cur = val; is_first = false; }}
          *(ptrd++) = cur;
          if (ptrs>=ptrse) {
            T *pd = data(0,y,z,c); cur = cimg::min(cur,*ptrse); for (int x = 0; x<(int)((buf)._width); ++x) { *pd = cur; pd+=off; }
          } else {
            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
              const T val = *ptrs; if (ptrs<ptrse) ptrs+=off; if (val<=cur) { cur = val; is_first = false; }
              *(ptrd++) = cur;
            }
            for (int p = L - s - 1; p>0; --p) {
              const T val = *ptrs; ptrs+=off;
              if (is_first) {
                const T *nptrs = ptrs - off; cur = val;
                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
              *(ptrd++) = cur;
            }
            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
            }
            *(ptrd--) = cur;
            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
            }
            T *pd = data(0,y,z,c); for (T *ps = (buf)._data, *_maxps = (buf)._data + (buf).size(); ps<_maxps; ++ps) { *pd = *ps; pd+=off; }
          }
        }
      }

      if (sy>1 && _height>1) {
        const int L = height(), off = width(), s = (int)sy, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1,
          s2 = _s2>L?L:_s2;
        CImg<T> buf(L);



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x) {
          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
          const T *const ptrsb = data(x,0,z,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
          T cur = *ptrs; ptrs+=off; bool is_first = true;
          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
            const T val = *ptrs; ptrs+=off; if (val<=cur) { cur = val; is_first = false; }
          }
          *(ptrd++) = cur;
          if (ptrs>=ptrse) {
            T *pd = data(x,0,z,c); cur = cimg::min(cur,*ptrse); for (int x = 0; x<(int)((buf)._width); ++x) { *pd = cur; pd+=off; }
          } else {
            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
              const T val = *ptrs; if (ptrs<ptrse) ptrs+=off; if (val<=cur) { cur = val; is_first = false; }
              *(ptrd++) = cur;
            }
            for (int p = L - s - 1; p>0; --p) {
              const T val = *ptrs; ptrs+=off;
              if (is_first) {
                const T *nptrs = ptrs - off; cur = val;
                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
              *(ptrd++) = cur;
            }
            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
            }
            *(ptrd--) = cur;
            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
            }
            T *pd = data(x,0,z,c); for (T *ps = (buf)._data, *_maxps = (buf)._data + (buf).size(); ps<_maxps; ++ps) { *pd = *ps; pd+=off; }
          }
        }
      }

      if (sz>1 && _depth>1) {
        const int L = depth(), off = width()*height(), s = (int)sz, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1,
          s2 = _s2>L?L:_s2;
        CImg<T> buf(L);



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
          const T *const ptrsb = data(x,y,0,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
          T cur = *ptrs; ptrs+=off; bool is_first = true;
          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
            const T val = *ptrs; ptrs+=off; if (val<=cur) { cur = val; is_first = false; }
          }
          *(ptrd++) = cur;
          if (ptrs>=ptrse) {
            T *pd = data(x,y,0,c); cur = cimg::min(cur,*ptrse); for (int x = 0; x<(int)((buf)._width); ++x) { *pd = cur; pd+=off; }
          } else {
            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
              const T val = *ptrs; if (ptrs<ptrse) ptrs+=off; if (val<=cur) { cur = val; is_first = false; }
              *(ptrd++) = cur;
            }
            for (int p = L - s - 1; p>0; --p) {
              const T val = *ptrs; ptrs+=off;
              if (is_first) {
                const T *nptrs = ptrs - off; cur = val;
                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
              *(ptrd++) = cur;
            }
            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
            }
            *(ptrd--) = cur;
            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
            }
            T *pd = data(x,y,0,c); for (T *ps = (buf)._data, *_maxps = (buf)._data + (buf).size(); ps<_maxps; ++ps) { *pd = *ps; pd+=off; }
          }
        }
      }
      return *this;
    }


    CImg<T> get_erode(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) const {
      return (+*this).erode(sx,sy,sz);
    }





    CImg<T>& erode(const unsigned int s) {
      return erode(s,s,s);
    }


    CImg<T> get_erode(const unsigned int s) const {
      return (+*this).erode(s);
    }







    template<typename t>
    CImg<T>& dilate(const CImg<t>& mask, const unsigned int boundary_conditions=1,
                    const bool is_normalized=false) {
      if (is_empty() || !mask) return *this;
      return get_dilate(mask,boundary_conditions,is_normalized).move_to(*this);
    }


    template<typename t>
    CImg<typename cimg::superset<T,t>::type> get_dilate(const CImg<t>& mask, const unsigned int boundary_conditions=1,
                              const bool is_normalized=false) const {
      if (is_empty() || !mask) return *this;
      typedef typename cimg::superset<T,t>::type Tt;
      CImg<Tt> res(_width,_height,_depth,_spectrum);
      const int
        mx2 = mask.width()/2, my2 = mask.height()/2, mz2 = mask.depth()/2,
        mx1 = mx2 - 1 + (mask.width()%2), my1 = my2 - 1 + (mask.height()%2), mz1 = mz2 - 1 + (mask.depth()%2),
        mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2;



      for (int c = 0; c<(int)((*this)._spectrum); ++c) {
        const CImg<T> _img = get_shared_channel(c%_spectrum);
        const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
        if (is_normalized) {



          for (int z = mz1; z<mze; ++z)
            for (int y = my1; y<mye; ++y)
              for (int x = mx1; x<mxe; ++x) {
                Tt max_val = cimg::type<Tt>::min();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const t mval = _mask(mx1+xm,my1+ym,mz1+zm);
                      const Tt cval = (Tt)(_img(x+xm,y+ym,z+zm) - mval);
                      if (mval && cval>max_val) max_val = cval;
                    }
                res(x,y,z,c) = max_val;
              }
          if (boundary_conditions)



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
              for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                Tt max_val = cimg::type<Tt>::min();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const t mval = _mask(mx1+xm,my1+ym,mz1+zm);
                      const Tt cval = (Tt)(_img._atXYZ(x+xm,y+ym,z+zm) - mval);
                      if (mval && cval>max_val) max_val = cval;
                    }
                res(x,y,z,c) = max_val;
              }
          else



            for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y)
              for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                Tt max_val = cimg::type<Tt>::min();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const t mval = _mask(mx1+xm,my1+ym,mz1+zm);
                      const Tt cval = (Tt)(_img.atXYZ(x+xm,y+ym,z+zm,0,0) - mval);
                      if (mval && cval>max_val) max_val = cval;
                    }
                res(x,y,z,c) = max_val;
              }
        } else {



          for (int z = mz1; z<mze; ++z)
            for (int y = my1; y<mye; ++y)
              for (int x = mx1; x<mxe; ++x) {
                Tt max_val = cimg::type<Tt>::min();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const Tt cval = (Tt)_img(x+xm,y+ym,z+zm);
                      if (_mask(mx1+xm,my1+ym,mz1+zm) && cval>max_val) max_val = cval;
                    }
                res(x,y,z,c) = max_val;
              }
          if (boundary_conditions)



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
              for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                Tt max_val = cimg::type<Tt>::min();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const T cval = (Tt)_img._atXYZ(x+xm,y+ym,z+zm);
                      if (_mask(mx1+xm,my1+ym,mz1+zm) && cval>max_val) max_val = cval;
                    }
                res(x,y,z,c) = max_val;
              }
          else



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y)
              for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1-1 || x>=mxe)?++x:(x=mxe))) {
                Tt max_val = cimg::type<Tt>::min();
                for (int zm = -mz1; zm<=mz2; ++zm)
                  for (int ym = -my1; ym<=my2; ++ym)
                    for (int xm = -mx1; xm<=mx2; ++xm) {
                      const T cval = (Tt)_img.atXYZ(x+xm,y+ym,z+zm,0,0);
                      if (_mask(mx1+xm,my1+ym,mz1+zm) && cval>max_val) max_val = cval;
                    }
                res(x,y,z,c) = max_val;
              }
        }
      }
      return res;
    }







    CImg<T>& dilate(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) {
      if (is_empty() || (sx==1 && sy==1 && sz==1)) return *this;
      if (sx>1 && _width>1) {
        const int L = width(), off = 1, s = (int)sx, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1, s2 = _s2>L?L:_s2;
        CImg<T> buf(L);



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
          const T *const ptrsb = data(0,y,z,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
          T cur = *ptrs; ptrs+=off; bool is_first = true;
          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
            const T val = *ptrs; ptrs+=off; if (val>=cur) { cur = val; is_first = false; }
          }
          *(ptrd++) = cur;
          if (ptrs>=ptrse) {
            T *pd = data(0,y,z,c); cur = cimg::max(cur,*ptrse); for (int x = 0; x<(int)((buf)._width); ++x) { *pd = cur; pd+=off; }
          } else {
            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
              const T val = *ptrs; if (ptrs<ptrse) ptrs+=off; if (val>=cur) { cur = val; is_first = false; }
              *(ptrd++) = cur;
            }
            for (int p = L - s - 1; p>0; --p) {
              const T val = *ptrs; ptrs+=off;
              if (is_first) {
                const T *nptrs = ptrs - off; cur = val;
                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
              *(ptrd++) = cur;
            }
            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
            }
            *(ptrd--) = cur;
            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
            }
            T *pd = data(0,y,z,c); for (T *ps = (buf)._data, *_maxps = (buf)._data + (buf).size(); ps<_maxps; ++ps) { *pd = *ps; pd+=off; }
          }
        }
      }

      if (sy>1 && _height>1) {
        const int L = height(), off = width(), s = (int)sy, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1,
          s2 = _s2>L?L:_s2;
        CImg<T> buf(L);



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x) {
          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
          const T *const ptrsb = data(x,0,z,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
          T cur = *ptrs; ptrs+=off; bool is_first = true;
          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
            const T val = *ptrs; ptrs+=off; if (val>=cur) { cur = val; is_first = false; }
          }
          *(ptrd++) = cur;
          if (ptrs>=ptrse) {
            T *pd = data(x,0,z,c); cur = cimg::max(cur,*ptrse); for (int x = 0; x<(int)((buf)._width); ++x) { *pd = cur; pd+=off; }
          } else {
            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
              const T val = *ptrs; if (ptrs<ptrse) ptrs+=off; if (val>=cur) { cur = val; is_first = false; }
              *(ptrd++) = cur;
            }
            for (int p = L - s - 1; p>0; --p) {
              const T val = *ptrs; ptrs+=off;
              if (is_first) {
                const T *nptrs = ptrs - off; cur = val;
                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
              *(ptrd++) = cur;
            }
            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
            }
            *(ptrd--) = cur;
            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
            }
            T *pd = data(x,0,z,c); for (T *ps = (buf)._data, *_maxps = (buf)._data + (buf).size(); ps<_maxps; ++ps) { *pd = *ps; pd+=off; }
          }
        }
      }

      if (sz>1 && _depth>1) {
        const int L = depth(), off = width()*height(), s = (int)sz, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1,
          s2 = _s2>L?L:_s2;
        CImg<T> buf(L);



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
          const T *const ptrsb = data(x,y,0,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
          T cur = *ptrs; ptrs+=off; bool is_first = true;
          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
            const T val = *ptrs; ptrs+=off; if (val>=cur) { cur = val; is_first = false; }
          }
          *(ptrd++) = cur;
          if (ptrs>=ptrse) {
            T *pd = data(x,y,0,c); cur = cimg::max(cur,*ptrse); for (int x = 0; x<(int)((buf)._width); ++x) { *pd = cur; pd+=off; }
          } else {
            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
              const T val = *ptrs; if (ptrs<ptrse) ptrs+=off; if (val>=cur) { cur = val; is_first = false; }
              *(ptrd++) = cur;
            }
            for (int p = L - s - 1; p>0; --p) {
              const T val = *ptrs; ptrs+=off;
              if (is_first) {
                const T *nptrs = ptrs - off; cur = val;
                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
              *(ptrd++) = cur;
            }
            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
            }
            *(ptrd--) = cur;
            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
            }
            T *pd = data(x,y,0,c); for (T *ps = (buf)._data, *_maxps = (buf)._data + (buf).size(); ps<_maxps; ++ps) { *pd = *ps; pd+=off; }
          }
        }
      }
      return *this;
    }


    CImg<T> get_dilate(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) const {
      return (+*this).dilate(sx,sy,sz);
    }





    CImg<T>& dilate(const unsigned int s) {
      return dilate(s,s,s);
    }


    CImg<T> get_dilate(const unsigned int s) const {
      return (+*this).dilate(s);
    }
# 25396 "../src/CImg.h"
    template<typename t>
    CImg<T>& watershed(const CImg<t>& priority, const bool fill_lines=true) {
      if (is_empty()) return *this;
      if (!is_sameXYZ(priority))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "watershed(): image instance and specified priority (%u,%u,%u,%u,%p) "
                                    "have different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    priority._width,priority._height,priority._depth,priority._spectrum,priority._data);
      if (_spectrum!=1) {
        for (int c = 0; c<(int)((*this)._spectrum); ++c)
          get_shared_channel(c).watershed(priority.get_shared_channel(c%priority._spectrum),fill_lines);
        return *this;
      }

      CImg<boolT> is_queued(_width,_height,_depth,1,0);
      CImg<typename cimg::superset2<T,t,int>::type> Q;
      unsigned int sizeQ = 0;


      const T *ptrs = _data;
      for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) if (*(ptrs++)) {
        if (x-1>=0 && !(*this)(x-1,y,z)) Q._priority_queue_insert(is_queued,sizeQ,priority(x-1,y,z),x-1,y,z);
        if (x+1<width() && !(*this)(x+1,y,z)) Q._priority_queue_insert(is_queued,sizeQ,priority(x+1,y,z),x+1,y,z);
        if (y-1>=0 && !(*this)(x,y-1,z)) Q._priority_queue_insert(is_queued,sizeQ,priority(x,y-1,z),x,y-1,z);
        if (y+1<height() && !(*this)(x,y+1,z)) Q._priority_queue_insert(is_queued,sizeQ,priority(x,y+1,z),x,y+1,z);
        if (z-1>=0 && !(*this)(x,y,z-1)) Q._priority_queue_insert(is_queued,sizeQ,priority(x,y,z-1),x,y,z-1);
        if (z+1<depth() && !(*this)(x,y,z+1)) Q._priority_queue_insert(is_queued,sizeQ,priority(x,y,z+1),x,y,z+1);
      }


      while (sizeQ) {


        const int x = (int)Q(0,1), y = (int)Q(0,2), z = (int)Q(0,3);
        Q._priority_queue_remove(sizeQ);


        bool is_same_label = true;
        unsigned int label = 0;
        if (x-1>=0) {
          if ((*this)(x-1,y,z)) {
            if (!label) label = (unsigned int)(*this)(x-1,y,z);
            else if (label!=(*this)(x-1,y,z)) is_same_label = false;
          } else Q._priority_queue_insert(is_queued,sizeQ,priority(x-1,y,z),x-1,y,z);
        }
        if (x+1<width()) {
          if ((*this)(x+1,y,z)) {
            if (!label) label = (unsigned int)(*this)(x+1,y,z);
            else if (label!=(*this)(x+1,y,z)) is_same_label = false;
          } else Q._priority_queue_insert(is_queued,sizeQ,priority(x+1,y,z),x+1,y,z);
        }
        if (y-1>=0) {
          if ((*this)(x,y-1,z)) {
            if (!label) label = (unsigned int)(*this)(x,y-1,z);
            else if (label!=(*this)(x,y-1,z)) is_same_label = false;
          } else Q._priority_queue_insert(is_queued,sizeQ,priority(x,y-1,z),x,y-1,z);
        }
        if (y+1<height()) {
          if ((*this)(x,y+1,z)) {
            if (!label) label = (unsigned int)(*this)(x,y+1,z);
            else if (label!=(*this)(x,y+1,z)) is_same_label = false;
          } else Q._priority_queue_insert(is_queued,sizeQ,priority(x,y+1,z),x,y+1,z);
        }
        if (z-1>=0) {
          if ((*this)(x,y,z-1)) {
            if (!label) label = (unsigned int)(*this)(x,y,z-1);
            else if (label!=(*this)(x,y,z-1)) is_same_label = false;
          } else Q._priority_queue_insert(is_queued,sizeQ,priority(x,y,z-1),x,y,z-1);
        }
        if (z+1<depth()) {
          if ((*this)(x,y,z+1)) {
            if (!label) label = (unsigned int)(*this)(x,y,z+1);
            else if (label!=(*this)(x,y,z+1)) is_same_label = false;
          } else Q._priority_queue_insert(is_queued,sizeQ,priority(x,y,z+1),x,y,z+1);
        }
        if (is_same_label) (*this)(x,y,z) = (T)label;
      }


      if (fill_lines) {


        is_queued = false;
        const T *ptrs = _data;
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) if (!*(ptrs++) &&
                                     ((x-1>=0 && (*this)(x-1,y,z)) || (x+1<width() && (*this)(x+1,y,z)) ||
                                      (y-1>=0 && (*this)(x,y-1,z)) || (y+1<height() && (*this)(x,y+1,z)) ||
                                      (z-1>=0 && (*this)(x,y,z-1)) || (z+1>depth() && (*this)(x,y,z+1))))
          Q._priority_queue_insert(is_queued,sizeQ,priority(x,y,z),x,y,z);


        while (sizeQ) {
          const int x = (int)Q(0,1), y = (int)Q(0,2), z = (int)Q(0,3);
          Q._priority_queue_remove(sizeQ);
          t pmax = cimg::type<t>::min();
          int xmax = 0, ymax = 0, zmax = 0;
          if (x-1>=0) {
            if ((*this)(x-1,y,z)) {
              if (priority(x-1,y,z)>pmax) { pmax = priority(x-1,y,z); xmax = x-1; ymax = y; zmax = z; }
            } else Q._priority_queue_insert(is_queued,sizeQ,priority(x-1,y,z),x-1,y,z);
          }
          if (x+1<width()) {
            if ((*this)(x+1,y,z)) {
              if (priority(x+1,y,z)>pmax) { pmax = priority(x+1,y,z); xmax = x+1; ymax = y; zmax = z; }
            } else Q._priority_queue_insert(is_queued,sizeQ,priority(x+1,y,z),x+1,y,z);
          }
          if (y-1>=0) {
            if ((*this)(x,y-1,z)) {
              if (priority(x,y-1,z)>pmax) { pmax = priority(x,y-1,z); xmax = x; ymax = y-1; zmax = z; }
            } else Q._priority_queue_insert(is_queued,sizeQ,priority(x,y-1,z),x,y-1,z);
          }
          if (y+1<height()) {
            if ((*this)(x,y+1,z)) {
              if (priority(x,y+1,z)>pmax) { pmax = priority(x,y+1,z); xmax = x; ymax = y+1; zmax = z; }
            } else Q._priority_queue_insert(is_queued,sizeQ,priority(x,y+1,z),x,y+1,z);
          }
          if (z-1>=0) {
            if ((*this)(x,y,z-1)) {
              if (priority(x,y,z-1)>pmax) { pmax = priority(x,y,z-1); xmax = x; ymax = y; zmax = z-1; }
            } else Q._priority_queue_insert(is_queued,sizeQ,priority(x,y,z-1),x,y,z-1);
          }
          if (z+1<depth()) {
            if ((*this)(x,y,z+1)) {
              if (priority(x,y,z+1)>pmax) { pmax = priority(x,y,z+1); xmax = x; ymax = y; zmax = z+1; }
            } else Q._priority_queue_insert(is_queued,sizeQ,priority(x,y,z+1),x,y,z+1);
          }
          (*this)(x,y,z) = (*this)(xmax,ymax,zmax);
        }
      }
      return *this;
    }


    template<typename t>
    CImg<T> get_watershed(const CImg<t>& priority, const bool fill_lines=true) const {
      return (+*this).watershed(priority,fill_lines);
    }


    template<typename t>
    bool _priority_queue_insert(CImg<boolT>& is_queued, unsigned int& siz, const t value,
                                const unsigned int x, const unsigned int y, const unsigned int z) {
      if (is_queued(x,y,z)) return false;
      is_queued(x,y,z) = true;
      if (++siz>=_width) { if (!is_empty()) resize(_width*2,4,1,1,0); else assign(64,4); }
      (*this)(siz-1,0) = (T)value; (*this)(siz-1,1) = (T)x; (*this)(siz-1,2) = (T)y; (*this)(siz-1,3) = (T)z;
      for (unsigned int pos = siz - 1, par = 0; pos && value>(*this)(par=(pos+1)/2-1,0); pos = par) {
        cimg::swap((*this)(pos,0),(*this)(par,0)); cimg::swap((*this)(pos,1),(*this)(par,1));
        cimg::swap((*this)(pos,2),(*this)(par,2)); cimg::swap((*this)(pos,3),(*this)(par,3));
      }
      return true;
    }

    CImg<T>& _priority_queue_remove(unsigned int& siz) {
      (*this)(0,0) = (*this)(--siz,0); (*this)(0,1) = (*this)(siz,1);
      (*this)(0,2) = (*this)(siz,2); (*this)(0,3) = (*this)(siz,3);
      const float value = (*this)(0,0);
      for (unsigned int pos = 0, left = 0, right = 0;
           ((right=2*(pos+1),(left=right-1))<siz && value<(*this)(left,0)) || (right<siz && value<(*this)(right,0));) {
        if (right<siz) {
          if ((*this)(left,0)>(*this)(right,0)) {
            cimg::swap((*this)(pos,0),(*this)(left,0)); cimg::swap((*this)(pos,1),(*this)(left,1));
            cimg::swap((*this)(pos,2),(*this)(left,2)); cimg::swap((*this)(pos,3),(*this)(left,3));
            pos = left;
          } else {
            cimg::swap((*this)(pos,0),(*this)(right,0)); cimg::swap((*this)(pos,1),(*this)(right,1));
            cimg::swap((*this)(pos,2),(*this)(right,2)); cimg::swap((*this)(pos,3),(*this)(right,3));
            pos = right;
          }
        } else {
          cimg::swap((*this)(pos,0),(*this)(left,0)); cimg::swap((*this)(pos,1),(*this)(left,1));
          cimg::swap((*this)(pos,2),(*this)(left,2)); cimg::swap((*this)(pos,3),(*this)(left,3));
          pos = left;
        }
      }
      return *this;
    }
# 25582 "../src/CImg.h"
    CImg<T>& deriche(const float sigma, const int order=0, const char axis='x', const bool boundary_conditions=true) {
# 25602 "../src/CImg.h"
      const char naxis = cimg::uncase(axis);
      const float nsigma = sigma>=0?sigma:-sigma*(naxis=='x'?_width:naxis=='y'?_height:naxis=='z'?_depth:_spectrum)/100;
      if (is_empty() || (nsigma<0.1f && !order)) return *this;
      const float
        nnsigma = nsigma<0.1f?0.1f:nsigma,
        alpha = 1.695f/nnsigma,
        ema = (float)std::exp(-alpha),
        ema2 = (float)std::exp(-2*alpha),
        b1 = -2*ema,
        b2 = ema2;
      float a0 = 0, a1 = 0, a2 = 0, a3 = 0, coefp = 0, coefn = 0;
      switch (order) {
      case 0 : {
        const float k = (1-ema)*(1-ema)/(1+2*alpha*ema-ema2);
        a0 = k;
        a1 = k*(alpha-1)*ema;
        a2 = k*(alpha+1)*ema;
        a3 = -k*ema2;
      } break;
      case 1 : {
        const float k = -(1-ema)*(1-ema)*(1-ema)/(2*(ema+1)*ema);
        a0 = a3 = 0;
        a1 = k*ema;
        a2 = -a1;
      } break;
      case 2 : {
        const float
          ea = (float)std::exp(-alpha),
          k = -(ema2-1)/(2*alpha*ema),
          kn = (-2*(-1+3*ea-3*ea*ea+ea*ea*ea)/(3*ea+1+3*ea*ea+ea*ea*ea));
        a0 = kn;
        a1 = -kn*(1+k*alpha)*ema;
        a2 = kn*(1-k*alpha)*ema;
        a3 = -kn*ema2;
      } break;
      default :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "deriche(): Invalid specified filter order %u "
                                    "(should be { 0=smoothing | 1=1st-derivative | 2=2nd-derivative }).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    order);
      }
      coefp = (a0+a1)/(1+b1+b2);
      coefn = (a2+a3)/(1+b1+b2);
      switch (naxis) {
      case 'x' : {
        const int N = _width;
        const unsigned long off = 1U;



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { T *ptrX = data(0,y,z,c); CImg<Tfloat> Y(N); Tfloat *ptrY = Y._data, yb = 0, yp = 0; T xp = (T)0; if (boundary_conditions) { xp = *ptrX; yb = yp = (Tfloat)(coefp*xp); } for (int m = 0; m<N; ++m) { const T xc = *ptrX; ptrX+=off; const Tfloat yc = *(ptrY++) = (Tfloat)(a0*xc + a1*xp - b1*yp - b2*yb); xp = xc; yb = yp; yp = yc; } T xn = (T)0, xa = (T)0; Tfloat yn = 0, ya = 0; if (boundary_conditions) { xn = xa = *(ptrX-off); yn = ya = (Tfloat)coefn*xn; } for (int n = N-1; n>=0; --n) { const T xc = *(ptrX-=off); const Tfloat yc = (Tfloat)(a2*xn + a3*xa - b1*yn - b2*ya); xa = xn; xn = xc; ya = yn; yn = yc; *ptrX = (T)(*(--ptrY)+yc); }; }
      } break;
      case 'y' : {
        const int N = _height;
        const unsigned long off = (unsigned long)_width;



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x) { T *ptrX = data(x,0,z,c); CImg<Tfloat> Y(N); Tfloat *ptrY = Y._data, yb = 0, yp = 0; T xp = (T)0; if (boundary_conditions) { xp = *ptrX; yb = yp = (Tfloat)(coefp*xp); } for (int m = 0; m<N; ++m) { const T xc = *ptrX; ptrX+=off; const Tfloat yc = *(ptrY++) = (Tfloat)(a0*xc + a1*xp - b1*yp - b2*yb); xp = xc; yb = yp; yp = yc; } T xn = (T)0, xa = (T)0; Tfloat yn = 0, ya = 0; if (boundary_conditions) { xn = xa = *(ptrX-off); yn = ya = (Tfloat)coefn*xn; } for (int n = N-1; n>=0; --n) { const T xc = *(ptrX-=off); const Tfloat yc = (Tfloat)(a2*xn + a3*xa - b1*yn - b2*ya); xa = xn; xn = xc; ya = yn; yn = yc; *ptrX = (T)(*(--ptrY)+yc); }; }
      } break;
      case 'z' : {
        const int N = _depth;
        const unsigned long off = (unsigned long)_width*_height;



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { T *ptrX = data(x,y,0,c); CImg<Tfloat> Y(N); Tfloat *ptrY = Y._data, yb = 0, yp = 0; T xp = (T)0; if (boundary_conditions) { xp = *ptrX; yb = yp = (Tfloat)(coefp*xp); } for (int m = 0; m<N; ++m) { const T xc = *ptrX; ptrX+=off; const Tfloat yc = *(ptrY++) = (Tfloat)(a0*xc + a1*xp - b1*yp - b2*yb); xp = xc; yb = yp; yp = yc; } T xn = (T)0, xa = (T)0; Tfloat yn = 0, ya = 0; if (boundary_conditions) { xn = xa = *(ptrX-off); yn = ya = (Tfloat)coefn*xn; } for (int n = N-1; n>=0; --n) { const T xc = *(ptrX-=off); const Tfloat yc = (Tfloat)(a2*xn + a3*xa - b1*yn - b2*ya); xa = xn; xn = xc; ya = yn; yn = yc; *ptrX = (T)(*(--ptrY)+yc); }; }
      } break;
      default : {
        const int N = _spectrum;
        const unsigned long off = (unsigned long)_width*_height*_depth;



        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) { T *ptrX = data(x,y,z,0); CImg<Tfloat> Y(N); Tfloat *ptrY = Y._data, yb = 0, yp = 0; T xp = (T)0; if (boundary_conditions) { xp = *ptrX; yb = yp = (Tfloat)(coefp*xp); } for (int m = 0; m<N; ++m) { const T xc = *ptrX; ptrX+=off; const Tfloat yc = *(ptrY++) = (Tfloat)(a0*xc + a1*xp - b1*yp - b2*yb); xp = xc; yb = yp; yp = yc; } T xn = (T)0, xa = (T)0; Tfloat yn = 0, ya = 0; if (boundary_conditions) { xn = xa = *(ptrX-off); yn = ya = (Tfloat)coefn*xn; } for (int n = N-1; n>=0; --n) { const T xc = *(ptrX-=off); const Tfloat yc = (Tfloat)(a2*xn + a3*xa - b1*yn - b2*ya); xa = xn; xn = xc; ya = yn; yn = yc; *ptrX = (T)(*(--ptrY)+yc); }; }
      }
      }
      return *this;
    }


    CImg<Tfloat> get_deriche(const float sigma, const int order=0, const char axis='x',
                             const bool boundary_conditions=true) const {
      return CImg<Tfloat>(*this,false).deriche(sigma,order,axis,boundary_conditions);
    }
# 25700 "../src/CImg.h"
    template <int K>
    static void _cimg_recursive_apply(T *data, const Tfloat filter[], const int N, const unsigned long off,
                                      const int order, const bool boundary_conditions) {
      Tfloat val[K];
      switch (order) {
      case 0 : {
        for (int pass = 0; pass<2; ++pass) {
          for (int k = 1; k<K; ++k) val[k] = (Tfloat)(boundary_conditions?*data:0);
          for (int n = 0; n<N; ++n) {
            val[0] = (Tfloat)(*data)*filter[0];
            for (int k = 1; k<K; ++k) val[0]+=val[k]*filter[k];
            *data = (T)val[0];
            if (!pass) data+=off; else data-=off;
            for (int k = K-1; k>0; --k) val[k] = val[k-1];
          }
          if (!pass) data-=off;
        }
      } break;
      case 1 : {
        Tfloat x[3];
        for (int pass = 0; pass<2; ++pass) {
          for (int k = 0; k<3; ++k) x[k] = (Tfloat)(boundary_conditions?*data:0);
          for (int k = 0; k<K; ++k) val[k] = 0;
          for (int n = 0; n<N-1; ++n) {
            if (!pass) {
              x[0] = (Tfloat)*(data+off);
              val[0] = 0.5f * (x[0] - x[2])*filter[0];
            } else val[0] = (Tfloat)(*data)*filter[0];
            for (int k = 1; k<K; ++k) val[0]+=val[k]*filter[k];
            *data = (T)val[0];
            if (!pass) {
              data+=off;
              for (int k = 2; k>0; --k) x[k] = x[k-1];
            } else data-=off;
            for (int k = K-1; k>0; --k) val[k] = val[k-1];
          }
          *data = (T)0;
        }
      } break;
      case 2: {
        Tfloat x[3];
        for (int pass = 0; pass<2; ++pass) {
          for (int k = 0; k<3; ++k) x[k] = (Tfloat)(boundary_conditions?*data:0);
          for (int k = 0; k<K; ++k) val[k] = 0;
          for (int n = 0; n<N-1; ++n) {
            if (!pass) { x[0] = (Tfloat)*(data+off); val[0] = (x[1] - x[2])*filter[0]; }
            else { x[0] = (Tfloat)*(data-off); val[0] = (x[2] - x[1])*filter[0]; }
            for (int k = 1; k<K; ++k) val[0]+=val[k]*filter[k];
            *data = (T)val[0];
            if (!pass) data+=off; else data-=off;
            for (int k = 2; k>0; --k) x[k] = x[k-1];
            for (int k = K-1; k>0; --k) val[k] = val[k-1];
          }
          *data = (T)0;
        }
      } break;
      case 3: {
        Tfloat x[3];
        for (int pass = 0; pass<2; ++pass) {
          for (int k = 0; k<3; ++k) x[k] = (Tfloat)(boundary_conditions?*data:0);
          for (int k = 0; k<K; ++k) val[k] = 0;
          for (int n = 0; n<N-1; ++n) {
            if (!pass) { x[0] = (Tfloat)*(data+off); val[0] = (x[0] - 2*x[1] + x[2])*filter[0]; }
            else { x[0] = (Tfloat)*(data-off); val[0] = 0.5f*(x[2] - x[0])*filter[0]; }
            for (int k = 1; k<K; ++k) val[0]+=val[k]*filter[k];
            *data = (T)val[0];
            if (!pass) data+=off; else data-=off;
            for (int k = 2; k>0; --k) x[k] = x[k-1];
            for (int k = K-1; k>0; --k) val[k] = val[k-1];
          }
          *data = (T)0;
        }
      } break;
      }
    }
# 25788 "../src/CImg.h"
    CImg<T>& vanvliet(const float sigma, const int order, const char axis='x', const bool boundary_conditions=true) {
      if (is_empty()) return *this;
      const char naxis = cimg::uncase(axis);
      const float nsigma = sigma>=0?sigma:-sigma*(naxis=='x'?_width:naxis=='y'?_height:naxis=='z'?_depth:_spectrum)/100;
      if (is_empty() || (nsigma<0.1f && !order)) return *this;
      const Tfloat
        nnsigma = nsigma<0.1f?0.1f:nsigma,
        q = (Tfloat)(nnsigma<2.5?3.97156-4.14554*std::sqrt(1-0.2689*nnsigma):0.98711*nnsigma-0.96330),
        b0 = 1.57825f + 2.44413f*q + 1.4281f*q*q + 0.422205f*q*q*q,
        b1 = (2.44413f*q + 2.85619f*q*q + 1.26661f*q*q*q),
        b2 = -(1.4281f*q*q + 1.26661f*q*q*q),
        b3 = 0.422205f*q*q*q,
        B = 1.f - (b1 + b2 + b3)/b0;
      Tfloat filter[4];
      filter[0] = B; filter[1] = b1/b0; filter[2] = b2/b0; filter[3] = b3/b0;

      switch (naxis) {
      case 'x' : {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y)
          _cimg_recursive_apply<4>(data(0,y,z,c),filter,_width,1U,order,boundary_conditions);
      } break;
      case 'y' : {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x)
          _cimg_recursive_apply<4>(data(x,0,z,c),filter,_height,(unsigned long)_width,order,boundary_conditions);
      } break;
      case 'z' : {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x)
          _cimg_recursive_apply<4>(data(x,y,0,c),filter,_depth,(unsigned long)(_width*_height),
                                   order,boundary_conditions);
      } break;
      default : {



        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x)
          _cimg_recursive_apply<4>(data(x,y,z,0),filter,_spectrum,(unsigned long)(_width*_height*_depth),
                                   order,boundary_conditions);
      }
      }
      return *this;
    }


    CImg<Tfloat> get_vanvliet(const float sigma, const int order, const char axis='x',
                              const bool boundary_conditions=true) const {
      return CImg<Tfloat>(*this,false).vanvliet(sigma,order,axis,boundary_conditions);
    }
# 25857 "../src/CImg.h"
    CImg<T>& blur(const float sigma_x, const float sigma_y, const float sigma_z,
                  const bool boundary_conditions=true, const bool is_gaussian=false) {
      if (!is_empty()) {
        if (is_gaussian) {
          if (_width>1) vanvliet(sigma_x,0,'x',boundary_conditions);
          if (_height>1) vanvliet(sigma_y,0,'y',boundary_conditions);
          if (_depth>1) vanvliet(sigma_z,0,'z',boundary_conditions);
        } else {
          if (_width>1) deriche(sigma_x,0,'x',boundary_conditions);
          if (_height>1) deriche(sigma_y,0,'y',boundary_conditions);
          if (_depth>1) deriche(sigma_z,0,'z',boundary_conditions);
        }
      }
      return *this;
    }


    CImg<Tfloat> get_blur(const float sigma_x, const float sigma_y, const float sigma_z,
                          const bool boundary_conditions=true, const bool is_gaussian=false) const {
      return CImg<Tfloat>(*this,false).blur(sigma_x,sigma_y,sigma_z,boundary_conditions,is_gaussian);
    }







    CImg<T>& blur(const float sigma, const bool boundary_conditions=true, const bool is_gaussian=false) {
      const float nsigma = sigma>=0?sigma:-sigma*cimg::max(_width,_height,_depth)/100;
      return blur(nsigma,nsigma,nsigma,boundary_conditions,is_gaussian);
    }


    CImg<Tfloat> get_blur(const float sigma, const bool boundary_conditions=true, const bool is_gaussian=false) const {
      return CImg<Tfloat>(*this,false).blur(sigma,boundary_conditions,is_gaussian);
    }
# 25906 "../src/CImg.h"
    template<typename t>
    CImg<T>& blur_anisotropic(const CImg<t>& G,
                              const float amplitude=60, const float dl=0.8f, const float da=30,
                              const float gauss_prec=2, const unsigned int interpolation_type=0,
                              const bool is_fast_approx=1) {


      if (!is_sameXYZ(G) || (G._spectrum!=3 && G._spectrum!=6))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "blur_anisotropic(): Invalid specified diffusion tensor field (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    G._width,G._height,G._depth,G._spectrum,G._data);

      if (is_empty() || amplitude<=0 || dl<0) return *this;
      const bool is_3d = (G._spectrum==6);
      T val_min, val_max = max_min(val_min);

      if (da<=0) {
        CImg<Tfloat> velocity(_width,_height,_depth,_spectrum);
        for (unsigned int iteration = 0; iteration<(unsigned int)amplitude; ++iteration) {
          Tfloat *ptrd = velocity._data, veloc_max = 0;
          if (is_3d)
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
              for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
                const Tfloat
                  ixx = Incc + Ipcc - 2*Iccc,
                  ixy = (Innc + Ippc - Inpc - Ipnc)/4,
                  ixz = (Incn + Ipcp - Incp - Ipcn)/4,
                  iyy = Icnc + Icpc - 2*Iccc,
                  iyz = (Icnn + Icpp - Icnp - Icpn)/4,
                  izz = Iccn + Iccp - 2*Iccc,
                  veloc = (Tfloat)(G(x,y,z,0)*ixx + 2*G(x,y,z,1)*ixy + 2*G(x,y,z,2)*ixz +
                                   G(x,y,z,3)*iyy + 2*G(x,y,z,4)*iyz + G(x,y,z,5)*izz);
                *(ptrd++) = veloc;
                if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
              }
            }
          else
            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
              Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
              for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
                const Tfloat
                  ixx = Inc + Ipc - 2*Icc,
                  ixy = (Inn + Ipp - Inp - Ipn)/4,
                  iyy = Icn + Icp - 2*Icc,
                  veloc = (Tfloat)(G(x,y,0,0)*ixx + 2*G(x,y,0,1)*ixy + G(x,y,0,2)*iyy);
                *(ptrd++) = veloc;
                if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
              }
            }
          if (veloc_max>0) *this+=(velocity*=dl/veloc_max);
        }
      } else {
        const unsigned long whd = (unsigned long)_width*_height*_depth;
        const float sqrt2amplitude = (float)std::sqrt(2*amplitude);
        const int dx1 = width() - 1, dy1 = height() - 1, dz1 = depth() - 1;
        CImg<Tfloat> res(_width,_height,_depth,_spectrum,0), W(_width,_height,_depth,is_3d?4:3), val(_spectrum,1,1,1,0);
        int N = 0;
        if (is_3d) {
          for (float phi = (180%(int)da)/2.0f; phi<=180; phi+=da) {
            const float phir = (float)(phi*cimg::PI/180), datmp = (float)(da/std::cos(phir)),
              da2 = datmp<1?360.0f:datmp;
            for (float theta = 0; theta<360; (theta+=da2),++N) {
              const float
                thetar = (float)(theta*cimg::PI/180),
                vx = (float)(std::cos(thetar)*std::cos(phir)),
                vy = (float)(std::sin(thetar)*std::cos(phir)),
                vz = (float)std::sin(phir);
              const t
                *pa = G.data(0,0,0,0), *pb = G.data(0,0,0,1), *pc = G.data(0,0,0,2),
                *pd = G.data(0,0,0,3), *pe = G.data(0,0,0,4), *pf = G.data(0,0,0,5);
              Tfloat *pd0 = W.data(0,0,0,0), *pd1 = W.data(0,0,0,1), *pd2 = W.data(0,0,0,2), *pd3 = W.data(0,0,0,3);
              for (int zg = 0; zg<(int)((G)._depth); ++zg) for (int yg = 0; yg<(int)((G)._height); ++yg) for (int xg = 0; xg<(int)((G)._width); ++xg) {
                const t a = *(pa++), b = *(pb++), c = *(pc++), d = *(pd++), e = *(pe++), f = *(pf++);
                const float
                  u = (float)(a*vx + b*vy + c*vz),
                  v = (float)(b*vx + d*vy + e*vz),
                  w = (float)(c*vx + e*vy + f*vz),
                  n = (float)std::sqrt(1e-5+u*u+v*v+w*w),
                  dln = dl/n;
                *(pd0++) = (Tfloat)(u*dln);
                *(pd1++) = (Tfloat)(v*dln);
                *(pd2++) = (Tfloat)(w*dln);
                *(pd3++) = (Tfloat)n;
              }




              for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
                val.fill(0);
                const float
                  n = (float)W(x,y,z,3),
                  fsigma = (float)(n*sqrt2amplitude),
                  fsigma2 = 2*fsigma*fsigma,
                  length = gauss_prec*fsigma;
                float
                  S = 0,
                  X = (float)x,
                  Y = (float)y,
                  Z = (float)z;
                switch (interpolation_type) {
                case 0 : {
                  for (float l = 0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1 && Z>=0 && Z<=dz1; l+=dl) {
                    const int
                      cx = (int)(X+0.5f),
                      cy = (int)(Y+0.5f),
                      cz = (int)(Z+0.5f);
                    const float
                      u = (float)W(cx,cy,cz,0),
                      v = (float)W(cx,cy,cz,1),
                      w = (float)W(cx,cy,cz,2);
                    if (is_fast_approx) { for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)(*this)(cx,cy,cz,c); ++S; }
                    else {
                      const float coef = (float)std::exp(-l*l/fsigma2);
                      for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)(coef*(*this)(cx,cy,cz,c));
                      S+=coef;
                    }
                    X+=u; Y+=v; Z+=w;
                  }
                } break;
                case 1 : {
                  for (float l = 0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1 && Z>=0 && Z<=dz1; l+=dl) {
                    const float
                      u = (float)(W._linear_atXYZ(X,Y,Z,0)),
                      v = (float)(W._linear_atXYZ(X,Y,Z,1)),
                      w = (float)(W._linear_atXYZ(X,Y,Z,2));
                    if (is_fast_approx) { for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)_linear_atXYZ(X,Y,Z,c); ++S; }
                    else {
                      const float coef = (float)std::exp(-l*l/fsigma2);
                      for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)(coef*_linear_atXYZ(X,Y,Z,c));
                      S+=coef;
                    }
                    X+=u; Y+=v; Z+=w;
                  }
                } break;
                default : {
                  for (float l = 0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1 && Z>=0 && Z<=dz1; l+=dl) {
                    const float
                      u0 = (float)(0.5f*W._linear_atXYZ(X,Y,Z,0)),
                      v0 = (float)(0.5f*W._linear_atXYZ(X,Y,Z,1)),
                      w0 = (float)(0.5f*W._linear_atXYZ(X,Y,Z,2)),
                      u = (float)(W._linear_atXYZ(X+u0,Y+v0,Z+w0,0)),
                      v = (float)(W._linear_atXYZ(X+u0,Y+v0,Z+w0,1)),
                      w = (float)(W._linear_atXYZ(X+u0,Y+v0,Z+w0,2));
                    if (is_fast_approx) { for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)_linear_atXYZ(X,Y,Z,c); ++S; }
                    else {
                      const float coef = (float)std::exp(-l*l/fsigma2);
                      for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)(coef*_linear_atXYZ(X,Y,Z,c));
                      S+=coef;
                    }
                    X+=u; Y+=v; Z+=w;
                  }
                } break;
                }
                Tfloat *ptrd = res.data(x,y,z);
                if (S>0) for (int c = 0; c<(int)((res)._spectrum); ++c) { *ptrd+=val[c]/S; ptrd+=whd; }
                else for (int c = 0; c<(int)((res)._spectrum); ++c) { *ptrd+=(Tfloat)((*this)(x,y,z,c)); ptrd+=whd; }
              }
            }
          }
        } else {
          for (float theta = (360%(int)da)/2.0f; theta<360; (theta+=da),++N) {
            const float thetar = (float)(theta*cimg::PI/180),
              vx = (float)(std::cos(thetar)), vy = (float)(std::sin(thetar));
            const t *pa = G.data(0,0,0,0), *pb = G.data(0,0,0,1), *pc = G.data(0,0,0,2);
            Tfloat *pd0 = W.data(0,0,0,0), *pd1 = W.data(0,0,0,1), *pd2 = W.data(0,0,0,2);
            for (int yg = 0; yg<(int)((G)._height); ++yg) for (int xg = 0; xg<(int)((G)._width); ++xg) {
              const t a = *(pa++), b = *(pb++), c = *(pc++);
              const float
                u = (float)(a*vx + b*vy),
                v = (float)(b*vx + c*vy),
                n = (float)std::sqrt(1e-5+u*u+v*v),
                dln = dl/n;
              *(pd0++) = (Tfloat)(u*dln);
              *(pd1++) = (Tfloat)(v*dln);
              *(pd2++) = (Tfloat)n;
            }




            for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
              val.fill(0);
              const float
                n = (float)W(x,y,0,2),
                fsigma = (float)(n*sqrt2amplitude),
                fsigma2 = 2*fsigma*fsigma,
                length = gauss_prec*fsigma;
              float
                S = 0,
                X = (float)x,
                Y = (float)y;
              switch (interpolation_type) {
              case 0 : {
                for (float l = 0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1; l+=dl) {
                  const int
                    cx = (int)(X+0.5f),
                    cy = (int)(Y+0.5f);
                  const float
                    u = (float)W(cx,cy,0,0),
                    v = (float)W(cx,cy,0,1);
                  if (is_fast_approx) { for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)(*this)(cx,cy,0,c); ++S; }
                  else {
                    const float coef = (float)std::exp(-l*l/fsigma2);
                    for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)(coef*(*this)(cx,cy,0,c));
                    S+=coef;
                  }
                  X+=u; Y+=v;
                }
              } break;
              case 1 : {
                for (float l = 0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1; l+=dl) {
                  const float
                    u = (float)(W._linear_atXY(X,Y,0,0)),
                    v = (float)(W._linear_atXY(X,Y,0,1));
                  if (is_fast_approx) { for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)_linear_atXY(X,Y,0,c); ++S; }
                  else {
                    const float coef = (float)std::exp(-l*l/fsigma2);
                    for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)(coef*_linear_atXY(X,Y,0,c));
                    S+=coef;
                  }
                  X+=u; Y+=v;
                }
              } break;
              default : {
                for (float l = 0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1; l+=dl) {
                  const float
                    u0 = (float)(0.5f*W._linear_atXY(X,Y,0,0)),
                    v0 = (float)(0.5f*W._linear_atXY(X,Y,0,1)),
                    u = (float)(W._linear_atXY(X+u0,Y+v0,0,0)),
                    v = (float)(W._linear_atXY(X+u0,Y+v0,0,1));
                  if (is_fast_approx) { for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)_linear_atXY(X,Y,0,c); ++S; }
                  else {
                    const float coef = (float)std::exp(-l*l/fsigma2);
                    for (int c = 0; c<(int)((*this)._spectrum); ++c) val[c]+=(Tfloat)(coef*_linear_atXY(X,Y,0,c));
                    S+=coef;
                  }
                  X+=u; Y+=v;
                }
              }
              }
              Tfloat *ptrd = res.data(x,y);
              if (S>0) for (int c = 0; c<(int)((res)._spectrum); ++c) { *ptrd+=val[c]/S; ptrd+=whd; }
              else for (int c = 0; c<(int)((res)._spectrum); ++c) { *ptrd+=(Tfloat)((*this)(x,y,0,c)); ptrd+=whd; }
            }
          }
        }
        const Tfloat *ptrs = res._data;
        for (T *ptrd = (*this)._data, *_maxptrd = (*this)._data + (*this).size(); ptrd<_maxptrd; ++ptrd) {
          const Tfloat val = *(ptrs++)/N;
          *ptrd = val<val_min?val_min:(val>val_max?val_max:(T)val);
        }
      }
      return *this;
    }


    template<typename t>
    CImg<T> get_blur_anisotropic(const CImg<t>& G,
                                 const float amplitude=60, const float dl=0.8f, const float da=30,
                                 const float gauss_prec=2, const unsigned int interpolation_type=0,
                                 const bool is_fast_approx=true) const {
      return (+*this).blur_anisotropic(G,amplitude,dl,da,gauss_prec,interpolation_type,is_fast_approx);
    }
# 26187 "../src/CImg.h"
    CImg<T>& blur_anisotropic(const float amplitude, const float sharpness=0.7f, const float anisotropy=0.6f,
                              const float alpha=0.6f, const float sigma=1.1f, const float dl=0.8f, const float da=30,
                              const float gauss_prec=2, const unsigned int interpolation_type=0,
                              const bool is_fast_approx=true) {
      return blur_anisotropic(get_diffusion_tensors(sharpness,anisotropy,alpha,sigma,interpolation_type!=3),
                              amplitude,dl,da,gauss_prec,interpolation_type,is_fast_approx);
    }


    CImg<T> get_blur_anisotropic(const float amplitude, const float sharpness=0.7f, const float anisotropy=0.6f,
                                 const float alpha=0.6f, const float sigma=1.1f, const float dl=0.8f,
                                 const float da=30, const float gauss_prec=2, const unsigned int interpolation_type=0,
                                 const bool is_fast_approx=true) const {
      return (+*this).blur_anisotropic(amplitude,sharpness,anisotropy,alpha,sigma,dl,da,gauss_prec,interpolation_type,
                                       is_fast_approx);
    }
# 26218 "../src/CImg.h"
    template<typename t>
    CImg<T>& blur_bilateral(const CImg<t>& guide,
                            const float sigma_x, const float sigma_y,
                            const float sigma_z, const float sigma_r,
                            const int bgrid_x, const int bgrid_y,
                            const int bgrid_z, const int bgrid_r) {
      if (!is_sameXYZ(guide))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "blur_bilateral(): Invalid size for specified guide image (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    guide._width,guide._height,guide._depth,guide._spectrum,guide._data);
      if (is_empty()) return *this;
      T m, M = guide.max_min(m);
      if (m==M) return *this;
      const float range = (float)(M - m);
      const unsigned int
        bx0 = (unsigned int)(bgrid_x>=0?bgrid_x:_width*-bgrid_x/100),
        by0 = (unsigned int)(bgrid_y>=0?bgrid_y:_height*-bgrid_y/100),
        bz0 = (unsigned int)(bgrid_z>=0?bgrid_z:_depth*-bgrid_z/100),
        br0 = (unsigned int)(bgrid_r>=0?bgrid_r:-range*bgrid_r/100),
        bx = bx0>0?bx0:1,
        by = by0>0?by0:1,
        bz = bz0>0?bz0:1,
        br = br0>0?br0:1;
      const float
        _sigma_x = sigma_x>=0?sigma_x:-sigma_x*_width/100,
        _sigma_y = sigma_y>=0?sigma_y:-sigma_y*_height/100,
        _sigma_z = sigma_z>=0?sigma_z:-sigma_z*_depth/100,
        _sigma_r = sigma_r>=0?sigma_r:-sigma_r*range/100,
        nsigma_x = _sigma_x*bx/_width,
        nsigma_y = _sigma_y*by/_height,
        nsigma_z = _sigma_z*bz/_depth,
        nsigma_r = _sigma_r*br/range;
      if (nsigma_x>0 || nsigma_y>0 || nsigma_z>0 || nsigma_r>0) {
        const bool is_3d = (_depth>1);
        if (is_3d) {
          CImg<floatT> bgrid(bx,by,bz,br), bgridw(bx,by,bz,br);
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const CImg<t> _guide = guide.get_shared_channel(c%guide._spectrum);
            bgrid.fill(0); bgridw.fill(0);
            for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
              const T val = (*this)(x,y,z,c);
              const float gval = (float)_guide(x,y,z);
              const int X = x*bx/_width, Y = y*by/_height, Z = z*bz/_depth,
                R = (int)cimg::min(br-1.0f,(gval-m)*br/range);
              bgrid(X,Y,Z,R) += (float)val;
              bgridw(X,Y,Z,R) += 1;
            }
            bgrid.blur(nsigma_x,nsigma_y,nsigma_z,true).deriche(nsigma_r,0,'c',false);
            bgridw.blur(nsigma_x,nsigma_y,nsigma_z,true).deriche(nsigma_r,0,'c',false);
            for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
              const float gval = (float)_guide(x,y,z);
              const int X = x*bx/_width, Y = y*by/_height, Z = z*bz/_depth,
                R = (int)cimg::min(br-1.0f,(gval-m)*br/range);
              const float bval0 = bgrid(X,Y,Z,R), bval1 = bgridw(X,Y,Z,R);
              (*this)(x,y,z,c) = (T)(bval0/bval1);
            }
          }
        } else {
          CImg<floatT> bgrid(bx,by,br,2);
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const CImg<t> _guide = guide.get_shared_channel(c%guide._spectrum);
            bgrid.fill(0);
            for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
              const T val = (*this)(x,y,c);
              const float gval = (float)_guide(x,y);
              const int X = x*bx/_width, Y = y*by/_height, R = (int)cimg::min(br-1.0f,(gval-m)*br/range);
              bgrid(X,Y,R,0) += (float)val;
              bgrid(X,Y,R,1) += 1;
            }
            bgrid.blur(nsigma_x,nsigma_y,0,true).blur(0,0,nsigma_r,false);
            for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
              const float gval = (float)_guide(x,y);
              const int X = x*bx/_width, Y = y*by/_height, R = (int)cimg::min(br-1.0f,(gval-m)*br/range);
              const float bval0 = bgrid(X,Y,R,0), bval1 = bgrid(X,Y,R,1);
              (*this)(x,y,c) = (T)(bval0/bval1);
            }
          }
        }
      }
      return *this;
    }


    template<typename t>
    CImg<T> get_blur_bilateral(const CImg<t>& guide,
                               const float sigma_x, const float sigma_y,
                               const float sigma_z, const float sigma_r,
                               const int bgrid_x, const int bgrid_y,
                               const int bgrid_z, const int bgrid_r) const {
      return (+*this).blur_bilateral(guide,sigma_x,sigma_y,sigma_z,sigma_r,bgrid_x,bgrid_y,bgrid_z,bgrid_r);
    }
# 26319 "../src/CImg.h"
    template<typename t>
    CImg<T>& blur_bilateral(const CImg<t>& guide,
                            const float sigma_s, const float sigma_r,
                            const int bgrid_s=-33, const int bgrid_r=32) {
      const float nsigma_s = sigma_s>=0?sigma_s:-sigma_s*cimg::max(_width,_height,_depth)/100;
      return blur_bilateral(guide,nsigma_s,nsigma_s,nsigma_s,sigma_r,bgrid_s,bgrid_s,bgrid_s,bgrid_r);
    }


    template<typename t>
    CImg<T> get_blur_bilateral(const CImg<t>& guide,
                               const float sigma_s, const float sigma_r,
                               const int bgrid_s=-33, const int bgrid_r=32) const {
      return (+*this).blur_bilateral(guide,sigma_s,sigma_s,sigma_s,sigma_r,bgrid_s,bgrid_s,bgrid_s,bgrid_r);
    }
# 26344 "../src/CImg.h"
    CImg<T>& blur_patch(const float sigma_s, const float sigma_p, const unsigned int patch_size=3,
                        const unsigned int lookup_size=4, const float smoothness=0, const bool is_fast_approx=true) {
      if (is_empty() || !patch_size || !lookup_size) return *this;
      return get_blur_patch(sigma_s,sigma_p,patch_size,lookup_size,smoothness,is_fast_approx).move_to(*this);
    }


    CImg<T> get_blur_patch(const float sigma_s, const float sigma_p, const unsigned int patch_size=3,
                           const unsigned int lookup_size=4, const float smoothness=0,
                           const bool is_fast_approx=true) const {
# 26437 "../src/CImg.h"
      if (is_empty() || !patch_size || !lookup_size) return +*this;
      CImg<Tfloat> res(_width,_height,_depth,_spectrum,0);
      const CImg<T> _img = smoothness>0?get_blur(smoothness):CImg<Tfloat>(),&img = smoothness>0?_img:*this;
      CImg<T> P(patch_size*patch_size*_spectrum), Q(P);
      const float
        nsigma_s = sigma_s>=0?sigma_s:-sigma_s*cimg::max(_width,_height,_depth)/100,
        sigma_s2 = nsigma_s*nsigma_s, sigma_p2 = sigma_p*sigma_p, sigma_p3 = 3*sigma_p,
        Pnorm = P.size()*sigma_p2;
      const int rsize2 = (int)lookup_size/2, rsize1 = (int)lookup_size - rsize2 - 1;
      const unsigned int N2 = patch_size*patch_size, N3 = N2*patch_size;
      cimg::unused(N2,N3);
      if (_depth>1) switch (patch_size) {
        case 2 : if (is_fast_approx) for (int z = 0, _n1z = 1>=((res)._depth)?(int)((res)._depth)-1:1; _n1z<(int)((res)._depth) || z==--_n1z; ++z, ++_n1z) for (int y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1; _n1y<(int)((res)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1; _n1x<(int)((res)._width) || x==--_n1x; ++x, ++_n1x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(x,y,z,c), pP[1] = (T)(img)(_n1x,y,z,c), pP[2] = (T)(img)(x,_n1y,z,c), pP[3] = (T)(img)(_n1x,_n1y,z,c), pP[4] = (T)(img)(x,y,_n1z,c), pP[5] = (T)(img)(_n1x,y,_n1z,c), pP[6] = (T)(img)(x,_n1y,_n1z,c), pP[7] = (T)(img)(_n1x,_n1y,_n1z,c); pP+=N3; } const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1, x1 = x + rsize2, y1 = y + rsize2, z1 = z + rsize2; float sum_weights = 0; for (int r = (int)(z0)<0?0:(int)(z0), _n1r = r+1>=(int)((res)._depth)?(int)((res)._depth)-1:r+1; r<=(int)(z1) && (_n1r<(int)((res)._depth) || r==--_n1r); ++r, ++_n1r) for (int q = (int)(y0)<0?0:(int)(y0), _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1; q<=(int)(y1) && (_n1q<(int)((res)._height) || q==--_n1q); ++q, ++_n1q) for (int p = (int)(x0)<0?0:(int)(x0), _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1; p<=(int)(x1) && (_n1p<(int)((res)._width) || p==--_n1p); ++p, ++_n1p) if (cimg::abs(img(x,y,z,0) - img(p,q,r,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(p,q,r,c), pQ[1] = (T)(img)(_n1p,q,r,c), pQ[2] = (T)(img)(p,_n1q,r,c), pQ[3] = (T)(img)(_n1p,_n1q,r,c), pQ[4] = (T)(img)(p,q,_n1r,c), pQ[5] = (T)(img)(_n1p,q,_n1r,c), pQ[6] = (T)(img)(p,_n1q,_n1r,c), pQ[7] = (T)(img)(_n1p,_n1q,_n1r,c); pQ+=N3; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, dz = (float)r - z, alldist = distance2 + (dx*dx + dy*dy + dz*dz)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight*(*this)(p,q,r,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c) = (Tfloat)((*this)(x,y,z,c)); } else for (int z = 0, _n1z = 1>=((res)._depth)?(int)((res)._depth)-1:1; _n1z<(int)((res)._depth) || z==--_n1z; ++z, ++_n1z) for (int y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1; _n1y<(int)((res)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1; _n1x<(int)((res)._width) || x==--_n1x; ++x, ++_n1x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(x,y,z,c), pP[1] = (T)(img)(_n1x,y,z,c), pP[2] = (T)(img)(x,_n1y,z,c), pP[3] = (T)(img)(_n1x,_n1y,z,c), pP[4] = (T)(img)(x,y,_n1z,c), pP[5] = (T)(img)(_n1x,y,_n1z,c), pP[6] = (T)(img)(x,_n1y,_n1z,c), pP[7] = (T)(img)(_n1x,_n1y,_n1z,c); pP+=N3; } const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1, x1 = x + rsize2, y1 = y + rsize2, z1 = z + rsize2; float sum_weights = 0, weight_max = 0; for (int r = (int)(z0)<0?0:(int)(z0), _n1r = r+1>=(int)((res)._depth)?(int)((res)._depth)-1:r+1; r<=(int)(z1) && (_n1r<(int)((res)._depth) || r==--_n1r); ++r, ++_n1r) for (int q = (int)(y0)<0?0:(int)(y0), _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1; q<=(int)(y1) && (_n1q<(int)((res)._height) || q==--_n1q); ++q, ++_n1q) for (int p = (int)(x0)<0?0:(int)(x0), _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1; p<=(int)(x1) && (_n1p<(int)((res)._width) || p==--_n1p); ++p, ++_n1p) if (p!=x || q!=y || r!=z) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(p,q,r,c), pQ[1] = (T)(img)(_n1p,q,r,c), pQ[2] = (T)(img)(p,_n1q,r,c), pQ[3] = (T)(img)(_n1p,_n1q,r,c), pQ[4] = (T)(img)(p,q,_n1r,c), pQ[5] = (T)(img)(_n1p,q,_n1r,c), pQ[6] = (T)(img)(p,_n1q,_n1r,c), pQ[7] = (T)(img)(_n1p,_n1q,_n1r,c); pQ+=N3; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, dz = (float)r - z, alldist = distance2 + (dx*dx + dy*dy + dz*dz)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight*(*this)(p,q,r,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight_max*(*this)(x,y,z,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c) = (Tfloat)((*this)(x,y,z,c)); } break;
        case 3 : if (is_fast_approx) for (int z = 0, _p1z = 0, _n1z = 1>=((res)._depth)?(int)((res)._depth)-1:1; _n1z<(int)((res)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1; _n1y<(int)((res)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1; _n1x<(int)((res)._width) || x==--_n1x; _p1x = x++, ++_n1x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p1x,_p1y,_p1z,c), pP[1] = (T)(img)(x,_p1y,_p1z,c), pP[2] = (T)(img)(_n1x,_p1y,_p1z,c), pP[3] = (T)(img)(_p1x,y,_p1z,c), pP[4] = (T)(img)(x,y,_p1z,c), pP[5] = (T)(img)(_n1x,y,_p1z,c), pP[6] = (T)(img)(_p1x,_n1y,_p1z,c), pP[7] = (T)(img)(x,_n1y,_p1z,c), pP[8] = (T)(img)(_n1x,_n1y,_p1z,c), pP[9] = (T)(img)(_p1x,_p1y,z,c), pP[10] = (T)(img)(x,_p1y,z,c), pP[11] = (T)(img)(_n1x,_p1y,z,c), pP[12] = (T)(img)(_p1x,y,z,c), pP[13] = (T)(img)(x,y,z,c), pP[14] = (T)(img)(_n1x,y,z,c), pP[15] = (T)(img)(_p1x,_n1y,z,c), pP[16] = (T)(img)(x,_n1y,z,c), pP[17] = (T)(img)(_n1x,_n1y,z,c), pP[18] = (T)(img)(_p1x,_p1y,_n1z,c), pP[19] = (T)(img)(x,_p1y,_n1z,c), pP[20] = (T)(img)(_n1x,_p1y,_n1z,c), pP[21] = (T)(img)(_p1x,y,_n1z,c), pP[22] = (T)(img)(x,y,_n1z,c), pP[23] = (T)(img)(_n1x,y,_n1z,c), pP[24] = (T)(img)(_p1x,_n1y,_n1z,c), pP[25] = (T)(img)(x,_n1y,_n1z,c), pP[26] = (T)(img)(_n1x,_n1y,_n1z,c); pP+=N3; } const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1, x1 = x + rsize2, y1 = y + rsize2, z1 = z + rsize2; float sum_weights = 0; for (int r = (int)(z0)<0?0:(int)(z0), _p1r = r-1<0?0:r-1, _n1r = r+1>=(int)((res)._depth)?(int)((res)._depth)-1:r+1; r<=(int)(z1) && (_n1r<(int)((res)._depth) || r==--_n1r); _p1r = r++, ++_n1r) for (int q = (int)(y0)<0?0:(int)(y0), _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1; q<=(int)(y1) && (_n1q<(int)((res)._height) || q==--_n1q); _p1q = q++, ++_n1q) for (int p = (int)(x0)<0?0:(int)(x0), _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1; p<=(int)(x1) && (_n1p<(int)((res)._width) || p==--_n1p); _p1p = p++, ++_n1p) if (cimg::abs(img(x,y,z,0) - img(p,q,r,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p1p,_p1q,_p1r,c), pQ[1] = (T)(img)(p,_p1q,_p1r,c), pQ[2] = (T)(img)(_n1p,_p1q,_p1r,c), pQ[3] = (T)(img)(_p1p,q,_p1r,c), pQ[4] = (T)(img)(p,q,_p1r,c), pQ[5] = (T)(img)(_n1p,q,_p1r,c), pQ[6] = (T)(img)(_p1p,_n1q,_p1r,c), pQ[7] = (T)(img)(p,_n1q,_p1r,c), pQ[8] = (T)(img)(_n1p,_n1q,_p1r,c), pQ[9] = (T)(img)(_p1p,_p1q,r,c), pQ[10] = (T)(img)(p,_p1q,r,c), pQ[11] = (T)(img)(_n1p,_p1q,r,c), pQ[12] = (T)(img)(_p1p,q,r,c), pQ[13] = (T)(img)(p,q,r,c), pQ[14] = (T)(img)(_n1p,q,r,c), pQ[15] = (T)(img)(_p1p,_n1q,r,c), pQ[16] = (T)(img)(p,_n1q,r,c), pQ[17] = (T)(img)(_n1p,_n1q,r,c), pQ[18] = (T)(img)(_p1p,_p1q,_n1r,c), pQ[19] = (T)(img)(p,_p1q,_n1r,c), pQ[20] = (T)(img)(_n1p,_p1q,_n1r,c), pQ[21] = (T)(img)(_p1p,q,_n1r,c), pQ[22] = (T)(img)(p,q,_n1r,c), pQ[23] = (T)(img)(_n1p,q,_n1r,c), pQ[24] = (T)(img)(_p1p,_n1q,_n1r,c), pQ[25] = (T)(img)(p,_n1q,_n1r,c), pQ[26] = (T)(img)(_n1p,_n1q,_n1r,c); pQ+=N3; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, dz = (float)r - z, alldist = distance2 + (dx*dx + dy*dy + dz*dz)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight*(*this)(p,q,r,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c) = (Tfloat)((*this)(x,y,z,c)); } else for (int z = 0, _p1z = 0, _n1z = 1>=((res)._depth)?(int)((res)._depth)-1:1; _n1z<(int)((res)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1; _n1y<(int)((res)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1; _n1x<(int)((res)._width) || x==--_n1x; _p1x = x++, ++_n1x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p1x,_p1y,_p1z,c), pP[1] = (T)(img)(x,_p1y,_p1z,c), pP[2] = (T)(img)(_n1x,_p1y,_p1z,c), pP[3] = (T)(img)(_p1x,y,_p1z,c), pP[4] = (T)(img)(x,y,_p1z,c), pP[5] = (T)(img)(_n1x,y,_p1z,c), pP[6] = (T)(img)(_p1x,_n1y,_p1z,c), pP[7] = (T)(img)(x,_n1y,_p1z,c), pP[8] = (T)(img)(_n1x,_n1y,_p1z,c), pP[9] = (T)(img)(_p1x,_p1y,z,c), pP[10] = (T)(img)(x,_p1y,z,c), pP[11] = (T)(img)(_n1x,_p1y,z,c), pP[12] = (T)(img)(_p1x,y,z,c), pP[13] = (T)(img)(x,y,z,c), pP[14] = (T)(img)(_n1x,y,z,c), pP[15] = (T)(img)(_p1x,_n1y,z,c), pP[16] = (T)(img)(x,_n1y,z,c), pP[17] = (T)(img)(_n1x,_n1y,z,c), pP[18] = (T)(img)(_p1x,_p1y,_n1z,c), pP[19] = (T)(img)(x,_p1y,_n1z,c), pP[20] = (T)(img)(_n1x,_p1y,_n1z,c), pP[21] = (T)(img)(_p1x,y,_n1z,c), pP[22] = (T)(img)(x,y,_n1z,c), pP[23] = (T)(img)(_n1x,y,_n1z,c), pP[24] = (T)(img)(_p1x,_n1y,_n1z,c), pP[25] = (T)(img)(x,_n1y,_n1z,c), pP[26] = (T)(img)(_n1x,_n1y,_n1z,c); pP+=N3; } const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1, x1 = x + rsize2, y1 = y + rsize2, z1 = z + rsize2; float sum_weights = 0, weight_max = 0; for (int r = (int)(z0)<0?0:(int)(z0), _p1r = r-1<0?0:r-1, _n1r = r+1>=(int)((res)._depth)?(int)((res)._depth)-1:r+1; r<=(int)(z1) && (_n1r<(int)((res)._depth) || r==--_n1r); _p1r = r++, ++_n1r) for (int q = (int)(y0)<0?0:(int)(y0), _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1; q<=(int)(y1) && (_n1q<(int)((res)._height) || q==--_n1q); _p1q = q++, ++_n1q) for (int p = (int)(x0)<0?0:(int)(x0), _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1; p<=(int)(x1) && (_n1p<(int)((res)._width) || p==--_n1p); _p1p = p++, ++_n1p) if (p!=x || q!=y || r!=z) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p1p,_p1q,_p1r,c), pQ[1] = (T)(img)(p,_p1q,_p1r,c), pQ[2] = (T)(img)(_n1p,_p1q,_p1r,c), pQ[3] = (T)(img)(_p1p,q,_p1r,c), pQ[4] = (T)(img)(p,q,_p1r,c), pQ[5] = (T)(img)(_n1p,q,_p1r,c), pQ[6] = (T)(img)(_p1p,_n1q,_p1r,c), pQ[7] = (T)(img)(p,_n1q,_p1r,c), pQ[8] = (T)(img)(_n1p,_n1q,_p1r,c), pQ[9] = (T)(img)(_p1p,_p1q,r,c), pQ[10] = (T)(img)(p,_p1q,r,c), pQ[11] = (T)(img)(_n1p,_p1q,r,c), pQ[12] = (T)(img)(_p1p,q,r,c), pQ[13] = (T)(img)(p,q,r,c), pQ[14] = (T)(img)(_n1p,q,r,c), pQ[15] = (T)(img)(_p1p,_n1q,r,c), pQ[16] = (T)(img)(p,_n1q,r,c), pQ[17] = (T)(img)(_n1p,_n1q,r,c), pQ[18] = (T)(img)(_p1p,_p1q,_n1r,c), pQ[19] = (T)(img)(p,_p1q,_n1r,c), pQ[20] = (T)(img)(_n1p,_p1q,_n1r,c), pQ[21] = (T)(img)(_p1p,q,_n1r,c), pQ[22] = (T)(img)(p,q,_n1r,c), pQ[23] = (T)(img)(_n1p,q,_n1r,c), pQ[24] = (T)(img)(_p1p,_n1q,_n1r,c), pQ[25] = (T)(img)(p,_n1q,_n1r,c), pQ[26] = (T)(img)(_n1p,_n1q,_n1r,c); pQ+=N3; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, dz = (float)r - z, alldist = distance2 + (dx*dx + dy*dy + dz*dz)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight*(*this)(p,q,r,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight_max*(*this)(x,y,z,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c) = (Tfloat)((*this)(x,y,z,c)); } break;
        default : {
          const int psize2 = (int)patch_size/2, psize1 = (int)patch_size - psize2 - 1;
          if (is_fast_approx)



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
              P = img.get_crop(x - psize1,y - psize1,z - psize1,x + psize2,y + psize2,z + psize2,true);
              const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1,
                x1 = x + rsize2, y1 = y + rsize2, z1 = z + rsize2;
              float sum_weights = 0;
              for (int r = (int)(z0)<0?0:(int)(z0), _maxr = (int)(z1)<(int)((res)._depth)?(int)(z1):(int)((res)._depth)-1; r<=_maxr; ++r) for (int q = (int)(y0)<0?0:(int)(y0), _maxq = (int)(y1)<(int)((res)._height)?(int)(y1):(int)((res)._height)-1; q<=_maxq; ++q) for (int p = (int)(x0)<0?0:(int)(x0), _maxp = (int)(x1)<(int)((res)._width)?(int)(x1):(int)((res)._width)-1; p<=_maxp; ++p) if (cimg::abs(img(x,y,z,0)-img(p,q,r,0))<sigma_p3) {
                (Q = img.get_crop(p - psize1,q - psize1,r - psize1,p + psize2,q + psize2,r + psize2,true))-=P;
                const float
                  dx = (float)x - p, dy = (float)y - q, dz = (float)z - r,
                  distance2 = (float)(Q.pow(2).sum()/Pnorm + (dx*dx + dy*dy + dz*dz)/sigma_s2),
                  weight = distance2>3?0.0f:1.0f;
                sum_weights+=weight;
                for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight*(*this)(p,q,r,c);
              }
              if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)/=sum_weights;
              else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c) = (Tfloat)((*this)(x,y,z,c));
            } else



            for (int z = 0; z<(int)((res)._depth); ++z) for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
              P = img.get_crop(x - psize1,y - psize1,z - psize1,x + psize2,y + psize2,z + psize2,true);
              const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1,
                x1 = x + rsize2, y1 = y + rsize2, z1 = z + rsize2;
              float sum_weights = 0, weight_max = 0;
              for (int r = (int)(z0)<0?0:(int)(z0), _maxr = (int)(z1)<(int)((res)._depth)?(int)(z1):(int)((res)._depth)-1; r<=_maxr; ++r) for (int q = (int)(y0)<0?0:(int)(y0), _maxq = (int)(y1)<(int)((res)._height)?(int)(y1):(int)((res)._height)-1; q<=_maxq; ++q) for (int p = (int)(x0)<0?0:(int)(x0), _maxp = (int)(x1)<(int)((res)._width)?(int)(x1):(int)((res)._width)-1; p<=_maxp; ++p) if (p!=x || q!=y || r!=z) {
                (Q = img.get_crop(p - psize1,q - psize1,r - psize1,p + psize2,q + psize2,r + psize2,true))-=P;
                const float
                  dx = (float)x - p, dy = (float)y - q, dz = (float)z - r,
                  distance2 = (float)(Q.pow(2).sum()/Pnorm + (dx*dx + dy*dy + dz*dz)/sigma_s2),
                  weight = (float)std::exp(-distance2);
                if (weight>weight_max) weight_max = weight;
                sum_weights+=weight;
                for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight*(*this)(p,q,r,c);
              }
              sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)+=weight_max*(*this)(x,y,z,c);
              if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c)/=sum_weights;
              else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,z,c) = (Tfloat)((*this)(x,y,z,c));
            }
        }
        } else switch (patch_size) {
        case 2 : if (is_fast_approx) for (int y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1; _n1y<(int)((res)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1; _n1x<(int)((res)._width) || x==--_n1x; ++x, ++_n1x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(x,y,0,c), pP[1] = (T)(img)(_n1x,y,0,c), pP[2] = (T)(img)(x,_n1y,0,c), pP[3] = (T)(img)(_n1x,_n1y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0; for (int q = (int)(y0)<0?0:(int)(y0), _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1; q<=(int)(y1) && (_n1q<(int)((res)._height) || q==--_n1q); ++q, ++_n1q) for (int p = (int)(x0)<0?0:(int)(x0), _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1; p<=(int)(x1) && (_n1p<(int)((res)._width) || p==--_n1p); ++p, ++_n1p) if (cimg::abs(img(x,y,0,0) - img(p,q,0,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(p,q,0,c), pQ[1] = (T)(img)(_n1p,q,0,c), pQ[2] = (T)(img)(p,_n1q,0,c), pQ[3] = (T)(img)(_n1p,_n1q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } else for (int y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1; _n1y<(int)((res)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1; _n1x<(int)((res)._width) || x==--_n1x; ++x, ++_n1x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(x,y,0,c), pP[1] = (T)(img)(_n1x,y,0,c), pP[2] = (T)(img)(x,_n1y,0,c), pP[3] = (T)(img)(_n1x,_n1y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0, weight_max = 0; for (int q = (int)(y0)<0?0:(int)(y0), _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1; q<=(int)(y1) && (_n1q<(int)((res)._height) || q==--_n1q); ++q, ++_n1q) for (int p = (int)(x0)<0?0:(int)(x0), _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1; p<=(int)(x1) && (_n1p<(int)((res)._width) || p==--_n1p); ++p, ++_n1p) if (p!=x || q!=y) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(p,q,0,c), pQ[1] = (T)(img)(_n1p,q,0,c), pQ[2] = (T)(img)(p,_n1q,0,c), pQ[3] = (T)(img)(_n1p,_n1q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } break;
        case 3 : if (is_fast_approx) for (int y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1; _n1y<(int)((res)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1; _n1x<(int)((res)._width) || x==--_n1x; _p1x = x++, ++_n1x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p1x,_p1y,0,c), pP[1] = (T)(img)(x,_p1y,0,c), pP[2] = (T)(img)(_n1x,_p1y,0,c), pP[3] = (T)(img)(_p1x,y,0,c), pP[4] = (T)(img)(x,y,0,c), pP[5] = (T)(img)(_n1x,y,0,c), pP[6] = (T)(img)(_p1x,_n1y,0,c), pP[7] = (T)(img)(x,_n1y,0,c), pP[8] = (T)(img)(_n1x,_n1y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1; q<=(int)(y1) && (_n1q<(int)((res)._height) || q==--_n1q); _p1q = q++, ++_n1q) for (int p = (int)(x0)<0?0:(int)(x0), _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1; p<=(int)(x1) && (_n1p<(int)((res)._width) || p==--_n1p); _p1p = p++, ++_n1p) if (cimg::abs(img(x,y,0,0) - img(p,q,0,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p1p,_p1q,0,c), pQ[1] = (T)(img)(p,_p1q,0,c), pQ[2] = (T)(img)(_n1p,_p1q,0,c), pQ[3] = (T)(img)(_p1p,q,0,c), pQ[4] = (T)(img)(p,q,0,c), pQ[5] = (T)(img)(_n1p,q,0,c), pQ[6] = (T)(img)(_p1p,_n1q,0,c), pQ[7] = (T)(img)(p,_n1q,0,c), pQ[8] = (T)(img)(_n1p,_n1q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } else for (int y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1; _n1y<(int)((res)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1; _n1x<(int)((res)._width) || x==--_n1x; _p1x = x++, ++_n1x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p1x,_p1y,0,c), pP[1] = (T)(img)(x,_p1y,0,c), pP[2] = (T)(img)(_n1x,_p1y,0,c), pP[3] = (T)(img)(_p1x,y,0,c), pP[4] = (T)(img)(x,y,0,c), pP[5] = (T)(img)(_n1x,y,0,c), pP[6] = (T)(img)(_p1x,_n1y,0,c), pP[7] = (T)(img)(x,_n1y,0,c), pP[8] = (T)(img)(_n1x,_n1y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0, weight_max = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1; q<=(int)(y1) && (_n1q<(int)((res)._height) || q==--_n1q); _p1q = q++, ++_n1q) for (int p = (int)(x0)<0?0:(int)(x0), _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1; p<=(int)(x1) && (_n1p<(int)((res)._width) || p==--_n1p); _p1p = p++, ++_n1p) if (p!=x || q!=y) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p1p,_p1q,0,c), pQ[1] = (T)(img)(p,_p1q,0,c), pQ[2] = (T)(img)(_n1p,_p1q,0,c), pQ[3] = (T)(img)(_p1p,q,0,c), pQ[4] = (T)(img)(p,q,0,c), pQ[5] = (T)(img)(_n1p,q,0,c), pQ[6] = (T)(img)(_p1p,_n1q,0,c), pQ[7] = (T)(img)(p,_n1q,0,c), pQ[8] = (T)(img)(_n1p,_n1q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } break;
        case 4 : if (is_fast_approx) for (int y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2; _n2y<(int)((res)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2; _n2x<(int)((res)._width) || _n1x==--_n2x || x==(_n2x = --_n1x); _p1x = x++, ++_n1x, ++_n2x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p1x,_p1y,0,c), pP[1] = (T)(img)(x,_p1y,0,c), pP[2] = (T)(img)(_n1x,_p1y,0,c), pP[3] = (T)(img)(_n2x,_p1y,0,c), pP[4] = (T)(img)(_p1x,y,0,c), pP[5] = (T)(img)(x,y,0,c), pP[6] = (T)(img)(_n1x,y,0,c), pP[7] = (T)(img)(_n2x,y,0,c), pP[8] = (T)(img)(_p1x,_n1y,0,c), pP[9] = (T)(img)(x,_n1y,0,c), pP[10] = (T)(img)(_n1x,_n1y,0,c), pP[11] = (T)(img)(_n2x,_n1y,0,c), pP[12] = (T)(img)(_p1x,_n2y,0,c), pP[13] = (T)(img)(x,_n2y,0,c), pP[14] = (T)(img)(_n1x,_n2y,0,c), pP[15] = (T)(img)(_n2x,_n2y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2; q<=(int)(y1) && (_n2q<(int)((res)._height) || _n1q==--_n2q || q==(_n2q = --_n1q)); _p1q = q++, ++_n1q, ++_n2q) for (int p = (int)(x0)<0?0:(int)(x0), _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2; p<=(int)(x1) && (_n2p<(int)((res)._width) || _n1p==--_n2p || p==(_n2p = --_n1p)); _p1p = p++, ++_n1p, ++_n2p) if (cimg::abs(img(x,y,0,0) - img(p,q,0,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p1p,_p1q,0,c), pQ[1] = (T)(img)(p,_p1q,0,c), pQ[2] = (T)(img)(_n1p,_p1q,0,c), pQ[3] = (T)(img)(_n2p,_p1q,0,c), pQ[4] = (T)(img)(_p1p,q,0,c), pQ[5] = (T)(img)(p,q,0,c), pQ[6] = (T)(img)(_n1p,q,0,c), pQ[7] = (T)(img)(_n2p,q,0,c), pQ[8] = (T)(img)(_p1p,_n1q,0,c), pQ[9] = (T)(img)(p,_n1q,0,c), pQ[10] = (T)(img)(_n1p,_n1q,0,c), pQ[11] = (T)(img)(_n2p,_n1q,0,c), pQ[12] = (T)(img)(_p1p,_n2q,0,c), pQ[13] = (T)(img)(p,_n2q,0,c), pQ[14] = (T)(img)(_n1p,_n2q,0,c), pQ[15] = (T)(img)(_n2p,_n2q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } else for (int y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2; _n2y<(int)((res)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2; _n2x<(int)((res)._width) || _n1x==--_n2x || x==(_n2x = --_n1x); _p1x = x++, ++_n1x, ++_n2x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p1x,_p1y,0,c), pP[1] = (T)(img)(x,_p1y,0,c), pP[2] = (T)(img)(_n1x,_p1y,0,c), pP[3] = (T)(img)(_n2x,_p1y,0,c), pP[4] = (T)(img)(_p1x,y,0,c), pP[5] = (T)(img)(x,y,0,c), pP[6] = (T)(img)(_n1x,y,0,c), pP[7] = (T)(img)(_n2x,y,0,c), pP[8] = (T)(img)(_p1x,_n1y,0,c), pP[9] = (T)(img)(x,_n1y,0,c), pP[10] = (T)(img)(_n1x,_n1y,0,c), pP[11] = (T)(img)(_n2x,_n1y,0,c), pP[12] = (T)(img)(_p1x,_n2y,0,c), pP[13] = (T)(img)(x,_n2y,0,c), pP[14] = (T)(img)(_n1x,_n2y,0,c), pP[15] = (T)(img)(_n2x,_n2y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0, weight_max = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2; q<=(int)(y1) && (_n2q<(int)((res)._height) || _n1q==--_n2q || q==(_n2q = --_n1q)); _p1q = q++, ++_n1q, ++_n2q) for (int p = (int)(x0)<0?0:(int)(x0), _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2; p<=(int)(x1) && (_n2p<(int)((res)._width) || _n1p==--_n2p || p==(_n2p = --_n1p)); _p1p = p++, ++_n1p, ++_n2p) if (p!=x || q!=y) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p1p,_p1q,0,c), pQ[1] = (T)(img)(p,_p1q,0,c), pQ[2] = (T)(img)(_n1p,_p1q,0,c), pQ[3] = (T)(img)(_n2p,_p1q,0,c), pQ[4] = (T)(img)(_p1p,q,0,c), pQ[5] = (T)(img)(p,q,0,c), pQ[6] = (T)(img)(_n1p,q,0,c), pQ[7] = (T)(img)(_n2p,q,0,c), pQ[8] = (T)(img)(_p1p,_n1q,0,c), pQ[9] = (T)(img)(p,_n1q,0,c), pQ[10] = (T)(img)(_n1p,_n1q,0,c), pQ[11] = (T)(img)(_n2p,_n1q,0,c), pQ[12] = (T)(img)(_p1p,_n2q,0,c), pQ[13] = (T)(img)(p,_n2q,0,c), pQ[14] = (T)(img)(_n1p,_n2q,0,c), pQ[15] = (T)(img)(_n2p,_n2q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } break;
        case 5 : if (is_fast_approx) for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2; _n2y<(int)((res)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2; _n2x<(int)((res)._width) || _n1x==--_n2x || x==(_n2x = --_n1x); _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p2x,_p2y,0,c), pP[1] = (T)(img)(_p1x,_p2y,0,c), pP[2] = (T)(img)(x,_p2y,0,c), pP[3] = (T)(img)(_n1x,_p2y,0,c), pP[4] = (T)(img)(_n2x,_p2y,0,c), pP[5] = (T)(img)(_p2x,_p1y,0,c), pP[6] = (T)(img)(_p1x,_p1y,0,c), pP[7] = (T)(img)(x,_p1y,0,c), pP[8] = (T)(img)(_n1x,_p1y,0,c), pP[9] = (T)(img)(_n2x,_p1y,0,c), pP[10] = (T)(img)(_p2x,y,0,c), pP[11] = (T)(img)(_p1x,y,0,c), pP[12] = (T)(img)(x,y,0,c), pP[13] = (T)(img)(_n1x,y,0,c), pP[14] = (T)(img)(_n2x,y,0,c), pP[15] = (T)(img)(_p2x,_n1y,0,c), pP[16] = (T)(img)(_p1x,_n1y,0,c), pP[17] = (T)(img)(x,_n1y,0,c), pP[18] = (T)(img)(_n1x,_n1y,0,c), pP[19] = (T)(img)(_n2x,_n1y,0,c), pP[20] = (T)(img)(_p2x,_n2y,0,c), pP[21] = (T)(img)(_p1x,_n2y,0,c), pP[22] = (T)(img)(x,_n2y,0,c), pP[23] = (T)(img)(_n1x,_n2y,0,c), pP[24] = (T)(img)(_n2x,_n2y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2; q<=(int)(y1) && (_n2q<(int)((res)._height) || _n1q==--_n2q || q==(_n2q = --_n1q)); _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q) for (int p = (int)(x0)<0?0:(int)(x0), _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2; p<=(int)(x1) && (_n2p<(int)((res)._width) || _n1p==--_n2p || p==(_n2p = --_n1p)); _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p) if (cimg::abs(img(x,y,0,0) - img(p,q,0,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p2p,_p2q,0,c), pQ[1] = (T)(img)(_p1p,_p2q,0,c), pQ[2] = (T)(img)(p,_p2q,0,c), pQ[3] = (T)(img)(_n1p,_p2q,0,c), pQ[4] = (T)(img)(_n2p,_p2q,0,c), pQ[5] = (T)(img)(_p2p,_p1q,0,c), pQ[6] = (T)(img)(_p1p,_p1q,0,c), pQ[7] = (T)(img)(p,_p1q,0,c), pQ[8] = (T)(img)(_n1p,_p1q,0,c), pQ[9] = (T)(img)(_n2p,_p1q,0,c), pQ[10] = (T)(img)(_p2p,q,0,c), pQ[11] = (T)(img)(_p1p,q,0,c), pQ[12] = (T)(img)(p,q,0,c), pQ[13] = (T)(img)(_n1p,q,0,c), pQ[14] = (T)(img)(_n2p,q,0,c), pQ[15] = (T)(img)(_p2p,_n1q,0,c), pQ[16] = (T)(img)(_p1p,_n1q,0,c), pQ[17] = (T)(img)(p,_n1q,0,c), pQ[18] = (T)(img)(_n1p,_n1q,0,c), pQ[19] = (T)(img)(_n2p,_n1q,0,c), pQ[20] = (T)(img)(_p2p,_n2q,0,c), pQ[21] = (T)(img)(_p1p,_n2q,0,c), pQ[22] = (T)(img)(p,_n2q,0,c), pQ[23] = (T)(img)(_n1p,_n2q,0,c), pQ[24] = (T)(img)(_n2p,_n2q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } else for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2; _n2y<(int)((res)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2; _n2x<(int)((res)._width) || _n1x==--_n2x || x==(_n2x = --_n1x); _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p2x,_p2y,0,c), pP[1] = (T)(img)(_p1x,_p2y,0,c), pP[2] = (T)(img)(x,_p2y,0,c), pP[3] = (T)(img)(_n1x,_p2y,0,c), pP[4] = (T)(img)(_n2x,_p2y,0,c), pP[5] = (T)(img)(_p2x,_p1y,0,c), pP[6] = (T)(img)(_p1x,_p1y,0,c), pP[7] = (T)(img)(x,_p1y,0,c), pP[8] = (T)(img)(_n1x,_p1y,0,c), pP[9] = (T)(img)(_n2x,_p1y,0,c), pP[10] = (T)(img)(_p2x,y,0,c), pP[11] = (T)(img)(_p1x,y,0,c), pP[12] = (T)(img)(x,y,0,c), pP[13] = (T)(img)(_n1x,y,0,c), pP[14] = (T)(img)(_n2x,y,0,c), pP[15] = (T)(img)(_p2x,_n1y,0,c), pP[16] = (T)(img)(_p1x,_n1y,0,c), pP[17] = (T)(img)(x,_n1y,0,c), pP[18] = (T)(img)(_n1x,_n1y,0,c), pP[19] = (T)(img)(_n2x,_n1y,0,c), pP[20] = (T)(img)(_p2x,_n2y,0,c), pP[21] = (T)(img)(_p1x,_n2y,0,c), pP[22] = (T)(img)(x,_n2y,0,c), pP[23] = (T)(img)(_n1x,_n2y,0,c), pP[24] = (T)(img)(_n2x,_n2y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0, weight_max = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2; q<=(int)(y1) && (_n2q<(int)((res)._height) || _n1q==--_n2q || q==(_n2q = --_n1q)); _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q) for (int p = (int)(x0)<0?0:(int)(x0), _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2; p<=(int)(x1) && (_n2p<(int)((res)._width) || _n1p==--_n2p || p==(_n2p = --_n1p)); _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p) if (p!=x || q!=y) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p2p,_p2q,0,c), pQ[1] = (T)(img)(_p1p,_p2q,0,c), pQ[2] = (T)(img)(p,_p2q,0,c), pQ[3] = (T)(img)(_n1p,_p2q,0,c), pQ[4] = (T)(img)(_n2p,_p2q,0,c), pQ[5] = (T)(img)(_p2p,_p1q,0,c), pQ[6] = (T)(img)(_p1p,_p1q,0,c), pQ[7] = (T)(img)(p,_p1q,0,c), pQ[8] = (T)(img)(_n1p,_p1q,0,c), pQ[9] = (T)(img)(_n2p,_p1q,0,c), pQ[10] = (T)(img)(_p2p,q,0,c), pQ[11] = (T)(img)(_p1p,q,0,c), pQ[12] = (T)(img)(p,q,0,c), pQ[13] = (T)(img)(_n1p,q,0,c), pQ[14] = (T)(img)(_n2p,q,0,c), pQ[15] = (T)(img)(_p2p,_n1q,0,c), pQ[16] = (T)(img)(_p1p,_n1q,0,c), pQ[17] = (T)(img)(p,_n1q,0,c), pQ[18] = (T)(img)(_n1p,_n1q,0,c), pQ[19] = (T)(img)(_n2p,_n1q,0,c), pQ[20] = (T)(img)(_p2p,_n2q,0,c), pQ[21] = (T)(img)(_p1p,_n2q,0,c), pQ[22] = (T)(img)(p,_n2q,0,c), pQ[23] = (T)(img)(_n1p,_n2q,0,c), pQ[24] = (T)(img)(_n2p,_n2q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } break;
        case 6 : if (is_fast_approx) for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2, _n3y = 3>=((res)._height)?(int)((res)._height)-1:3; _n3y<(int)((res)._height) || _n2y==--_n3y || _n1y==--_n2y || y==(_n3y = _n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2, _n3x = 3>=((res)._width)?(int)((res)._width)-1:3; _n3x<(int)((res)._width) || _n2x==--_n3x || _n1x==--_n2x || x==(_n3x = _n2x = --_n1x); _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p2x,_p2y,0,c), pP[1] = (T)(img)(_p1x,_p2y,0,c), pP[2] = (T)(img)(x,_p2y,0,c), pP[3] = (T)(img)(_n1x,_p2y,0,c), pP[4] = (T)(img)(_n2x,_p2y,0,c), pP[5] = (T)(img)(_n3x,_p2y,0,c), pP[6] = (T)(img)(_p2x,_p1y,0,c), pP[7] = (T)(img)(_p1x,_p1y,0,c), pP[8] = (T)(img)(x,_p1y,0,c), pP[9] = (T)(img)(_n1x,_p1y,0,c), pP[10] = (T)(img)(_n2x,_p1y,0,c), pP[11] = (T)(img)(_n3x,_p1y,0,c), pP[12] = (T)(img)(_p2x,y,0,c), pP[13] = (T)(img)(_p1x,y,0,c), pP[14] = (T)(img)(x,y,0,c), pP[15] = (T)(img)(_n1x,y,0,c), pP[16] = (T)(img)(_n2x,y,0,c), pP[17] = (T)(img)(_n3x,y,0,c), pP[18] = (T)(img)(_p2x,_n1y,0,c), pP[19] = (T)(img)(_p1x,_n1y,0,c), pP[20] = (T)(img)(x,_n1y,0,c), pP[21] = (T)(img)(_n1x,_n1y,0,c), pP[22] = (T)(img)(_n2x,_n1y,0,c), pP[23] = (T)(img)(_n3x,_n1y,0,c), pP[24] = (T)(img)(_p2x,_n2y,0,c), pP[25] = (T)(img)(_p1x,_n2y,0,c), pP[26] = (T)(img)(x,_n2y,0,c), pP[27] = (T)(img)(_n1x,_n2y,0,c), pP[28] = (T)(img)(_n2x,_n2y,0,c), pP[29] = (T)(img)(_n3x,_n2y,0,c), pP[30] = (T)(img)(_p2x,_n3y,0,c), pP[31] = (T)(img)(_p1x,_n3y,0,c), pP[32] = (T)(img)(x,_n3y,0,c), pP[33] = (T)(img)(_n1x,_n3y,0,c), pP[34] = (T)(img)(_n2x,_n3y,0,c), pP[35] = (T)(img)(_n3x,_n3y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2, _n3q = q+3>=(int)((res)._height)?(int)((res)._height)-1:q+3; q<=(int)(y1) && (_n3q<(int)((res)._height) || _n2q==--_n3q || _n1q==--_n2q || q==(_n3q = _n2q = --_n1q)); _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q, ++_n3q) for (int p = (int)(x0)<0?0:(int)(x0), _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2, _n3p = p+3>=(int)((res)._width)?(int)((res)._width)-1:p+3; p<=(int)(x1) && (_n3p<(int)((res)._width) || _n2p==--_n3p || _n1p==--_n2p || p==(_n3p = _n2p = --_n1p)); _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p, ++_n3p) if (cimg::abs(img(x,y,0,0) - img(p,q,0,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p2p,_p2q,0,c), pQ[1] = (T)(img)(_p1p,_p2q,0,c), pQ[2] = (T)(img)(p,_p2q,0,c), pQ[3] = (T)(img)(_n1p,_p2q,0,c), pQ[4] = (T)(img)(_n2p,_p2q,0,c), pQ[5] = (T)(img)(_n3p,_p2q,0,c), pQ[6] = (T)(img)(_p2p,_p1q,0,c), pQ[7] = (T)(img)(_p1p,_p1q,0,c), pQ[8] = (T)(img)(p,_p1q,0,c), pQ[9] = (T)(img)(_n1p,_p1q,0,c), pQ[10] = (T)(img)(_n2p,_p1q,0,c), pQ[11] = (T)(img)(_n3p,_p1q,0,c), pQ[12] = (T)(img)(_p2p,q,0,c), pQ[13] = (T)(img)(_p1p,q,0,c), pQ[14] = (T)(img)(p,q,0,c), pQ[15] = (T)(img)(_n1p,q,0,c), pQ[16] = (T)(img)(_n2p,q,0,c), pQ[17] = (T)(img)(_n3p,q,0,c), pQ[18] = (T)(img)(_p2p,_n1q,0,c), pQ[19] = (T)(img)(_p1p,_n1q,0,c), pQ[20] = (T)(img)(p,_n1q,0,c), pQ[21] = (T)(img)(_n1p,_n1q,0,c), pQ[22] = (T)(img)(_n2p,_n1q,0,c), pQ[23] = (T)(img)(_n3p,_n1q,0,c), pQ[24] = (T)(img)(_p2p,_n2q,0,c), pQ[25] = (T)(img)(_p1p,_n2q,0,c), pQ[26] = (T)(img)(p,_n2q,0,c), pQ[27] = (T)(img)(_n1p,_n2q,0,c), pQ[28] = (T)(img)(_n2p,_n2q,0,c), pQ[29] = (T)(img)(_n3p,_n2q,0,c), pQ[30] = (T)(img)(_p2p,_n3q,0,c), pQ[31] = (T)(img)(_p1p,_n3q,0,c), pQ[32] = (T)(img)(p,_n3q,0,c), pQ[33] = (T)(img)(_n1p,_n3q,0,c), pQ[34] = (T)(img)(_n2p,_n3q,0,c), pQ[35] = (T)(img)(_n3p,_n3q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } else for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2, _n3y = 3>=((res)._height)?(int)((res)._height)-1:3; _n3y<(int)((res)._height) || _n2y==--_n3y || _n1y==--_n2y || y==(_n3y = _n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2, _n3x = 3>=((res)._width)?(int)((res)._width)-1:3; _n3x<(int)((res)._width) || _n2x==--_n3x || _n1x==--_n2x || x==(_n3x = _n2x = --_n1x); _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p2x,_p2y,0,c), pP[1] = (T)(img)(_p1x,_p2y,0,c), pP[2] = (T)(img)(x,_p2y,0,c), pP[3] = (T)(img)(_n1x,_p2y,0,c), pP[4] = (T)(img)(_n2x,_p2y,0,c), pP[5] = (T)(img)(_n3x,_p2y,0,c), pP[6] = (T)(img)(_p2x,_p1y,0,c), pP[7] = (T)(img)(_p1x,_p1y,0,c), pP[8] = (T)(img)(x,_p1y,0,c), pP[9] = (T)(img)(_n1x,_p1y,0,c), pP[10] = (T)(img)(_n2x,_p1y,0,c), pP[11] = (T)(img)(_n3x,_p1y,0,c), pP[12] = (T)(img)(_p2x,y,0,c), pP[13] = (T)(img)(_p1x,y,0,c), pP[14] = (T)(img)(x,y,0,c), pP[15] = (T)(img)(_n1x,y,0,c), pP[16] = (T)(img)(_n2x,y,0,c), pP[17] = (T)(img)(_n3x,y,0,c), pP[18] = (T)(img)(_p2x,_n1y,0,c), pP[19] = (T)(img)(_p1x,_n1y,0,c), pP[20] = (T)(img)(x,_n1y,0,c), pP[21] = (T)(img)(_n1x,_n1y,0,c), pP[22] = (T)(img)(_n2x,_n1y,0,c), pP[23] = (T)(img)(_n3x,_n1y,0,c), pP[24] = (T)(img)(_p2x,_n2y,0,c), pP[25] = (T)(img)(_p1x,_n2y,0,c), pP[26] = (T)(img)(x,_n2y,0,c), pP[27] = (T)(img)(_n1x,_n2y,0,c), pP[28] = (T)(img)(_n2x,_n2y,0,c), pP[29] = (T)(img)(_n3x,_n2y,0,c), pP[30] = (T)(img)(_p2x,_n3y,0,c), pP[31] = (T)(img)(_p1x,_n3y,0,c), pP[32] = (T)(img)(x,_n3y,0,c), pP[33] = (T)(img)(_n1x,_n3y,0,c), pP[34] = (T)(img)(_n2x,_n3y,0,c), pP[35] = (T)(img)(_n3x,_n3y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0, weight_max = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2, _n3q = q+3>=(int)((res)._height)?(int)((res)._height)-1:q+3; q<=(int)(y1) && (_n3q<(int)((res)._height) || _n2q==--_n3q || _n1q==--_n2q || q==(_n3q = _n2q = --_n1q)); _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q, ++_n3q) for (int p = (int)(x0)<0?0:(int)(x0), _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2, _n3p = p+3>=(int)((res)._width)?(int)((res)._width)-1:p+3; p<=(int)(x1) && (_n3p<(int)((res)._width) || _n2p==--_n3p || _n1p==--_n2p || p==(_n3p = _n2p = --_n1p)); _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p, ++_n3p) if (p!=x || q!=y) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p2p,_p2q,0,c), pQ[1] = (T)(img)(_p1p,_p2q,0,c), pQ[2] = (T)(img)(p,_p2q,0,c), pQ[3] = (T)(img)(_n1p,_p2q,0,c), pQ[4] = (T)(img)(_n2p,_p2q,0,c), pQ[5] = (T)(img)(_n3p,_p2q,0,c), pQ[6] = (T)(img)(_p2p,_p1q,0,c), pQ[7] = (T)(img)(_p1p,_p1q,0,c), pQ[8] = (T)(img)(p,_p1q,0,c), pQ[9] = (T)(img)(_n1p,_p1q,0,c), pQ[10] = (T)(img)(_n2p,_p1q,0,c), pQ[11] = (T)(img)(_n3p,_p1q,0,c), pQ[12] = (T)(img)(_p2p,q,0,c), pQ[13] = (T)(img)(_p1p,q,0,c), pQ[14] = (T)(img)(p,q,0,c), pQ[15] = (T)(img)(_n1p,q,0,c), pQ[16] = (T)(img)(_n2p,q,0,c), pQ[17] = (T)(img)(_n3p,q,0,c), pQ[18] = (T)(img)(_p2p,_n1q,0,c), pQ[19] = (T)(img)(_p1p,_n1q,0,c), pQ[20] = (T)(img)(p,_n1q,0,c), pQ[21] = (T)(img)(_n1p,_n1q,0,c), pQ[22] = (T)(img)(_n2p,_n1q,0,c), pQ[23] = (T)(img)(_n3p,_n1q,0,c), pQ[24] = (T)(img)(_p2p,_n2q,0,c), pQ[25] = (T)(img)(_p1p,_n2q,0,c), pQ[26] = (T)(img)(p,_n2q,0,c), pQ[27] = (T)(img)(_n1p,_n2q,0,c), pQ[28] = (T)(img)(_n2p,_n2q,0,c), pQ[29] = (T)(img)(_n3p,_n2q,0,c), pQ[30] = (T)(img)(_p2p,_n3q,0,c), pQ[31] = (T)(img)(_p1p,_n3q,0,c), pQ[32] = (T)(img)(p,_n3q,0,c), pQ[33] = (T)(img)(_n1p,_n3q,0,c), pQ[34] = (T)(img)(_n2p,_n3q,0,c), pQ[35] = (T)(img)(_n3p,_n3q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } break;
        case 7 : if (is_fast_approx) for (int y = 0, _p3y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2, _n3y = 3>=((res)._height)?(int)((res)._height)-1:3; _n3y<(int)((res)._height) || _n2y==--_n3y || _n1y==--_n2y || y==(_n3y = _n2y = --_n1y); _p3y = _p2y, _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y) for (int x = 0, _p3x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2, _n3x = 3>=((res)._width)?(int)((res)._width)-1:3; _n3x<(int)((res)._width) || _n2x==--_n3x || _n1x==--_n2x || x==(_n3x = _n2x = --_n1x); _p3x = _p2x, _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p3x,_p3y,0,c), pP[1] = (T)(img)(_p2x,_p3y,0,c), pP[2] = (T)(img)(_p1x,_p3y,0,c), pP[3] = (T)(img)(x,_p3y,0,c), pP[4] = (T)(img)(_n1x,_p3y,0,c), pP[5] = (T)(img)(_n2x,_p3y,0,c), pP[6] = (T)(img)(_n3x,_p3y,0,c), pP[7] = (T)(img)(_p3x,_p2y,0,c), pP[8] = (T)(img)(_p2x,_p2y,0,c), pP[9] = (T)(img)(_p1x,_p2y,0,c), pP[10] = (T)(img)(x,_p2y,0,c), pP[11] = (T)(img)(_n1x,_p2y,0,c), pP[12] = (T)(img)(_n2x,_p2y,0,c), pP[13] = (T)(img)(_n3x,_p2y,0,c), pP[14] = (T)(img)(_p3x,_p1y,0,c), pP[15] = (T)(img)(_p2x,_p1y,0,c), pP[16] = (T)(img)(_p1x,_p1y,0,c), pP[17] = (T)(img)(x,_p1y,0,c), pP[18] = (T)(img)(_n1x,_p1y,0,c), pP[19] = (T)(img)(_n2x,_p1y,0,c), pP[20] = (T)(img)(_n3x,_p1y,0,c), pP[21] = (T)(img)(_p3x,y,0,c), pP[22] = (T)(img)(_p2x,y,0,c), pP[23] = (T)(img)(_p1x,y,0,c), pP[24] = (T)(img)(x,y,0,c), pP[25] = (T)(img)(_n1x,y,0,c), pP[26] = (T)(img)(_n2x,y,0,c), pP[27] = (T)(img)(_n3x,y,0,c), pP[28] = (T)(img)(_p3x,_n1y,0,c), pP[29] = (T)(img)(_p2x,_n1y,0,c), pP[30] = (T)(img)(_p1x,_n1y,0,c), pP[31] = (T)(img)(x,_n1y,0,c), pP[32] = (T)(img)(_n1x,_n1y,0,c), pP[33] = (T)(img)(_n2x,_n1y,0,c), pP[34] = (T)(img)(_n3x,_n1y,0,c), pP[35] = (T)(img)(_p3x,_n2y,0,c), pP[36] = (T)(img)(_p2x,_n2y,0,c), pP[37] = (T)(img)(_p1x,_n2y,0,c), pP[38] = (T)(img)(x,_n2y,0,c), pP[39] = (T)(img)(_n1x,_n2y,0,c), pP[40] = (T)(img)(_n2x,_n2y,0,c), pP[41] = (T)(img)(_n3x,_n2y,0,c), pP[42] = (T)(img)(_p3x,_n3y,0,c), pP[43] = (T)(img)(_p2x,_n3y,0,c), pP[44] = (T)(img)(_p1x,_n3y,0,c), pP[45] = (T)(img)(x,_n3y,0,c), pP[46] = (T)(img)(_n1x,_n3y,0,c), pP[47] = (T)(img)(_n2x,_n3y,0,c), pP[48] = (T)(img)(_n3x,_n3y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p3q = q-3<0?0:q-3, _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2, _n3q = q+3>=(int)((res)._height)?(int)((res)._height)-1:q+3; q<=(int)(y1) && (_n3q<(int)((res)._height) || _n2q==--_n3q || _n1q==--_n2q || q==(_n3q = _n2q = --_n1q)); _p3q = _p2q, _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q, ++_n3q) for (int p = (int)(x0)<0?0:(int)(x0), _p3p = p-3<0?0:p-3, _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2, _n3p = p+3>=(int)((res)._width)?(int)((res)._width)-1:p+3; p<=(int)(x1) && (_n3p<(int)((res)._width) || _n2p==--_n3p || _n1p==--_n2p || p==(_n3p = _n2p = --_n1p)); _p3p = _p2p, _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p, ++_n3p) if (cimg::abs(img(x,y,0,0) - img(p,q,0,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p3p,_p3q,0,c), pQ[1] = (T)(img)(_p2p,_p3q,0,c), pQ[2] = (T)(img)(_p1p,_p3q,0,c), pQ[3] = (T)(img)(p,_p3q,0,c), pQ[4] = (T)(img)(_n1p,_p3q,0,c), pQ[5] = (T)(img)(_n2p,_p3q,0,c), pQ[6] = (T)(img)(_n3p,_p3q,0,c), pQ[7] = (T)(img)(_p3p,_p2q,0,c), pQ[8] = (T)(img)(_p2p,_p2q,0,c), pQ[9] = (T)(img)(_p1p,_p2q,0,c), pQ[10] = (T)(img)(p,_p2q,0,c), pQ[11] = (T)(img)(_n1p,_p2q,0,c), pQ[12] = (T)(img)(_n2p,_p2q,0,c), pQ[13] = (T)(img)(_n3p,_p2q,0,c), pQ[14] = (T)(img)(_p3p,_p1q,0,c), pQ[15] = (T)(img)(_p2p,_p1q,0,c), pQ[16] = (T)(img)(_p1p,_p1q,0,c), pQ[17] = (T)(img)(p,_p1q,0,c), pQ[18] = (T)(img)(_n1p,_p1q,0,c), pQ[19] = (T)(img)(_n2p,_p1q,0,c), pQ[20] = (T)(img)(_n3p,_p1q,0,c), pQ[21] = (T)(img)(_p3p,q,0,c), pQ[22] = (T)(img)(_p2p,q,0,c), pQ[23] = (T)(img)(_p1p,q,0,c), pQ[24] = (T)(img)(p,q,0,c), pQ[25] = (T)(img)(_n1p,q,0,c), pQ[26] = (T)(img)(_n2p,q,0,c), pQ[27] = (T)(img)(_n3p,q,0,c), pQ[28] = (T)(img)(_p3p,_n1q,0,c), pQ[29] = (T)(img)(_p2p,_n1q,0,c), pQ[30] = (T)(img)(_p1p,_n1q,0,c), pQ[31] = (T)(img)(p,_n1q,0,c), pQ[32] = (T)(img)(_n1p,_n1q,0,c), pQ[33] = (T)(img)(_n2p,_n1q,0,c), pQ[34] = (T)(img)(_n3p,_n1q,0,c), pQ[35] = (T)(img)(_p3p,_n2q,0,c), pQ[36] = (T)(img)(_p2p,_n2q,0,c), pQ[37] = (T)(img)(_p1p,_n2q,0,c), pQ[38] = (T)(img)(p,_n2q,0,c), pQ[39] = (T)(img)(_n1p,_n2q,0,c), pQ[40] = (T)(img)(_n2p,_n2q,0,c), pQ[41] = (T)(img)(_n3p,_n2q,0,c), pQ[42] = (T)(img)(_p3p,_n3q,0,c), pQ[43] = (T)(img)(_p2p,_n3q,0,c), pQ[44] = (T)(img)(_p1p,_n3q,0,c), pQ[45] = (T)(img)(p,_n3q,0,c), pQ[46] = (T)(img)(_n1p,_n3q,0,c), pQ[47] = (T)(img)(_n2p,_n3q,0,c), pQ[48] = (T)(img)(_n3p,_n3q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } else for (int y = 0, _p3y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2, _n3y = 3>=((res)._height)?(int)((res)._height)-1:3; _n3y<(int)((res)._height) || _n2y==--_n3y || _n1y==--_n2y || y==(_n3y = _n2y = --_n1y); _p3y = _p2y, _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y) for (int x = 0, _p3x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2, _n3x = 3>=((res)._width)?(int)((res)._width)-1:3; _n3x<(int)((res)._width) || _n2x==--_n3x || _n1x==--_n2x || x==(_n3x = _n2x = --_n1x); _p3x = _p2x, _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p3x,_p3y,0,c), pP[1] = (T)(img)(_p2x,_p3y,0,c), pP[2] = (T)(img)(_p1x,_p3y,0,c), pP[3] = (T)(img)(x,_p3y,0,c), pP[4] = (T)(img)(_n1x,_p3y,0,c), pP[5] = (T)(img)(_n2x,_p3y,0,c), pP[6] = (T)(img)(_n3x,_p3y,0,c), pP[7] = (T)(img)(_p3x,_p2y,0,c), pP[8] = (T)(img)(_p2x,_p2y,0,c), pP[9] = (T)(img)(_p1x,_p2y,0,c), pP[10] = (T)(img)(x,_p2y,0,c), pP[11] = (T)(img)(_n1x,_p2y,0,c), pP[12] = (T)(img)(_n2x,_p2y,0,c), pP[13] = (T)(img)(_n3x,_p2y,0,c), pP[14] = (T)(img)(_p3x,_p1y,0,c), pP[15] = (T)(img)(_p2x,_p1y,0,c), pP[16] = (T)(img)(_p1x,_p1y,0,c), pP[17] = (T)(img)(x,_p1y,0,c), pP[18] = (T)(img)(_n1x,_p1y,0,c), pP[19] = (T)(img)(_n2x,_p1y,0,c), pP[20] = (T)(img)(_n3x,_p1y,0,c), pP[21] = (T)(img)(_p3x,y,0,c), pP[22] = (T)(img)(_p2x,y,0,c), pP[23] = (T)(img)(_p1x,y,0,c), pP[24] = (T)(img)(x,y,0,c), pP[25] = (T)(img)(_n1x,y,0,c), pP[26] = (T)(img)(_n2x,y,0,c), pP[27] = (T)(img)(_n3x,y,0,c), pP[28] = (T)(img)(_p3x,_n1y,0,c), pP[29] = (T)(img)(_p2x,_n1y,0,c), pP[30] = (T)(img)(_p1x,_n1y,0,c), pP[31] = (T)(img)(x,_n1y,0,c), pP[32] = (T)(img)(_n1x,_n1y,0,c), pP[33] = (T)(img)(_n2x,_n1y,0,c), pP[34] = (T)(img)(_n3x,_n1y,0,c), pP[35] = (T)(img)(_p3x,_n2y,0,c), pP[36] = (T)(img)(_p2x,_n2y,0,c), pP[37] = (T)(img)(_p1x,_n2y,0,c), pP[38] = (T)(img)(x,_n2y,0,c), pP[39] = (T)(img)(_n1x,_n2y,0,c), pP[40] = (T)(img)(_n2x,_n2y,0,c), pP[41] = (T)(img)(_n3x,_n2y,0,c), pP[42] = (T)(img)(_p3x,_n3y,0,c), pP[43] = (T)(img)(_p2x,_n3y,0,c), pP[44] = (T)(img)(_p1x,_n3y,0,c), pP[45] = (T)(img)(x,_n3y,0,c), pP[46] = (T)(img)(_n1x,_n3y,0,c), pP[47] = (T)(img)(_n2x,_n3y,0,c), pP[48] = (T)(img)(_n3x,_n3y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0, weight_max = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p3q = q-3<0?0:q-3, _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2, _n3q = q+3>=(int)((res)._height)?(int)((res)._height)-1:q+3; q<=(int)(y1) && (_n3q<(int)((res)._height) || _n2q==--_n3q || _n1q==--_n2q || q==(_n3q = _n2q = --_n1q)); _p3q = _p2q, _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q, ++_n3q) for (int p = (int)(x0)<0?0:(int)(x0), _p3p = p-3<0?0:p-3, _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2, _n3p = p+3>=(int)((res)._width)?(int)((res)._width)-1:p+3; p<=(int)(x1) && (_n3p<(int)((res)._width) || _n2p==--_n3p || _n1p==--_n2p || p==(_n3p = _n2p = --_n1p)); _p3p = _p2p, _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p, ++_n3p) if (p!=x || q!=y) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p3p,_p3q,0,c), pQ[1] = (T)(img)(_p2p,_p3q,0,c), pQ[2] = (T)(img)(_p1p,_p3q,0,c), pQ[3] = (T)(img)(p,_p3q,0,c), pQ[4] = (T)(img)(_n1p,_p3q,0,c), pQ[5] = (T)(img)(_n2p,_p3q,0,c), pQ[6] = (T)(img)(_n3p,_p3q,0,c), pQ[7] = (T)(img)(_p3p,_p2q,0,c), pQ[8] = (T)(img)(_p2p,_p2q,0,c), pQ[9] = (T)(img)(_p1p,_p2q,0,c), pQ[10] = (T)(img)(p,_p2q,0,c), pQ[11] = (T)(img)(_n1p,_p2q,0,c), pQ[12] = (T)(img)(_n2p,_p2q,0,c), pQ[13] = (T)(img)(_n3p,_p2q,0,c), pQ[14] = (T)(img)(_p3p,_p1q,0,c), pQ[15] = (T)(img)(_p2p,_p1q,0,c), pQ[16] = (T)(img)(_p1p,_p1q,0,c), pQ[17] = (T)(img)(p,_p1q,0,c), pQ[18] = (T)(img)(_n1p,_p1q,0,c), pQ[19] = (T)(img)(_n2p,_p1q,0,c), pQ[20] = (T)(img)(_n3p,_p1q,0,c), pQ[21] = (T)(img)(_p3p,q,0,c), pQ[22] = (T)(img)(_p2p,q,0,c), pQ[23] = (T)(img)(_p1p,q,0,c), pQ[24] = (T)(img)(p,q,0,c), pQ[25] = (T)(img)(_n1p,q,0,c), pQ[26] = (T)(img)(_n2p,q,0,c), pQ[27] = (T)(img)(_n3p,q,0,c), pQ[28] = (T)(img)(_p3p,_n1q,0,c), pQ[29] = (T)(img)(_p2p,_n1q,0,c), pQ[30] = (T)(img)(_p1p,_n1q,0,c), pQ[31] = (T)(img)(p,_n1q,0,c), pQ[32] = (T)(img)(_n1p,_n1q,0,c), pQ[33] = (T)(img)(_n2p,_n1q,0,c), pQ[34] = (T)(img)(_n3p,_n1q,0,c), pQ[35] = (T)(img)(_p3p,_n2q,0,c), pQ[36] = (T)(img)(_p2p,_n2q,0,c), pQ[37] = (T)(img)(_p1p,_n2q,0,c), pQ[38] = (T)(img)(p,_n2q,0,c), pQ[39] = (T)(img)(_n1p,_n2q,0,c), pQ[40] = (T)(img)(_n2p,_n2q,0,c), pQ[41] = (T)(img)(_n3p,_n2q,0,c), pQ[42] = (T)(img)(_p3p,_n3q,0,c), pQ[43] = (T)(img)(_p2p,_n3q,0,c), pQ[44] = (T)(img)(_p1p,_n3q,0,c), pQ[45] = (T)(img)(p,_n3q,0,c), pQ[46] = (T)(img)(_n1p,_n3q,0,c), pQ[47] = (T)(img)(_n2p,_n3q,0,c), pQ[48] = (T)(img)(_n3p,_n3q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } break;
        case 8 : if (is_fast_approx) for (int y = 0, _p3y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2, _n3y = 3>=((res)._height)?(int)((res)._height)-1:3, _n4y = 4>=((res)._height)?(int)((res)._height)-1:4; _n4y<(int)((res)._height) || _n3y==--_n4y || _n2y==--_n3y || _n1y==--_n2y || y==(_n4y = _n3y = _n2y = --_n1y); _p3y = _p2y, _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y, ++_n4y) for (int x = 0, _p3x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2, _n3x = 3>=((res)._width)?(int)((res)._width)-1:3, _n4x = 4>=((res)._width)?(int)((res)._width)-1:4; _n4x<(int)((res)._width) || _n3x==--_n4x || _n2x==--_n3x || _n1x==--_n2x || x==(_n4x = _n3x = _n2x = --_n1x); _p3x = _p2x, _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x, ++_n4x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p3x,_p3y,0,c), pP[1] = (T)(img)(_p2x,_p3y,0,c), pP[2] = (T)(img)(_p1x,_p3y,0,c), pP[3] = (T)(img)(x,_p3y,0,c), pP[4] = (T)(img)(_n1x,_p3y,0,c), pP[5] = (T)(img)(_n2x,_p3y,0,c), pP[6] = (T)(img)(_n3x,_p3y,0,c), pP[7] = (T)(img)(_n4x,_p3y,0,c), pP[8] = (T)(img)(_p3x,_p2y,0,c), pP[9] = (T)(img)(_p2x,_p2y,0,c), pP[10] = (T)(img)(_p1x,_p2y,0,c), pP[11] = (T)(img)(x,_p2y,0,c), pP[12] = (T)(img)(_n1x,_p2y,0,c), pP[13] = (T)(img)(_n2x,_p2y,0,c), pP[14] = (T)(img)(_n3x,_p2y,0,c), pP[15] = (T)(img)(_n4x,_p2y,0,c), pP[16] = (T)(img)(_p3x,_p1y,0,c), pP[17] = (T)(img)(_p2x,_p1y,0,c), pP[18] = (T)(img)(_p1x,_p1y,0,c), pP[19] = (T)(img)(x,_p1y,0,c), pP[20] = (T)(img)(_n1x,_p1y,0,c), pP[21] = (T)(img)(_n2x,_p1y,0,c), pP[22] = (T)(img)(_n3x,_p1y,0,c), pP[23] = (T)(img)(_n4x,_p1y,0,c), pP[24] = (T)(img)(_p3x,y,0,c), pP[25] = (T)(img)(_p2x,y,0,c), pP[26] = (T)(img)(_p1x,y,0,c), pP[27] = (T)(img)(x,y,0,c), pP[28] = (T)(img)(_n1x,y,0,c), pP[29] = (T)(img)(_n2x,y,0,c), pP[30] = (T)(img)(_n3x,y,0,c), pP[31] = (T)(img)(_n4x,y,0,c), pP[32] = (T)(img)(_p3x,_n1y,0,c), pP[33] = (T)(img)(_p2x,_n1y,0,c), pP[34] = (T)(img)(_p1x,_n1y,0,c), pP[35] = (T)(img)(x,_n1y,0,c), pP[36] = (T)(img)(_n1x,_n1y,0,c), pP[37] = (T)(img)(_n2x,_n1y,0,c), pP[38] = (T)(img)(_n3x,_n1y,0,c), pP[39] = (T)(img)(_n4x,_n1y,0,c), pP[40] = (T)(img)(_p3x,_n2y,0,c), pP[41] = (T)(img)(_p2x,_n2y,0,c), pP[42] = (T)(img)(_p1x,_n2y,0,c), pP[43] = (T)(img)(x,_n2y,0,c), pP[44] = (T)(img)(_n1x,_n2y,0,c), pP[45] = (T)(img)(_n2x,_n2y,0,c), pP[46] = (T)(img)(_n3x,_n2y,0,c), pP[47] = (T)(img)(_n4x,_n2y,0,c), pP[48] = (T)(img)(_p3x,_n3y,0,c), pP[49] = (T)(img)(_p2x,_n3y,0,c), pP[50] = (T)(img)(_p1x,_n3y,0,c), pP[51] = (T)(img)(x,_n3y,0,c), pP[52] = (T)(img)(_n1x,_n3y,0,c), pP[53] = (T)(img)(_n2x,_n3y,0,c), pP[54] = (T)(img)(_n3x,_n3y,0,c), pP[55] = (T)(img)(_n4x,_n3y,0,c), pP[56] = (T)(img)(_p3x,_n4y,0,c), pP[57] = (T)(img)(_p2x,_n4y,0,c), pP[58] = (T)(img)(_p1x,_n4y,0,c), pP[59] = (T)(img)(x,_n4y,0,c), pP[60] = (T)(img)(_n1x,_n4y,0,c), pP[61] = (T)(img)(_n2x,_n4y,0,c), pP[62] = (T)(img)(_n3x,_n4y,0,c), pP[63] = (T)(img)(_n4x,_n4y,0,c);; pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p3q = q-3<0?0:q-3, _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2, _n3q = q+3>=(int)((res)._height)?(int)((res)._height)-1:q+3, _n4q = q+4>=(int)((res)._height)?(int)((res)._height)-1:q+4; q<=(int)(y1) && (_n4q<(int)((res)._height) || _n3q==--_n4q || _n2q==--_n3q || _n1q==--_n2q || q==(_n4q = _n3q = _n2q = --_n1q)); _p3q = _p2q, _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q, ++_n3q, ++_n4q) for (int p = (int)(x0)<0?0:(int)(x0), _p3p = p-3<0?0:p-3, _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2, _n3p = p+3>=(int)((res)._width)?(int)((res)._width)-1:p+3, _n4p = p+4>=(int)((res)._width)?(int)((res)._width)-1:p+4; p<=(int)(x1) && (_n4p<(int)((res)._width) || _n3p==--_n4p || _n2p==--_n3p || _n1p==--_n2p || p==(_n4p = _n3p = _n2p = --_n1p)); _p3p = _p2p, _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p, ++_n3p, ++_n4p) if (cimg::abs(img(x,y,0,0) - img(p,q,0,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p3p,_p3q,0,c), pQ[1] = (T)(img)(_p2p,_p3q,0,c), pQ[2] = (T)(img)(_p1p,_p3q,0,c), pQ[3] = (T)(img)(p,_p3q,0,c), pQ[4] = (T)(img)(_n1p,_p3q,0,c), pQ[5] = (T)(img)(_n2p,_p3q,0,c), pQ[6] = (T)(img)(_n3p,_p3q,0,c), pQ[7] = (T)(img)(_n4p,_p3q,0,c), pQ[8] = (T)(img)(_p3p,_p2q,0,c), pQ[9] = (T)(img)(_p2p,_p2q,0,c), pQ[10] = (T)(img)(_p1p,_p2q,0,c), pQ[11] = (T)(img)(p,_p2q,0,c), pQ[12] = (T)(img)(_n1p,_p2q,0,c), pQ[13] = (T)(img)(_n2p,_p2q,0,c), pQ[14] = (T)(img)(_n3p,_p2q,0,c), pQ[15] = (T)(img)(_n4p,_p2q,0,c), pQ[16] = (T)(img)(_p3p,_p1q,0,c), pQ[17] = (T)(img)(_p2p,_p1q,0,c), pQ[18] = (T)(img)(_p1p,_p1q,0,c), pQ[19] = (T)(img)(p,_p1q,0,c), pQ[20] = (T)(img)(_n1p,_p1q,0,c), pQ[21] = (T)(img)(_n2p,_p1q,0,c), pQ[22] = (T)(img)(_n3p,_p1q,0,c), pQ[23] = (T)(img)(_n4p,_p1q,0,c), pQ[24] = (T)(img)(_p3p,q,0,c), pQ[25] = (T)(img)(_p2p,q,0,c), pQ[26] = (T)(img)(_p1p,q,0,c), pQ[27] = (T)(img)(p,q,0,c), pQ[28] = (T)(img)(_n1p,q,0,c), pQ[29] = (T)(img)(_n2p,q,0,c), pQ[30] = (T)(img)(_n3p,q,0,c), pQ[31] = (T)(img)(_n4p,q,0,c), pQ[32] = (T)(img)(_p3p,_n1q,0,c), pQ[33] = (T)(img)(_p2p,_n1q,0,c), pQ[34] = (T)(img)(_p1p,_n1q,0,c), pQ[35] = (T)(img)(p,_n1q,0,c), pQ[36] = (T)(img)(_n1p,_n1q,0,c), pQ[37] = (T)(img)(_n2p,_n1q,0,c), pQ[38] = (T)(img)(_n3p,_n1q,0,c), pQ[39] = (T)(img)(_n4p,_n1q,0,c), pQ[40] = (T)(img)(_p3p,_n2q,0,c), pQ[41] = (T)(img)(_p2p,_n2q,0,c), pQ[42] = (T)(img)(_p1p,_n2q,0,c), pQ[43] = (T)(img)(p,_n2q,0,c), pQ[44] = (T)(img)(_n1p,_n2q,0,c), pQ[45] = (T)(img)(_n2p,_n2q,0,c), pQ[46] = (T)(img)(_n3p,_n2q,0,c), pQ[47] = (T)(img)(_n4p,_n2q,0,c), pQ[48] = (T)(img)(_p3p,_n3q,0,c), pQ[49] = (T)(img)(_p2p,_n3q,0,c), pQ[50] = (T)(img)(_p1p,_n3q,0,c), pQ[51] = (T)(img)(p,_n3q,0,c), pQ[52] = (T)(img)(_n1p,_n3q,0,c), pQ[53] = (T)(img)(_n2p,_n3q,0,c), pQ[54] = (T)(img)(_n3p,_n3q,0,c), pQ[55] = (T)(img)(_n4p,_n3q,0,c), pQ[56] = (T)(img)(_p3p,_n4q,0,c), pQ[57] = (T)(img)(_p2p,_n4q,0,c), pQ[58] = (T)(img)(_p1p,_n4q,0,c), pQ[59] = (T)(img)(p,_n4q,0,c), pQ[60] = (T)(img)(_n1p,_n4q,0,c), pQ[61] = (T)(img)(_n2p,_n4q,0,c), pQ[62] = (T)(img)(_n3p,_n4q,0,c), pQ[63] = (T)(img)(_n4p,_n4q,0,c);; pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } else for (int y = 0, _p3y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=((res)._height)?(int)((res)._height)-1:2, _n3y = 3>=((res)._height)?(int)((res)._height)-1:3, _n4y = 4>=((res)._height)?(int)((res)._height)-1:4; _n4y<(int)((res)._height) || _n3y==--_n4y || _n2y==--_n3y || _n1y==--_n2y || y==(_n4y = _n3y = _n2y = --_n1y); _p3y = _p2y, _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y, ++_n4y) for (int x = 0, _p3x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=((res)._width)?(int)((res)._width)-1:2, _n3x = 3>=((res)._width)?(int)((res)._width)-1:3, _n4x = 4>=((res)._width)?(int)((res)._width)-1:4; _n4x<(int)((res)._width) || _n3x==--_n4x || _n2x==--_n3x || _n1x==--_n2x || x==(_n4x = _n3x = _n2x = --_n1x); _p3x = _p2x, _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x, ++_n4x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p3x,_p3y,0,c), pP[1] = (T)(img)(_p2x,_p3y,0,c), pP[2] = (T)(img)(_p1x,_p3y,0,c), pP[3] = (T)(img)(x,_p3y,0,c), pP[4] = (T)(img)(_n1x,_p3y,0,c), pP[5] = (T)(img)(_n2x,_p3y,0,c), pP[6] = (T)(img)(_n3x,_p3y,0,c), pP[7] = (T)(img)(_n4x,_p3y,0,c), pP[8] = (T)(img)(_p3x,_p2y,0,c), pP[9] = (T)(img)(_p2x,_p2y,0,c), pP[10] = (T)(img)(_p1x,_p2y,0,c), pP[11] = (T)(img)(x,_p2y,0,c), pP[12] = (T)(img)(_n1x,_p2y,0,c), pP[13] = (T)(img)(_n2x,_p2y,0,c), pP[14] = (T)(img)(_n3x,_p2y,0,c), pP[15] = (T)(img)(_n4x,_p2y,0,c), pP[16] = (T)(img)(_p3x,_p1y,0,c), pP[17] = (T)(img)(_p2x,_p1y,0,c), pP[18] = (T)(img)(_p1x,_p1y,0,c), pP[19] = (T)(img)(x,_p1y,0,c), pP[20] = (T)(img)(_n1x,_p1y,0,c), pP[21] = (T)(img)(_n2x,_p1y,0,c), pP[22] = (T)(img)(_n3x,_p1y,0,c), pP[23] = (T)(img)(_n4x,_p1y,0,c), pP[24] = (T)(img)(_p3x,y,0,c), pP[25] = (T)(img)(_p2x,y,0,c), pP[26] = (T)(img)(_p1x,y,0,c), pP[27] = (T)(img)(x,y,0,c), pP[28] = (T)(img)(_n1x,y,0,c), pP[29] = (T)(img)(_n2x,y,0,c), pP[30] = (T)(img)(_n3x,y,0,c), pP[31] = (T)(img)(_n4x,y,0,c), pP[32] = (T)(img)(_p3x,_n1y,0,c), pP[33] = (T)(img)(_p2x,_n1y,0,c), pP[34] = (T)(img)(_p1x,_n1y,0,c), pP[35] = (T)(img)(x,_n1y,0,c), pP[36] = (T)(img)(_n1x,_n1y,0,c), pP[37] = (T)(img)(_n2x,_n1y,0,c), pP[38] = (T)(img)(_n3x,_n1y,0,c), pP[39] = (T)(img)(_n4x,_n1y,0,c), pP[40] = (T)(img)(_p3x,_n2y,0,c), pP[41] = (T)(img)(_p2x,_n2y,0,c), pP[42] = (T)(img)(_p1x,_n2y,0,c), pP[43] = (T)(img)(x,_n2y,0,c), pP[44] = (T)(img)(_n1x,_n2y,0,c), pP[45] = (T)(img)(_n2x,_n2y,0,c), pP[46] = (T)(img)(_n3x,_n2y,0,c), pP[47] = (T)(img)(_n4x,_n2y,0,c), pP[48] = (T)(img)(_p3x,_n3y,0,c), pP[49] = (T)(img)(_p2x,_n3y,0,c), pP[50] = (T)(img)(_p1x,_n3y,0,c), pP[51] = (T)(img)(x,_n3y,0,c), pP[52] = (T)(img)(_n1x,_n3y,0,c), pP[53] = (T)(img)(_n2x,_n3y,0,c), pP[54] = (T)(img)(_n3x,_n3y,0,c), pP[55] = (T)(img)(_n4x,_n3y,0,c), pP[56] = (T)(img)(_p3x,_n4y,0,c), pP[57] = (T)(img)(_p2x,_n4y,0,c), pP[58] = (T)(img)(_p1x,_n4y,0,c), pP[59] = (T)(img)(x,_n4y,0,c), pP[60] = (T)(img)(_n1x,_n4y,0,c), pP[61] = (T)(img)(_n2x,_n4y,0,c), pP[62] = (T)(img)(_n3x,_n4y,0,c), pP[63] = (T)(img)(_n4x,_n4y,0,c);; pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0, weight_max = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p3q = q-3<0?0:q-3, _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2, _n3q = q+3>=(int)((res)._height)?(int)((res)._height)-1:q+3, _n4q = q+4>=(int)((res)._height)?(int)((res)._height)-1:q+4; q<=(int)(y1) && (_n4q<(int)((res)._height) || _n3q==--_n4q || _n2q==--_n3q || _n1q==--_n2q || q==(_n4q = _n3q = _n2q = --_n1q)); _p3q = _p2q, _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q, ++_n3q, ++_n4q) for (int p = (int)(x0)<0?0:(int)(x0), _p3p = p-3<0?0:p-3, _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2, _n3p = p+3>=(int)((res)._width)?(int)((res)._width)-1:p+3, _n4p = p+4>=(int)((res)._width)?(int)((res)._width)-1:p+4; p<=(int)(x1) && (_n4p<(int)((res)._width) || _n3p==--_n4p || _n2p==--_n3p || _n1p==--_n2p || p==(_n4p = _n3p = _n2p = --_n1p)); _p3p = _p2p, _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p, ++_n3p, ++_n4p) if (p!=x || q!=y) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p3p,_p3q,0,c), pQ[1] = (T)(img)(_p2p,_p3q,0,c), pQ[2] = (T)(img)(_p1p,_p3q,0,c), pQ[3] = (T)(img)(p,_p3q,0,c), pQ[4] = (T)(img)(_n1p,_p3q,0,c), pQ[5] = (T)(img)(_n2p,_p3q,0,c), pQ[6] = (T)(img)(_n3p,_p3q,0,c), pQ[7] = (T)(img)(_n4p,_p3q,0,c), pQ[8] = (T)(img)(_p3p,_p2q,0,c), pQ[9] = (T)(img)(_p2p,_p2q,0,c), pQ[10] = (T)(img)(_p1p,_p2q,0,c), pQ[11] = (T)(img)(p,_p2q,0,c), pQ[12] = (T)(img)(_n1p,_p2q,0,c), pQ[13] = (T)(img)(_n2p,_p2q,0,c), pQ[14] = (T)(img)(_n3p,_p2q,0,c), pQ[15] = (T)(img)(_n4p,_p2q,0,c), pQ[16] = (T)(img)(_p3p,_p1q,0,c), pQ[17] = (T)(img)(_p2p,_p1q,0,c), pQ[18] = (T)(img)(_p1p,_p1q,0,c), pQ[19] = (T)(img)(p,_p1q,0,c), pQ[20] = (T)(img)(_n1p,_p1q,0,c), pQ[21] = (T)(img)(_n2p,_p1q,0,c), pQ[22] = (T)(img)(_n3p,_p1q,0,c), pQ[23] = (T)(img)(_n4p,_p1q,0,c), pQ[24] = (T)(img)(_p3p,q,0,c), pQ[25] = (T)(img)(_p2p,q,0,c), pQ[26] = (T)(img)(_p1p,q,0,c), pQ[27] = (T)(img)(p,q,0,c), pQ[28] = (T)(img)(_n1p,q,0,c), pQ[29] = (T)(img)(_n2p,q,0,c), pQ[30] = (T)(img)(_n3p,q,0,c), pQ[31] = (T)(img)(_n4p,q,0,c), pQ[32] = (T)(img)(_p3p,_n1q,0,c), pQ[33] = (T)(img)(_p2p,_n1q,0,c), pQ[34] = (T)(img)(_p1p,_n1q,0,c), pQ[35] = (T)(img)(p,_n1q,0,c), pQ[36] = (T)(img)(_n1p,_n1q,0,c), pQ[37] = (T)(img)(_n2p,_n1q,0,c), pQ[38] = (T)(img)(_n3p,_n1q,0,c), pQ[39] = (T)(img)(_n4p,_n1q,0,c), pQ[40] = (T)(img)(_p3p,_n2q,0,c), pQ[41] = (T)(img)(_p2p,_n2q,0,c), pQ[42] = (T)(img)(_p1p,_n2q,0,c), pQ[43] = (T)(img)(p,_n2q,0,c), pQ[44] = (T)(img)(_n1p,_n2q,0,c), pQ[45] = (T)(img)(_n2p,_n2q,0,c), pQ[46] = (T)(img)(_n3p,_n2q,0,c), pQ[47] = (T)(img)(_n4p,_n2q,0,c), pQ[48] = (T)(img)(_p3p,_n3q,0,c), pQ[49] = (T)(img)(_p2p,_n3q,0,c), pQ[50] = (T)(img)(_p1p,_n3q,0,c), pQ[51] = (T)(img)(p,_n3q,0,c), pQ[52] = (T)(img)(_n1p,_n3q,0,c), pQ[53] = (T)(img)(_n2p,_n3q,0,c), pQ[54] = (T)(img)(_n3p,_n3q,0,c), pQ[55] = (T)(img)(_n4p,_n3q,0,c), pQ[56] = (T)(img)(_p3p,_n4q,0,c), pQ[57] = (T)(img)(_p2p,_n4q,0,c), pQ[58] = (T)(img)(_p1p,_n4q,0,c), pQ[59] = (T)(img)(p,_n4q,0,c), pQ[60] = (T)(img)(_n1p,_n4q,0,c), pQ[61] = (T)(img)(_n2p,_n4q,0,c), pQ[62] = (T)(img)(_n3p,_n4q,0,c), pQ[63] = (T)(img)(_n4p,_n4q,0,c);; pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } break;
        case 9 : if (is_fast_approx) for (int y = 0, _p4y = 0, _p3y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=(int)((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=(int)((res)._height)?(int)((res)._height)-1:2, _n3y = 3>=(int)((res)._height)?(int)((res)._height)-1:3, _n4y = 4>=(int)((res)._height)?(int)((res)._height)-1:4; _n4y<(int)((res)._height) || _n3y==--_n4y || _n2y==--_n3y || _n1y==--_n2y || y==(_n4y = _n3y = _n2y = --_n1y); _p4y = _p3y, _p3y = _p2y, _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y, ++_n4y) for (int x = 0, _p4x = 0, _p3x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=(int)((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=(int)((res)._width)?(int)((res)._width)-1:2, _n3x = 3>=(int)((res)._width)?(int)((res)._width)-1:3, _n4x = 4>=(int)((res)._width)?(int)((res)._width)-1:4; _n4x<(int)((res)._width) || _n3x==--_n4x || _n2x==--_n3x || _n1x==--_n2x || x==(_n4x = _n3x = _n2x = --_n1x); _p4x = _p3x, _p3x = _p2x, _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x, ++_n4x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p4x,_p4y,0,c), pP[1] = (T)(img)(_p3x,_p4y,0,c), pP[2] = (T)(img)(_p2x,_p4y,0,c), pP[3] = (T)(img)(_p1x,_p4y,0,c), pP[4] = (T)(img)(x,_p4y,0,c), pP[5] = (T)(img)(_n1x,_p4y,0,c), pP[6] = (T)(img)(_n2x,_p4y,0,c), pP[7] = (T)(img)(_n3x,_p4y,0,c), pP[8] = (T)(img)(_n4x,_p4y,0,c), pP[9] = (T)(img)(_p4x,_p3y,0,c), pP[10] = (T)(img)(_p3x,_p3y,0,c), pP[11] = (T)(img)(_p2x,_p3y,0,c), pP[12] = (T)(img)(_p1x,_p3y,0,c), pP[13] = (T)(img)(x,_p3y,0,c), pP[14] = (T)(img)(_n1x,_p3y,0,c), pP[15] = (T)(img)(_n2x,_p3y,0,c), pP[16] = (T)(img)(_n3x,_p3y,0,c), pP[17] = (T)(img)(_n4x,_p3y,0,c), pP[18] = (T)(img)(_p4x,_p2y,0,c), pP[19] = (T)(img)(_p3x,_p2y,0,c), pP[20] = (T)(img)(_p2x,_p2y,0,c), pP[21] = (T)(img)(_p1x,_p2y,0,c), pP[22] = (T)(img)(x,_p2y,0,c), pP[23] = (T)(img)(_n1x,_p2y,0,c), pP[24] = (T)(img)(_n2x,_p2y,0,c), pP[25] = (T)(img)(_n3x,_p2y,0,c), pP[26] = (T)(img)(_n4x,_p2y,0,c), pP[27] = (T)(img)(_p4x,_p1y,0,c), pP[28] = (T)(img)(_p3x,_p1y,0,c), pP[29] = (T)(img)(_p2x,_p1y,0,c), pP[30] = (T)(img)(_p1x,_p1y,0,c), pP[31] = (T)(img)(x,_p1y,0,c), pP[32] = (T)(img)(_n1x,_p1y,0,c), pP[33] = (T)(img)(_n2x,_p1y,0,c), pP[34] = (T)(img)(_n3x,_p1y,0,c), pP[35] = (T)(img)(_n4x,_p1y,0,c), pP[36] = (T)(img)(_p4x,y,0,c), pP[37] = (T)(img)(_p3x,y,0,c), pP[38] = (T)(img)(_p2x,y,0,c), pP[39] = (T)(img)(_p1x,y,0,c), pP[40] = (T)(img)(x,y,0,c), pP[41] = (T)(img)(_n1x,y,0,c), pP[42] = (T)(img)(_n2x,y,0,c), pP[43] = (T)(img)(_n3x,y,0,c), pP[44] = (T)(img)(_n4x,y,0,c), pP[45] = (T)(img)(_p4x,_n1y,0,c), pP[46] = (T)(img)(_p3x,_n1y,0,c), pP[47] = (T)(img)(_p2x,_n1y,0,c), pP[48] = (T)(img)(_p1x,_n1y,0,c), pP[49] = (T)(img)(x,_n1y,0,c), pP[50] = (T)(img)(_n1x,_n1y,0,c), pP[51] = (T)(img)(_n2x,_n1y,0,c), pP[52] = (T)(img)(_n3x,_n1y,0,c), pP[53] = (T)(img)(_n4x,_n1y,0,c), pP[54] = (T)(img)(_p4x,_n2y,0,c), pP[55] = (T)(img)(_p3x,_n2y,0,c), pP[56] = (T)(img)(_p2x,_n2y,0,c), pP[57] = (T)(img)(_p1x,_n2y,0,c), pP[58] = (T)(img)(x,_n2y,0,c), pP[59] = (T)(img)(_n1x,_n2y,0,c), pP[60] = (T)(img)(_n2x,_n2y,0,c), pP[61] = (T)(img)(_n3x,_n2y,0,c), pP[62] = (T)(img)(_n4x,_n2y,0,c), pP[63] = (T)(img)(_p4x,_n3y,0,c), pP[64] = (T)(img)(_p3x,_n3y,0,c), pP[65] = (T)(img)(_p2x,_n3y,0,c), pP[66] = (T)(img)(_p1x,_n3y,0,c), pP[67] = (T)(img)(x,_n3y,0,c), pP[68] = (T)(img)(_n1x,_n3y,0,c), pP[69] = (T)(img)(_n2x,_n3y,0,c), pP[70] = (T)(img)(_n3x,_n3y,0,c), pP[71] = (T)(img)(_n4x,_n3y,0,c), pP[72] = (T)(img)(_p4x,_n4y,0,c), pP[73] = (T)(img)(_p3x,_n4y,0,c), pP[74] = (T)(img)(_p2x,_n4y,0,c), pP[75] = (T)(img)(_p1x,_n4y,0,c), pP[76] = (T)(img)(x,_n4y,0,c), pP[77] = (T)(img)(_n1x,_n4y,0,c), pP[78] = (T)(img)(_n2x,_n4y,0,c), pP[79] = (T)(img)(_n3x,_n4y,0,c), pP[80] = (T)(img)(_n4x,_n4y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p4q = q-4<0?0:q-4, _p3q = q-3<0?0:q-3, _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2, _n3q = q+3>=(int)((res)._height)?(int)((res)._height)-1:q+3, _n4q = q+4>=(int)((res)._height)?(int)((res)._height)-1:q+4; q<=(int)(y1) && (_n4q<(int)((res)._height) || _n3q==--_n4q || _n2q==--_n3q || _n1q==--_n2q || q==(_n4q = _n3q = _n2q = --_n1q)); _p4q = _p3q, _p3q = _p2q, _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q, ++_n3q, ++_n4q) for (int p = (int)(x0)<0?0:(int)(x0), _p4p = p-4<0?0:p-4, _p3p = p-3<0?0:p-3, _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2, _n3p = p+3>=(int)((res)._width)?(int)((res)._width)-1:p+3, _n4p = p+4>=(int)((res)._width)?(int)((res)._width)-1:p+4; p<=(int)(x1) && (_n4p<(int)((res)._width) || _n3p==--_n4p || _n2p==--_n3p || _n1p==--_n2p || p==(_n4p = _n3p = _n2p = --_n1p)); _p4p = _p3p, _p3p = _p2p, _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p, ++_n3p, ++_n4p) if (cimg::abs(img(x,y,0,0) - img(p,q,0,0))<sigma_p3) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p4p,_p4q,0,c), pQ[1] = (T)(img)(_p3p,_p4q,0,c), pQ[2] = (T)(img)(_p2p,_p4q,0,c), pQ[3] = (T)(img)(_p1p,_p4q,0,c), pQ[4] = (T)(img)(p,_p4q,0,c), pQ[5] = (T)(img)(_n1p,_p4q,0,c), pQ[6] = (T)(img)(_n2p,_p4q,0,c), pQ[7] = (T)(img)(_n3p,_p4q,0,c), pQ[8] = (T)(img)(_n4p,_p4q,0,c), pQ[9] = (T)(img)(_p4p,_p3q,0,c), pQ[10] = (T)(img)(_p3p,_p3q,0,c), pQ[11] = (T)(img)(_p2p,_p3q,0,c), pQ[12] = (T)(img)(_p1p,_p3q,0,c), pQ[13] = (T)(img)(p,_p3q,0,c), pQ[14] = (T)(img)(_n1p,_p3q,0,c), pQ[15] = (T)(img)(_n2p,_p3q,0,c), pQ[16] = (T)(img)(_n3p,_p3q,0,c), pQ[17] = (T)(img)(_n4p,_p3q,0,c), pQ[18] = (T)(img)(_p4p,_p2q,0,c), pQ[19] = (T)(img)(_p3p,_p2q,0,c), pQ[20] = (T)(img)(_p2p,_p2q,0,c), pQ[21] = (T)(img)(_p1p,_p2q,0,c), pQ[22] = (T)(img)(p,_p2q,0,c), pQ[23] = (T)(img)(_n1p,_p2q,0,c), pQ[24] = (T)(img)(_n2p,_p2q,0,c), pQ[25] = (T)(img)(_n3p,_p2q,0,c), pQ[26] = (T)(img)(_n4p,_p2q,0,c), pQ[27] = (T)(img)(_p4p,_p1q,0,c), pQ[28] = (T)(img)(_p3p,_p1q,0,c), pQ[29] = (T)(img)(_p2p,_p1q,0,c), pQ[30] = (T)(img)(_p1p,_p1q,0,c), pQ[31] = (T)(img)(p,_p1q,0,c), pQ[32] = (T)(img)(_n1p,_p1q,0,c), pQ[33] = (T)(img)(_n2p,_p1q,0,c), pQ[34] = (T)(img)(_n3p,_p1q,0,c), pQ[35] = (T)(img)(_n4p,_p1q,0,c), pQ[36] = (T)(img)(_p4p,q,0,c), pQ[37] = (T)(img)(_p3p,q,0,c), pQ[38] = (T)(img)(_p2p,q,0,c), pQ[39] = (T)(img)(_p1p,q,0,c), pQ[40] = (T)(img)(p,q,0,c), pQ[41] = (T)(img)(_n1p,q,0,c), pQ[42] = (T)(img)(_n2p,q,0,c), pQ[43] = (T)(img)(_n3p,q,0,c), pQ[44] = (T)(img)(_n4p,q,0,c), pQ[45] = (T)(img)(_p4p,_n1q,0,c), pQ[46] = (T)(img)(_p3p,_n1q,0,c), pQ[47] = (T)(img)(_p2p,_n1q,0,c), pQ[48] = (T)(img)(_p1p,_n1q,0,c), pQ[49] = (T)(img)(p,_n1q,0,c), pQ[50] = (T)(img)(_n1p,_n1q,0,c), pQ[51] = (T)(img)(_n2p,_n1q,0,c), pQ[52] = (T)(img)(_n3p,_n1q,0,c), pQ[53] = (T)(img)(_n4p,_n1q,0,c), pQ[54] = (T)(img)(_p4p,_n2q,0,c), pQ[55] = (T)(img)(_p3p,_n2q,0,c), pQ[56] = (T)(img)(_p2p,_n2q,0,c), pQ[57] = (T)(img)(_p1p,_n2q,0,c), pQ[58] = (T)(img)(p,_n2q,0,c), pQ[59] = (T)(img)(_n1p,_n2q,0,c), pQ[60] = (T)(img)(_n2p,_n2q,0,c), pQ[61] = (T)(img)(_n3p,_n2q,0,c), pQ[62] = (T)(img)(_n4p,_n2q,0,c), pQ[63] = (T)(img)(_p4p,_n3q,0,c), pQ[64] = (T)(img)(_p3p,_n3q,0,c), pQ[65] = (T)(img)(_p2p,_n3q,0,c), pQ[66] = (T)(img)(_p1p,_n3q,0,c), pQ[67] = (T)(img)(p,_n3q,0,c), pQ[68] = (T)(img)(_n1p,_n3q,0,c), pQ[69] = (T)(img)(_n2p,_n3q,0,c), pQ[70] = (T)(img)(_n3p,_n3q,0,c), pQ[71] = (T)(img)(_n4p,_n3q,0,c), pQ[72] = (T)(img)(_p4p,_n4q,0,c), pQ[73] = (T)(img)(_p3p,_n4q,0,c), pQ[74] = (T)(img)(_p2p,_n4q,0,c), pQ[75] = (T)(img)(_p1p,_n4q,0,c), pQ[76] = (T)(img)(p,_n4q,0,c), pQ[77] = (T)(img)(_n1p,_n4q,0,c), pQ[78] = (T)(img)(_n2p,_n4q,0,c), pQ[79] = (T)(img)(_n3p,_n4q,0,c), pQ[80] = (T)(img)(_n4p,_n4q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = alldist>3?0.0f:1.0f; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } else for (int y = 0, _p4y = 0, _p3y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=(int)((res)._height)?(int)((res)._height)-1:1, _n2y = 2>=(int)((res)._height)?(int)((res)._height)-1:2, _n3y = 3>=(int)((res)._height)?(int)((res)._height)-1:3, _n4y = 4>=(int)((res)._height)?(int)((res)._height)-1:4; _n4y<(int)((res)._height) || _n3y==--_n4y || _n2y==--_n3y || _n1y==--_n2y || y==(_n4y = _n3y = _n2y = --_n1y); _p4y = _p3y, _p3y = _p2y, _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y, ++_n3y, ++_n4y) for (int x = 0, _p4x = 0, _p3x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=(int)((res)._width)?(int)((res)._width)-1:1, _n2x = 2>=(int)((res)._width)?(int)((res)._width)-1:2, _n3x = 3>=(int)((res)._width)?(int)((res)._width)-1:3, _n4x = 4>=(int)((res)._width)?(int)((res)._width)-1:4; _n4x<(int)((res)._width) || _n3x==--_n4x || _n2x==--_n3x || _n1x==--_n2x || x==(_n4x = _n3x = _n2x = --_n1x); _p4x = _p3x, _p3x = _p2x, _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x, ++_n3x, ++_n4x) { T *pP = P._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pP[0] = (T)(img)(_p4x,_p4y,0,c), pP[1] = (T)(img)(_p3x,_p4y,0,c), pP[2] = (T)(img)(_p2x,_p4y,0,c), pP[3] = (T)(img)(_p1x,_p4y,0,c), pP[4] = (T)(img)(x,_p4y,0,c), pP[5] = (T)(img)(_n1x,_p4y,0,c), pP[6] = (T)(img)(_n2x,_p4y,0,c), pP[7] = (T)(img)(_n3x,_p4y,0,c), pP[8] = (T)(img)(_n4x,_p4y,0,c), pP[9] = (T)(img)(_p4x,_p3y,0,c), pP[10] = (T)(img)(_p3x,_p3y,0,c), pP[11] = (T)(img)(_p2x,_p3y,0,c), pP[12] = (T)(img)(_p1x,_p3y,0,c), pP[13] = (T)(img)(x,_p3y,0,c), pP[14] = (T)(img)(_n1x,_p3y,0,c), pP[15] = (T)(img)(_n2x,_p3y,0,c), pP[16] = (T)(img)(_n3x,_p3y,0,c), pP[17] = (T)(img)(_n4x,_p3y,0,c), pP[18] = (T)(img)(_p4x,_p2y,0,c), pP[19] = (T)(img)(_p3x,_p2y,0,c), pP[20] = (T)(img)(_p2x,_p2y,0,c), pP[21] = (T)(img)(_p1x,_p2y,0,c), pP[22] = (T)(img)(x,_p2y,0,c), pP[23] = (T)(img)(_n1x,_p2y,0,c), pP[24] = (T)(img)(_n2x,_p2y,0,c), pP[25] = (T)(img)(_n3x,_p2y,0,c), pP[26] = (T)(img)(_n4x,_p2y,0,c), pP[27] = (T)(img)(_p4x,_p1y,0,c), pP[28] = (T)(img)(_p3x,_p1y,0,c), pP[29] = (T)(img)(_p2x,_p1y,0,c), pP[30] = (T)(img)(_p1x,_p1y,0,c), pP[31] = (T)(img)(x,_p1y,0,c), pP[32] = (T)(img)(_n1x,_p1y,0,c), pP[33] = (T)(img)(_n2x,_p1y,0,c), pP[34] = (T)(img)(_n3x,_p1y,0,c), pP[35] = (T)(img)(_n4x,_p1y,0,c), pP[36] = (T)(img)(_p4x,y,0,c), pP[37] = (T)(img)(_p3x,y,0,c), pP[38] = (T)(img)(_p2x,y,0,c), pP[39] = (T)(img)(_p1x,y,0,c), pP[40] = (T)(img)(x,y,0,c), pP[41] = (T)(img)(_n1x,y,0,c), pP[42] = (T)(img)(_n2x,y,0,c), pP[43] = (T)(img)(_n3x,y,0,c), pP[44] = (T)(img)(_n4x,y,0,c), pP[45] = (T)(img)(_p4x,_n1y,0,c), pP[46] = (T)(img)(_p3x,_n1y,0,c), pP[47] = (T)(img)(_p2x,_n1y,0,c), pP[48] = (T)(img)(_p1x,_n1y,0,c), pP[49] = (T)(img)(x,_n1y,0,c), pP[50] = (T)(img)(_n1x,_n1y,0,c), pP[51] = (T)(img)(_n2x,_n1y,0,c), pP[52] = (T)(img)(_n3x,_n1y,0,c), pP[53] = (T)(img)(_n4x,_n1y,0,c), pP[54] = (T)(img)(_p4x,_n2y,0,c), pP[55] = (T)(img)(_p3x,_n2y,0,c), pP[56] = (T)(img)(_p2x,_n2y,0,c), pP[57] = (T)(img)(_p1x,_n2y,0,c), pP[58] = (T)(img)(x,_n2y,0,c), pP[59] = (T)(img)(_n1x,_n2y,0,c), pP[60] = (T)(img)(_n2x,_n2y,0,c), pP[61] = (T)(img)(_n3x,_n2y,0,c), pP[62] = (T)(img)(_n4x,_n2y,0,c), pP[63] = (T)(img)(_p4x,_n3y,0,c), pP[64] = (T)(img)(_p3x,_n3y,0,c), pP[65] = (T)(img)(_p2x,_n3y,0,c), pP[66] = (T)(img)(_p1x,_n3y,0,c), pP[67] = (T)(img)(x,_n3y,0,c), pP[68] = (T)(img)(_n1x,_n3y,0,c), pP[69] = (T)(img)(_n2x,_n3y,0,c), pP[70] = (T)(img)(_n3x,_n3y,0,c), pP[71] = (T)(img)(_n4x,_n3y,0,c), pP[72] = (T)(img)(_p4x,_n4y,0,c), pP[73] = (T)(img)(_p3x,_n4y,0,c), pP[74] = (T)(img)(_p2x,_n4y,0,c), pP[75] = (T)(img)(_p1x,_n4y,0,c), pP[76] = (T)(img)(x,_n4y,0,c), pP[77] = (T)(img)(_n1x,_n4y,0,c), pP[78] = (T)(img)(_n2x,_n4y,0,c), pP[79] = (T)(img)(_n3x,_n4y,0,c), pP[80] = (T)(img)(_n4x,_n4y,0,c); pP+=N2; } const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; float sum_weights = 0, weight_max = 0; for (int q = (int)(y0)<0?0:(int)(y0), _p4q = q-4<0?0:q-4, _p3q = q-3<0?0:q-3, _p2q = q-2<0?0:q-2, _p1q = q-1<0?0:q-1, _n1q = q+1>=(int)((res)._height)?(int)((res)._height)-1:q+1, _n2q = q+2>=(int)((res)._height)?(int)((res)._height)-1:q+2, _n3q = q+3>=(int)((res)._height)?(int)((res)._height)-1:q+3, _n4q = q+4>=(int)((res)._height)?(int)((res)._height)-1:q+4; q<=(int)(y1) && (_n4q<(int)((res)._height) || _n3q==--_n4q || _n2q==--_n3q || _n1q==--_n2q || q==(_n4q = _n3q = _n2q = --_n1q)); _p4q = _p3q, _p3q = _p2q, _p2q = _p1q, _p1q = q++, ++_n1q, ++_n2q, ++_n3q, ++_n4q) for (int p = (int)(x0)<0?0:(int)(x0), _p4p = p-4<0?0:p-4, _p3p = p-3<0?0:p-3, _p2p = p-2<0?0:p-2, _p1p = p-1<0?0:p-1, _n1p = p+1>=(int)((res)._width)?(int)((res)._width)-1:p+1, _n2p = p+2>=(int)((res)._width)?(int)((res)._width)-1:p+2, _n3p = p+3>=(int)((res)._width)?(int)((res)._width)-1:p+3, _n4p = p+4>=(int)((res)._width)?(int)((res)._width)-1:p+4; p<=(int)(x1) && (_n4p<(int)((res)._width) || _n3p==--_n4p || _n2p==--_n3p || _n1p==--_n2p || p==(_n4p = _n3p = _n2p = --_n1p)); _p4p = _p3p, _p3p = _p2p, _p2p = _p1p, _p1p = p++, ++_n1p, ++_n2p, ++_n3p, ++_n4p) if (p!=x || q!=y) { T *pQ = Q._data; for (int c = 0; c<(int)((res)._spectrum); ++c) { pQ[0] = (T)(img)(_p4p,_p4q,0,c), pQ[1] = (T)(img)(_p3p,_p4q,0,c), pQ[2] = (T)(img)(_p2p,_p4q,0,c), pQ[3] = (T)(img)(_p1p,_p4q,0,c), pQ[4] = (T)(img)(p,_p4q,0,c), pQ[5] = (T)(img)(_n1p,_p4q,0,c), pQ[6] = (T)(img)(_n2p,_p4q,0,c), pQ[7] = (T)(img)(_n3p,_p4q,0,c), pQ[8] = (T)(img)(_n4p,_p4q,0,c), pQ[9] = (T)(img)(_p4p,_p3q,0,c), pQ[10] = (T)(img)(_p3p,_p3q,0,c), pQ[11] = (T)(img)(_p2p,_p3q,0,c), pQ[12] = (T)(img)(_p1p,_p3q,0,c), pQ[13] = (T)(img)(p,_p3q,0,c), pQ[14] = (T)(img)(_n1p,_p3q,0,c), pQ[15] = (T)(img)(_n2p,_p3q,0,c), pQ[16] = (T)(img)(_n3p,_p3q,0,c), pQ[17] = (T)(img)(_n4p,_p3q,0,c), pQ[18] = (T)(img)(_p4p,_p2q,0,c), pQ[19] = (T)(img)(_p3p,_p2q,0,c), pQ[20] = (T)(img)(_p2p,_p2q,0,c), pQ[21] = (T)(img)(_p1p,_p2q,0,c), pQ[22] = (T)(img)(p,_p2q,0,c), pQ[23] = (T)(img)(_n1p,_p2q,0,c), pQ[24] = (T)(img)(_n2p,_p2q,0,c), pQ[25] = (T)(img)(_n3p,_p2q,0,c), pQ[26] = (T)(img)(_n4p,_p2q,0,c), pQ[27] = (T)(img)(_p4p,_p1q,0,c), pQ[28] = (T)(img)(_p3p,_p1q,0,c), pQ[29] = (T)(img)(_p2p,_p1q,0,c), pQ[30] = (T)(img)(_p1p,_p1q,0,c), pQ[31] = (T)(img)(p,_p1q,0,c), pQ[32] = (T)(img)(_n1p,_p1q,0,c), pQ[33] = (T)(img)(_n2p,_p1q,0,c), pQ[34] = (T)(img)(_n3p,_p1q,0,c), pQ[35] = (T)(img)(_n4p,_p1q,0,c), pQ[36] = (T)(img)(_p4p,q,0,c), pQ[37] = (T)(img)(_p3p,q,0,c), pQ[38] = (T)(img)(_p2p,q,0,c), pQ[39] = (T)(img)(_p1p,q,0,c), pQ[40] = (T)(img)(p,q,0,c), pQ[41] = (T)(img)(_n1p,q,0,c), pQ[42] = (T)(img)(_n2p,q,0,c), pQ[43] = (T)(img)(_n3p,q,0,c), pQ[44] = (T)(img)(_n4p,q,0,c), pQ[45] = (T)(img)(_p4p,_n1q,0,c), pQ[46] = (T)(img)(_p3p,_n1q,0,c), pQ[47] = (T)(img)(_p2p,_n1q,0,c), pQ[48] = (T)(img)(_p1p,_n1q,0,c), pQ[49] = (T)(img)(p,_n1q,0,c), pQ[50] = (T)(img)(_n1p,_n1q,0,c), pQ[51] = (T)(img)(_n2p,_n1q,0,c), pQ[52] = (T)(img)(_n3p,_n1q,0,c), pQ[53] = (T)(img)(_n4p,_n1q,0,c), pQ[54] = (T)(img)(_p4p,_n2q,0,c), pQ[55] = (T)(img)(_p3p,_n2q,0,c), pQ[56] = (T)(img)(_p2p,_n2q,0,c), pQ[57] = (T)(img)(_p1p,_n2q,0,c), pQ[58] = (T)(img)(p,_n2q,0,c), pQ[59] = (T)(img)(_n1p,_n2q,0,c), pQ[60] = (T)(img)(_n2p,_n2q,0,c), pQ[61] = (T)(img)(_n3p,_n2q,0,c), pQ[62] = (T)(img)(_n4p,_n2q,0,c), pQ[63] = (T)(img)(_p4p,_n3q,0,c), pQ[64] = (T)(img)(_p3p,_n3q,0,c), pQ[65] = (T)(img)(_p2p,_n3q,0,c), pQ[66] = (T)(img)(_p1p,_n3q,0,c), pQ[67] = (T)(img)(p,_n3q,0,c), pQ[68] = (T)(img)(_n1p,_n3q,0,c), pQ[69] = (T)(img)(_n2p,_n3q,0,c), pQ[70] = (T)(img)(_n3p,_n3q,0,c), pQ[71] = (T)(img)(_n4p,_n3q,0,c), pQ[72] = (T)(img)(_p4p,_n4q,0,c), pQ[73] = (T)(img)(_p3p,_n4q,0,c), pQ[74] = (T)(img)(_p2p,_n4q,0,c), pQ[75] = (T)(img)(_p1p,_n4q,0,c), pQ[76] = (T)(img)(p,_n4q,0,c), pQ[77] = (T)(img)(_n1p,_n4q,0,c), pQ[78] = (T)(img)(_n2p,_n4q,0,c), pQ[79] = (T)(img)(_n3p,_n4q,0,c), pQ[80] = (T)(img)(_n4p,_n4q,0,c); pQ+=N2; } float distance2 = 0; pQ = Q._data; for (T *pP = (P)._data, *_maxpP = (P)._data + (P).size(); pP<_maxpP; ++pP) { const float dI = (float)*pP - (float)*(pQ++); distance2+=dI*dI; } distance2/=Pnorm; const float dx = (float)p - x, dy = (float)q - y, alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = (float)std::exp(-alldist); if (weight>weight_max) weight_max = weight; sum_weights+=weight; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c); } sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c); if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights; else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c)); } break;
        default : {
          const int psize2 = (int)patch_size/2, psize1 = (int)patch_size - psize2 - 1;
          if (is_fast_approx)



            for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
              P = img.get_crop(x - psize1,y - psize1,x + psize2,y + psize2,true);
              const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2;
              float sum_weights = 0;
              for (int q = (int)(y0)<0?0:(int)(y0), _maxq = (int)(y1)<(int)((res)._height)?(int)(y1):(int)((res)._height)-1; q<=_maxq; ++q) for (int p = (int)(x0)<0?0:(int)(x0), _maxp = (int)(x1)<(int)((res)._width)?(int)(x1):(int)((res)._width)-1; p<=_maxp; ++p) if (cimg::abs(img(x,y,0)-img(p,q,0))<sigma_p3) {
                (Q = img.get_crop(p - psize1,q - psize1,p + psize2,q + psize2,true))-=P;
                const float
                  dx = (float)x - p, dy = (float)y - q,
                  distance2 = (float)(Q.pow(2).sum()/Pnorm + (dx*dx + dy*dy)/sigma_s2),
                  weight = distance2>3?0.0f:1.0f;
                sum_weights+=weight;
                for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c);
              }
              if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights;
              else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c) = (Tfloat)((*this)(x,y,c));
            } else



            for (int y = 0; y<(int)((res)._height); ++y) for (int x = 0; x<(int)((res)._width); ++x) {
              P = img.get_crop(x - psize1,y - psize1,x + psize2,y + psize2,true);
              const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2;
              float sum_weights = 0, weight_max = 0;
              for (int q = (int)(y0)<0?0:(int)(y0), _maxq = (int)(y1)<(int)((res)._height)?(int)(y1):(int)((res)._height)-1; q<=_maxq; ++q) for (int p = (int)(x0)<0?0:(int)(x0), _maxp = (int)(x1)<(int)((res)._width)?(int)(x1):(int)((res)._width)-1; p<=_maxp; ++p) if (p!=x || q!=y) {
                (Q = img.get_crop(p - psize1,q - psize1,p + psize2,q + psize2,true))-=P;
                const float
                  dx = (float)x - p, dy = (float)y - q,
                  distance2 = (float)(Q.pow(2).sum()/Pnorm + (dx*dx + dy*dy)/sigma_s2),
                  weight = (float)std::exp(-distance2);
                if (weight>weight_max) weight_max = weight;
                sum_weights+=weight;
                for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight*(*this)(p,q,c);
              }
              sum_weights+=weight_max; for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)+=weight_max*(*this)(x,y,c);
              if (sum_weights>0) for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,c)/=sum_weights;
              else for (int c = 0; c<(int)((res)._spectrum); ++c) res(x,y,0,c) = (Tfloat)((*this)(x,y,c));
            }
        }
        }
      return res;
    }






    CImg<T>& blur_median(const unsigned int n, const float threshold=0) {
      if (!n) return *this;
      return get_blur_median(n,threshold).move_to(*this);
    }


    CImg<T> get_blur_median(const unsigned int n, const float threshold=0) const {
      if (is_empty() || n<=1) return +*this;
      CImg<T> res(_width,_height,_depth,_spectrum);
      T *ptrd = res._data;
      cimg::unused(ptrd);
      const int hl = n/2, hr = hl - 1 + n%2;
      if (res._depth!=1) {
        if (threshold>0)



          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
            const int
              x0 = x - hl, y0 = y - hl, z0 = z-hl, x1 = x + hr, y1 = y + hr, z1 = z+hr,
              nx0 = x0<0?0:x0, ny0 = y0<0?0:y0, nz0 = z0<0?0:z0,
              nx1 = x1>=width()?width()-1:x1, ny1 = y1>=height()?height()-1:y1, nz1 = z1>=depth()?depth()-1:z1;
            const float val0 = (float)(*this)(x,y,z,c);
            CImg<T> values(n*n*n);
            unsigned int nb_values = 0;
            T *ptrd = values.data();
            for (int r = (int)(nz0)<0?0:(int)(nz0), _maxr = (int)(nz1)<(int)((*this)._depth)?(int)(nz1):(int)((*this)._depth)-1; r<=_maxr; ++r) for (int q = (int)(ny0)<0?0:(int)(ny0), _maxq = (int)(ny1)<(int)((*this)._height)?(int)(ny1):(int)((*this)._height)-1; q<=_maxq; ++q) for (int p = (int)(nx0)<0?0:(int)(nx0), _maxp = (int)(nx1)<(int)((*this)._width)?(int)(nx1):(int)((*this)._width)-1; p<=_maxp; ++p)
              if (cimg::abs((float)(*this)(p,q,r,c)-val0)<=threshold) { *(ptrd++) = (*this)(p,q,r,c); ++nb_values; }
            res(x,y,z,c) = values.get_shared_points(0,nb_values-1).median();
          }
        else



          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
            const int
              x0 = x - hl, y0 = y - hl, z0 = z-hl, x1 = x + hr, y1 = y + hr, z1 = z+hr,
              nx0 = x0<0?0:x0, ny0 = y0<0?0:y0, nz0 = z0<0?0:z0,
              nx1 = x1>=width()?width()-1:x1, ny1 = y1>=height()?height()-1:y1, nz1 = z1>=depth()?depth()-1:z1;
            res(x,y,z,c) = get_crop(nx0,ny0,nz0,c,nx1,ny1,nz1,c).median();
          }
      } else {

        if (res._height!=1) {
          if (threshold>0)



            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
              const int
                x0 = x - hl, y0 = y - hl, x1 = x + hr, y1 = y + hr,
                nx0 = x0<0?0:x0, ny0 = y0<0?0:y0,
                                          nx1 = x1>=width()?width()-1:x1, ny1 = y1>=height()?height()-1:y1;
              const float val0 = (float)(*this)(x,y,c);
              CImg<T> values(n*n);
              unsigned int nb_values = 0;
              T *ptrd = values.data();
              for (int q = (int)(ny0)<0?0:(int)(ny0), _maxq = (int)(ny1)<(int)((*this)._height)?(int)(ny1):(int)((*this)._height)-1; q<=_maxq; ++q) for (int p = (int)(nx0)<0?0:(int)(nx0), _maxp = (int)(nx1)<(int)((*this)._width)?(int)(nx1):(int)((*this)._width)-1; p<=_maxp; ++p)
                if (cimg::abs((float)(*this)(p,q,c)-val0)<=threshold) { *(ptrd++) = (*this)(p,q,c); ++nb_values; }
              res(x,y,c) = values.get_shared_points(0,nb_values-1).median();
            }
          else switch (n) {
            case 3 : {



              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                T I[9] = { 0 };
                T J[9]; T& Jpp = J[0]; T& Jcp = J[1]; T& Jnp = J[2]; T& Jpc = J[3]; T& Jcc = J[4]; T& Jnc = J[5]; T& Jpn = J[6]; T& Jcn = J[7]; T& Jnn = J[8]; Jpp = Jcp = Jnp = Jpc = Jcc = Jnc = Jpn = Jcn = Jnn = 0;
                for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (T)(*this)(0,y,0,c)), (I[6] = I[7] = (T)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,0,c)), (I[5] = (T)(*this)(_n1x,y,0,c)), (I[8] = (T)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
                  std::memcpy(J,I,9*sizeof(T));
                  if ((Jcp)>(Jnp)) cimg::swap(Jcp,Jnp); if ((Jcc)>(Jnc)) cimg::swap(Jcc,Jnc); if ((Jcn)>(Jnn)) cimg::swap(Jcn,Jnn);
                  if ((Jpp)>(Jcp)) cimg::swap(Jpp,Jcp); if ((Jpc)>(Jcc)) cimg::swap(Jpc,Jcc); if ((Jpn)>(Jcn)) cimg::swap(Jpn,Jcn);
                  if ((Jcp)>(Jnp)) cimg::swap(Jcp,Jnp); if ((Jcc)>(Jnc)) cimg::swap(Jcc,Jnc); if ((Jcn)>(Jnn)) cimg::swap(Jcn,Jnn);
                  if ((Jpp)>(Jpc)) cimg::swap(Jpp,Jpc); if ((Jnc)>(Jnn)) cimg::swap(Jnc,Jnn); if ((Jcc)>(Jcn)) cimg::swap(Jcc,Jcn);
                  if ((Jpc)>(Jpn)) cimg::swap(Jpc,Jpn); if ((Jcp)>(Jcc)) cimg::swap(Jcp,Jcc); if ((Jnp)>(Jnc)) cimg::swap(Jnp,Jnc);
                  if ((Jcc)>(Jcn)) cimg::swap(Jcc,Jcn); if ((Jcc)>(Jnp)) cimg::swap(Jcc,Jnp); if ((Jpn)>(Jcc)) cimg::swap(Jpn,Jcc);
                  if ((Jcc)>(Jnp)) cimg::swap(Jcc,Jnp);
                  res(x,y,c) = Jcc;
                }
              }
            } break;
            case 5 : {



              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                T I[25] = { 0 };
                T J[25]; T& Jbb = J[0]; T& Jpb = J[1]; T& Jcb = J[2]; T& Jnb = J[3]; T& Jab = J[4]; T& Jbp = J[5]; T& Jpp = J[6]; T& Jcp = J[7]; T& Jnp = J[8]; T& Jap = J[9]; T& Jbc = J[10]; T& Jpc = J[11]; T& Jcc = J[12]; T& Jnc = J[13]; T& Jac = J[14]; T& Jbn = J[15]; T& Jpn = J[16]; T& Jcn = J[17]; T& Jnn = J[18]; T& Jan = J[19]; T& Jba = J[20]; T& Jpa = J[21]; T& Jca = J[22]; T& Jna = J[23]; T& Jaa = J[24]; Jbb = Jpb = Jcb = Jnb = Jab = Jbp = Jpp = Jcp = Jnp = Jap = Jbc = Jpc = Jcc = Jnc = Jac = Jbn = Jpn = Jcn = Jnn = Jan = Jba = Jpa = Jca = Jna = Jaa = 0;
                for (int y = 0, _p2y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1, _n2y = 2>=((*this)._height)?(int)((*this)._height)-1:2; _n2y<(int)((*this)._height) || _n1y==--_n2y || y==(_n2y = --_n1y); _p2y = _p1y, _p1y = y++, ++_n1y, ++_n2y) for (int x = 0, _p2x = 0, _p1x = 0, _n1x = 1>=(*this)._width?(*this).width()-1:1, _n2x = (int)( (I[0] = I[1] = I[2] = (T)(*this)(_p2x,_p2y,0,c)), (I[5] = I[6] = I[7] = (T)(*this)(0,_p1y,0,c)), (I[10] = I[11] = I[12] = (T)(*this)(0,y,0,c)), (I[15] = I[16] = I[17] = (T)(*this)(0,_n1y,0,c)), (I[20] = I[21] = I[22] = (T)(*this)(0,_n2y,0,c)), (I[3] = (T)(*this)(_n1x,_p2y,0,c)), (I[8] = (T)(*this)(_n1x,_p1y,0,c)), (I[13] = (T)(*this)(_n1x,y,0,c)), (I[18] = (T)(*this)(_n1x,_n1y,0,c)), (I[23] = (T)(*this)(_n1x,_n2y,0,c)), 2>=(*this)._width?(*this).width()-1:2); (_n2x<(*this).width() && ( (I[4] = (T)(*this)(_n2x,_p2y,0,c)), (I[9] = (T)(*this)(_n2x,_p1y,0,c)), (I[14] = (T)(*this)(_n2x,y,0,c)), (I[19] = (T)(*this)(_n2x,_n1y,0,c)), (I[24] = (T)(*this)(_n2x,_n2y,0,c)),1)) || _n1x==--_n2x || x==(_n2x = --_n1x); I[0] = I[1], I[1] = I[2], I[2] = I[3], I[3] = I[4], I[5] = I[6], I[6] = I[7], I[7] = I[8], I[8] = I[9], I[10] = I[11], I[11] = I[12], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[17] = I[18], I[18] = I[19], I[20] = I[21], I[21] = I[22], I[22] = I[23], I[23] = I[24], _p2x = _p1x, _p1x = x++, ++_n1x, ++_n2x) {
                  std::memcpy(J,I,25*sizeof(T));
                  if ((Jbb)>(Jpb)) cimg::swap(Jbb,Jpb); if ((Jnb)>(Jab)) cimg::swap(Jnb,Jab); if ((Jcb)>(Jab)) cimg::swap(Jcb,Jab);
                  if ((Jcb)>(Jnb)) cimg::swap(Jcb,Jnb); if ((Jpp)>(Jcp)) cimg::swap(Jpp,Jcp); if ((Jbp)>(Jcp)) cimg::swap(Jbp,Jcp);
                  if ((Jbp)>(Jpp)) cimg::swap(Jbp,Jpp); if ((Jap)>(Jbc)) cimg::swap(Jap,Jbc); if ((Jnp)>(Jbc)) cimg::swap(Jnp,Jbc);
                  if ((Jnp)>(Jap)) cimg::swap(Jnp,Jap); if ((Jcc)>(Jnc)) cimg::swap(Jcc,Jnc); if ((Jpc)>(Jnc)) cimg::swap(Jpc,Jnc);
                  if ((Jpc)>(Jcc)) cimg::swap(Jpc,Jcc); if ((Jbn)>(Jpn)) cimg::swap(Jbn,Jpn); if ((Jac)>(Jpn)) cimg::swap(Jac,Jpn);
                  if ((Jac)>(Jbn)) cimg::swap(Jac,Jbn); if ((Jnn)>(Jan)) cimg::swap(Jnn,Jan); if ((Jcn)>(Jan)) cimg::swap(Jcn,Jan);
                  if ((Jcn)>(Jnn)) cimg::swap(Jcn,Jnn); if ((Jpa)>(Jca)) cimg::swap(Jpa,Jca); if ((Jba)>(Jca)) cimg::swap(Jba,Jca);
                  if ((Jba)>(Jpa)) cimg::swap(Jba,Jpa); if ((Jna)>(Jaa)) cimg::swap(Jna,Jaa); if ((Jcb)>(Jbp)) cimg::swap(Jcb,Jbp);
                  if ((Jnb)>(Jpp)) cimg::swap(Jnb,Jpp); if ((Jbb)>(Jpp)) cimg::swap(Jbb,Jpp); if ((Jbb)>(Jnb)) cimg::swap(Jbb,Jnb);
                  if ((Jab)>(Jcp)) cimg::swap(Jab,Jcp); if ((Jpb)>(Jcp)) cimg::swap(Jpb,Jcp); if ((Jpb)>(Jab)) cimg::swap(Jpb,Jab);
                  if ((Jpc)>(Jac)) cimg::swap(Jpc,Jac); if ((Jnp)>(Jac)) cimg::swap(Jnp,Jac); if ((Jnp)>(Jpc)) cimg::swap(Jnp,Jpc);
                  if ((Jcc)>(Jbn)) cimg::swap(Jcc,Jbn); if ((Jap)>(Jbn)) cimg::swap(Jap,Jbn); if ((Jap)>(Jcc)) cimg::swap(Jap,Jcc);
                  if ((Jnc)>(Jpn)) cimg::swap(Jnc,Jpn); if ((Jbc)>(Jpn)) cimg::swap(Jbc,Jpn); if ((Jbc)>(Jnc)) cimg::swap(Jbc,Jnc);
                  if ((Jba)>(Jna)) cimg::swap(Jba,Jna); if ((Jcn)>(Jna)) cimg::swap(Jcn,Jna); if ((Jcn)>(Jba)) cimg::swap(Jcn,Jba);
                  if ((Jpa)>(Jaa)) cimg::swap(Jpa,Jaa); if ((Jnn)>(Jaa)) cimg::swap(Jnn,Jaa); if ((Jnn)>(Jpa)) cimg::swap(Jnn,Jpa);
                  if ((Jan)>(Jca)) cimg::swap(Jan,Jca); if ((Jnp)>(Jcn)) cimg::swap(Jnp,Jcn); if ((Jap)>(Jnn)) cimg::swap(Jap,Jnn);
                  if ((Jbb)>(Jnn)) cimg::swap(Jbb,Jnn); if ((Jbb)>(Jap)) cimg::swap(Jbb,Jap); if ((Jbc)>(Jan)) cimg::swap(Jbc,Jan);
                  if ((Jpb)>(Jan)) cimg::swap(Jpb,Jan); if ((Jpb)>(Jbc)) cimg::swap(Jpb,Jbc); if ((Jpc)>(Jba)) cimg::swap(Jpc,Jba);
                  if ((Jcb)>(Jba)) cimg::swap(Jcb,Jba); if ((Jcb)>(Jpc)) cimg::swap(Jcb,Jpc); if ((Jcc)>(Jpa)) cimg::swap(Jcc,Jpa);
                  if ((Jnb)>(Jpa)) cimg::swap(Jnb,Jpa); if ((Jnb)>(Jcc)) cimg::swap(Jnb,Jcc); if ((Jnc)>(Jca)) cimg::swap(Jnc,Jca);
                  if ((Jab)>(Jca)) cimg::swap(Jab,Jca); if ((Jab)>(Jnc)) cimg::swap(Jab,Jnc); if ((Jac)>(Jna)) cimg::swap(Jac,Jna);
                  if ((Jbp)>(Jna)) cimg::swap(Jbp,Jna); if ((Jbp)>(Jac)) cimg::swap(Jbp,Jac); if ((Jbn)>(Jaa)) cimg::swap(Jbn,Jaa);
                  if ((Jpp)>(Jaa)) cimg::swap(Jpp,Jaa); if ((Jpp)>(Jbn)) cimg::swap(Jpp,Jbn); if ((Jcp)>(Jpn)) cimg::swap(Jcp,Jpn);
                  if ((Jcp)>(Jan)) cimg::swap(Jcp,Jan); if ((Jnc)>(Jpa)) cimg::swap(Jnc,Jpa); if ((Jbn)>(Jna)) cimg::swap(Jbn,Jna);
                  if ((Jcp)>(Jnc)) cimg::swap(Jcp,Jnc); if ((Jcp)>(Jbn)) cimg::swap(Jcp,Jbn); if ((Jpb)>(Jap)) cimg::swap(Jpb,Jap);
                  if ((Jnb)>(Jpc)) cimg::swap(Jnb,Jpc); if ((Jbp)>(Jcn)) cimg::swap(Jbp,Jcn); if ((Jpc)>(Jcn)) cimg::swap(Jpc,Jcn);
                  if ((Jap)>(Jcn)) cimg::swap(Jap,Jcn); if ((Jab)>(Jbc)) cimg::swap(Jab,Jbc); if ((Jpp)>(Jcc)) cimg::swap(Jpp,Jcc);
                  if ((Jcp)>(Jac)) cimg::swap(Jcp,Jac); if ((Jab)>(Jpp)) cimg::swap(Jab,Jpp); if ((Jab)>(Jcp)) cimg::swap(Jab,Jcp);
                  if ((Jcc)>(Jac)) cimg::swap(Jcc,Jac); if ((Jbc)>(Jac)) cimg::swap(Jbc,Jac); if ((Jpp)>(Jcp)) cimg::swap(Jpp,Jcp);
                  if ((Jbc)>(Jcc)) cimg::swap(Jbc,Jcc); if ((Jpp)>(Jbc)) cimg::swap(Jpp,Jbc); if ((Jpp)>(Jcn)) cimg::swap(Jpp,Jcn);
                  if ((Jcc)>(Jcn)) cimg::swap(Jcc,Jcn); if ((Jcp)>(Jcn)) cimg::swap(Jcp,Jcn); if ((Jcp)>(Jbc)) cimg::swap(Jcp,Jbc);
                  if ((Jcc)>(Jnn)) cimg::swap(Jcc,Jnn); if ((Jcp)>(Jcc)) cimg::swap(Jcp,Jcc); if ((Jbc)>(Jnn)) cimg::swap(Jbc,Jnn);
                  if ((Jcc)>(Jba)) cimg::swap(Jcc,Jba); if ((Jbc)>(Jba)) cimg::swap(Jbc,Jba); if ((Jbc)>(Jcc)) cimg::swap(Jbc,Jcc);
                  res(x,y,c) = Jcc;
                }
              }
            } break;
            default : {



              for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
                const int
                  x0 = x - hl, y0 = y - hl, x1 = x + hr, y1 = y + hr,
                  nx0 = x0<0?0:x0, ny0 = y0<0?0:y0,
                                            nx1 = x1>=width()?width()-1:x1, ny1 = y1>=height()?height()-1:y1;
                res(x,y,c) = get_crop(nx0,ny0,0,c,nx1,ny1,0,c).median();
              }
            }
            }
        } else {

          if (threshold>0)



            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int x = 0; x<(int)((*this)._width); ++x) {
              const int
                x0 = x - hl, x1 = x + hr,
                nx0 = x0<0?0:x0, nx1 = x1>=width()?width()-1:x1;
              const float val0 = (float)(*this)(x,c);
              CImg<T> values(n);
              unsigned int nb_values = 0;
              T *ptrd = values.data();
              for (int p = (int)(nx0)<0?0:(int)(nx0), _maxp = (int)(nx1)<(int)((*this)._width)?(int)(nx1):(int)((*this)._width)-1; p<=_maxp; ++p)
                if (cimg::abs((float)(*this)(p,c)-val0)<=threshold) { *(ptrd++) = (*this)(p,c); ++nb_values; }
              res(x,c) = values.get_shared_points(0,nb_values-1).median();
            }
          else switch (n) {
            case 2 : {



              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                T I[4] = { 0 };
                for (int y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = (int)( (I[0] = (T)(*this)(0,y,0,c)), (I[2] = (T)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[1] = (T)(*this)(_n1x,y,0,c)), (I[3] = (T)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[2] = I[3], ++x, ++_n1x) res(x,c) = (T)(0.5f*(I[0]+I[1]));
              }
            } break;
            case 3 : {



              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                T I[9] = { 0 };
                for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (T)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (T)(*this)(0,y,0,c)), (I[6] = I[7] = (T)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (T)(*this)(_n1x,_p1y,0,c)), (I[5] = (T)(*this)(_n1x,y,0,c)), (I[8] = (T)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x)
                  res(x,c) = I[3]<I[4]?(I[4]<I[5]?I[4]:(I[3]<I[5]?I[5]:I[3])):(I[3]<I[5]?I[3]:(I[4]<I[5]?I[5]:I[4]));
              }
            } break;
            default : {



              for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int x = 0; x<(int)((*this)._width); ++x) {
                const int
                  x0 = x - hl, x1 = x + hr,
                  nx0 = x0<0?0:x0, nx1 = x1>=width()?width()-1:x1;
                res(x,c) = get_crop(nx0,0,0,c,nx1,0,0,c).median();
              }
            }
            }
        }
      }
      return res;
    }
# 26763 "../src/CImg.h"
    CImg<T>& sharpen(const float amplitude, const bool sharpen_type=false, const float edge=1,
                     const float alpha=0, const float sigma=0) {
      if (is_empty()) return *this;
      T val_min, val_max = max_min(val_min);
      const float nedge = edge/2;
      CImg<Tfloat> velocity(_width,_height,_depth,_spectrum), _veloc_max(_spectrum);

      if (_depth>1) {
        if (sharpen_type) {
          CImg<Tfloat> G = (alpha>0?get_blur(alpha).get_structure_tensors():get_structure_tensors());
          if (sigma>0) G.blur(sigma);



          for (int z = 0; z<(int)((G)._depth); ++z) for (int y = 0; y<(int)((G)._height); ++y) {
            Tfloat *ptrG0 = G.data(0,y,z,0), *ptrG1 = G.data(0,y,z,1),
              *ptrG2 = G.data(0,y,z,2), *ptrG3 = G.data(0,y,z,3);
            CImg<Tfloat> val, vec;
            for (int x = 0; x<(int)((G)._width); ++x) {
              G.get_tensor_at(x,y,z).symmetric_eigen(val,vec);
              if (val[0]<0) val[0] = 0;
              if (val[1]<0) val[1] = 0;
              if (val[2]<0) val[2] = 0;
              *(ptrG0++) = vec(0,0);
              *(ptrG1++) = vec(0,1);
              *(ptrG2++) = vec(0,2);
              *(ptrG3++) = 1 - (Tfloat)std::pow(1+val[0]+val[1]+val[2],-(Tfloat)nedge);
            }
          }



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat *ptrd = velocity.data(0,0,0,c), veloc_max = 0;
            Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
            for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
              const Tfloat
                u = G(x,y,z,0),
                v = G(x,y,z,1),
                w = G(x,y,z,2),
                amp = G(x,y,z,3),
                ixx = Incc + Ipcc - 2*Iccc,
                ixy = (Innc + Ippc - Inpc - Ipnc)/4,
                ixz = (Incn + Ipcp - Incp - Ipcn)/4,
                iyy = Icnc + Icpc - 2*Iccc,
                iyz = (Icnn + Icpp - Icnp - Icpn)/4,
                izz = Iccn + Iccp - 2*Iccc,
                ixf = Incc - Iccc,
                ixb = Iccc - Ipcc,
                iyf = Icnc - Iccc,
                iyb = Iccc - Icpc,
                izf = Iccn - Iccc,
                izb = Iccc - Iccp,
                itt = u*u*ixx + v*v*iyy + w*w*izz + 2*u*v*ixy + 2*u*w*ixz + 2*v*w*iyz,
                it = u*cimg::minmod(ixf,ixb) + v*cimg::minmod(iyf,iyb) + w*cimg::minmod(izf,izb),
                veloc = -amp*cimg::sign(itt)*cimg::abs(it);
              *(ptrd++) = veloc;
              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
            }
            _veloc_max[c] = veloc_max;
          }
        } else
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat *ptrd = velocity.data(0,0,0,c), veloc_max = 0;
            Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
            for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
              const Tfloat veloc = -Ipcc - Incc - Icpc - Icnc - Iccp - Iccn + 6*Iccc;
              *(ptrd++) = veloc;
              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
            }
            _veloc_max[c] = veloc_max;
          }
      } else {
        if (sharpen_type) {
          CImg<Tfloat> G = (alpha>0?get_blur(alpha).get_structure_tensors():get_structure_tensors());
          if (sigma>0) G.blur(sigma);



          for (int y = 0; y<(int)((G)._height); ++y) {
            CImg<Tfloat> val, vec;
            Tfloat *ptrG0 = G.data(0,y,0,0), *ptrG1 = G.data(0,y,0,1), *ptrG2 = G.data(0,y,0,2);
            for (int x = 0; x<(int)((G)._width); ++x) {
              G.get_tensor_at(x,y).symmetric_eigen(val,vec);
              if (val[0]<0) val[0] = 0;
              if (val[1]<0) val[1] = 0;
              *(ptrG0++) = vec(0,0);
              *(ptrG1++) = vec(0,1);
              *(ptrG2++) = 1 - (Tfloat)std::pow(1 + val[0] + val[1],-(Tfloat)nedge);
            }
          }



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat *ptrd = velocity.data(0,0,0,c), veloc_max = 0;
            Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
            for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,0,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,0,c)), (I[5] = (Tfloat)(*this)(_n1x,y,0,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
              const Tfloat
                u = G(x,y,0),
                v = G(x,y,1),
                amp = G(x,y,2),
                ixx = Inc + Ipc - 2*Icc,
                ixy = (Inn + Ipp - Inp - Ipn)/4,
                iyy = Icn + Icp - 2*Icc,
                ixf = Inc - Icc,
                ixb = Icc - Ipc,
                iyf = Icn - Icc,
                iyb = Icc - Icp,
                itt = u*u*ixx + v*v*iyy + 2*u*v*ixy,
                it = u*cimg::minmod(ixf,ixb) + v*cimg::minmod(iyf,iyb),
                veloc = -amp*cimg::sign(itt)*cimg::abs(it);
              *(ptrd++) = veloc;
              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
            }
            _veloc_max[c] = veloc_max;
          }
        } else
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat *ptrd = velocity.data(0,0,0,c), veloc_max = 0;
            Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
            for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,0,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,0,c)), (I[5] = (Tfloat)(*this)(_n1x,y,0,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
              const Tfloat veloc = -Ipc - Inc - Icp - Icn + 4*Icc;
              *(ptrd++) = veloc;
              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
            }
            _veloc_max[c] = veloc_max;
          }
      }
      const Tfloat veloc_max = _veloc_max.max();
      if (veloc_max<=0) return *this;
      return ((velocity*=amplitude/veloc_max)+=*this).cut(val_min,val_max).move_to(*this);
    }


    CImg<T> get_sharpen(const float amplitude, const bool sharpen_type=false, const float edge=1,
                        const float alpha=0, const float sigma=0) const {
      return (+*this).sharpen(amplitude,sharpen_type,edge,alpha,sigma);
    }
# 26915 "../src/CImg.h"
    CImgList<Tfloat> get_gradient(const char *const axes=0, const int scheme=3) const {
      CImgList<Tfloat> grad(2,_width,_height,_depth,_spectrum);
      bool is_3d = false;
      if (axes) {
        for (unsigned int a = 0; axes[a]; ++a) {
          const char axis = cimg::uncase(axes[a]);
          switch (axis) {
          case 'x' : case 'y' : break;
          case 'z' : is_3d = true; break;
          default :
            throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "get_gradient(): Invalid specified axis '%c'.",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        axis);
          }
        }
      } else is_3d = (_depth>1);
      if (is_3d) {
        CImg<Tfloat>(_width,_height,_depth,_spectrum).move_to(grad);
        switch (scheme) {
        case -1 : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const unsigned long off = c*_width*_height*_depth;
            Tfloat *ptrd0 = grad[0]._data + off, *ptrd1 = grad[1]._data + off, *ptrd2 = grad[2]._data + off;
            Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
            for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
              *(ptrd0++) = Iccc - Ipcc;
              *(ptrd1++) = Iccc - Icpc;
              *(ptrd2++) = Iccc - Iccp;
            }
          }
        } break;
        case 1 : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const unsigned long off = c*_width*_height*_depth;
            Tfloat *ptrd0 = grad[0]._data + off, *ptrd1 = grad[1]._data + off, *ptrd2 = grad[2]._data + off;
            Tfloat I[8]; Tfloat& Iccc = I[0]; Tfloat& Incc = I[1]; Tfloat& Icnc = I[2]; Tfloat& Innc = I[3]; Tfloat& Iccn = I[4]; Tfloat& Incn = I[5]; Tfloat& Icnn = I[6]; Tfloat& Innn = I[7]; Iccc = Incc = Icnc = Innc = Iccn = Incn = Icnn = Innn = 0;
            for (int z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; ++z, ++_n1z) for (int y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = (int)( (I[0] = (Tfloat)(*this)(0,y,z,c)), (I[2] = (Tfloat)(*this)(0,_n1y,z,c)), (I[4] = (Tfloat)(*this)(0,y,_n1z,c)), (I[6] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[1] = (Tfloat)(*this)(_n1x,y,z,c)), (I[3] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[7] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[2] = I[3], I[4] = I[5], I[6] = I[7], ++x, ++_n1x) {
              *(ptrd0++) = Incc - Iccc;
              *(ptrd1++) = Icnc - Iccc;
              *(ptrd2++) = Iccn - Iccc;
            }
          }
        } break;
        case 4 : {
          grad[0] = get_deriche(0,1,'x');
          grad[1] = get_deriche(0,1,'y');
          grad[2] = get_deriche(0,1,'z');
        } break;
        case 5 : {
          grad[0] = get_vanvliet(0,1,'x');
          grad[1] = get_vanvliet(0,1,'y');
          grad[2] = get_vanvliet(0,1,'z');
        } break;
        default : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const unsigned long off = c*_width*_height*_depth;
            Tfloat *ptrd0 = grad[0]._data + off, *ptrd1 = grad[1]._data + off, *ptrd2 = grad[2]._data + off;
            Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
            for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
              *(ptrd0++) = (Incc - Ipcc)/2;
              *(ptrd1++) = (Icnc - Icpc)/2;
              *(ptrd2++) = (Iccn - Iccp)/2;
            }
          }
        }
        }
      } else switch (scheme) {
      case -1 : {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
          const unsigned long off = c*_width*_height*_depth + z*_width*_height;
          Tfloat *ptrd0 = grad[0]._data + off, *ptrd1 = grad[1]._data + off;
          Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
          for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
            *(ptrd0++) = Icc - Ipc;
            *(ptrd1++) = Icc - Icp;
          }
        }
      } break;
      case 1 : {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
          const unsigned long off = c*_width*_height*_depth + z*_width*_height;
          Tfloat *ptrd0 = grad[0]._data + off, *ptrd1 = grad[1]._data + off;
          Tfloat I[4]; Tfloat& Icc = I[0]; Tfloat& Inc = I[1]; Tfloat& Icn = I[2]; Tfloat& Inn = I[3]; Icc = Inc = Icn = Inn = 0;
          for (int y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; ++y, ++_n1y) for (int x = 0, _n1x = (int)( (I[0] = (Tfloat)(*this)(0,y,z,c)), (I[2] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[1] = (Tfloat)(*this)(_n1x,y,z,c)), (I[3] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[2] = I[3], ++x, ++_n1x) {
            *(ptrd0++) = Inc - Icc;
            *(ptrd1++) = Icn - Icc;
          }
        }
      } break;
      case 2 : {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
          const unsigned long off = c*_width*_height*_depth + z*_width*_height;
          Tfloat *ptrd0 = grad[0]._data + off, *ptrd1 = grad[1]._data + off;
          Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
          for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
            *(ptrd0++) = -Ipp - 2*Ipc - Ipn + Inp + 2*Inc + Inn;
            *(ptrd1++) = -Ipp - 2*Icp - Inp + Ipn + 2*Icn + Inn;
          }
        }
      } break;
      case 3 : {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
          const unsigned long off = c*_width*_height*_depth + z*_width*_height;
          Tfloat *ptrd0 = grad[0]._data + off, *ptrd1 = grad[1]._data + off;
          Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
          const Tfloat a = (Tfloat)(0.25f*(2-std::sqrt(2.0f))), b = (Tfloat)(0.5f*(std::sqrt(2.0f)-1));
          for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
            *(ptrd0++) = -a*Ipp - b*Ipc - a*Ipn + a*Inp + b*Inc + a*Inn;
            *(ptrd1++) = -a*Ipp - b*Icp - a*Inp + a*Ipn + b*Icn + a*Inn;
          }
        }
      } break;
      case 4 : {
        grad[0] = get_deriche(0,1,'x');
        grad[1] = get_deriche(0,1,'y');
      } break;
      case 5 : {
        grad[0] = get_vanvliet(0,1,'x');
        grad[1] = get_vanvliet(0,1,'y');
      } break;
      default : {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
          const unsigned long off = c*_width*_height*_depth + z*_width*_height;
          Tfloat *ptrd0 = grad[0]._data + off, *ptrd1 = grad[1]._data + off;
          Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
          for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
            *(ptrd0++) = (Inc - Ipc)/2;
            *(ptrd1++) = (Icn - Icp)/2;
          }
        }
      }
      }
      if (!axes) return grad;
      CImgList<Tfloat> res;
      for (unsigned int l = 0; axes[l]; ++l) {
        const char axis = cimg::uncase(axes[l]);
        switch (axis) {
        case 'x' : res.insert(grad[0]); break;
        case 'y' : res.insert(grad[1]); break;
        case 'z' : res.insert(grad[2]); break;
        }
      }
      grad.assign();
      return res;
    }





    CImgList<Tfloat> get_hessian(const char *const axes=0) const {
      CImgList<Tfloat> res;
      const char *naxes = axes, *const def_axes2d = "xxxyyy", *const def_axes3d = "xxxyxzyyyzzz";
      if (!axes) naxes = _depth>1?def_axes3d:def_axes2d;
      const unsigned int lmax = std::strlen(naxes);
      if (lmax%2)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_hessian(): Invalid specified axes '%s'.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    naxes);

      res.assign(lmax/2,_width,_height,_depth,_spectrum);
      if (!cimg::strcasecmp(naxes,def_axes3d)) {




        for (int c = 0; c<(int)((*this)._spectrum); ++c) {
          const unsigned long off = c*_width*_height*_depth;
          Tfloat
            *ptrd0 = res[0]._data + off, *ptrd1 = res[1]._data + off, *ptrd2 = res[2]._data + off,
            *ptrd3 = res[3]._data + off, *ptrd4 = res[4]._data + off, *ptrd5 = res[5]._data + off;
          Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
          for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
            *(ptrd0++) = Ipcc + Incc - 2*Iccc;
            *(ptrd1++) = (Ippc + Innc - Ipnc - Inpc)/4;
            *(ptrd2++) = (Ipcp + Incn - Ipcn - Incp)/4;
            *(ptrd3++) = Icpc + Icnc - 2*Iccc;
            *(ptrd4++) = (Icpp + Icnn - Icpn - Icnp)/4;
            *(ptrd5++) = Iccn + Iccp - 2*Iccc;
          }
        }
      } else if (!cimg::strcasecmp(naxes,def_axes2d)) {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
          const unsigned long off = c*_width*_height*_depth + z*_width*_height;
          Tfloat *ptrd0 = res[0]._data + off, *ptrd1 = res[1]._data + off, *ptrd2 = res[2]._data + off;
          Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
          for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
            *(ptrd0++) = Ipc + Inc - 2*Icc;
            *(ptrd1++) = (Ipp + Inn - Ipn - Inp)/4;
            *(ptrd2++) = Icp + Icn - 2*Icc;
          }
        }
      } else for (unsigned int l = 0; l<lmax; ) {
          const unsigned int l2 = l/2;
          char axis1 = naxes[l++], axis2 = naxes[l++];
          if (axis1>axis2) cimg::swap(axis1,axis2);
          bool valid_axis = false;
          if (axis1=='x' && axis2=='x') {
            valid_axis = true;



            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
              Tfloat *ptrd = res[l2].data(0,0,z,c);
              Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
              for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) *(ptrd++) = Ipc + Inc - 2*Icc;
            }
          }
          else if (axis1=='x' && axis2=='y') {
            valid_axis = true;



            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
              Tfloat *ptrd = res[l2].data(0,0,z,c);
              Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
              for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) *(ptrd++) = (Ipp + Inn - Ipn - Inp)/4;
            }
          }
          else if (axis1=='x' && axis2=='z') {
            valid_axis = true;



            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              Tfloat *ptrd = res[l2].data(0,0,0,c);
              Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
              for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) *(ptrd++) = (Ipcp + Incn - Ipcn - Incp)/4;
            }
          }
          else if (axis1=='y' && axis2=='y') {
            valid_axis = true;



            for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
              Tfloat *ptrd = res[l2].data(0,0,z,c);
              Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
              for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) *(ptrd++) = Icp + Icn - 2*Icc;
            }
          }
          else if (axis1=='y' && axis2=='z') {
            valid_axis = true;



            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              Tfloat *ptrd = res[l2].data(0,0,0,c);
              Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) *(ptrd++) = (Icpp + Icnn - Icpn - Icnp)/4;
            }
          }
          else if (axis1=='z' && axis2=='z') {
            valid_axis = true;



            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              Tfloat *ptrd = res[l2].data(0,0,0,c);
              Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
              for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) *(ptrd++) = Iccn + Iccp - 2*Iccc;
            }
          }
          else if (!valid_axis)
            throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "get_hessian(): Invalid specified axes '%s'.",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        naxes);
        }
      return res;
    }


    CImg<T>& laplacian() {
      return get_laplacian().move_to(*this);
    }


    CImg<Tfloat> get_laplacian() const {
      if (is_empty()) return CImg<Tfloat>();
      CImg<Tfloat> res(_width,_height,_depth,_spectrum);
      if (_depth>1) {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) {
          Tfloat *ptrd = res.data(0,0,0,c);
          Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
          for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) *(ptrd++) = Incc + Ipcc + Icnc + Icpc + Iccn + Iccp - 6*Iccc;
        }
      } else if (_height>1) {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) {
          Tfloat *ptrd = res.data(0,0,0,c);
          Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
          for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,0,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,0,c)), (I[5] = (Tfloat)(*this)(_n1x,y,0,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) *(ptrd++) = Inc + Ipc + Icn + Icp - 4*Icc;
        }
      } else {



        for (int c = 0; c<(int)((*this)._spectrum); ++c) {
          Tfloat *ptrd = res.data(0,0,0,c);
          Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
          for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,0,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,0,c)), (I[5] = (Tfloat)(*this)(_n1x,y,0,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) *(ptrd++) = Inc + Ipc - 2*Icc;
        }
      }
      return res;
    }





    CImg<T>& structure_tensors(const unsigned int scheme=2) {
      return get_structure_tensors(scheme).move_to(*this);
    }


    CImg<Tfloat> get_structure_tensors(const unsigned int scheme=2) const {
      if (is_empty()) return *this;
      CImg<Tfloat> res;
      if (_depth>1) {
        res.assign(_width,_height,_depth,6,0);
        switch (scheme) {
        case 0 : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat
              *ptrd0 = res.data(0,0,0,0), *ptrd1 = res.data(0,0,0,1), *ptrd2 = res.data(0,0,0,2),
              *ptrd3 = res.data(0,0,0,3), *ptrd4 = res.data(0,0,0,4), *ptrd5 = res.data(0,0,0,5);
            Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
            for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
              const Tfloat
                ix = (Incc - Ipcc)/2,
                iy = (Icnc - Icpc)/2,
                iz = (Iccn - Iccp)/2;
              *(ptrd0++)+=ix*ix;
              *(ptrd1++)+=ix*iy;
              *(ptrd2++)+=ix*iz;
              *(ptrd3++)+=iy*iy;
              *(ptrd4++)+=iy*iz;
              *(ptrd5++)+=iz*iz;
            }
          }
        } break;
        case 1 : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat
              *ptrd0 = res.data(0,0,0,0), *ptrd1 = res.data(0,0,0,1), *ptrd2 = res.data(0,0,0,2),
              *ptrd3 = res.data(0,0,0,3), *ptrd4 = res.data(0,0,0,4), *ptrd5 = res.data(0,0,0,5);
            Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
            for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
              const Tfloat
                ixf = Incc - Iccc, ixb = Iccc - Ipcc,
                iyf = Icnc - Iccc, iyb = Iccc - Icpc,
                izf = Iccn - Iccc, izb = Iccc - Iccp;
              *(ptrd0++)+=(ixf*ixf + 2*ixf*ixb + ixb*ixb)/4;
              *(ptrd1++)+=(ixf*iyf + ixf*iyb + ixb*iyf + ixb*iyb)/4;
              *(ptrd2++)+=(ixf*izf + ixf*izb + ixb*izf + ixb*izb)/4;
              *(ptrd3++)+=(iyf*iyf + 2*iyf*iyb + iyb*iyb)/4;
              *(ptrd4++)+=(iyf*izf + iyf*izb + iyb*izf + iyb*izb)/4;
              *(ptrd5++)+=(izf*izf + 2*izf*izb + izb*izb)/4;
            }
          }
        } break;
        default : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat
              *ptrd0 = res.data(0,0,0,0), *ptrd1 = res.data(0,0,0,1), *ptrd2 = res.data(0,0,0,2),
              *ptrd3 = res.data(0,0,0,3), *ptrd4 = res.data(0,0,0,4), *ptrd5 = res.data(0,0,0,5);
            Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
            for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) {
              const Tfloat
                ixf = Incc - Iccc, ixb = Iccc - Ipcc,
                iyf = Icnc - Iccc, iyb = Iccc - Icpc,
                izf = Iccn - Iccc, izb = Iccc - Iccp;
              *(ptrd0++)+=(ixf*ixf + ixb*ixb)/2;
              *(ptrd1++)+=(ixf*iyf + ixf*iyb + ixb*iyf + ixb*iyb)/4;
              *(ptrd2++)+=(ixf*izf + ixf*izb + ixb*izf + ixb*izb)/4;
              *(ptrd3++)+=(iyf*iyf + iyb*iyb)/2;
              *(ptrd4++)+=(iyf*izf + iyf*izb + iyb*izf + iyb*izb)/4;
              *(ptrd5++)+=(izf*izf + izb*izb)/2;
            }
          }
        } break;
        }
      } else {
        res.assign(_width,_height,_depth,3,0);
        switch (scheme) {
        case 0 : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat *ptrd0 = res.data(0,0,0,0), *ptrd1 = res.data(0,0,0,1), *ptrd2 = res.data(0,0,0,2);
            Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
            for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,0,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,0,c)), (I[5] = (Tfloat)(*this)(_n1x,y,0,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
              const Tfloat
                ix = (Inc - Ipc)/2,
                iy = (Icn - Icp)/2;
              *(ptrd0++)+=ix*ix;
              *(ptrd1++)+=ix*iy;
              *(ptrd2++)+=iy*iy;
            }
          }
        } break;
        case 1 : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat *ptrd0 = res.data(0,0,0,0), *ptrd1 = res.data(0,0,0,1), *ptrd2 = res.data(0,0,0,2);
            Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
            for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,0,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,0,c)), (I[5] = (Tfloat)(*this)(_n1x,y,0,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
              const Tfloat
                ixf = Inc - Icc, ixb = Icc - Ipc,
                iyf = Icn - Icc, iyb = Icc - Icp;
              *(ptrd0++)+=(ixf*ixf + 2*ixf*ixb + ixb*ixb)/4;
              *(ptrd1++)+=(ixf*iyf + ixf*iyb + ixb*iyf + ixb*iyb)/4;
              *(ptrd2++)+=(iyf*iyf + 2*iyf*iyb + iyb*iyb)/4;
            }
          }
        } break;
        default : {



          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            Tfloat *ptrd0 = res.data(0,0,0,0), *ptrd1 = res.data(0,0,0,1), *ptrd2 = res.data(0,0,0,2);
            Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
            for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,0,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,0,c)), (I[5] = (Tfloat)(*this)(_n1x,y,0,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) {
              const Tfloat
                ixf = Inc - Icc, ixb = Icc - Ipc,
                iyf = Icn - Icc, iyb = Icc - Icp;
              *(ptrd0++)+=(ixf*ixf + ixb*ixb)/2;
              *(ptrd1++)+=(ixf*iyf + ixf*iyb + ixb*iyf + ixb*iyb)/4;
              *(ptrd2++)+=(iyf*iyf + iyb*iyb)/2;
            }
          }
        } break;
        }
      }
      return res;
    }
# 27408 "../src/CImg.h"
    CImg<T>& diffusion_tensors(const float sharpness=0.7f, const float anisotropy=0.6f,
                               const float alpha=0.6f, const float sigma=1.1f, const bool is_sqrt=false) {
      CImg<Tfloat> res;
      const float
        nsharpness = cimg::max(sharpness,1e-5f),
        power1 = (is_sqrt?0.5f:1)*nsharpness,
        power2 = power1/(1e-7f+1-anisotropy);
      blur(alpha).normalize(0,(T)255);

      if (_depth>1) {
        get_structure_tensors().move_to(res).blur(sigma);



        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
          Tfloat
            *ptrd0 = res.data(0,y,z,0), *ptrd1 = res.data(0,y,z,1), *ptrd2 = res.data(0,y,z,2),
            *ptrd3 = res.data(0,y,z,3), *ptrd4 = res.data(0,y,z,4), *ptrd5 = res.data(0,y,z,5);
          CImg<floatT> val(3), vec(3,3);
          for (int x = 0; x<(int)((*this)._width); ++x) {
            res.get_tensor_at(x,y,z).symmetric_eigen(val,vec);
            const float
              _l1 = val[2], _l2 = val[1], _l3 = val[0],
              l1 = _l1>0?_l1:0, l2 = _l2>0?_l2:0, l3 = _l3>0?_l3:0,
              ux = vec(0,0), uy = vec(0,1), uz = vec(0,2),
              vx = vec(1,0), vy = vec(1,1), vz = vec(1,2),
              wx = vec(2,0), wy = vec(2,1), wz = vec(2,2),
              n1 = (float)std::pow(1+l1+l2+l3,-power1),
              n2 = (float)std::pow(1+l1+l2+l3,-power2);
            *(ptrd0++) = n1*(ux*ux + vx*vx) + n2*wx*wx;
            *(ptrd1++) = n1*(ux*uy + vx*vy) + n2*wx*wy;
            *(ptrd2++) = n1*(ux*uz + vx*vz) + n2*wx*wz;
            *(ptrd3++) = n1*(uy*uy + vy*vy) + n2*wy*wy;
            *(ptrd4++) = n1*(uy*uz + vy*vz) + n2*wy*wz;
            *(ptrd5++) = n1*(uz*uz + vz*vz) + n2*wz*wz;
          }
        }
      } else {
        get_structure_tensors().move_to(res).blur(sigma);



        for (int y = 0; y<(int)((*this)._height); ++y) {
          Tfloat *ptrd0 = res.data(0,y,0,0), *ptrd1 = res.data(0,y,0,1), *ptrd2 = res.data(0,y,0,2);
          CImg<floatT> val(2), vec(2,2);
          for (int x = 0; x<(int)((*this)._width); ++x) {
            res.get_tensor_at(x,y).symmetric_eigen(val,vec);
            const float
              _l1 = val[1], _l2 = val[0],
              l1 = _l1>0?_l1:0, l2 = _l2>0?_l2:0,
              ux = vec(1,0), uy = vec(1,1),
              vx = vec(0,0), vy = vec(0,1),
              n1 = (float)std::pow(1+l1+l2,-power1),
              n2 = (float)std::pow(1+l1+l2,-power2);
            *(ptrd0++) = n1*ux*ux + n2*vx*vx;
            *(ptrd1++) = n1*ux*uy + n2*vx*vy;
            *(ptrd2++) = n1*uy*uy + n2*vy*vy;
          }
        }
      }
      return res.move_to(*this);
    }


    CImg<Tfloat> get_diffusion_tensors(const float sharpness=0.7f, const float anisotropy=0.6f,
                                       const float alpha=0.6f, const float sigma=1.1f, const bool is_sqrt=false) const {
      return CImg<Tfloat>(*this,false).diffusion_tensors(sharpness,anisotropy,alpha,sigma,is_sqrt);
    }
# 27486 "../src/CImg.h"
    CImg<T>& displacement(const CImg<T>& source, const float smoothness=0.1f, const float precision=5.0f,
                          const unsigned int nb_scales=0, const unsigned int iteration_max=10000,
                          const bool is_backward=false) {
      return get_displacement(source,smoothness,precision,nb_scales,iteration_max,is_backward).move_to(*this);
    }


    CImg<Tfloat> get_displacement(const CImg<T>& source,
                                  const float smoothness=0.1f, const float precision=5.0f,
                                  const unsigned int nb_scales=0, const unsigned int iteration_max=10000,
                                  const bool is_backward=false) const {
      if (is_empty() || !source) return +*this;
      if (!is_sameXYZC(source))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "displacement(): Instance and source image (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    source._width,source._height,source._depth,source._spectrum,source._data);
      if (precision<0)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "displacement(): Invalid specified precision %g "
                                    "(should be >=0)",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    precision);
      const unsigned int _nb_scales = nb_scales>0?nb_scales:
        (unsigned int)(2*std::log((double)(cimg::max(_width,_height))));
      const float _precision = (float)std::pow(10.0,-(double)precision);
      float sm, sM = source.max_min(sm), tm, tM = max_min(tm);
      const float sdelta = sm==sM?1:(sM - sm), tdelta = tm==tM?1:(tM - tm);
      const bool is_3d = source._depth>1;
      CImg<floatT> U;

      for (int scale = _nb_scales-1; scale>=0; --scale) {
        const float factor = (float)std::pow(1.5,(double)scale);
        const unsigned int
          _sw = (unsigned int)(_width/factor), sw = _sw?_sw:1,
          _sh = (unsigned int)(_height/factor), sh = _sh?_sh:1,
          _sd = (unsigned int)(_depth/factor), sd = _sd?_sd:1;
        if (sw<5 && sh<5 && (!is_3d || sd<5)) continue;
        const CImg<Tfloat>
          I1 = (source.get_resize(sw,sh,sd,-100,2)-=sm)/=sdelta,
          I2 = (get_resize(I1,2)-=tm)/=tdelta;
        if (U) (U*=1.5f).resize(I2._width,I2._height,I2._depth,-100,3);
        else U.assign(I2._width,I2._height,I2._depth,is_3d?3:2,0);
        float dt = 2, energy = cimg::type<float>::max();
        const CImgList<Tfloat> dI = is_backward?I1.get_gradient():I2.get_gradient();

        for (unsigned int iteration = 0; iteration<iteration_max; ++iteration) {
          float _energy = 0;
          if (is_3d) {
            if (smoothness>=0) for (int z = 0, _p1z = 0, _n1z = 1>=((U)._depth)?(int)((U)._depth)-1:1; _n1z<(int)((U)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((U)._height)?(int)((U)._height)-1:1; _n1y<(int)((U)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = 1>=((U)._width)?(int)((U)._width)-1:1; _n1x<(int)((U)._width) || x==--_n1x; _p1x = x++, ++_n1x) {
                const float
                  X = is_backward?x - U(x,y,z,0):x + U(x,y,z,0),
                  Y = is_backward?y - U(x,y,z,1):y + U(x,y,z,1),
                  Z = is_backward?z - U(x,y,z,2):z + U(x,y,z,2);
                float delta_I = 0, _energy_regul = 0;
                if (is_backward) for (int c = 0; c<(int)((I2)._spectrum); ++c) delta_I+=(float)(I1.linear_atXYZ(X,Y,Z,c) - I2(x,y,z,c));
                else for (int c = 0; c<(int)((I2)._spectrum); ++c) delta_I+=(float)(I1(x,y,z,c) - I2.linear_atXYZ(X,Y,Z,c));
                for (int c = 0; c<(int)((U)._spectrum); ++c) {
                  const float
                    Ux = 0.5f*(U(_n1x,y,z,c) - U(_p1x,y,z,c)),
                    Uy = 0.5f*(U(x,_n1y,z,c) - U(x,_p1y,z,c)),
                    Uz = 0.5f*(U(x,y,_n1z,c) - U(x,y,_p1z,c)),
                    Uxx = U(_n1x,y,z,c) + U(_p1x,y,z,c),
                    Uyy = U(x,_n1y,z,c) + U(x,_p1y,z,c),
                    Uzz = U(x,y,_n1z,c) + U(x,y,_p1z,c);
                  U(x,y,z,c) = (float)(U(x,y,z,c) + dt*(delta_I*dI[c].linear_atXYZ(X,Y,Z) +
                                                        smoothness* ( Uxx + Uyy + Uzz)))/(1+6*smoothness*dt);
                  _energy_regul+=Ux*Ux + Uy*Uy + Uz*Uz;
                }
                _energy+=delta_I*delta_I + smoothness*_energy_regul;
              } else {
              const float nsmoothness = -smoothness;
              for (int z = 0, _p1z = 0, _n1z = 1>=((U)._depth)?(int)((U)._depth)-1:1; _n1z<(int)((U)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((U)._height)?(int)((U)._height)-1:1; _n1y<(int)((U)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = 1>=((U)._width)?(int)((U)._width)-1:1; _n1x<(int)((U)._width) || x==--_n1x; _p1x = x++, ++_n1x) {
                const float
                  X = is_backward?x - U(x,y,z,0):x + U(x,y,z,0),
                  Y = is_backward?y - U(x,y,z,1):y + U(x,y,z,1),
                  Z = is_backward?z - U(x,y,z,2):z + U(x,y,z,2);
                float delta_I = 0, _energy_regul = 0;
                if (is_backward) for (int c = 0; c<(int)((I2)._spectrum); ++c) delta_I+=(float)(I1.linear_atXYZ(X,Y,Z,c) - I2(x,y,z,c));
                else for (int c = 0; c<(int)((I2)._spectrum); ++c) delta_I+=(float)(I1(x,y,z,c) - I2.linear_atXYZ(X,Y,Z,c));
                for (int c = 0; c<(int)((U)._spectrum); ++c) {
                  const float
                    Ux = 0.5f*(U(_n1x,y,z,c) - U(_p1x,y,z,c)),
                    Uy = 0.5f*(U(x,_n1y,z,c) - U(x,_p1y,z,c)),
                    Uz = 0.5f*(U(x,y,_n1z,c) - U(x,y,_p1z,c)),
                    N2 = Ux*Ux + Uy*Uy + Uz*Uz,
                    N = std::sqrt(N2),
                    N3 = 1e-5f + N2*N,
                    coef_a = (1 - Ux*Ux/N2)/N,
                    coef_b = -2*Ux*Uy/N3,
                    coef_c = -2*Ux*Uz/N3,
                    coef_d = (1 - Uy*Uy/N2)/N,
                    coef_e = -2*Uy*Uz/N3,
                    coef_f = (1 - Uz*Uz/N2)/N,
                    Uxx = U(_n1x,y,z,c) + U(_p1x,y,z,c),
                    Uyy = U(x,_n1y,z,c) + U(x,_p1y,z,c),
                    Uzz = U(x,y,_n1z,c) + U(x,y,_p1z,c),
                    Uxy = 0.25f*(U(_n1x,_n1y,z,c) + U(_p1x,_p1y,z,c) - U(_n1x,_p1y,z,c) - U(_n1x,_p1y,z,c)),
                    Uxz = 0.25f*(U(_n1x,y,_n1z,c) + U(_p1x,y,_p1z,c) - U(_n1x,y,_p1z,c) - U(_n1x,y,_p1z,c)),
                    Uyz = 0.25f*(U(x,_n1y,_n1z,c) + U(x,_p1y,_p1z,c) - U(x,_n1y,_p1z,c) - U(x,_n1y,_p1z,c));
                  U(x,y,z,c) = (float)(U(x,y,z,c) + dt*(delta_I*dI[c].linear_atXYZ(X,Y,Z) +
                                                        nsmoothness* ( coef_a*Uxx + coef_b*Uxy +
                                                                       coef_c*Uxz + coef_d*Uyy +
                                                                       coef_e*Uyz + coef_f*Uzz ))
                                       )/(1+2*(coef_a+coef_d+coef_f)*nsmoothness*dt);
                  _energy_regul+=N;
                }
                _energy+=delta_I*delta_I + nsmoothness*_energy_regul;
              }
            }
          } else {
            if (smoothness>=0) for (int y = 0, _p1y = 0, _n1y = 1>=((U)._height)?(int)((U)._height)-1:1; _n1y<(int)((U)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = 1>=((U)._width)?(int)((U)._width)-1:1; _n1x<(int)((U)._width) || x==--_n1x; _p1x = x++, ++_n1x) {
                const float
                  X = is_backward?x - U(x,y,0):x + U(x,y,0),
                  Y = is_backward?y - U(x,y,1):y + U(x,y,1);
                float delta_I = 0, _energy_regul = 0;
                if (is_backward) for (int c = 0; c<(int)((I2)._spectrum); ++c) delta_I+=(float)(I1.linear_atXY(X,Y,c) - I2(x,y,c));
                else for (int c = 0; c<(int)((I2)._spectrum); ++c) delta_I+=(float)(I1(x,y,c) - I2.linear_atXY(X,Y,c));
                for (int c = 0; c<(int)((U)._spectrum); ++c) {
                  const float
                    Ux = 0.5f*(U(_n1x,y,c) - U(_p1x,y,c)),
                    Uy = 0.5f*(U(x,_n1y,c) - U(x,_p1y,c)),
                    Uxx = U(_n1x,y,c) + U(_p1x,y,c),
                    Uyy = U(x,_n1y,c) + U(x,_p1y,c);
                  U(x,y,c) = (float)(U(x,y,c) + dt*(delta_I*dI[c].linear_atXY(X,Y) +
                                                    smoothness*( Uxx + Uyy )))/(1+4*smoothness*dt);
                  _energy_regul+=Ux*Ux + Uy*Uy;
                }
                _energy+=delta_I*delta_I + smoothness*_energy_regul;
              } else {
              const float nsmoothness = -smoothness;
              for (int y = 0, _p1y = 0, _n1y = 1>=((U)._height)?(int)((U)._height)-1:1; _n1y<(int)((U)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = 1>=((U)._width)?(int)((U)._width)-1:1; _n1x<(int)((U)._width) || x==--_n1x; _p1x = x++, ++_n1x) {
                const float
                  X = is_backward?x - U(x,y,0):x + U(x,y,0),
                  Y = is_backward?y - U(x,y,1):y + U(x,y,1);
                float delta_I = 0, _energy_regul = 0;
                if (is_backward) for (int c = 0; c<(int)((I2)._spectrum); ++c) delta_I+=(float)(I1.linear_atXY(X,Y,c) - I2(x,y,c));
                else for (int c = 0; c<(int)((I2)._spectrum); ++c) delta_I+=(float)(I1(x,y,c) - I2.linear_atXY(X,Y,c));
                for (int c = 0; c<(int)((U)._spectrum); ++c) {
                  const float
                    Ux = 0.5f*(U(_n1x,y,c) - U(_p1x,y,c)),
                    Uy = 0.5f*(U(x,_n1y,c) - U(x,_p1y,c)),
                    N2 = Ux*Ux + Uy*Uy,
                    N = std::sqrt(N2),
                    N3 = 1e-5f + N2*N,
                    coef_a = Uy*Uy/N3,
                    coef_b = -2*Ux*Uy/N3,
                    coef_c = Ux*Ux/N3,
                    Uxx = U(_n1x,y,c) + U(_p1x,y,c),
                    Uyy = U(x,_n1y,c) + U(x,_p1y,c),
                    Uxy = 0.25f*(U(_n1x,_n1y,c) + U(_p1x,_p1y,c) - U(_n1x,_p1y,c) - U(_n1x,_p1y,c));
                  U(x,y,c) = (float)(U(x,y,c) + dt*(delta_I*dI[c].linear_atXY(X,Y) +
                                                    nsmoothness*( coef_a*Uxx + coef_b*Uxy + coef_c*Uyy )))/
                    (1+2*(coef_a+coef_c)*nsmoothness*dt);
                  _energy_regul+=N;
                }
                _energy+=delta_I*delta_I + nsmoothness*_energy_regul;
              }
            }
          }
          const float d_energy = (_energy - energy)/(sw*sh*sd);
          if (d_energy<=0 && -d_energy<_precision) break;
          if (d_energy>0) dt*=0.5f;
          energy = _energy;
        }
      }
      return U;
    }
# 27668 "../src/CImg.h"
    CImg<T>& distance(const T value, const unsigned int metric=2) {
      if (is_empty()) return *this;
      bool is_value = false;
      for (T *ptr = (*this)._data, *_maxptr = (*this)._data + (*this).size(); ptr<_maxptr; ++ptr) *ptr = *ptr==value?is_value=true,0:(T)999999999;
      if (!is_value) return fill(cimg::type<T>::max());
      switch (metric) {
      case 0 : return _distance_core(_distance_sep_cdt,_distance_dist_cdt);
      case 1 : return _distance_core(_distance_sep_mdt,_distance_dist_mdt);
      case 3 : return _distance_core(_distance_sep_edt,_distance_dist_edt);
      default : return _distance_core(_distance_sep_edt,_distance_dist_edt).sqrt();
      }
      return *this;
    }


    CImg<Tfloat> get_distance(const T value, const unsigned int metric=2) const {
      return CImg<Tfloat>(*this,false).distance((Tfloat)value,metric);
    }

    static long _distance_sep_edt(const long i, const long u, const long *const g) {
      return (u*u-i*i+g[u]-g[i])/(2*(u-i));
    }

    static long _distance_dist_edt(const long x, const long i, const long *const g) {
      return (x-i)*(x-i) + g[i];
    }

    static long _distance_sep_mdt(const long i, const long u, const long *const g) {
      return (u-i<=g[u]-g[i]?999999999:(g[u]-g[i]+u+i)/2);
    }

    static long _distance_dist_mdt(const long x, const long i, const long *const g) {
      return (x<i?i-x:x-i) + g[i];
    }

    static long _distance_sep_cdt(const long i, const long u, const long *const g) {
      const long h = (i+u)/2;
      if (g[i]<=g[u]) { return h<i+g[u]?i+g[u]:h; }
      return h<u-g[i]?h:u-g[i];
    }

    static long _distance_dist_cdt(const long x, const long i, const long *const g) {
      const long d = x<i?i-x:x-i;
      return d<g[i]?g[i]:d;
    }

    static void _distance_scan(const unsigned int len,
                               const long *const g,
                               long (*const sep)(const long, const long, const long *const),
                               long (*const f)(const long, const long, const long *const),
                               long *const s,
                               long *const t,
                               long *const dt) {
      long q = s[0] = t[0] = 0;
      for (int u = 1; u<(int)len; ++u) {
        while ((q>=0) && f(t[q],s[q],g)>f(t[q],u,g)) { --q; }
        if (q<0) { q = 0; s[0] = u; }
        else { const long w = 1 + sep(s[q], u, g); if (w<(long)len) { ++q; s[q] = u; t[q] = w; }}
      }
      for (int u = (int)len-1; u>=0; --u) { dt[u] = f(u,s[q],g); if (u==t[q]) --q; }
    }

    CImg<T>& _distance_core(long (*const sep)(const long, const long, const long *const),
                            long (*const f)(const long, const long, const long *const)) {
      const unsigned long wh = (unsigned long)_width*_height;



      for (int c = 0; c<(int)((*this)._spectrum); ++c) {
        CImg<longT> g(_width), dt(_width), s(_width), t(_width);
        CImg<T> img = get_shared_channel(c);



        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
          for (int x = 0; x<(int)((*this)._width); ++x) g[x] = (long)img(x,y,z,0,wh);
          _distance_scan(_width,g,sep,f,s,t,dt);
          for (int x = 0; x<(int)((*this)._width); ++x) img(x,y,z,0,wh) = (T)dt[x];
        }
        if (_height>1) {
          g.assign(_height); dt.assign(_height); s.assign(_height); t.assign(_height);



          for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x) {
            for (int y = 0; y<(int)((*this)._height); ++y) g[y] = (long)img(x,y,z,0,wh);
            _distance_scan(_height,g,sep,f,s,t,dt);
            for (int y = 0; y<(int)((*this)._height); ++y) img(x,y,z,0,wh) = (T)dt[y];
          }
        }
        if (_depth>1) {
          g.assign(_depth); dt.assign(_depth); s.assign(_depth); t.assign(_depth);



          for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
            for (int z = 0; z<(int)((*this)._depth); ++z) g[z] = (long)img(x,y,z,0,wh);
            _distance_scan(_depth,g,sep,f,s,t,dt);
            for (int z = 0; z<(int)((*this)._depth); ++z) img(x,y,z,0,wh) = (T)dt[z];
          }
        }
      }
      return *this;
    }







    template<typename t>
    CImg<T>& distance(const T value, const CImg<t>& metric_mask) {
      if (is_empty()) return *this;
      bool is_value = false;
      for (T *ptr = (*this)._data, *_maxptr = (*this)._data + (*this).size(); ptr<_maxptr; ++ptr) *ptr = *ptr==value?is_value=true,0:(T)999999999;
      if (!is_value) return fill(cimg::type<T>::max());
      const unsigned long wh = (unsigned long)_width*_height;



      for (int c = 0; c<(int)((*this)._spectrum); ++c) {
        CImg<T> img = get_shared_channel(c);



        for (int dz = 0; dz<(int)((metric_mask)._depth); ++dz) for (int dy = 0; dy<(int)((metric_mask)._height); ++dy) for (int dx = 0; dx<(int)((metric_mask)._width); ++dx) {
          const t weight = metric_mask(dx,dy,dz);
          if (weight) {
            for (int z = dz, nz = 0; z<depth(); ++z,++nz) {
              for (int y = dy , ny = 0; y<height(); ++y,++ny) {
                for (int x = dx, nx = 0; x<width(); ++x,++nx) {
                  const T dd = img(nx,ny,nz,0,wh) + weight;
                  if (dd<img(x,y,z,0,wh)) img(x,y,z,0,wh) = dd;
                }
              }
            }
            for (int z = depth() - 1 - dz, nz = depth() - 1; z>=0; --z,--nz) {
              for (int y = height() - 1 - dy, ny = height() - 1; y>=0; --y,--ny) {
                for (int x = width() - 1 - dx, nx = width() - 1; x>=0; --x,--nx) {
                  const T dd = img(nx,ny,nz,0,wh) + weight;
                  if (dd<img(x,y,z,0,wh)) img(x,y,z,0,wh) = dd;
                }
              }
            }
          }
        }
      }
      return *this;
    }


    template<typename t>
    CImg<Tfloat> get_distance(const T value, const CImg<t>& metric_mask) const {
      return CImg<Tfloat>(*this,false).distance(value,metric_mask);
    }







    template<typename t, typename to>
    CImg<T>& distance_dijkstra(const T value, const CImg<t>& metric, const bool is_high_connectivity,
                               CImg<to>& return_path) {
      return get_distance_dijkstra(value,metric,is_high_connectivity,return_path).move_to(*this);
    }


    template<typename t, typename to>
    CImg<typename cimg::superset<t,long>::type>
    get_distance_dijkstra(const T value, const CImg<t>& metric, const bool is_high_connectivity,
                          CImg<to>& return_path) const {
      if (is_empty()) return return_path.assign();
      if (!is_sameXYZ(metric))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "distance_dijkstra(): image instance and metric map (%u,%u,%u,%u) "
                                    "have incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    metric._width,metric._height,metric._depth,metric._spectrum);
      typedef typename cimg::superset<t,long>::type td;
      CImg<td> result(_width,_height,_depth,_spectrum), Q;
      CImg<boolT> is_queued(_width,_height,_depth,1);
      if (return_path) return_path.assign(_width,_height,_depth,_spectrum);

      for (int c = 0; c<(int)((*this)._spectrum); ++c) {
        const CImg<T> img = get_shared_channel(c);
        const CImg<t> met = metric.get_shared_channel(c%metric._spectrum);
        CImg<td> res = result.get_shared_channel(c);
        CImg<to> path = return_path?return_path.get_shared_channel(c):CImg<to>();
        unsigned int sizeQ = 0;


        is_queued.fill(0);
        for (int z = 0; z<(int)((img)._depth); ++z) for (int y = 0; y<(int)((img)._height); ++y) for (int x = 0; x<(int)((img)._width); ++x) if (img(x,y,z)==value) {
          Q._priority_queue_insert(is_queued,sizeQ,0,x,y,z);
          res(x,y,z) = 0;
          if (path) path(x,y,z) = (to)0;
        }


        while (sizeQ) {


          const int x = (int)Q(0,1), y = (int)Q(0,2), z = (int)Q(0,3);
          const td P = (td)-Q(0,0);
          Q._priority_queue_remove(sizeQ);


          td npot = 0;
          if (x-1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x-1,y,z)+P),x-1,y,z)) {
            res(x-1,y,z) = npot; if (path) path(x-1,y,z) = (to)2;
          }
          if (x+1<width() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x+1,y,z)+P),x+1,y,z)) {
            res(x+1,y,z) = npot; if (path) path(x+1,y,z) = (to)1;
          }
          if (y-1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y-1,z)+P),x,y-1,z)) {
            res(x,y-1,z) = npot; if (path) path(x,y-1,z) = (to)8;
          }
          if (y+1<height() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y+1,z)+P),x,y+1,z)) {
            res(x,y+1,z) = npot; if (path) path(x,y+1,z) = (to)4;
          }
          if (z-1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y,z-1)+P),x,y,z-1)) {
            res(x,y,z-1) = npot; if (path) path(x,y,z-1) = (to)32;
          }
          if (z+1<depth() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y,z+1)+P),x,y,z+1)) {
            res(x,y,z+1) = npot; if (path) path(x,y,z+1) = (to)16;
          }

          if (is_high_connectivity) {
            const float sqrt2 = std::sqrt(2.0f), sqrt3 = std::sqrt(3.0f);


            if (x-1>=0 && y-1>=0 &&
                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x-1,y-1,z)+P)),x-1,y-1,z)) {
              res(x-1,y-1,z) = npot; if (path) path(x-1,y-1,z) = (to)10;
            }
            if (x+1<width() && y-1>=0 &&
                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x+1,y-1,z)+P)),x+1,y-1,z)) {
              res(x+1,y-1,z) = npot; if (path) path(x+1,y-1,z) = (to)9;
            }
            if (x-1>=0 && y+1<height() &&
                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x-1,y+1,z)+P)),x-1,y+1,z)) {
              res(x-1,y+1,z) = npot; if (path) path(x-1,y+1,z) = (to)6;
            }
            if (x+1<width() && y+1<height() &&
                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x+1,y+1,z)+P)),x+1,y+1,z)) {
              res(x+1,y+1,z) = npot; if (path) path(x+1,y+1,z) = (to)5;
            }

            if (z-1>=0) {
              if (x-1>=0 &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x-1,y,z-1)+P)),x-1,y,z-1)) {
                res(x-1,y,z-1) = npot; if (path) path(x-1,y,z-1) = (to)34;
              }
              if (x+1<width() &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x+1,y,z-1)+P)),x+1,y,z-1)) {
                res(x+1,y,z-1) = npot; if (path) path(x+1,y,z-1) = (to)33;
              }
              if (y-1>=0 &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y-1,z-1)+P)),x,y-1,z-1)) {
                res(x,y-1,z-1) = npot; if (path) path(x,y-1,z-1) = (to)40;
              }
              if (y+1<height() &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y+1,z-1)+P)),x,y+1,z-1)) {
                res(x,y+1,z-1) = npot; if (path) path(x,y+1,z-1) = (to)36;
              }
              if (x-1>=0 && y-1>=0 &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x-1,y-1,z-1)+P)),x-1,y-1,z-1)) {
                res(x-1,y-1,z-1) = npot; if (path) path(x-1,y-1,z-1) = (to)42;
              }
              if (x+1<width() && y-1>=0 &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x+1,y-1,z-1)+P)),x+1,y-1,z-1)) {
                res(x+1,y-1,z-1) = npot; if (path) path(x+1,y-1,z-1) = (to)41;
              }
              if (x-1>=0 && y+1<height() &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x-1,y+1,z-1)+P)),x-1,y+1,z-1)) {
                res(x-1,y+1,z-1) = npot; if (path) path(x-1,y+1,z-1) = (to)38;
              }
              if (x+1<width() && y+1<height() &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x+1,y+1,z-1)+P)),x+1,y+1,z-1)) {
                res(x+1,y+1,z-1) = npot; if (path) path(x+1,y+1,z-1) = (to)37;
              }
            }

            if (z+1<depth()) {
              if (x-1>=0 &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x-1,y,z+1)+P)),x-1,y,z+1)) {
                res(x-1,y,z+1) = npot; if (path) path(x-1,y,z+1) = (to)18;
              }
              if (x+1<width() &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x+1,y,z+1)+P)),x+1,y,z+1)) {
                res(x+1,y,z+1) = npot; if (path) path(x+1,y,z+1) = (to)17;
              }
              if (y-1>=0 &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y-1,z+1)+P)),x,y-1,z+1)) {
                res(x,y-1,z+1) = npot; if (path) path(x,y-1,z+1) = (to)24;
              }
              if (y+1<height() &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y+1,z+1)+P)),x,y+1,z+1)) {
                res(x,y+1,z+1) = npot; if (path) path(x,y+1,z+1) = (to)20;
              }
              if (x-1>=0 && y-1>=0 &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x-1,y-1,z+1)+P)),x-1,y-1,z+1)) {
                res(x-1,y-1,z+1) = npot; if (path) path(x-1,y-1,z+1) = (to)26;
              }
              if (x+1<width() && y-1>=0 &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x+1,y-1,z+1)+P)),x+1,y-1,z+1)) {
                res(x+1,y-1,z+1) = npot; if (path) path(x+1,y-1,z+1) = (to)25;
              }
              if (x-1>=0 && y+1<height() &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x-1,y+1,z+1)+P)),x-1,y+1,z+1)) {
                res(x-1,y+1,z+1) = npot; if (path) path(x-1,y+1,z+1) = (to)22;
              }
              if (x+1<width() && y+1<height() &&
                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x+1,y+1,z+1)+P)),x+1,y+1,z+1)) {
                res(x+1,y+1,z+1) = npot; if (path) path(x+1,y+1,z+1) = (to)21;
              }
            }
          }
        }
      }
      return result;
    }


    template<typename t>
    CImg<T>& distance_dijkstra(const T value, const CImg<t>& metric,
                               const bool is_high_connectivity=false) {
      return get_distance_dijkstra(value,metric,is_high_connectivity).move_to(*this);
    }


    template<typename t>
    CImg<Tfloat> get_distance_dijkstra(const T value, const CImg<t>& metric,
                                       const bool is_high_connectivity=false) const {
      CImg<T> return_path;
      return get_distance_dijkstra(value,metric,is_high_connectivity,return_path);
    }






    template<typename t>
    CImg<T>& distance_eikonal(const T value, const CImg<t>& metric) {
      return get_distance_eikonal(value,metric).move_to(*this);
    }


    template<typename t>
    CImg<Tfloat> get_distance_eikonal(const T value, const CImg<t>& metric) const {
      if (is_empty()) return *this;
      if (!is_sameXYZ(metric))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "distance_eikonal(): image instance and metric map (%u,%u,%u,%u) have "
                                    "incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    metric._width,metric._height,metric._depth,metric._spectrum);
      CImg<Tfloat> result(_width,_height,_depth,_spectrum,cimg::type<Tfloat>::max()), Q;
      CImg<charT> state(_width,_height,_depth);




      for (int c = 0; c<(int)((*this)._spectrum); ++c) {
        const CImg<T> img = get_shared_channel(c);
        const CImg<t> met = metric.get_shared_channel(c%metric._spectrum);
        CImg<Tfloat> res = result.get_shared_channel(c);
        unsigned int sizeQ = 0;
        state.fill(-1);


        Tfloat *ptr1 = res._data; char *ptr2 = state._data;
        for (T *ptr0 = (img)._data, *_maxptr0 = (img)._data + (img).size(); ptr0<_maxptr0; ++ptr0) { if (*ptr0==value) { *ptr1 = 0; *ptr2 = 1; } ++ptr1; ++ptr2; }


        ptr2 = state._data;
        for (int z = 0; z<(int)((img)._depth); ++z) for (int y = 0; y<(int)((img)._height); ++y) for (int x = 0; x<(int)((img)._width); ++x) if (*(ptr2++)==1) {
          if (x-1>=0 && state(x-1,y,z)==-1) {
            const Tfloat dist = res(x-1,y,z) = __distance_eikonal(res,met(x-1,y,z),x-1,y,z);
            Q._eik_priority_queue_insert(state,sizeQ,-dist,x-1,y,z);
          }
          if (x+1<width() && state(x+1,y,z)==-1) {
            const Tfloat dist = res(x+1,y,z) = __distance_eikonal(res,met(x+1,y,z),x+1,y,z);
            Q._eik_priority_queue_insert(state,sizeQ,-dist,x+1,y,z);
          }
          if (y-1>=0 && state(x,y-1,z)==-1) {
            const Tfloat dist = res(x,y-1,z) = __distance_eikonal(res,met(x,y-1,z),x,y-1,z);
            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y-1,z);
          }
          if (y+1<height() && state(x,y+1,z)==-1) {
            const Tfloat dist = res(x,y+1,z) = __distance_eikonal(res,met(x,y+1,z),x,y+1,z);
            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y+1,z);
          }
          if (z-1>=0 && state(x,y,z-1)==-1) {
            const Tfloat dist = res(x,y,z-1) = __distance_eikonal(res,met(x,y,z-1),x,y,z-1);
            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z-1);
          }
          if (z+1<depth() && state(x,y,z+1)==-1) {
            const Tfloat dist = res(x,y,z+1) = __distance_eikonal(res,met(x,y,z+1),x,y,z+1);
            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z+1);
          }
        }


        while (sizeQ) {
          int x = -1, y = -1, z = -1;
          while (sizeQ && x<0) {
            x = (int)Q(0,1); y = (int)Q(0,2); z = (int)Q(0,3);
            Q._priority_queue_remove(sizeQ);
            if (state(x,y,z)==1) x = -1; else state(x,y,z) = 1;
          }
          if (x>=0) {
            if (x-1>=0 && state(x-1,y,z)!=1) {
              const Tfloat dist = __distance_eikonal(res,met(x-1,y,z),x-1,y,z);
              if (dist<res(x-1,y,z)) { res(x-1,y,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x-1,y,z); }
            }
            if (x+1<width() && state(x+1,y,z)!=1) {
              const Tfloat dist = __distance_eikonal(res,met(x+1,y,z),x+1,y,z);
              if (dist<res(x+1,y,z)) { res(x+1,y,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x+1,y,z); }
            }
            if (y-1>=0 && state(x,y-1,z)!=1) {
              const Tfloat dist = __distance_eikonal(res,met(x,y-1,z),x,y-1,z);
              if (dist<res(x,y-1,z)) { res(x,y-1,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y-1,z); }
            }
            if (y+1<height() && state(x,y+1,z)!=1) {
              const Tfloat dist = __distance_eikonal(res,met(x,y+1,z),x,y+1,z);
              if (dist<res(x,y+1,z)) { res(x,y+1,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y+1,z); }
            }
            if (z-1>=0 && state(x,y,z-1)!=1) {
              const Tfloat dist = __distance_eikonal(res,met(x,y,z-1),x,y,z-1);
              if (dist<res(x,y,z-1)) { res(x,y,z-1) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z-1); }
            }
            if (z+1<depth() && state(x,y,z+1)!=1) {
              const Tfloat dist = __distance_eikonal(res,met(x,y,z+1),x,y,z+1);
              if (dist<res(x,y,z+1)) { res(x,y,z+1) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z+1); }
            }
          }
        }
      }
      return result;
    }


    Tfloat __distance_eikonal(const CImg<Tfloat>& res, const Tfloat P,
                              const int x=0, const int y=0, const int z=0) const {
      const T M = cimg::type<T>::max();
      T T1 = cimg::min(x-1>=0?res(x-1,y,z):M,x+1<width()?res(x+1,y,z):M);
      Tfloat root = 0;
      if (_depth>1) {
        T
          T2 = cimg::min(y-1>=0?res(x,y-1,z):M,y+1<height()?res(x,y+1,z):M),
          T3 = cimg::min(z-1>=0?res(x,y,z-1):M,z+1<depth()?res(x,y,z+1):M);
        if (T1>T2) cimg::swap(T1,T2);
        if (T2>T3) cimg::swap(T2,T3);
        if (T1>T2) cimg::swap(T1,T2);
        if (P<=0) return (Tfloat)T1;
        if (T3<M && ___distance_eikonal(3,-2*(T1+T2+T3),T1*T1+T2*T2+T3*T3-P*P,root)) return cimg::max((Tfloat)T3,root);
        if (T2<M && ___distance_eikonal(2,-2*(T1+T2),T1*T1+T2*T2-P*P,root)) return cimg::max((Tfloat)T2,root);
        return P + T1;
      } else if (_height>1) {
        T T2 = cimg::min(y-1>=0?res(x,y-1,z):M,y+1<height()?res(x,y+1,z):M);
        if (T1>T2) cimg::swap(T1,T2);
        if (P<=0) return (Tfloat)T1;
        if (T2<M && ___distance_eikonal(2,-2*(T1+T2),T1*T1+T2*T2-P*P,root)) return cimg::max((Tfloat)T2,root);
        return P + T1;
      } else {
        if (P<=0) return (Tfloat)T1;
        return P + T1;
      }
      return 0;
    }


    static bool ___distance_eikonal(const Tfloat a, const Tfloat b, const Tfloat c, Tfloat &root) {
      const Tfloat delta = b*b - 4*a*c;
      if (delta<0) return false;
      root = 0.5f*(-b + std::sqrt(delta))/a;
      return true;
    }


    template<typename t>
    void _eik_priority_queue_insert(CImg<charT>& state, unsigned int& siz, const t value,
                                    const unsigned int x, const unsigned int y, const unsigned int z) {
      if (state(x,y,z)>0) return;
      state(x,y,z) = 0;
      if (++siz>=_width) { if (!is_empty()) resize(_width*2,4,1,1,0); else assign(64,4); }
      (*this)(siz-1,0) = (T)value; (*this)(siz-1,1) = (T)x; (*this)(siz-1,2) = (T)y; (*this)(siz-1,3) = (T)z;
      for (unsigned int pos = siz - 1, par = 0; pos && value>(*this)(par=(pos+1)/2-1,0); pos = par) {
        cimg::swap((*this)(pos,0),(*this)(par,0)); cimg::swap((*this)(pos,1),(*this)(par,1));
        cimg::swap((*this)(pos,2),(*this)(par,2)); cimg::swap((*this)(pos,3),(*this)(par,3));
      }
    }







    CImg<T>& distance_eikonal(const unsigned int nb_iterations, const float band_size=0, const float time_step=0.5f) {
      if (is_empty()) return *this;
      CImg<Tfloat> velocity(*this);
      for (unsigned int iteration = 0; iteration<nb_iterations; ++iteration) {
        Tfloat *ptrd = velocity._data, veloc_max = 0;
        if (_depth>1) {
          Tfloat I[27]; Tfloat& Ippp = I[0]; Tfloat& Icpp = I[1]; Tfloat& Inpp = I[2]; Tfloat& Ipcp = I[3]; Tfloat& Iccp = I[4]; Tfloat& Incp = I[5]; Tfloat& Ipnp = I[6]; Tfloat& Icnp = I[7]; Tfloat& Innp = I[8]; Tfloat& Ippc = I[9]; Tfloat& Icpc = I[10]; Tfloat& Inpc = I[11]; Tfloat& Ipcc = I[12]; Tfloat& Iccc = I[13]; Tfloat& Incc = I[14]; Tfloat& Ipnc = I[15]; Tfloat& Icnc = I[16]; Tfloat& Innc = I[17]; Tfloat& Ippn = I[18]; Tfloat& Icpn = I[19]; Tfloat& Inpn = I[20]; Tfloat& Ipcn = I[21]; Tfloat& Iccn = I[22]; Tfloat& Incn = I[23]; Tfloat& Ipnn = I[24]; Tfloat& Icnn = I[25]; Tfloat& Innn = I[26]; Ippp = Icpp = Inpp = Ipcp = Iccp = Incp = Ipnp = Icnp = Innp = Ippc = Icpc = Inpc = Ipcc = Iccc = Incc = Ipnc = Icnc = Innc = Ippn = Icpn = Inpn = Ipcn = Iccn = Incn = Ipnn = Icnn = Innn = 0;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0, _p1z = 0, _n1z = 1>=((*this)._depth)?(int)((*this)._depth)-1:1; _n1z<(int)((*this)._depth) || z==--_n1z; _p1z = z++, ++_n1z) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,_p1z,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,_p1z,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,_p1z,c)), (I[9] = I[10] = (Tfloat)(*this)(0,_p1y,z,c)), (I[12] = I[13] = (Tfloat)(*this)(0,y,z,c)), (I[15] = I[16] = (Tfloat)(*this)(0,_n1y,z,c)), (I[18] = I[19] = (Tfloat)(*this)(0,_p1y,_n1z,c)), (I[21] = I[22] = (Tfloat)(*this)(0,y,_n1z,c)), (I[24] = I[25] = (Tfloat)(*this)(0,_n1y,_n1z,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,_p1z,c)), (I[5] = (Tfloat)(*this)(_n1x,y,_p1z,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,_p1z,c)), (I[11] = (Tfloat)(*this)(_n1x,_p1y,z,c)), (I[14] = (Tfloat)(*this)(_n1x,y,z,c)), (I[17] = (Tfloat)(*this)(_n1x,_n1y,z,c)), (I[20] = (Tfloat)(*this)(_n1x,_p1y,_n1z,c)), (I[23] = (Tfloat)(*this)(_n1x,y,_n1z,c)), (I[26] = (Tfloat)(*this)(_n1x,_n1y,_n1z,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], I[9] = I[10], I[10] = I[11], I[12] = I[13], I[13] = I[14], I[15] = I[16], I[16] = I[17], I[18] = I[19], I[19] = I[20], I[21] = I[22], I[22] = I[23], I[24] = I[25], I[25] = I[26], _p1x = x++, ++_n1x) if (band_size<=0 || cimg::abs(Iccc)<band_size) {
            const Tfloat
              gx = (Incc - Ipcc)/2,
              gy = (Icnc - Icpc)/2,
              gz = (Iccn - Iccp)/2,
              sgn = -cimg::sign(Iccc),
              ix = gx*sgn>0?(Incc - Iccc):(Iccc - Ipcc),
              iy = gy*sgn>0?(Icnc - Iccc):(Iccc - Icpc),
              iz = gz*sgn>0?(Iccn - Iccc):(Iccc - Iccp),
              ng = (Tfloat)(1e-5f + std::sqrt(gx*gx + gy*gy + gz*gz)),
              ngx = gx/ng,
              ngy = gy/ng,
              ngz = gz/ng,
              veloc = sgn*(ngx*ix + ngy*iy + ngz*iz - 1);
            *(ptrd++) = veloc;
            if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
          } else *(ptrd++) = 0;
        } else {
          Tfloat I[9]; Tfloat& Ipp = I[0]; Tfloat& Icp = I[1]; Tfloat& Inp = I[2]; Tfloat& Ipc = I[3]; Tfloat& Icc = I[4]; Tfloat& Inc = I[5]; Tfloat& Ipn = I[6]; Tfloat& Icn = I[7]; Tfloat& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0, _p1y = 0, _n1y = 1>=((*this)._height)?(int)((*this)._height)-1:1; _n1y<(int)((*this)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (Tfloat)(*this)(_p1x,_p1y,0,c)), (I[3] = I[4] = (Tfloat)(*this)(0,y,0,c)), (I[6] = I[7] = (Tfloat)(*this)(0,_n1y,0,c)), 1>=(*this)._width?(*this).width()-1:1); (_n1x<(*this).width() && ( (I[2] = (Tfloat)(*this)(_n1x,_p1y,0,c)), (I[5] = (Tfloat)(*this)(_n1x,y,0,c)), (I[8] = (Tfloat)(*this)(_n1x,_n1y,0,c)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x) if (band_size<=0 || cimg::abs(Icc)<band_size) {
            const Tfloat
              gx = (Inc - Ipc)/2,
              gy = (Icn - Icp)/2,
              sgn = -cimg::sign(Icc),
              ix = gx*sgn>0?(Inc - Icc):(Icc - Ipc),
              iy = gy*sgn>0?(Icn - Icc):(Icc - Icp),
              ng = (Tfloat)(1e-5f + std::sqrt(gx*gx + gy*gy)),
              ngx = gx/ng,
              ngy = gy/ng,
              veloc = sgn*(ngx*ix + ngy*iy - 1);
            *(ptrd++) = veloc;
            if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
          } else *(ptrd++) = 0;
        }
        if (veloc_max>0) *this+=(velocity*=time_step/veloc_max);
      }
      return *this;
    }


    CImg<Tfloat> get_distance_eikonal(const unsigned int nb_iterations, const float band_size=0,
                                      const float time_step=0.5f) const {
      return CImg<Tfloat>(*this,false).distance_eikonal(nb_iterations,band_size,time_step);
    }







    CImg<T>& haar(const char axis, const bool invert=false, const unsigned int nb_scales=1) {
      return get_haar(axis,invert,nb_scales).move_to(*this);
    }


    CImg<Tfloat> get_haar(const char axis, const bool invert=false, const unsigned int nb_scales=1) const {
      if (is_empty() || !nb_scales) return +*this;
      CImg<Tfloat> res;
      const Tfloat sqrt2 = std::sqrt(2);
      if (nb_scales==1) {
        switch (cimg::uncase(axis)) {
        case 'x' : {
          const unsigned int w = _width/2;
          if (w) {
            if ((w%2) && w!=1)
              throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                          "haar(): Sub-image width %u is not even.",
                                          _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                          w);

            res.assign(_width,_height,_depth,_spectrum);
            if (invert) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
              for (unsigned int x = 0, xw = w, x2 = 0; x<w; ++x, ++xw) {
                const Tfloat val0 = (Tfloat)(*this)(x,y,z,c), val1 = (Tfloat)(*this)(xw,y,z,c);
                res(x2++,y,z,c) = (val0 - val1)/sqrt2;
                res(x2++,y,z,c) = (val0 + val1)/sqrt2;
              }
            } else for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
              for (unsigned int x = 0, xw = w, x2 = 0; x<w; ++x, ++xw) {
                const Tfloat val0 = (Tfloat)(*this)(x2++,y,z,c), val1 = (Tfloat)(*this)(x2++,y,z,c);
                res(x,y,z,c) = (val0 + val1)/sqrt2;
                res(xw,y,z,c) = (val1 - val0)/sqrt2;
              }
            }
          } else return *this;
        } break;
        case 'y' : {
          const unsigned int h = _height/2;
          if (h) {
            if ((h%2) && h!=1)
              throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                          "haar(): Sub-image height %u is not even.",
                                          _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                          h);

            res.assign(_width,_height,_depth,_spectrum);
            if (invert) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x) {
              for (unsigned int y = 0, yh = h, y2 = 0; y<h; ++y, ++yh) {
                const Tfloat val0 = (Tfloat)(*this)(x,y,z,c), val1 = (Tfloat)(*this)(x,yh,z,c);
                res(x,y2++,z,c) = (val0 - val1)/sqrt2;
                res(x,y2++,z,c) = (val0 + val1)/sqrt2;
              }
            } else for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int x = 0; x<(int)((*this)._width); ++x) {
              for (unsigned int y = 0, yh = h, y2 = 0; y<h; ++y, ++yh) {
                const Tfloat val0 = (Tfloat)(*this)(x,y2++,z,c), val1 = (Tfloat)(*this)(x,y2++,z,c);
                res(x,y,z,c) = (val0 + val1)/sqrt2;
                res(x,yh,z,c) = (val1 - val0)/sqrt2;
              }
            }
          } else return *this;
        } break;
        case 'z' : {
          const unsigned int d = _depth/2;
          if (d) {
            if ((d%2) && d!=1)
              throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                          "haar(): Sub-image depth %u is not even.",
                                          _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                          d);

            res.assign(_width,_height,_depth,_spectrum);
            if (invert) for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
              for (unsigned int z = 0, zd = d, z2 = 0; z<d; ++z, ++zd) {
                const Tfloat val0 = (Tfloat)(*this)(x,y,z,c), val1 = (Tfloat)(*this)(x,y,zd,c);
                res(x,y,z2++,c) = (val0 - val1)/sqrt2;
                res(x,y,z2++,c) = (val0 + val1)/sqrt2;
              }
            } else for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
              for (unsigned int z = 0, zd = d, z2 = 0; z<d; ++z, ++zd) {
                const Tfloat val0 = (Tfloat)(*this)(x,y,z2++,c), val1 = (Tfloat)(*this)(x,y,z2++,c);
                res(x,y,z,c) = (val0 + val1)/sqrt2;
                res(x,y,zd,c) = (val1 - val0)/sqrt2;
              }
            }
          } else return *this;
        } break;
        default :
          throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "haar(): Invalid specified axis '%c' "
                                      "(should be { x | y | z }).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      axis);
        }
      } else {
        if (invert) {
          res.assign(*this);
          switch (cimg::uncase(axis)) {
          case 'x' : {
            unsigned int w = _width;
            for (unsigned int s = 1; w && s<nb_scales; ++s) w/=2;
            for (w = w?w:1; w<=_width; w*=2) res.draw_image(res.get_crop(0,w-1).get_haar('x',true,1));
          } break;
          case 'y' : {
            unsigned int h = _width;
            for (unsigned int s = 1; h && s<nb_scales; ++s) h/=2;
            for (h = h?h:1; h<=_height; h*=2) res.draw_image(res.get_crop(0,0,_width-1,h-1).get_haar('y',true,1));
          } break;
          case 'z' : {
            unsigned int d = _depth;
            for (unsigned int s = 1; d && s<nb_scales; ++s) d/=2;
            for (d = d?d:1; d<=_depth; d*=2)
              res.draw_image(res.get_crop(0,0,0,_width-1,_height-1,d-1).get_haar('z',true,1));
          } break;
          default :
            throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "haar(): Invalid specified axis '%c' "
                                        "(should be { x | y | z }).",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        axis);
          }
        } else {
          res = get_haar(axis,false,1);
          switch (cimg::uncase(axis)) {
          case 'x' : {
            for (unsigned int s = 1, w = _width/2; w && s<nb_scales; ++s, w/=2)
              res.draw_image(res.get_crop(0,w-1).get_haar('x',false,1));
          } break;
          case 'y' : {
            for (unsigned int s = 1, h = _height/2; h && s<nb_scales; ++s, h/=2)
              res.draw_image(res.get_crop(0,0,_width-1,h-1).get_haar('y',false,1));
          } break;
          case 'z' : {
            for (unsigned int s = 1, d = _depth/2; d && s<nb_scales; ++s, d/=2)
              res.draw_image(res.get_crop(0,0,0,_width-1,_height-1,d-1).get_haar('z',false,1));
          } break;
          default :
            throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "haar(): Invalid specified axis '%c' "
                                        "(should be { x | y | z }).",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                        axis);
          }
        }
      }
      return res;
    }






    CImg<T>& haar(const bool invert=false, const unsigned int nb_scales=1) {
      return get_haar(invert,nb_scales).move_to(*this);
    }


    CImg<Tfloat> get_haar(const bool invert=false, const unsigned int nb_scales=1) const {
      CImg<Tfloat> res;
      if (nb_scales==1) {
        if (_width>1) get_haar('x',invert,1).move_to(res);
        if (_height>1) { if (res) res.haar('y',invert,1); else get_haar('y',invert,1).move_to(res); }
        if (_depth>1) { if (res) res.haar('z',invert,1); else get_haar('z',invert,1).move_to(res); }
        if (res) return res;
      } else {
        if (invert) {
          res.assign(*this);
          if (_width>1) {
            if (_height>1) {
              if (_depth>1) {
                unsigned int w = _width, h = _height, d = _depth;
                for (unsigned int s = 1; w && h && d && s<nb_scales; ++s) { w/=2; h/=2; d/=2; }
                for (w = w?w:1, h = h?h:1, d = d?d:1; w<=_width && h<=_height && d<=_depth; w*=2, h*=2, d*=2)
                  res.draw_image(res.get_crop(0,0,0,w-1,h-1,d-1).get_haar(true,1));
              } else {
                unsigned int w = _width, h = _height;
                for (unsigned int s = 1; w && h && s<nb_scales; ++s) { w/=2; h/=2; }
                for (w = w?w:1, h = h?h:1; w<=_width && h<=_height; w*=2, h*=2)
                  res.draw_image(res.get_crop(0,0,0,w-1,h-1,0).get_haar(true,1));
              }
            } else {
              if (_depth>1) {
                unsigned int w = _width, d = _depth;
                for (unsigned int s = 1; w && d && s<nb_scales; ++s) { w/=2; d/=2; }
                for (w = w?w:1, d = d?d:1; w<=_width && d<=_depth; w*=2, d*=2)
                  res.draw_image(res.get_crop(0,0,0,w-1,0,d-1).get_haar(true,1));
              } else {
                unsigned int w = _width;
                for (unsigned int s = 1; w && s<nb_scales; ++s) w/=2;
                for (w = w?w:1; w<=_width; w*=2)
                  res.draw_image(res.get_crop(0,0,0,w-1,0,0).get_haar(true,1));
              }
            }
          } else {
            if (_height>1) {
              if (_depth>1) {
                unsigned int h = _height, d = _depth;
                for (unsigned int s = 1; h && d && s<nb_scales; ++s) { h/=2; d/=2; }
                for (h = h?h:1, d = d?d:1; h<=_height && d<=_depth; h*=2, d*=2)
                  res.draw_image(res.get_crop(0,0,0,0,h-1,d-1).get_haar(true,1));
              } else {
                unsigned int h = _height;
                for (unsigned int s = 1; h && s<nb_scales; ++s) h/=2;
                for (h = h?h:1; h<=_height; h*=2)
                  res.draw_image(res.get_crop(0,0,0,0,h-1,0).get_haar(true,1));
              }
            } else {
              if (_depth>1) {
                unsigned int d = _depth;
                for (unsigned int s = 1; d && s<nb_scales; ++s) d/=2;
                for (d = d?d:1; d<=_depth; d*=2)
                  res.draw_image(res.get_crop(0,0,0,0,0,d-1).get_haar(true,1));
              } else return *this;
            }
          }
        } else {
          res = get_haar(false,1);
          if (_width>1) {
            if (_height>1) {
              if (_depth>1)
                for (unsigned int s = 1, w = _width/2, h = _height/2, d = _depth/2; w && h && d && s<nb_scales;
                     ++s, w/=2, h/=2, d/=2)
                  res.draw_image(res.get_crop(0,0,0,w-1,h-1,d-1).haar(false,1));
              else for (unsigned int s = 1, w = _width/2, h = _height/2; w && h && s<nb_scales; ++s, w/=2, h/=2)
                     res.draw_image(res.get_crop(0,0,0,w-1,h-1,0).haar(false,1));
            } else {
              if (_depth>1) for (unsigned int s = 1, w = _width/2, d = _depth/2; w && d && s<nb_scales; ++s, w/=2, d/=2)
                              res.draw_image(res.get_crop(0,0,0,w-1,0,d-1).haar(false,1));
              else for (unsigned int s = 1, w = _width/2; w && s<nb_scales; ++s, w/=2)
                     res.draw_image(res.get_crop(0,0,0,w-1,0,0).haar(false,1));
            }
          } else {
            if (_height>1) {
              if (_depth>1)
                for (unsigned int s = 1, h = _height/2, d = _depth/2; h && d && s<nb_scales; ++s, h/=2, d/=2)
                  res.draw_image(res.get_crop(0,0,0,0,h-1,d-1).haar(false,1));
              else for (unsigned int s = 1, h = _height/2; h && s<nb_scales; ++s, h/=2)
                     res.draw_image(res.get_crop(0,0,0,0,h-1,0).haar(false,1));
            } else {
              if (_depth>1) for (unsigned int s = 1, d = _depth/2; d && s<nb_scales; ++s, d/=2)
                              res.draw_image(res.get_crop(0,0,0,0,0,d-1).haar(false,1));
              else return *this;
            }
          }
        }
        return res;
      }
      return *this;
    }






    CImgList<Tfloat> get_FFT(const char axis, const bool is_invert=false) const {
      CImgList<Tfloat> res(*this,CImg<Tfloat>());
      CImg<Tfloat>::FFT(res[0],res[1],axis,is_invert);
      return res;
    }





    CImgList<Tfloat> get_FFT(const bool is_invert=false) const {
      CImgList<Tfloat> res(*this,CImg<Tfloat>());
      CImg<Tfloat>::FFT(res[0],res[1],is_invert);
      return res;
    }
# 28508 "../src/CImg.h"
    static void FFT(CImg<T>& real, CImg<T>& imag, const char axis, const bool is_invert=false) {
      if (!real)
        throw CImgInstanceException("CImg<%s>::FFT(): Specified real part is empty.",
                                    pixel_type());

      if (!imag) imag.assign(real._width,real._height,real._depth,real._spectrum,0);
      if (!real.is_sameXYZC(imag))
        throw CImgInstanceException("CImg<%s>::FFT(): Specified real part (%u,%u,%u,%u,%p) and "
                                    "imaginary part (%u,%u,%u,%u,%p) have different dimensions.",
                                    pixel_type(),
                                    real._width,real._height,real._depth,real._spectrum,real._data,
                                    imag._width,imag._height,imag._depth,imag._spectrum,imag._data);
# 28613 "../src/CImg.h"
      switch (cimg::uncase(axis)) {
      case 'x' : {
        const unsigned int N = real._width, N2 = (N>>1);
        if (((N-1)&N) && N!=1)
          throw CImgInstanceException("CImgList<%s>::FFT(): Specified real and imaginary parts (%u,%u,%u,%u) "
                                      "have non 2^N dimension along the X-axis.",
                                      pixel_type(),
                                      real._width,real._height,real._depth,real._spectrum);

        for (unsigned int i = 0, j = 0; i<N2; ++i) {
          if (j>i) for (int c = 0; c<(int)((real)._spectrum); ++c) for (int z = 0; z<(int)((real)._depth); ++z) for (int y = 0; y<(int)((real)._height); ++y) {
            cimg::swap(real(i,y,z,c),real(j,y,z,c)); cimg::swap(imag(i,y,z,c),imag(j,y,z,c));
            if (j<N2) {
              const unsigned int ri = N-1-i, rj = N-1-j;
              cimg::swap(real(ri,y,z,c),real(rj,y,z,c)); cimg::swap(imag(ri,y,z,c),imag(rj,y,z,c));
            }
          }
          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
        }
        for (unsigned int delta = 2; delta<=N; delta<<=1) {
          const unsigned int delta2 = (delta>>1);
          for (unsigned int i = 0; i<N; i+=delta) {
            float wr = 1, wi = 0;
            const float angle = (float)((is_invert?+1:-1)*2*cimg::PI/delta),
                        ca = (float)std::cos(angle),
                        sa = (float)std::sin(angle);
            for (unsigned int k = 0; k<delta2; ++k) {
              const unsigned int j = i + k, nj = j + delta2;
              for (int c = 0; c<(int)((real)._spectrum); ++c) for (int z = 0; z<(int)((real)._depth); ++z) for (int y = 0; y<(int)((real)._height); ++y) {
                T &ir = real(j,y,z,c), &ii = imag(j,y,z,c), &nir = real(nj,y,z,c), &nii = imag(nj,y,z,c);
                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
                nir = (T)(ir - tmpr);
                nii = (T)(ii - tmpi);
                ir+=(T)tmpr;
                ii+=(T)tmpi;
              }
              const float nwr = wr*ca-wi*sa;
              wi = wi*ca + wr*sa;
              wr = nwr;
            }
          }
        }
        if (is_invert) { real/=N; imag/=N; }
      } break;
      case 'y' : {
        const unsigned int N = real._height, N2 = (N>>1);
        if (((N-1)&N) && N!=1)
          throw CImgInstanceException("CImgList<%s>::FFT(): Specified real and imaginary parts (%u,%u,%u,%u) "
                                      "have non 2^N dimension along the Y-axis.",
                                      pixel_type(),
                                      real._width,real._height,real._depth,real._spectrum);

        for (unsigned int i = 0, j = 0; i<N2; ++i) {
          if (j>i) for (int c = 0; c<(int)((real)._spectrum); ++c) for (int z = 0; z<(int)((real)._depth); ++z) for (int x = 0; x<(int)((real)._width); ++x) {
            cimg::swap(real(x,i,z,c),real(x,j,z,c)); cimg::swap(imag(x,i,z,c),imag(x,j,z,c));
            if (j<N2) {
              const unsigned int ri = N - 1 - i, rj = N - 1 - j;
              cimg::swap(real(x,ri,z,c),real(x,rj,z,c)); cimg::swap(imag(x,ri,z,c),imag(x,rj,z,c));
            }
          }
          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
        }
        for (unsigned int delta = 2; delta<=N; delta<<=1) {
          const unsigned int delta2 = (delta>>1);
          for (unsigned int i = 0; i<N; i+=delta) {
            float wr = 1, wi = 0;
            const float angle = (float)((is_invert?+1:-1)*2*cimg::PI/delta),
                        ca = (float)std::cos(angle), sa = (float)std::sin(angle);
            for (unsigned int k = 0; k<delta2; ++k) {
              const unsigned int j = i + k, nj = j + delta2;
              for (int c = 0; c<(int)((real)._spectrum); ++c) for (int z = 0; z<(int)((real)._depth); ++z) for (int x = 0; x<(int)((real)._width); ++x) {
                T &ir = real(x,j,z,c), &ii = imag(x,j,z,c), &nir = real(x,nj,z,c), &nii = imag(x,nj,z,c);
                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
                nir = (T)(ir - tmpr);
                nii = (T)(ii - tmpi);
                ir+=(T)tmpr;
                ii+=(T)tmpi;
              }
              const float nwr = wr*ca-wi*sa;
              wi = wi*ca + wr*sa;
              wr = nwr;
            }
          }
        }
        if (is_invert) { real/=N; imag/=N; }
      } break;
      case 'z' : {
        const unsigned int N = real._depth, N2 = (N>>1);
        if (((N-1)&N) && N!=1)
          throw CImgInstanceException("CImgList<%s>::FFT(): Specified real and imaginary parts (%u,%u,%u,%u) "
                                      "have non 2^N dimension along the Z-axis.",
                                      pixel_type(),
                                      real._width,real._height,real._depth,real._spectrum);

        for (unsigned int i = 0, j = 0; i<N2; ++i) {
          if (j>i) for (int c = 0; c<(int)((real)._spectrum); ++c) for (int y = 0; y<(int)((real)._height); ++y) for (int x = 0; x<(int)((real)._width); ++x) {
            cimg::swap(real(x,y,i,c),real(x,y,j,c)); cimg::swap(imag(x,y,i,c),imag(x,y,j,c));
            if (j<N2) {
              const unsigned int ri = N - 1 - i, rj = N - 1 - j;
              cimg::swap(real(x,y,ri,c),real(x,y,rj,c)); cimg::swap(imag(x,y,ri,c),imag(x,y,rj,c));
            }
          }
          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
        }
        for (unsigned int delta = 2; delta<=N; delta<<=1) {
          const unsigned int delta2 = (delta>>1);
          for (unsigned int i = 0; i<N; i+=delta) {
            float wr = 1, wi = 0;
            const float angle = (float)((is_invert?+1:-1)*2*cimg::PI/delta),
                        ca = (float)std::cos(angle), sa = (float)std::sin(angle);
            for (unsigned int k = 0; k<delta2; ++k) {
              const unsigned int j = i + k, nj = j + delta2;
              for (int c = 0; c<(int)((real)._spectrum); ++c) for (int y = 0; y<(int)((real)._height); ++y) for (int x = 0; x<(int)((real)._width); ++x) {
                T &ir = real(x,y,j,c), &ii = imag(x,y,j,c), &nir = real(x,y,nj,c), &nii = imag(x,y,nj,c);
                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
                nir = (T)(ir - tmpr);
                nii = (T)(ii - tmpi);
                ir+=(T)tmpr;
                ii+=(T)tmpi;
              }
              const float nwr = wr*ca-wi*sa;
              wi = wi*ca + wr*sa;
              wr = nwr;
            }
          }
        }
        if (is_invert) { real/=N; imag/=N; }
      } break;
      default :
        throw CImgArgumentException("CImgList<%s>::FFT(): Invalid specified axis '%c' for real and imaginary parts "
                                    "(%u,%u,%u,%u) "
                                    "(should be { x | y | z }).",
                                    pixel_type(),axis,
                                    real._width,real._height,real._depth,real._spectrum);
      }

    }
# 28759 "../src/CImg.h"
    static void FFT(CImg<T>& real, CImg<T>& imag, const bool is_invert=false, const unsigned int nb_threads=0) {
      if (!real)
        throw CImgInstanceException("CImgList<%s>::FFT(): Empty specified real part.",
                                    pixel_type());

      if (!imag) imag.assign(real._width,real._height,real._depth,real._spectrum,0);
      if (!real.is_sameXYZC(imag))
        throw CImgInstanceException("CImgList<%s>::FFT(): Specified real part (%u,%u,%u,%u,%p) and "
                                    "imaginary part (%u,%u,%u,%u,%p) have different dimensions.",
                                    pixel_type(),
                                    real._width,real._height,real._depth,real._spectrum,real._data,
                                    imag._width,imag._height,imag._depth,imag._spectrum,imag._data);
# 28824 "../src/CImg.h"
      cimg::unused(nb_threads);
      if (real._depth>1) FFT(real,imag,'z',is_invert);
      if (real._height>1) FFT(real,imag,'y',is_invert);
      if (real._width>1) FFT(real,imag,'x',is_invert);

    }
# 28844 "../src/CImg.h"
    CImg<T>& shift_object3d(const float tx, const float ty=0, const float tz=0) {
      if (_height!=3 || _depth>1 || _spectrum>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "shift_object3d(): Instance is not a set of 3d vertices.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      get_shared_row(0)+=tx; get_shared_row(1)+=ty; get_shared_row(2)+=tz;
      return *this;
    }


    CImg<Tfloat> get_shift_object3d(const float tx, const float ty=0, const float tz=0) const {
      return CImg<Tfloat>(*this,false).shift_object3d(tx,ty,tz);
    }





    CImg<T>& shift_object3d() {
      if (_height!=3 || _depth>1 || _spectrum>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "shift_object3d(): Instance is not a set of 3d vertices.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      CImg<T> xcoords = get_shared_row(0), ycoords = get_shared_row(1), zcoords = get_shared_row(2);
      float
        xm, xM = (float)xcoords.max_min(xm),
        ym, yM = (float)ycoords.max_min(ym),
        zm, zM = (float)zcoords.max_min(zm);
      xcoords-=(xm + xM)/2; ycoords-=(ym + yM)/2; zcoords-=(zm + zM)/2;
      return *this;
    }


    CImg<Tfloat> get_shift_object3d() const {
      return CImg<Tfloat>(*this,false).shift_object3d();
    }







    CImg<T>& resize_object3d(const float sx, const float sy=-100, const float sz=-100) {
      if (_height!=3 || _depth>1 || _spectrum>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "resize_object3d(): Instance is not a set of 3d vertices.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      CImg<T> xcoords = get_shared_row(0), ycoords = get_shared_row(1), zcoords = get_shared_row(2);
      float
        xm, xM = (float)xcoords.max_min(xm),
        ym, yM = (float)ycoords.max_min(ym),
        zm, zM = (float)zcoords.max_min(zm);
      if (xm<xM) { if (sx>0) xcoords*=sx/(xM-xm); else xcoords*=-sx/100; }
      if (ym<yM) { if (sy>0) ycoords*=sy/(yM-ym); else ycoords*=-sy/100; }
      if (zm<zM) { if (sz>0) zcoords*=sz/(zM-zm); else zcoords*=-sz/100; }
      return *this;
    }


    CImg<Tfloat> get_resize_object3d(const float sx, const float sy=-100, const float sz=-100) const {
      return CImg<Tfloat>(*this,false).resize_object3d(sx,sy,sz);
    }


    CImg<T> resize_object3d() {
      if (_height!=3 || _depth>1 || _spectrum>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "resize_object3d(): Instance is not a set of 3d vertices.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      CImg<T> xcoords = get_shared_row(0), ycoords = get_shared_row(1), zcoords = get_shared_row(2);
      float
        xm, xM = (float)xcoords.max_min(xm),
        ym, yM = (float)ycoords.max_min(ym),
        zm, zM = (float)zcoords.max_min(zm);
      const float dx = xM - xm, dy = yM - ym, dz = zM - zm, dmax = cimg::max(dx,dy,dz);
      if (dmax>0) { xcoords/=dmax; ycoords/=dmax; zcoords/=dmax; }
      return *this;
    }


    CImg<Tfloat> get_resize_object3d() const {
      return CImg<Tfloat>(*this,false).resize_object3d();
    }







    template<typename tf, typename tp, typename tff>
    CImg<T>& append_object3d(CImgList<tf>& primitives, const CImg<tp>& obj_vertices,
                             const CImgList<tff>& obj_primitives) {
      if (!obj_vertices || !obj_primitives) return *this;
      if (obj_vertices._height!=3 || obj_vertices._depth>1 || obj_vertices._spectrum>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "append_object3d(): Specified vertice image (%u,%u,%u,%u,%p) is not a "
                                    "set of 3d vertices.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    obj_vertices._width,obj_vertices._height,
                                    obj_vertices._depth,obj_vertices._spectrum,obj_vertices._data);

      if (is_empty()) { primitives.assign(obj_primitives); return assign(obj_vertices); }
      if (_height!=3 || _depth>1 || _spectrum>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "append_object3d(): Instance is not a set of 3d vertices.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const unsigned int P = _width;
      append(obj_vertices,'x');
      const unsigned int N = primitives._width;
      primitives.insert(obj_primitives);
      for (unsigned int i = N; i<primitives._width; ++i) {
        CImg<tf> &p = primitives[i];
        switch (p.size()) {
        case 1 : p[0]+=P; break;
        case 5 : p[0]+=P; p[1]+=P; break;
        case 2 : case 6 : p[0]+=P; p[1]+=P; break;
        case 3 : case 9 : p[0]+=P; p[1]+=P; p[2]+=P; break;
        case 4 : case 12 : p[0]+=P; p[1]+=P; p[2]+=P; p[3]+=P; break;
        }
      }
      return *this;
    }
# 28981 "../src/CImg.h"
    template<typename tp, typename tc, typename tt, typename tx>
    const CImg<T>& texturize_object3d(CImgList<tp>& primitives, CImgList<tc>& colors,
                                      const CImg<tt>& texture, const CImg<tx>& coords=CImg<tx>::empty()) const {
      if (is_empty()) return *this;
      if (_height!=3)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "texturize_object3d(): image instance is not a set of 3d points.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (coords && (coords._width!=_width || coords._height!=2))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "texturize_object3d(): Invalid specified texture coordinates (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    coords._width,coords._height,coords._depth,coords._spectrum,coords._data);
      CImg<unsigned int> _coords;
      if (!coords) {
        _coords.assign(_width,2);
        float
          xmin, xmax = (float)get_shared_row(0).max_min(xmin),
          ymin, ymax = (float)get_shared_row(1).max_min(ymin),
          dx = xmax>xmin?xmax-xmin:1,
          dy = ymax>ymin?ymax-ymin:1;
        for (int p = 0; p<(int)((*this)._width); ++p) {
          _coords(p,0) = (unsigned int)(((*this)(p,0)-xmin)*(texture._width-1)/dx);
          _coords(p,1) = (unsigned int)(((*this)(p,1)-ymin)*(texture._height-1)/dy);
        }
      } else _coords = coords;

      int texture_ind = -1;
      for (int l = 0; l<(int)(primitives)._width; ++l) {
        CImg<tp> &p = primitives[l];
        const unsigned int siz = p.size();
        switch (siz) {
        case 1 : {
          const unsigned int
            i0 = (unsigned int)p[0],
            x0 = (unsigned int)_coords(i0,0), y0 = (unsigned int)_coords(i0,1);
          texture.get_vector_at(x0,y0).move_to(colors[l]);
        } break;
        case 2 : case 6 : {
          const unsigned int
            i0 = (unsigned int)p[0], i1 = (unsigned int)p[1],
            x0 = (unsigned int)_coords(i0,0), y0 = (unsigned int)_coords(i0,1),
            x1 = (unsigned int)_coords(i1,0), y1 = (unsigned int)_coords(i1,1);
          if (texture_ind<0) colors[texture_ind=l] = texture; else colors[l].assign(colors[texture_ind],true);
          CImg<tp>::vector(i0,i1,x0,y0,x1,y1).move_to(p);
        } break;
        case 3 : case 9 : {
          const unsigned int
            i0 = (unsigned int)p[0], i1 = (unsigned int)p[1], i2 = (unsigned int)p[2],
            x0 = (unsigned int)_coords(i0,0), y0 = (unsigned int)_coords(i0,1),
            x1 = (unsigned int)_coords(i1,0), y1 = (unsigned int)_coords(i1,1),
            x2 = (unsigned int)_coords(i2,0), y2 = (unsigned int)_coords(i2,1);
          if (texture_ind<0) colors[texture_ind=l] = texture; else colors[l].assign(colors[texture_ind],true);
          CImg<tp>::vector(i0,i1,i2,x0,y0,x1,y1,x2,y2).move_to(p);
        } break;
        case 4 : case 12 : {
          const unsigned int
            i0 = (unsigned int)p[0], i1 = (unsigned int)p[1], i2 = (unsigned int)p[2], i3 = (unsigned int)p[3],
            x0 = (unsigned int)_coords(i0,0), y0 = (unsigned int)_coords(i0,1),
            x1 = (unsigned int)_coords(i1,0), y1 = (unsigned int)_coords(i1,1),
            x2 = (unsigned int)_coords(i2,0), y2 = (unsigned int)_coords(i2,1),
            x3 = (unsigned int)_coords(i3,0), y3 = (unsigned int)_coords(i3,1);
          if (texture_ind<0) colors[texture_ind=l] = texture; else colors[l].assign(colors[texture_ind],true);
          CImg<tp>::vector(i0,i1,i2,i3,x0,y0,x1,y1,x2,y2,x3,y3).move_to(p);
        } break;
        }
      }
      return *this;
    }
# 29068 "../src/CImg.h"
    template<typename tf, typename tc, typename te>
    CImg<floatT> get_elevation3d(CImgList<tf>& primitives, CImgList<tc>& colors, const CImg<te>& elevation) const {
      if (!is_sameXY(elevation) || elevation._depth>1 || elevation._spectrum>1)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_elevation3d(): Instance and specified elevation (%u,%u,%u,%u,%p) "
                                    "have incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    elevation._width,elevation._height,elevation._depth,
                                    elevation._spectrum,elevation._data);
      if (is_empty()) return *this;
      float m, M = (float)max_min(m);
      if (M==m) ++M;
      colors.assign();
      const unsigned int size_x1 = _width - 1, size_y1 = _height - 1;
      for (unsigned int y = 0; y<size_y1; ++y)
        for (unsigned int x = 0; x<size_x1; ++x) {
          const unsigned char
            r = (unsigned char)(((*this)(x,y,0) - m)*255/(M-m)),
            g = _spectrum>1?(unsigned char)(((*this)(x,y,1) - m)*255/(M-m)):r,
            b = _spectrum>2?(unsigned char)(((*this)(x,y,2) - m)*255/(M-m)):(_spectrum>1?0:r);
          CImg<tc>::vector((tc)r,(tc)g,(tc)b).move_to(colors);
        }
      const typename CImg<te>::_functor2d_int func(elevation);
      return elevation3d(primitives,func,0,0,_width-1.0f,_height-1.0f,_width,_height);
    }
# 29103 "../src/CImg.h"
    template<typename tf, typename tc>
    CImg<floatT> get_projections3d(CImgList<tf>& primitives, CImgList<tc>& colors,
                                   const unsigned int x0, const unsigned int y0, const unsigned int z0,
                                   const bool normalize_colors=false) const {
      float m = 0, M = 0, delta = 1;
      if (normalize_colors) { m = (float)min_max(M); delta = 255/(m==M?1:M-m); }
      const unsigned int
        _x0 = (x0>=_width)?_width - 1:x0,
        _y0 = (y0>=_height)?_height - 1:y0,
        _z0 = (z0>=_depth)?_depth - 1:z0;
      CImg<tc> img_xy, img_xz, img_yz;
      if (normalize_colors) {
        ((get_crop(0,0,_z0,0,_width-1,_height-1,_z0,_spectrum-1)-=m)*=delta).move_to(img_xy);
        ((get_crop(0,_y0,0,0,_width-1,_y0,_depth-1,_spectrum-1)-=m)*=delta).resize(_width,_depth,1,-100,-1).
          move_to(img_xz);
        ((get_crop(_x0,0,0,0,_x0,_height-1,_depth-1,_spectrum-1)-=m)*=delta).resize(_height,_depth,1,-100,-1).
          move_to(img_yz);
      } else {
        get_crop(0,0,_z0,0,_width-1,_height-1,_z0,_spectrum-1).move_to(img_xy);
        get_crop(0,_y0,0,0,_width-1,_y0,_depth-1,_spectrum-1).resize(_width,_depth,1,-100,-1).move_to(img_xz);
        get_crop(_x0,0,0,0,_x0,_height-1,_depth-1,_spectrum-1).resize(_height,_depth,1,-100,-1).move_to(img_yz);
      }
      CImg<floatT> points(12,3,1,1,
                          0,_width-1,_width-1,0, 0,_width-1,_width-1,0, _x0,_x0,_x0,_x0,
                          0,0,_height-1,_height-1, _y0,_y0,_y0,_y0, 0,_height-1,_height-1,0,
                          _z0,_z0,_z0,_z0, 0,0,_depth-1,_depth-1, 0,0,_depth-1,_depth-1);
      primitives.assign();
      CImg<tf>::vector(0,1,2,3,0,0,img_xy._width-1,0,img_xy._width-1,img_xy._height-1,0,img_xy._height-1).
        move_to(primitives);
      CImg<tf>::vector(4,5,6,7,0,0,img_xz._width-1,0,img_xz._width-1,img_xz._height-1,0,img_xz._height-1).
        move_to(primitives);
      CImg<tf>::vector(8,9,10,11,0,0,img_yz._width-1,0,img_yz._width-1,img_yz._height-1,0,img_yz._height-1).
        move_to(primitives);
      colors.assign();
      img_xy.move_to(colors);
      img_xz.move_to(colors);
      img_yz.move_to(colors);
      return points;
    }
# 29160 "../src/CImg.h"
    template<typename tf>
    CImg<floatT> get_isoline3d(CImgList<tf>& primitives, const float isovalue,
                               const int size_x=-100, const int size_y=-100) const {
      if (_spectrum>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_isoline3d(): Instance is not a scalar image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (_depth>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_isoline3d(): Instance is not a 2d image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      primitives.assign();
      if (is_empty()) return *this;
      CImg<floatT> vertices;
      if ((size_x==-100 && size_y==-100) || (size_x==width() && size_y==height())) {
        const _functor2d_int func(*this);
        vertices = isoline3d(primitives,func,isovalue,0,0,width()-1.0f,height()-1.0f,width(),height());
      } else {
        const _functor2d_float func(*this);
        vertices = isoline3d(primitives,func,isovalue,0,0,width()-1.0f,height()-1.0f,size_x,size_y);
      }
      return vertices;
    }
# 29202 "../src/CImg.h"
    template<typename tf>
    CImg<floatT> get_isosurface3d(CImgList<tf>& primitives, const float isovalue,
                                  const int size_x=-100, const int size_y=-100, const int size_z=-100) const {
      if (_spectrum>1)
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "get_isosurface3d(): Instance is not a scalar image.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      primitives.assign();
      if (is_empty()) return *this;
      CImg<floatT> vertices;
      if ((size_x==-100 && size_y==-100 && size_z==-100) || (size_x==width() && size_y==height() && size_z==depth())) {
        const _functor3d_int func(*this);
        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width()-1.0f,height()-1.0f,depth()-1.0f,
                                width(),height(),depth());
      } else {
        const _functor3d_float func(*this);
        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width()-1.0f,height()-1.0f,depth()-1.0f,
                                size_x,size_y,size_z);
      }
      return vertices;
    }
# 29235 "../src/CImg.h"
    template<typename tf, typename tfunc>
    static CImg<floatT> elevation3d(CImgList<tf>& primitives, const tfunc& func,
                                    const float x0, const float y0, const float x1, const float y1,
                                    const int size_x=256, const int size_y=256) {
      const float
        nx0 = x0<x1?x0:x1, ny0 = y0<y1?y0:y1,
        nx1 = x0<x1?x1:x0, ny1 = y0<y1?y1:y0;
      const unsigned int
        _nsize_x = (unsigned int)(size_x>=0?size_x:(nx1-nx0)*-size_x/100),
        nsize_x = _nsize_x?_nsize_x:1, nsize_x1 = nsize_x - 1,
        _nsize_y = (unsigned int)(size_y>=0?size_y:(ny1-ny0)*-size_y/100),
        nsize_y = _nsize_y?_nsize_y:1, nsize_y1 = nsize_y - 1;
      if (nsize_x<2 || nsize_y<2)
        throw CImgArgumentException("CImg<%s>::elevation3d(): Invalid specified size (%d,%d).",
                                    pixel_type(),
                                    nsize_x,nsize_y);

      CImg<floatT> vertices(nsize_x*nsize_y,3);
      floatT *ptr_x = vertices.data(0,0), *ptr_y = vertices.data(0,1), *ptr_z = vertices.data(0,2);
      for (unsigned int y = 0; y<nsize_y; ++y) {
        const float Y = ny0 + y*(ny1-ny0)/nsize_y1;
        for (unsigned int x = 0; x<nsize_x; ++x) {
          const float X = nx0 + x*(nx1-nx0)/nsize_x1;
          *(ptr_x++) = (float)x;
          *(ptr_y++) = (float)y;
          *(ptr_z++) = (float)func(X,Y);
        }
      }
      primitives.assign(nsize_x1*nsize_y1,1,4);
      for (unsigned int p = 0, y = 0; y<nsize_y1; ++y) {
        const unsigned int yw = y*nsize_x;
        for (unsigned int x = 0; x<nsize_x1; ++x) {
          const unsigned int xpyw = x + yw, xpyww = xpyw + nsize_x;
          primitives[p++].fill(xpyw,xpyww,xpyww+1,xpyw+1);
        }
      }
      return vertices;
    }


    template<typename tf>
    static CImg<floatT> elevation3d(CImgList<tf>& primitives, const char *const expression,
                                    const float x0, const float y0, const float x1, const float y1,
                                    const int size_x=256, const int size_y=256) {
      const _functor2d_expr func(expression);
      return elevation3d(primitives,func,x0,y0,x1,y1,size_x,size_y);
    }
# 29296 "../src/CImg.h"
    template<typename tf, typename tfunc>
    static CImg<floatT> isoline3d(CImgList<tf>& primitives, const tfunc& func, const float isovalue,
                                  const float x0, const float y0, const float x1, const float y1,
                                  const int size_x=256, const int size_y=256) {
      static const unsigned int edges[16] = { 0x0, 0x9, 0x3, 0xa, 0x6, 0xf, 0x5, 0xc, 0xc,
                                              0x5, 0xf, 0x6, 0xa, 0x3, 0x9, 0x0 };
      static const int segments[16][4] = { { -1,-1,-1,-1 }, { 0,3,-1,-1 }, { 0,1,-1,-1 }, { 1,3,-1,-1 },
                                           { 1,2,-1,-1 }, { 0,1,2,3 }, { 0,2,-1,-1 }, { 2,3,-1,-1 },
                                           { 2,3,-1,-1 }, { 0,2,-1,-1}, { 0,3,1,2 }, { 1,2,-1,-1 },
                                           { 1,3,-1,-1 }, { 0,1,-1,-1}, { 0,3,-1,-1}, { -1,-1,-1,-1 } };
      const unsigned int
        _nx = (unsigned int)(size_x>=0?size_x:cimg::round((x1-x0)*-size_x/100 + 1)),
        _ny = (unsigned int)(size_y>=0?size_y:cimg::round((y1-y0)*-size_y/100 + 1)),
        nx = _nx?_nx:1,
        ny = _ny?_ny:1,
        nxm1 = nx - 1,
        nym1 = ny - 1;
      primitives.assign();
      if (!nxm1 || !nym1) return CImg<floatT>();
      const float dx = (x1 - x0)/nxm1, dy = (y1 - y0)/nym1;
      CImgList<floatT> vertices;
      CImg<intT> indices1(nx,1,1,2,-1), indices2(nx,1,1,2);
      CImg<floatT> values1(nx), values2(nx);
      float X = x0, Y = y0, nX = X + dx, nY = Y + dy;


      for (int x = 0; x<(int)((values1)._width); ++x) { values1(x) = (float)func(X,Y); X+=dx; }


      for (unsigned int yi = 0, nyi = 1; yi<nym1; ++yi, ++nyi, Y=nY, nY+=dy) {
        X = x0; nX = X + dx;
        indices2.fill(-1);
        for (unsigned int xi = 0, nxi = 1; xi<nxm1; ++xi, ++nxi, X=nX, nX+=dx) {


          const float
            val0 = values1(xi),
            val1 = values1(nxi),
            val2 = values2(nxi) = (float)func(nX,nY),
            val3 = values2(xi) = (float)func(X,nY);
          const unsigned int
            configuration = (val0<isovalue?1:0) | (val1<isovalue?2:0) | (val2<isovalue?4:0) | (val3<isovalue?8:0),
            edge = edges[configuration];


          if (edge) {
            if ((edge&1) && indices1(xi,0)<0) {
              const float Xi = X + (isovalue-val0)*dx/(val1-val0);
              indices1(xi,0) = vertices._width;
              CImg<floatT>::vector(Xi,Y,0).move_to(vertices);
            }
            if ((edge&2) && indices1(nxi,1)<0) {
              const float Yi = Y + (isovalue-val1)*dy/(val2-val1);
              indices1(nxi,1) = vertices._width;
              CImg<floatT>::vector(nX,Yi,0).move_to(vertices);
            }
            if ((edge&4) && indices2(xi,0)<0) {
              const float Xi = X + (isovalue-val3)*dx/(val2-val3);
              indices2(xi,0) = vertices._width;
              CImg<floatT>::vector(Xi,nY,0).move_to(vertices);
            }
            if ((edge&8) && indices1(xi,1)<0) {
              const float Yi = Y + (isovalue-val0)*dy/(val3-val0);
              indices1(xi,1) = vertices._width;
              CImg<floatT>::vector(X,Yi,0).move_to(vertices);
            }


            for (const int *segment = segments[configuration]; *segment!=-1; ) {
              const unsigned int p0 = *(segment++), p1 = *(segment++);
              const tf
                i0 = (tf)(_isoline3d_indice(p0,indices1,indices2,xi,nxi)),
                i1 = (tf)(_isoline3d_indice(p1,indices1,indices2,xi,nxi));
              CImg<tf>::vector(i0,i1).move_to(primitives);
            }
          }
        }
        values1.swap(values2);
        indices1.swap(indices2);
      }
      return vertices>'x';
    }


    template<typename tf>
    static CImg<floatT> isoline3d(CImgList<tf>& primitives, const char *const expression, const float isovalue,
                                  const float x0, const float y0, const float x1, const float y1,
                                  const int size_x=256, const int size_y=256) {
      const _functor2d_expr func(expression);
      return isoline3d(primitives,func,isovalue,x0,y0,x1,y1,size_x,size_y);
    }

    template<typename t>
    static int _isoline3d_indice(const unsigned int edge, const CImg<t>& indices1, const CImg<t>& indices2,
                                 const unsigned int x, const unsigned int nx) {
      switch (edge) {
      case 0 : return (int)indices1(x,0);
      case 1 : return (int)indices1(nx,1);
      case 2 : return (int)indices2(x,0);
      case 3 : return (int)indices1(x,1);
      }
      return 0;
    }
# 29416 "../src/CImg.h"
    template<typename tf, typename tfunc>
    static CImg<floatT> isosurface3d(CImgList<tf>& primitives, const tfunc& func, const float isovalue,
                                     const float x0, const float y0, const float z0,
                                     const float x1, const float y1, const float z1,
                                     const int size_x=32, const int size_y=32, const int size_z=32) {
      static const unsigned int edges[256] = {
        0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
        0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
        0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
        0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
        0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc , 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000
      };

      static const int triangles[256][16] = {
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1 },
        { 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1 },
        { 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1 },
        { 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1 },
        { 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1 },
        { 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1 },
        { 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1 },
        { 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1 },
        { 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1 },
        { 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1 },
        { 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1 },
        { 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1 },
        { 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1 },
        { 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1 },
        { 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1 },
        { 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1 },
        { 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1 },
        { 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1 },
        { 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1 },
        { 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1 },
        { 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1 },
        { 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1 },
        { 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1 },
        { 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1 },
        { 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1 },
        { 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1 },
        { 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1 },
        { 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1 },
        { 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1 },
        { 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1 },
        { 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1 },
        { 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1 },
        { 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1 },
        { 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1 },
        { 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1 },
        { 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1 },
        { 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1 },
        { 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1 },
        { 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1 },
        { 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1 },
        { 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1 },
        { 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1 },
        { 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1 },
        { 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1 },
        { 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1 },
        { 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1 },
        { 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1 },
        { 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1 },
        { 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1 },
        { 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1 },
        { 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1 },
        { 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1 },
        { 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1 },
        { 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1 },
        { 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1 },
        { 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1 },
        { 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1 },
        { 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1 },
        { 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1 },
        { 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1 },
        { 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1 },
        { 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1 },
        { 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1 },
        { 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1 },
        { 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1 },
        { 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1 },
        { 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1 },
        { 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1 },
        { 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1 },
        { 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1 },
        { 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1 },
        { 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1 },
        { 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1 },
        { 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1 },
        { 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1 },
        { 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1 },
        { 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1 },
        { 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1 },
        { 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1 },
        { 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1 },
        { 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1 },
        { 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1 },
        { 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1 },
        { 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1 },
        { 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1 },
        { 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1 },
        { 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1 },
        { 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1 },
        { 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1 },
        { 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1 },
        { 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1 },
        { 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1 },
        { 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1 },
        { 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1 },
        { 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1 },
        { 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1 },
        { 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1 },
        { 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1 },
        { 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1 },
        { 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1 },
        { 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1 },
        { 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1 },
        { 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1 },
        { 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1 },
        { 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1 },
        { 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1 },
        { 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1 },
        { 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1 },
        { 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1 },
        { 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1 },
        { 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1 },
        { 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1 },
        { 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1 },
        { 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1 },
        { 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1 },
        { 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1 },
        { 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1 },
        { 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1 },
        { 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1 },
        { 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1 },
        { 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1 },
        { 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1 },
        { 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1 },
        { 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
      };

      const unsigned int
        _nx = (unsigned int)(size_x>=0?size_x:cimg::round((x1-x0)*-size_x/100 + 1)),
        _ny = (unsigned int)(size_y>=0?size_y:cimg::round((y1-y0)*-size_y/100 + 1)),
        _nz = (unsigned int)(size_z>=0?size_z:cimg::round((z1-z0)*-size_z/100 + 1)),
        nx = _nx?_nx:1,
        ny = _ny?_ny:1,
        nz = _nz?_nz:1,
        nxm1 = nx - 1,
        nym1 = ny - 1,
        nzm1 = nz - 1;
      primitives.assign();
      if (!nxm1 || !nym1 || !nzm1) return CImg<floatT>();
      const float dx = (x1 - x0)/nxm1, dy = (y1 - y0)/nym1, dz = (z1 - z0)/nzm1;
      CImgList<floatT> vertices;
      CImg<intT> indices1(nx,ny,1,3,-1), indices2(indices1);
      CImg<floatT> values1(nx,ny), values2(nx,ny);
      float X = 0, Y = 0, Z = 0, nX = 0, nY = 0, nZ = 0;


      Y = y0;
      for (int y = 0; y<(int)((values1)._height); ++y) {
        X = x0;
        for (int x = 0; x<(int)((values1)._width); ++x) { values1(x,y) = (float)func(X,Y,z0); X+=dx; }
        Y+=dy;
      }


      Z = z0; nZ = Z + dz;
      for (unsigned int zi = 0; zi<nzm1; ++zi, Z = nZ, nZ+=dz) {
        Y = y0; nY = Y + dy;
        indices2.fill(-1);
        for (unsigned int yi = 0, nyi = 1; yi<nym1; ++yi, ++nyi, Y = nY, nY+=dy) {
          X = x0; nX = X + dx;
          for (unsigned int xi = 0, nxi = 1; xi<nxm1; ++xi, ++nxi, X = nX, nX+=dx) {


            const float
              val0 = values1(xi,yi),
              val1 = values1(nxi,yi),
              val2 = values1(nxi,nyi),
              val3 = values1(xi,nyi),
              val4 = values2(xi,yi) = (float)func(X,Y,nZ),
              val5 = values2(nxi,yi) = (float)func(nX,Y,nZ),
              val6 = values2(nxi,nyi) = (float)func(nX,nY,nZ),
              val7 = values2(xi,nyi) = (float)func(X,nY,nZ);

            const unsigned int configuration =
              (val0<isovalue?1:0) | (val1<isovalue?2:0) | (val2<isovalue?4:0) | (val3<isovalue?8:0) |
              (val4<isovalue?16:0) | (val5<isovalue?32:0) | (val6<isovalue?64:0) | (val7<isovalue?128:0),
              edge = edges[configuration];


            if (edge) {
              if ((edge&1) && indices1(xi,yi,0)<0) {
                const float Xi = X + (isovalue-val0)*dx/(val1-val0);
                indices1(xi,yi,0) = vertices._width;
                CImg<floatT>::vector(Xi,Y,Z).move_to(vertices);
              }
              if ((edge&2) && indices1(nxi,yi,1)<0) {
                const float Yi = Y + (isovalue-val1)*dy/(val2-val1);
                indices1(nxi,yi,1) = vertices._width;
                CImg<floatT>::vector(nX,Yi,Z).move_to(vertices);
              }
              if ((edge&4) && indices1(xi,nyi,0)<0) {
                const float Xi = X + (isovalue-val3)*dx/(val2-val3);
                indices1(xi,nyi,0) = vertices._width;
                CImg<floatT>::vector(Xi,nY,Z).move_to(vertices);
              }
              if ((edge&8) && indices1(xi,yi,1)<0) {
                const float Yi = Y + (isovalue-val0)*dy/(val3-val0);
                indices1(xi,yi,1) = vertices._width;
                CImg<floatT>::vector(X,Yi,Z).move_to(vertices);
              }
              if ((edge&16) && indices2(xi,yi,0)<0) {
                const float Xi = X + (isovalue-val4)*dx/(val5-val4);
                indices2(xi,yi,0) = vertices._width;
                CImg<floatT>::vector(Xi,Y,nZ).move_to(vertices);
              }
              if ((edge&32) && indices2(nxi,yi,1)<0) {
                const float Yi = Y + (isovalue-val5)*dy/(val6-val5);
                indices2(nxi,yi,1) = vertices._width;
                CImg<floatT>::vector(nX,Yi,nZ).move_to(vertices);
              }
              if ((edge&64) && indices2(xi,nyi,0)<0) {
                const float Xi = X + (isovalue-val7)*dx/(val6-val7);
                indices2(xi,nyi,0) = vertices._width;
                CImg<floatT>::vector(Xi,nY,nZ).move_to(vertices);
              }
              if ((edge&128) && indices2(xi,yi,1)<0) {
                const float Yi = Y + (isovalue-val4)*dy/(val7-val4);
                indices2(xi,yi,1) = vertices._width;
                CImg<floatT>::vector(X,Yi,nZ).move_to(vertices);
              }
              if ((edge&256) && indices1(xi,yi,2)<0) {
                const float Zi = Z+ (isovalue-val0)*dz/(val4-val0);
                indices1(xi,yi,2) = vertices._width;
                CImg<floatT>::vector(X,Y,Zi).move_to(vertices);
              }
              if ((edge&512) && indices1(nxi,yi,2)<0) {
                const float Zi = Z + (isovalue-val1)*dz/(val5-val1);
                indices1(nxi,yi,2) = vertices._width;
                CImg<floatT>::vector(nX,Y,Zi).move_to(vertices);
              }
              if ((edge&1024) && indices1(nxi,nyi,2)<0) {
                const float Zi = Z + (isovalue-val2)*dz/(val6-val2);
                indices1(nxi,nyi,2) = vertices._width;
                CImg<floatT>::vector(nX,nY,Zi).move_to(vertices);
              }
              if ((edge&2048) && indices1(xi,nyi,2)<0) {
                const float Zi = Z + (isovalue-val3)*dz/(val7-val3);
                indices1(xi,nyi,2) = vertices._width;
                CImg<floatT>::vector(X,nY,Zi).move_to(vertices);
              }


              for (const int *triangle = triangles[configuration]; *triangle!=-1; ) {
                const unsigned int p0 = *(triangle++), p1 = *(triangle++), p2 = *(triangle++);
                const tf
                  i0 = (tf)(_isosurface3d_indice(p0,indices1,indices2,xi,yi,nxi,nyi)),
                  i1 = (tf)(_isosurface3d_indice(p1,indices1,indices2,xi,yi,nxi,nyi)),
                  i2 = (tf)(_isosurface3d_indice(p2,indices1,indices2,xi,yi,nxi,nyi));
                CImg<tf>::vector(i0,i2,i1).move_to(primitives);
              }
            }
          }
        }
        cimg::swap(values1,values2);
        cimg::swap(indices1,indices2);
      }
      return vertices>'x';
    }


    template<typename tf>
    static CImg<floatT> isosurface3d(CImgList<tf>& primitives, const char *const expression, const float isovalue,
                                     const float x0, const float y0, const float z0,
                                     const float x1, const float y1, const float z1,
                                     const int dx=32, const int dy=32, const int dz=32) {
      const _functor3d_expr func(expression);
      return isosurface3d(primitives,func,isovalue,x0,y0,z0,x1,y1,z1,dx,dy,dz);
    }

    template<typename t>
    static int _isosurface3d_indice(const unsigned int edge, const CImg<t>& indices1, const CImg<t>& indices2,
                                    const unsigned int x, const unsigned int y,
                                    const unsigned int nx, const unsigned int ny) {
      switch (edge) {
      case 0 : return indices1(x,y,0);
      case 1 : return indices1(nx,y,1);
      case 2 : return indices1(x,ny,0);
      case 3 : return indices1(x,y,1);
      case 4 : return indices2(x,y,0);
      case 5 : return indices2(nx,y,1);
      case 6 : return indices2(x,ny,0);
      case 7 : return indices2(x,y,1);
      case 8 : return indices1(x,y,2);
      case 9 : return indices1(nx,y,2);
      case 10 : return indices1(nx,ny,2);
      case 11 : return indices1(x,ny,2);
      }
      return 0;
    }


    struct _functor2d_int {
      const CImg<T>& ref;
      _functor2d_int(const CImg<T>& pref):ref(pref) {}
      float operator()(const float x, const float y) const {
        return (float)ref((int)x,(int)y);
      }
    };

    struct _functor2d_float {
      const CImg<T>& ref;
      _functor2d_float(const CImg<T>& pref):ref(pref) {}
      float operator()(const float x, const float y) const {
        return (float)ref._linear_atXY(x,y);
      }
    };

    struct _functor2d_expr {
      _cimg_math_parser *mp;
      _functor2d_expr(const char *const expr):mp(0) { mp = new _cimg_math_parser(CImg<T>::empty(),expr,0); }
      ~_functor2d_expr() { delete mp; }
      float operator()(const float x, const float y) const {
        return (float)(*mp)(x,y,0,0);
      }
    };

    struct _functor3d_int {
      const CImg<T>& ref;
      _functor3d_int(const CImg<T>& pref):ref(pref) {}
      float operator()(const float x, const float y, const float z) const {
        return (float)ref((int)x,(int)y,(int)z);
      }
    };

    struct _functor3d_float {
      const CImg<T>& ref;
      _functor3d_float(const CImg<T>& pref):ref(pref) {}
      float operator()(const float x, const float y, const float z) const {
        return (float)ref._linear_atXYZ(x,y,z);
      }
    };

    struct _functor3d_expr {
      _cimg_math_parser *mp;
      ~_functor3d_expr() { delete mp; }
      _functor3d_expr(const char *const expr):mp(0) { mp = new _cimg_math_parser(CImg<T>::empty(),expr,0); }
      float operator()(const float x, const float y, const float z) const {
        return (float)(*mp)(x,y,z,0);
      }
    };

    struct _functor4d_int {
      const CImg<T>& ref;
      _functor4d_int(const CImg<T>& pref):ref(pref) {}
      float operator()(const float x, const float y, const float z, const unsigned int c) const {
        return (float)ref((int)x,(int)y,(int)z,c);
      }
    };
# 29937 "../src/CImg.h"
    template<typename tf>
    static CImg<floatT> box3d(CImgList<tf>& primitives,
                              const float size_x=200, const float size_y=100, const float size_z=100) {
      primitives.assign(6,1,4,1,1, 0,3,2,1, 4,5,6,7, 0,1,5,4, 3,7,6,2, 0,4,7,3, 1,2,6,5);
      return CImg<floatT>(8,3,1,1,
                          0.,size_x,size_x, 0., 0.,size_x,size_x, 0.,
                          0., 0.,size_y,size_y, 0., 0.,size_y,size_y,
                          0., 0., 0., 0.,size_z,size_z,size_z,size_z);
    }
# 29963 "../src/CImg.h"
    template<typename tf>
    static CImg<floatT> cone3d(CImgList<tf>& primitives,
                               const float radius=50, const float size_z=100, const unsigned int subdivisions=24) {
      primitives.assign();
      if (!subdivisions) return CImg<floatT>();
      CImgList<floatT> vertices(2,1,3,1,1,
                                0.,0.,size_z,
                                0.,0.,0.);
      for (float delta = 360.0f/subdivisions, angle = 0; angle<360; angle+=delta) {
        const float a = (float)(angle*cimg::PI/180);
        CImg<floatT>::vector((float)(radius*std::cos(a)),(float)(radius*std::sin(a)),0).move_to(vertices);
      }
      const unsigned int nbr = vertices._width - 2;
      for (unsigned int p = 0; p<nbr; ++p) {
        const unsigned int curr = 2 + p, next = 2 + ((p+1)%nbr);
        CImg<tf>::vector(1,next,curr).move_to(primitives);
        CImg<tf>::vector(0,curr,next).move_to(primitives);
      }
      return vertices>'x';
    }
# 30000 "../src/CImg.h"
    template<typename tf>
    static CImg<floatT> cylinder3d(CImgList<tf>& primitives,
                                   const float radius=50, const float size_z=100, const unsigned int subdivisions=24) {
      primitives.assign();
      if (!subdivisions) return CImg<floatT>();
      CImgList<floatT> vertices(2,1,3,1,1,
                                0.,0.,0.,
                                0.,0.,size_z);
      for (float delta = 360.0f/subdivisions, angle = 0; angle<360; angle+=delta) {
        const float a = (float)(angle*cimg::PI/180);
        CImg<floatT>::vector((float)(radius*std::cos(a)),(float)(radius*std::sin(a)),0.0f).move_to(vertices);
        CImg<floatT>::vector((float)(radius*std::cos(a)),(float)(radius*std::sin(a)),size_z).move_to(vertices);
      }
      const unsigned int nbr = (vertices._width - 2)/2;
      for (unsigned int p = 0; p<nbr; ++p) {
        const unsigned int curr = 2+2*p, next = 2+(2*((p+1)%nbr));
        CImg<tf>::vector(0,next,curr).move_to(primitives);
        CImg<tf>::vector(1,curr+1,next+1).move_to(primitives);
        CImg<tf>::vector(curr,next,next+1,curr+1).move_to(primitives);
      }
      return vertices>'x';
    }
# 30040 "../src/CImg.h"
    template<typename tf>
    static CImg<floatT> torus3d(CImgList<tf>& primitives,
                                const float radius1=100, const float radius2=30,
                                const unsigned int subdivisions1=24, const unsigned int subdivisions2=12) {
      primitives.assign();
      if (!subdivisions1 || !subdivisions2) return CImg<floatT>();
      CImgList<floatT> vertices;
      for (unsigned int v = 0; v<subdivisions1; ++v) {
        const float
          beta = (float)(v*2*cimg::PI/subdivisions1),
          xc = radius1*(float)std::cos(beta),
          yc = radius1*(float)std::sin(beta);
        for (unsigned int u = 0; u<subdivisions2; ++u) {
          const float
            alpha = (float)(u*2*cimg::PI/subdivisions2),
            x = xc + radius2*(float)(std::cos(alpha)*std::cos(beta)),
            y = yc + radius2*(float)(std::cos(alpha)*std::sin(beta)),
            z = radius2*(float)std::sin(alpha);
          CImg<floatT>::vector(x,y,z).move_to(vertices);
        }
      }
      for (unsigned int vv = 0; vv<subdivisions1; ++vv) {
        const unsigned int nv = (vv+1)%subdivisions1;
        for (unsigned int uu = 0; uu<subdivisions2; ++uu) {
          const unsigned int nu = (uu+1)%subdivisions2, svv = subdivisions2*vv, snv = subdivisions2*nv;
          CImg<tf>::vector(svv+nu,svv+uu,snv+uu,snv+nu).move_to(primitives);
        }
      }
      return vertices>'x';
    }
# 30088 "../src/CImg.h"
    template<typename tf>
    static CImg<floatT> plane3d(CImgList<tf>& primitives,
                                const float size_x=100, const float size_y=100,
                                const unsigned int subdivisions_x=10, const unsigned int subdivisions_y=10) {
      primitives.assign();
      if (!subdivisions_x || !subdivisions_y) return CImg<floatT>();
      CImgList<floatT> vertices;
      const unsigned int w = subdivisions_x + 1, h = subdivisions_y + 1;
      const float fx = (float)size_x/w, fy = (float)size_y/h;
      for (unsigned int y = 0; y<h; ++y) for (unsigned int x = 0; x<w; ++x)
        CImg<floatT>::vector(fx*x,fy*y,0).move_to(vertices);
      for (unsigned int y = 0; y<subdivisions_y; ++y) for (unsigned int x = 0; x<subdivisions_x; ++x) {
        const int off1 = x+y*w, off2 = x+1+y*w, off3 = x+1+(y+1)*w, off4 = x+(y+1)*w;
        CImg<tf>::vector(off1,off4,off3,off2).move_to(primitives);
      }
      return vertices>'x';
    }
# 30121 "../src/CImg.h"
    template<typename tf>
    static CImg<floatT> sphere3d(CImgList<tf>& primitives,
                                 const float radius=50, const unsigned int subdivisions=3) {


      primitives.assign();
      const double tmp = (1+std::sqrt(5.0f))/2, a = 1.0/std::sqrt(1+tmp*tmp), b = tmp*a;
      CImgList<floatT> vertices(12,1,3,1,1, b,a,0.0, -b,a,0.0, -b,-a,0.0, b,-a,0.0, a,0.0,b, a,0.0,-b,
                                -a,0.0,-b, -a,0.0,b, 0.0,b,a, 0.0,-b,a, 0.0,-b,-a, 0.0,b,-a);
      primitives.assign(20,1,3,1,1, 4,8,7, 4,7,9, 5,6,11, 5,10,6, 0,4,3, 0,3,5, 2,7,1, 2,1,6,
                        8,0,11, 8,11,1, 9,10,3, 9,2,10, 8,4,0, 11,0,5, 4,9,3,
                        5,3,10, 7,8,1, 6,1,11, 7,2,9, 6,10,2);

      float he = (float)a;


      for (unsigned int i = 0; i<subdivisions; ++i) {
        const unsigned int L = primitives._width;
        he/=2;
        const float he2 = he*he;
        for (unsigned int l = 0; l<L; ++l) {
          const unsigned int
            p0 = (unsigned int)primitives(0,0), p1 = (unsigned int)primitives(0,1), p2 = (unsigned int)primitives(0,2);
          const float
            x0 = vertices(p0,0), y0 = vertices(p0,1), z0 = vertices(p0,2),
            x1 = vertices(p1,0), y1 = vertices(p1,1), z1 = vertices(p1,2),
            x2 = vertices(p2,0), y2 = vertices(p2,1), z2 = vertices(p2,2),
            tnx0 = (x0+x1)/2, tny0 = (y0+y1)/2, tnz0 = (z0+z1)/2, nn0 = (float)std::sqrt(tnx0*tnx0+tny0*tny0+tnz0*tnz0),
            tnx1 = (x0+x2)/2, tny1 = (y0+y2)/2, tnz1 = (z0+z2)/2, nn1 = (float)std::sqrt(tnx1*tnx1+tny1*tny1+tnz1*tnz1),
            tnx2 = (x1+x2)/2, tny2 = (y1+y2)/2, tnz2 = (z1+z2)/2, nn2 = (float)std::sqrt(tnx2*tnx2+tny2*tny2+tnz2*tnz2),
            nx0 = tnx0/nn0, ny0 = tny0/nn0, nz0 = tnz0/nn0,
            nx1 = tnx1/nn1, ny1 = tny1/nn1, nz1 = tnz1/nn1,
            nx2 = tnx2/nn2, ny2 = tny2/nn2, nz2 = tnz2/nn2;
          int i0 = -1, i1 = -1, i2 = -1;
          for (int p = 0; p<(int)(vertices)._width; ++p) {
            const float x = (float)vertices(p,0), y = (float)vertices(p,1), z = (float)vertices(p,2);
            if (cimg::sqr(x-nx0) + cimg::sqr(y-ny0) + cimg::sqr(z-nz0)<he2) i0 = p;
            if (cimg::sqr(x-nx1) + cimg::sqr(y-ny1) + cimg::sqr(z-nz1)<he2) i1 = p;
            if (cimg::sqr(x-nx2) + cimg::sqr(y-ny2) + cimg::sqr(z-nz2)<he2) i2 = p;
          }
          if (i0<0) { CImg<floatT>::vector(nx0,ny0,nz0).move_to(vertices); i0 = vertices._width - 1; }
          if (i1<0) { CImg<floatT>::vector(nx1,ny1,nz1).move_to(vertices); i1 = vertices._width - 1; }
          if (i2<0) { CImg<floatT>::vector(nx2,ny2,nz2).move_to(vertices); i2 = vertices._width - 1; }
          primitives.remove(0);
          CImg<tf>::vector(p0,i0,i1).move_to(primitives);
          CImg<tf>::vector((tf)i0,(tf)p1,(tf)i2).move_to(primitives);
          CImg<tf>::vector((tf)i1,(tf)i2,(tf)p2).move_to(primitives);
          CImg<tf>::vector((tf)i1,(tf)i0,(tf)i2).move_to(primitives);
        }
      }
      return (vertices>'x')*=radius;
    }
# 30190 "../src/CImg.h"
    template<typename tf, typename t>
    static CImg<floatT> ellipsoid3d(CImgList<tf>& primitives,
                                    const CImg<t>& tensor, const unsigned int subdivisions=3) {
      primitives.assign();
      if (!subdivisions) return CImg<floatT>();
      CImg<floatT> S, V;
      tensor.symmetric_eigen(S,V);
      const float orient =
        (V(0,1)*V(1,2) - V(0,2)*V(1,1))*V(2,0) +
        (V(0,2)*V(1,0) - V(0,0)*V(1,2))*V(2,1) +
        (V(0,0)*V(1,1) - V(0,1)*V(1,0))*V(2,2);
      if (orient<0) { V(2,0) = -V(2,0); V(2,1) = -V(2,1); V(2,2) = -V(2,2); }
      const float l0 = S[0], l1 = S[1], l2 = S[2];
      CImg<floatT> vertices = sphere3d(primitives,1.0,subdivisions);
      vertices.get_shared_row(0)*=l0;
      vertices.get_shared_row(1)*=l1;
      vertices.get_shared_row(2)*=l2;
      return V*vertices;
    }
# 30217 "../src/CImg.h"
    template<typename tp, typename tc, typename to>
    CImg<T>& object3dtoCImg3d(const CImgList<tp>& primitives,
                              const CImgList<tc>& colors,
                              const to& opacities,
                              const bool full_check=true) {
      return get_object3dtoCImg3d(primitives,colors,opacities,full_check).move_to(*this);
    }


    template<typename tp, typename tc>
    CImg<T>& object3dtoCImg3d(const CImgList<tp>& primitives,
                              const CImgList<tc>& colors,
                              const bool full_check=true) {
      return get_object3dtoCImg3d(primitives,colors,full_check).move_to(*this);
    }


    template<typename tp>
    CImg<T>& object3dtoCImg3d(const CImgList<tp>& primitives,
                              const bool full_check=true) {
      return get_object3dtoCImg3d(primitives,full_check).move_to(*this);
    }


    CImg<T>& object3dtoCImg3d(const bool full_check=true) {
      return get_object3dtoCImg3d(full_check).move_to(*this);
    }


    template<typename tp, typename tc, typename to>
    CImg<floatT> get_object3dtoCImg3d(const CImgList<tp>& primitives,
                                      const CImgList<tc>& colors,
                                      const to& opacities,
                                      const bool full_check=true) const {
      char error_message[1024] = { 0 };
      if (!is_object3d(primitives,colors,opacities,full_check,error_message))
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "object3dtoCImg3d(): Invalid specified 3d object (%u,%u) (%s).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),_width,primitives._width,error_message);
      CImg<floatT> res(1,_size_object3dtoCImg3d(primitives,colors,opacities));
      float *ptrd = res._data;


      *(ptrd++) = 'C' + 0.5f; *(ptrd++) = 'I' + 0.5f; *(ptrd++) = 'm' + 0.5f;
      *(ptrd++) = 'g' + 0.5f; *(ptrd++) = '3' + 0.5f; *(ptrd++) = 'd' + 0.5f;


      *(ptrd++) = cimg::uint2float(_width);
      *(ptrd++) = cimg::uint2float(primitives._width);


      if (is_empty() || !primitives) return res;
      const T *ptrx = data(0,0), *ptry = data(0,1), *ptrz = data(0,2);
      for (int p = 0; p<(int)((*this)._width); ++p) {
        *(ptrd++) = (float)*(ptrx++);
        *(ptrd++) = (float)*(ptry++);
        *(ptrd++) = (float)*(ptrz++);
      }


      for (int p = 0; p<(int)(primitives)._width; ++p) {
        *(ptrd++) = (float)primitives[p].size();
        const tp *ptrp = primitives[p]._data;
        for (unsigned long i = 0, _maxi = (primitives[p]).size(); i<_maxi; ++i) *(ptrd++) = cimg::uint2float((unsigned int)*(ptrp++));
      }


      const unsigned int csiz = cimg::min(colors._width,primitives._width);
      for (int c = 0; c<(int)csiz; ++c) {
        const CImg<tc>& color = colors[c];
        const tc *ptrc = color._data;
        if (color.size()==3) { *(ptrd++) = (float)*(ptrc++); *(ptrd++) = (float)*(ptrc++); *(ptrd++) = (float)*ptrc; }
        else {
          *(ptrd++) = -128.0f;
          int shared_ind = -1;
          if (color.is_shared()) for (int i = 0; i<c; ++i) if (ptrc==colors[i]._data) { shared_ind = i; break; }
          if (shared_ind<0) {
            *(ptrd++) = (float)color._width;
            *(ptrd++) = (float)color._height;
            *(ptrd++) = (float)color._spectrum;
            for (unsigned long l = 0, _maxl = (color).size(); l<_maxl; ++l) *(ptrd++) = (float)*(ptrc++);
          } else {
            *(ptrd++) = (float)shared_ind;
            *(ptrd++) = 0;
            *(ptrd++) = 0;
          }
        }
      }
      const int csiz2 = primitives._width - colors._width;
      for (int c = 0; c<csiz2; ++c) { *(ptrd++) = 200.0f; *(ptrd++) = 200.0f; *(ptrd++) = 200.0f; }


      ptrd = _object3dtoCImg3d(opacities,ptrd);
      const float *ptre = res.end();
      while (ptrd<ptre) *(ptrd++) = 1.0f;
      return res;
    }

    template<typename to>
    float* _object3dtoCImg3d(const CImgList<to>& opacities, float *ptrd) const {
      for (int o = 0; o<(int)(opacities)._width; ++o) {
        const CImg<to>& opacity = opacities[o];
        const to *ptro = opacity._data;
        if (opacity.size()==1) *(ptrd++) = (float)*ptro;
        else {
          *(ptrd++) = -128.0f;
          int shared_ind = -1;
          if (opacity.is_shared()) for (int i = 0; i<o; ++i) if (ptro==opacities[i]._data) { shared_ind = i; break; }
          if (shared_ind<0) {
            *(ptrd++) = (float)opacity._width;
            *(ptrd++) = (float)opacity._height;
            *(ptrd++) = (float)opacity._spectrum;
            for (unsigned long l = 0, _maxl = (opacity).size(); l<_maxl; ++l) *(ptrd++) = (float)*(ptro++);
          } else {
            *(ptrd++) = (float)shared_ind;
            *(ptrd++) = 0;
            *(ptrd++) = 0;
          }
        }
      }
      return ptrd;
    }

    template<typename to>
    float* _object3dtoCImg3d(const CImg<to>& opacities, float *ptrd) const {
      const to *ptro = opacities._data;
      for (unsigned long o = 0, _maxo = (opacities).size(); o<_maxo; ++o) *(ptrd++) = (float)*(ptro++);
      return ptrd;
    }

    template<typename tp, typename tc, typename to>
    unsigned int _size_object3dtoCImg3d(const CImgList<tp>& primitives,
                                        const CImgList<tc>& colors,
                                        const CImgList<to>& opacities) const {
      unsigned int siz = 8 + 3*width();
      for (int p = 0; p<(int)(primitives)._width; ++p) siz+=primitives[p].size() + 1;
      for (int c = cimg::min(primitives._width,colors._width)-1; c>=0; --c) {
        if (colors[c].is_shared()) siz+=4;
        else { const unsigned int csiz = colors[c].size(); siz+=(csiz!=3)?4+csiz:3; }
      }
      if (colors._width<primitives._width) siz+=3*(primitives._width - colors._width);
      for (int o = 0; o<(int)(opacities)._width; ++o) {
        if (opacities[o].is_shared()) siz+=4;
        else { const unsigned int osiz = opacities[o].size(); siz+=(osiz!=1)?4+osiz:1; }
      }
      siz+=primitives._width - opacities._width;
      return siz;
    }

    template<typename tp, typename tc, typename to>
    unsigned int _size_object3dtoCImg3d(const CImgList<tp>& primitives,
                                        const CImgList<tc>& colors,
                                        const CImg<to>& opacities) const {
      unsigned int siz = 8 + 3*width();
      for (int p = 0; p<(int)(primitives)._width; ++p) siz+=primitives[p].size() + 1;
      for (int c = cimg::min(primitives._width,colors._width)-1; c>=0; --c) {
        const unsigned int csiz = colors[c].size(); siz+=(csiz!=3)?4+csiz:3;
      }
      if (colors._width<primitives._width) siz+=3*(primitives._width - colors._width);
      siz+=primitives.size();
      cimg::unused(opacities);
      return siz;
    }


    template<typename tp, typename tc>
    CImg<floatT> get_object3dtoCImg3d(const CImgList<tp>& primitives,
                                      const CImgList<tc>& colors,
                                      const bool full_check=true) const {
      CImgList<T> opacities;
      return get_object3dtoCImg3d(primitives,colors,opacities,full_check);
    }


    template<typename tp>
    CImg<floatT> get_object3dtoCImg3d(const CImgList<tp>& primitives,
                                      const bool full_check=true) const {
      CImgList<T> colors, opacities;
      return get_object3dtoCImg3d(primitives,colors,opacities,full_check);
    }


    CImg<floatT> get_object3dtoCImg3d(const bool full_check=true) const {
      CImgList<T> opacities, colors;
      CImgList<uintT> primitives(width(),1,1,1,1);
      for (int p = 0; p<(int)(primitives)._width; ++p) primitives(p,0) = p;
      return get_object3dtoCImg3d(primitives,colors,opacities,full_check);
    }
# 30413 "../src/CImg.h"
    template<typename tp, typename tc, typename to>
    CImg<T>& CImg3dtoobject3d(CImgList<tp>& primitives,
                              CImgList<tc>& colors,
                              CImgList<to>& opacities,
                              const bool full_check=true) {
      return get_CImg3dtoobject3d(primitives,colors,opacities,full_check).move_to(*this);
    }


    template<typename tp, typename tc, typename to>
    CImg<T> get_CImg3dtoobject3d(CImgList<tp>& primitives,
                                 CImgList<tc>& colors,
                                 CImgList<to>& opacities,
                                 const bool full_check=true) const {
      char error_message[1024] = { 0 };
      if (!is_CImg3d(full_check,error_message))
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "CImg3dtoobject3d(): image instance is not a CImg3d (%s).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),error_message);
      const T *ptrs = _data + 6;
      const unsigned int
        nb_points = cimg::float2uint((float)*(ptrs++)),
        nb_primitives = cimg::float2uint((float)*(ptrs++));
      const CImg<T> points = CImg<T>(ptrs,3,nb_points,1,1,true).get_transpose();
      ptrs+=3*nb_points;
      primitives.assign(nb_primitives);
      for (int p = 0; p<(int)(primitives)._width; ++p) {
        const unsigned int nb_inds = (unsigned int)*(ptrs++);
        primitives[p].assign(1,nb_inds);
        tp *ptrp = primitives[p]._data;
        for (unsigned int i = 0; i<nb_inds; ++i) *(ptrp++) = (tp)cimg::float2uint((float)*(ptrs++));
      }
      colors.assign(nb_primitives);
      for (int c = 0; c<(int)(colors)._width; ++c) {
        if (*ptrs==(T)-128) {
          ++ptrs;
          const unsigned int w = (unsigned int)*(ptrs++), h = (unsigned int)*(ptrs++), s = (unsigned int)*(ptrs++);
          if (!h && !s) colors[c].assign(colors[w],true);
          else { colors[c].assign(ptrs,w,h,1,s,false); ptrs+=w*h*s; }
        } else { colors[c].assign(ptrs,1,1,1,3,false); ptrs+=3; }
      }
      opacities.assign(nb_primitives);
      for (int o = 0; o<(int)(opacities)._width; ++o) {
        if (*ptrs==(T)-128) {
          ++ptrs;
          const unsigned int w = (unsigned int)*(ptrs++), h = (unsigned int)*(ptrs++), s = (unsigned int)*(ptrs++);
          if (!h && !s) opacities[o].assign(opacities[w],true);
          else { opacities[o].assign(ptrs,w,h,1,s,false); ptrs+=w*h*s; }
        } else opacities[o].assign(1,1,1,1,*(ptrs++));
      }
      return points;
    }
# 30483 "../src/CImg.h"
    template<typename tc>
    CImg<T>& _draw_scanline(const int x0, const int x1, const int y,
                            const tc *const color, const float opacity,
                            const float brightness,
                            const float nopacity, const float copacity, const unsigned long whd) {
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const int nx0 = x0>0?x0:0, nx1 = x1<width()?x1:width()-1, dx = nx1 - nx0;
      if (dx>=0) {
        const tc *col = color;
        const unsigned long off = whd - dx - 1;
        T *ptrd = data(nx0,y);
        if (opacity>=1) {
          if (brightness==1) {
            if (sizeof(T)!=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)*(col++);
                for (int x = dx; x>=0; --x) *(ptrd++) = val;
                ptrd+=off;
              } else for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)*(col++);
                std::memset(ptrd,(int)val,dx+1);
                ptrd+=whd;
              }
          } else if (brightness<1) {
            if (sizeof(T)!=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)(*(col++)*brightness);
                for (int x = dx; x>=0; --x) *(ptrd++) = val;
                ptrd+=off;
              } else for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)(*(col++)*brightness);
                std::memset(ptrd,(int)val,dx+1);
                ptrd+=whd;
              }
          } else {
            if (sizeof(T)!=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)((2-brightness)**(col++) + (brightness-1)*maxval);
                for (int x = dx; x>=0; --x) *(ptrd++) = val;
                ptrd+=off;
              } else for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)((2-brightness)**(col++) + (brightness-1)*maxval);
                std::memset(ptrd,(int)val,dx+1);
                ptrd+=whd;
              }
          }
        } else {
          if (brightness==1) {
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              const T val = (T)*(col++);
              for (int x = dx; x>=0; --x) { *ptrd = (T)(val*nopacity + *ptrd*copacity); ++ptrd; }
              ptrd+=off;
            }
          } else if (brightness<=1) {
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              const T val = (T)(*(col++)*brightness);
              for (int x = dx; x>=0; --x) { *ptrd = (T)(val*nopacity + *ptrd*copacity); ++ptrd; }
              ptrd+=off;
            }
          } else {
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              const T val = (T)((2-brightness)**(col++) + (brightness-1)*maxval);
              for (int x = dx; x>=0; --x) { *ptrd = (T)(val*nopacity + *ptrd*copacity); ++ptrd; }
              ptrd+=off;
            }
          }
        }
      }
      return *this;
    }
# 30567 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_point(const int x0, const int y0, const int z0,
                        const tc *const color, const float opacity=1) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_point(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (x0>=0 && y0>=0 && z0>=0 && x0<width() && y0<height() && z0<depth()) {
        const unsigned long whd = (unsigned long)_width*_height*_depth;
        const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
        T *ptrd = data(x0,y0,z0,0);
        const tc *col = color;
        if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; }
        else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; }
      }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_point(const int x0, const int y0,
                        const tc *const color, const float opacity=1) {
      return draw_point(x0,y0,0,color,opacity);
    }







    template<typename t, typename tc>
    CImg<T>& draw_point(const CImg<t>& points,
                        const tc *const color, const float opacity=1) {
      if (is_empty() || !points) return *this;
      switch (points._height) {
      case 0 : case 1 :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_point(): Invalid specified point set (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    points._width,points._height,points._depth,points._spectrum,points._data);
      case 2 : {
        for (int i = 0; i<(int)((points)._width); ++i) draw_point((int)points(i,0),(int)points(i,1),color,opacity);
      } break;
      default : {
        for (int i = 0; i<(int)((points)._width); ++i) draw_point((int)points(i,0),(int)points(i,1),(int)points(i,2),color,opacity);
      }
      }
      return *this;
    }
# 30639 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_line(const int x0, const int y0,
                       const int x1, const int y1,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      static unsigned int hatch = ~0U - (~0U>>1);
      if (init_hatch) hatch = ~0U - (~0U>>1);
      const bool xdir = x0<x1, ydir = y0<y1;
      int
        nx0 = x0, nx1 = x1, ny0 = y0, ny1 = y1,
        &xleft = xdir?nx0:nx1, &yleft = xdir?ny0:ny1,
        &xright = xdir?nx1:nx0, &yright = xdir?ny1:ny0,
        &xup = ydir?nx0:nx1, &yup = ydir?ny0:ny1,
        &xdown = ydir?nx1:nx0, &ydown = ydir?ny1:ny0;
      if (xright<0 || xleft>=width()) return *this;
      if (xleft<0) { yleft-=(int)((float)xleft*((float)yright - yleft)/((float)xright - xleft)); xleft = 0; }
      if (xright>=width()) {
        yright-=(int)(((float)xright - width())*((float)yright - yleft)/((float)xright - xleft));
        xright = width() - 1;
      }
      if (ydown<0 || yup>=height()) return *this;
      if (yup<0) { xup-=(int)((float)yup*((float)xdown - xup)/((float)ydown - yup)); yup = 0; }
      if (ydown>=height()) {
        xdown-=(int)(((float)ydown - height())*((float)xdown - xup)/((float)ydown - yup));
        ydown = height() - 1;
      }
      T *ptrd0 = data(nx0,ny0);
      int dx = xright - xleft, dy = ydown - yup;
      const bool steep = dy>dx;
      if (steep) cimg::swap(nx0,ny0,nx1,ny1,dx,dy);
      const long
        offx = (nx0<nx1?1:-1)*(steep?width():1),
        offy = (ny0<ny1?1:-1)*(steep?1:width());
      const unsigned long wh = (unsigned long)_width*_height;
      if (opacity>=1) {
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          if (pattern&hatch) {
            T *ptrd = ptrd0; const tc* col = color;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=wh; }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          T *ptrd = ptrd0; const tc* col = color; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=wh; }
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        }
      } else {
        const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          if (pattern&hatch) {
            T *ptrd = ptrd0; const tc* col = color;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity**(col++) + *ptrd*copacity); ptrd+=wh; }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          T *ptrd = ptrd0; const tc* col = color;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity**(col++) + *ptrd*copacity); ptrd+=wh; }
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        }
      }
      return *this;
    }
# 30726 "../src/CImg.h"
    template<typename tz,typename tc>
    CImg<T>& draw_line(CImg<tz>& zbuffer,
                       const int x0, const int y0, const float z0,
                       const int x1, const int y1, const float z1,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) {
      typedef typename cimg::superset<tz,float>::type tzfloat;
      if (is_empty() || z0<=0 || z1<=0) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (!is_sameXY(zbuffer))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    zbuffer._width,zbuffer._height,zbuffer._depth,zbuffer._spectrum,zbuffer._data);
      static unsigned int hatch = ~0U - (~0U>>1);
      if (init_hatch) hatch = ~0U - (~0U>>1);
      const bool xdir = x0<x1, ydir = y0<y1;
      int
        nx0 = x0, nx1 = x1, ny0 = y0, ny1 = y1,
        &xleft = xdir?nx0:nx1, &yleft = xdir?ny0:ny1,
        &xright = xdir?nx1:nx0, &yright = xdir?ny1:ny0,
        &xup = ydir?nx0:nx1, &yup = ydir?ny0:ny1,
        &xdown = ydir?nx1:nx0, &ydown = ydir?ny1:ny0;
      tzfloat
        Z0 = 1/(tzfloat)z0, Z1 = 1/(tzfloat)z1, nz0 = Z0, nz1 = Z1, dz = Z1 - Z0,
        &zleft = xdir?nz0:nz1,
        &zright = xdir?nz1:nz0,
        &zup = ydir?nz0:nz1,
        &zdown = ydir?nz1:nz0;
      if (xright<0 || xleft>=width()) return *this;
      if (xleft<0) {
        const float D = (float)xright - xleft;
        yleft-=(int)((float)xleft*((float)yright - yleft)/D);
        zleft-=(tzfloat)xleft*(zright - zleft)/D;
        xleft = 0;
      }
      if (xright>=width()) {
        const float d = (float)xright - width(), D = (float)xright - xleft;
        yright-=(int)(d*((float)yright - yleft)/D);
        zright-=(tzfloat)d*(zright - zleft)/D;
        xright = width() - 1;
      }
      if (ydown<0 || yup>=height()) return *this;
      if (yup<0) {
        const float D = (float)ydown - yup;
        xup-=(int)((float)yup*((float)xdown - xup)/D);
        zup-=(tzfloat)yup*(zdown - zup)/D;
        yup = 0;
      }
      if (ydown>=height()) {
        const float d = (float)ydown - height(), D = (float)ydown - yup;
        xdown-=(int)(d*((float)xdown - xup)/D);
        zdown-=(tzfloat)d*(zdown - zup)/D;
        ydown = height() - 1;
      }
      T *ptrd0 = data(nx0,ny0);
      tz *ptrz = zbuffer.data(nx0,ny0);
      int dx = xright - xleft, dy = ydown - yup;
      const bool steep = dy>dx;
      if (steep) cimg::swap(nx0,ny0,nx1,ny1,dx,dy);
      const long
        offx = (nx0<nx1?1:-1)*(steep?width():1),
        offy = (ny0<ny1?1:-1)*(steep?1:width());
      const unsigned long wh = (unsigned long)_width*_height,
        ndx = dx>0?dx:1;
      if (opacity>=1) {
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          const tzfloat z = Z0 + x*dz/ndx;
          if (z>=(tzfloat)*ptrz && pattern&hatch) {
            *ptrz = (tz)z;
            T *ptrd = ptrd0; const tc *col = color;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=wh; }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx; ptrz+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; ptrz+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          const tzfloat z = Z0 + x*dz/ndx;
          if (z>=(tzfloat)*ptrz) {
            *ptrz = (tz)z;
            T *ptrd = ptrd0; const tc *col = color;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=wh; }
          }
          ptrd0+=offx; ptrz+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; ptrz+=offy; error+=dx; }
        }
      } else {
        const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          const tzfloat z = Z0 + x*dz/ndx;
          if (z>=(tzfloat)*ptrz && pattern&hatch) {
            *ptrz = (tz)z;
            T *ptrd = ptrd0; const tc *col = color;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity**(col++) + *ptrd*copacity); ptrd+=wh; }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx; ptrz+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; ptrz+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          const tzfloat z = Z0 + x*dz/ndx;
          if (z>=(tzfloat)*ptrz) {
            *ptrz = (tz)z;
            T *ptrd = ptrd0; const tc *col = color;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity**(col++) + *ptrd*copacity); ptrd+=wh; }
          }
          ptrd0+=offx; ptrz+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; ptrz+=offy; error+=dx; }
        }
      }
      return *this;
    }
# 30855 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_line(const int x0, const int y0, const int z0,
                       const int x1, const int y1, const int z1,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      static unsigned int hatch = ~0U - (~0U>>1);
      if (init_hatch) hatch = ~0U - (~0U>>1);
      int nx0 = x0, ny0 = y0, nz0 = z0, nx1 = x1, ny1 = y1, nz1 = z1;
      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
      if (nx1<0 || nx0>=width()) return *this;
      if (nx0<0) {
        const float D = 1.0f + nx1 - nx0;
        ny0-=(int)((float)nx0*(1.0f + ny1 - ny0)/D);
        nz0-=(int)((float)nx0*(1.0f + nz1 - nz0)/D);
        nx0 = 0;
      }
      if (nx1>=width()) {
        const float d = (float)nx1 - width(), D = 1.0f + nx1 - nx0;
        ny1+=(int)(d*(1.0f + ny0 - ny1)/D);
        nz1+=(int)(d*(1.0f + nz0 - nz1)/D);
        nx1 = width() - 1;
      }
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
      if (ny1<0 || ny0>=height()) return *this;
      if (ny0<0) {
        const float D = 1.0f + ny1 - ny0;
        nx0-=(int)((float)ny0*(1.0f + nx1 - nx0)/D);
        nz0-=(int)((float)ny0*(1.0f + nz1 - nz0)/D);
        ny0 = 0;
      }
      if (ny1>=height()) {
        const float d = (float)ny1 - height(), D = 1.0f + ny1 - ny0;
        nx1+=(int)(d*(1.0f + nx0 - nx1)/D);
        nz1+=(int)(d*(1.0f + nz0 - nz1)/D);
        ny1 = height() - 1;
      }
      if (nz0>nz1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
      if (nz1<0 || nz0>=depth()) return *this;
      if (nz0<0) {
        const float D = 1.0f + nz1 - nz0;
        nx0-=(int)((float)nz0*(1.0f + nx1 - nx0)/D);
        ny0-=(int)((float)nz0*(1.0f + ny1 - ny0)/D);
        nz0 = 0;
      }
      if (nz1>=depth()) {
        const float d = (float)nz1 - depth(), D = 1.0f + nz1 - nz0;
        nx1+=(int)(d*(1.0f + nx0 - nx1)/D);
        ny1+=(int)(d*(1.0f + ny0 - ny1)/D);
        nz1 = depth() - 1;
      }
      const unsigned int dmax = cimg::max(cimg::abs(nx1 - nx0),cimg::abs(ny1 - ny0),nz1 - nz0);
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      const float px = (nx1 - nx0)/(float)dmax, py = (ny1 - ny0)/(float)dmax, pz = (nz1 - nz0)/(float)dmax;
      float x = (float)nx0, y = (float)ny0, z = (float)nz0;
      if (opacity>=1) for (unsigned int t = 0; t<=dmax; ++t) {
        if (!(~pattern) || (~pattern && pattern&hatch)) {
          T* ptrd = data((unsigned int)x,(unsigned int)y,(unsigned int)z);
          const tc *col = color; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; }
        }
        x+=px; y+=py; z+=pz; if (pattern) { hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1); }
      } else {
        const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
        for (unsigned int t = 0; t<=dmax; ++t) {
          if (!(~pattern) || (~pattern && pattern&hatch)) {
            T* ptrd = data((unsigned int)x,(unsigned int)y,(unsigned int)z);
            const tc *col = color; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; }
          }
          x+=px; y+=py; z+=pz; if (pattern) { hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1); }
        }
      }
      return *this;
    }
# 30956 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_line(const int x0, const int y0,
                       const int x1, const int y1,
                       const CImg<tc>& texture,
                       const int tx0, const int ty0,
                       const int tx1, const int ty1,
                       const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) {
      if (is_empty()) return *this;
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture)) return draw_line(x0,y0,x1,y1,+texture,tx0,ty0,tx1,ty1,opacity,pattern,init_hatch);
      static unsigned int hatch = ~0U - (~0U>>1);
      if (init_hatch) hatch = ~0U - (~0U>>1);
      const bool xdir = x0<x1, ydir = y0<y1;
      int
        dtx = tx1-tx0, dty = ty1-ty0,
        nx0 = x0, nx1 = x1, ny0 = y0, ny1 = y1,
        tnx0 = tx0, tnx1 = tx1, tny0 = ty0, tny1 = ty1,
        &xleft = xdir?nx0:nx1, &yleft = xdir?ny0:ny1, &xright = xdir?nx1:nx0, &yright = xdir?ny1:ny0,
        &txleft = xdir?tnx0:tnx1, &tyleft = xdir?tny0:tny1, &txright = xdir?tnx1:tnx0, &tyright = xdir?tny1:tny0,
        &xup = ydir?nx0:nx1, &yup = ydir?ny0:ny1, &xdown = ydir?nx1:nx0, &ydown = ydir?ny1:ny0,
        &txup = ydir?tnx0:tnx1, &tyup = ydir?tny0:tny1, &txdown = ydir?tnx1:tnx0, &tydown = ydir?tny1:tny0;
      if (xright<0 || xleft>=width()) return *this;
      if (xleft<0) {
        const float D = (float)xright - xleft;
        yleft-=(int)((float)xleft*((float)yright - yleft)/D);
        txleft-=(int)((float)xleft*((float)txright - txleft)/D);
        tyleft-=(int)((float)xleft*((float)tyright - tyleft)/D);
        xleft = 0;
      }
      if (xright>=width()) {
        const float d = (float)xright - width(), D = (float)xright - xleft;
        yright-=(int)(d*((float)yright - yleft)/D);
        txright-=(int)(d*((float)txright - txleft)/D);
        tyright-=(int)(d*((float)tyright - tyleft)/D);
        xright = width() - 1;
      }
      if (ydown<0 || yup>=height()) return *this;
      if (yup<0) {
        const float D = (float)ydown - yup;
        xup-=(int)((float)yup*((float)xdown - xup)/D);
        txup-=(int)((float)yup*((float)txdown - txup)/D);
        tyup-=(int)((float)yup*((float)tydown - tyup)/D);
        yup = 0;
      }
      if (ydown>=height()) {
        const float d = (float)ydown - height(), D = (float)ydown - yup;
        xdown-=(int)(d*((float)xdown - xup)/D);
        txdown-=(int)(d*((float)txdown - txup)/D);
        tydown-=(int)(d*((float)tydown - tyup)/D);
        ydown = height() - 1;
      }
      T *ptrd0 = data(nx0,ny0);
      int dx = xright - xleft, dy = ydown - yup;
      const bool steep = dy>dx;
      if (steep) cimg::swap(nx0,ny0,nx1,ny1,dx,dy);
      const long
        offx = (nx0<nx1?1:-1)*(steep?width():1),
        offy = (ny0<ny1?1:-1)*(steep?1:width()),
        ndx = dx>0?dx:1;
      const unsigned long wh = (unsigned long)_width*_height;

      if (opacity>=1) {
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          if (pattern&hatch) {
            T *ptrd = ptrd0;
            const int tx = tx0 + x*dtx/ndx, ty = ty0 + x*dty/ndx;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)texture(tx,ty,0,c); ptrd+=wh; }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          T *ptrd = ptrd0;
          const int tx = tx0 + x*dtx/ndx, ty = ty0 + x*dty/ndx;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)texture(tx,ty,0,c); ptrd+=wh; }
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        }
      } else {
        const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          T *ptrd = ptrd0;
          if (pattern&hatch) {
            const int tx = tx0 + x*dtx/ndx, ty = ty0 + x*dty/ndx;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity*texture(tx,ty,0,c) + *ptrd*copacity); ptrd+=wh; }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          T *ptrd = ptrd0;
          const int tx = tx0 + x*dtx/ndx, ty = ty0 + x*dty/ndx;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity*texture(tx,ty,0,c) + *ptrd*copacity); ptrd+=wh; }
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        }
      }
      return *this;
    }
# 31078 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_line(const int x0, const int y0, const float z0,
                       const int x1, const int y1, const float z1,
                       const CImg<tc>& texture,
                       const int tx0, const int ty0,
                       const int tx1, const int ty1,
                       const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) {
      if (is_empty() && z0<=0 && z1<=0) return *this;
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture))
        return draw_line(x0,y0,z0,x1,y1,z1,+texture,tx0,ty0,tx1,ty1,opacity,pattern,init_hatch);
      static unsigned int hatch = ~0U - (~0U>>1);
      if (init_hatch) hatch = ~0U - (~0U>>1);
      const bool xdir = x0<x1, ydir = y0<y1;
      int
        nx0 = x0, nx1 = x1, ny0 = y0, ny1 = y1,
        &xleft = xdir?nx0:nx1, &yleft = xdir?ny0:ny1,
        &xright = xdir?nx1:nx0, &yright = xdir?ny1:ny0,
        &xup = ydir?nx0:nx1, &yup = ydir?ny0:ny1,
        &xdown = ydir?nx1:nx0, &ydown = ydir?ny1:ny0;
      float
        Tx0 = tx0/z0, Tx1 = tx1/z1,
        Ty0 = ty0/z0, Ty1 = ty1/z1,
        Z0 = 1/z0, Z1 = 1/z1,
        dz = Z1 - Z0, dtx = Tx1 - Tx0, dty = Ty1 - Ty0,
        tnx0 = Tx0, tnx1 = Tx1, tny0 = Ty0, tny1 = Ty1, nz0 = Z0, nz1 = Z1,
        &zleft = xdir?nz0:nz1, &txleft = xdir?tnx0:tnx1, &tyleft = xdir?tny0:tny1,
        &zright = xdir?nz1:nz0, &txright = xdir?tnx1:tnx0, &tyright = xdir?tny1:tny0,
        &zup = ydir?nz0:nz1, &txup = ydir?tnx0:tnx1, &tyup = ydir?tny0:tny1,
        &zdown = ydir?nz1:nz0, &txdown = ydir?tnx1:tnx0, &tydown = ydir?tny1:tny0;
      if (xright<0 || xleft>=width()) return *this;
      if (xleft<0) {
        const float D = (float)xright - xleft;
        yleft-=(int)((float)xleft*((float)yright - yleft)/D);
        zleft-=(float)xleft*(zright - zleft)/D;
        txleft-=(float)xleft*(txright - txleft)/D;
        tyleft-=(float)xleft*(tyright - tyleft)/D;
        xleft = 0;
      }
      if (xright>=width()) {
        const float d = (float)xright - width(), D = (float)xright - xleft;
        yright-=(int)(d*((float)yright - yleft)/D);
        zright-=d*(zright - zleft)/D;
        txright-=d*(txright - txleft)/D;
        tyright-=d*(tyright - tyleft)/D;
        xright = width() - 1;
      }
      if (ydown<0 || yup>=height()) return *this;
      if (yup<0) {
        const float D = (float)ydown - yup;
        xup-=(int)((float)yup*((float)xdown - xup)/D);
        zup-=(float)yup*(zdown - zup)/D;
        txup-=(float)yup*(txdown - txup)/D;
        tyup-=(float)yup*(tydown - tyup)/D;
        yup = 0;
      }
      if (ydown>=height()) {
        const float d = (float)ydown - height(), D = (float)ydown - yup;
        xdown-=(int)(d*((float)xdown - xup)/D);
        zdown-=d*(zdown - zup)/D;
        txdown-=d*(txdown - txup)/D;
        tydown-=d*(tydown - tyup)/D;
        ydown = height() - 1;
      }
      T *ptrd0 = data(nx0,ny0);
      int dx = xright - xleft, dy = ydown - yup;
      const bool steep = dy>dx;
      if (steep) cimg::swap(nx0,ny0,nx1,ny1,dx,dy);
      const long
        offx = (nx0<nx1?1:-1)*(steep?width():1),
        offy = (ny0<ny1?1:-1)*(steep?1:width()),
        ndx = dx>0?dx:1;
      const unsigned long wh = (unsigned long)_width*_height;

      if (opacity>=1) {
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          if (pattern&hatch) {
            const float z = Z0 + x*dz/ndx, tx = Tx0 + x*dtx/ndx, ty = Ty0 + x*dty/ndx;
            T *ptrd = ptrd0; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)texture((int)(tx/z),(int)(ty/z),0,c); ptrd+=wh; }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          const float z = Z0 + x*dz/ndx, tx = Tx0 + x*dtx/ndx, ty = Ty0 + x*dty/ndx;
          T *ptrd = ptrd0; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)texture((int)(tx/z),(int)(ty/z),0,c); ptrd+=wh; }
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        }
      } else {
        const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          if (pattern&hatch) {
            const float z = Z0 + x*dz/ndx, tx = Tx0 + x*dtx/ndx, ty = Ty0 + x*dty/ndx;
            T *ptrd = ptrd0;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)(nopacity*texture((int)(tx/z),(int)(ty/z),0,c) + *ptrd*copacity); ptrd+=wh;
            }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          const float z = Z0 + x*dz/ndx, tx = Tx0 + x*dtx/ndx, ty = Ty0 + x*dty/ndx;
          T *ptrd = ptrd0;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity*texture((int)(tx/z),(int)(ty/z),0,c) + *ptrd*copacity); ptrd+=wh; }
          ptrd0+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; error+=dx; }
        }
      }
      return *this;
    }
# 31214 "../src/CImg.h"
    template<typename tz, typename tc>
    CImg<T>& draw_line(CImg<tz>& zbuffer,
                       const int x0, const int y0, const float z0,
                       const int x1, const int y1, const float z1,
                       const CImg<tc>& texture,
                       const int tx0, const int ty0,
                       const int tx1, const int ty1,
                       const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) {
      typedef typename cimg::superset<tz,float>::type tzfloat;
      if (is_empty() || z0<=0 || z1<=0) return *this;
      if (!is_sameXY(zbuffer))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    zbuffer._width,zbuffer._height,zbuffer._depth,zbuffer._spectrum,zbuffer._data);
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture))
        return draw_line(zbuffer,x0,y0,z0,x1,y1,z1,+texture,tx0,ty0,tx1,ty1,opacity,pattern,init_hatch);
      static unsigned int hatch = ~0U - (~0U>>1);
      if (init_hatch) hatch = ~0U - (~0U>>1);
      const bool xdir = x0<x1, ydir = y0<y1;
      int
        nx0 = x0, nx1 = x1, ny0 = y0, ny1 = y1,
        &xleft = xdir?nx0:nx1, &yleft = xdir?ny0:ny1,
        &xright = xdir?nx1:nx0, &yright = xdir?ny1:ny0,
        &xup = ydir?nx0:nx1, &yup = ydir?ny0:ny1,
        &xdown = ydir?nx1:nx0, &ydown = ydir?ny1:ny0;
      float
        Tx0 = tx0/z0, Tx1 = tx1/z1,
        Ty0 = ty0/z0, Ty1 = ty1/z1,
        dtx = Tx1 - Tx0, dty = Ty1 - Ty0,
        tnx0 = Tx0, tnx1 = Tx1, tny0 = Ty0, tny1 = Ty1,
        &txleft = xdir?tnx0:tnx1, &tyleft = xdir?tny0:tny1,
        &txright = xdir?tnx1:tnx0, &tyright = xdir?tny1:tny0,
        &txup = ydir?tnx0:tnx1, &tyup = ydir?tny0:tny1,
        &txdown = ydir?tnx1:tnx0, &tydown = ydir?tny1:tny0;
      tzfloat
        Z0 = 1/(tzfloat)z0, Z1 = 1/(tzfloat)z1,
        dz = Z1 - Z0, nz0 = Z0, nz1 = Z1,
        &zleft = xdir?nz0:nz1,
        &zright = xdir?nz1:nz0,
        &zup = ydir?nz0:nz1,
        &zdown = ydir?nz1:nz0;
      if (xright<0 || xleft>=width()) return *this;
      if (xleft<0) {
        const float D = (float)xright - xleft;
        yleft-=(int)((float)xleft*((float)yright - yleft)/D);
        zleft-=(float)xleft*(zright - zleft)/D;
        txleft-=(float)xleft*(txright - txleft)/D;
        tyleft-=(float)xleft*(tyright - tyleft)/D;
        xleft = 0;
      }
      if (xright>=width()) {
        const float d = (float)xright - width(), D = (float)xright - xleft;
        yright-=(int)(d*((float)yright - yleft)/D);
        zright-=d*(zright - zleft)/D;
        txright-=d*(txright - txleft)/D;
        tyright-=d*(tyright - tyleft)/D;
        xright = width()-1;
      }
      if (ydown<0 || yup>=height()) return *this;
      if (yup<0) {
        const float D = (float)ydown - yup;
        xup-=(int)((float)yup*((float)xdown - xup)/D);
        zup-=yup*(zdown - zup)/D;
        txup-=yup*(txdown - txup)/D;
        tyup-=yup*(tydown - tyup)/D;
        yup = 0;
      }
      if (ydown>=height()) {
        const float d = (float)ydown - height(), D = (float)ydown - yup;
        xdown-=(int)(d*((float)xdown - xup)/D);
        zdown-=d*(zdown - zup)/D;
        txdown-=d*(txdown - txup)/D;
        tydown-=d*(tydown - tyup)/D;
        ydown = height()-1;
      }
      T *ptrd0 = data(nx0,ny0);
      tz *ptrz = zbuffer.data(nx0,ny0);
      int dx = xright - xleft, dy = ydown - yup;
      const bool steep = dy>dx;
      if (steep) cimg::swap(nx0,ny0,nx1,ny1,dx,dy);
      const long
        offx = (nx0<nx1?1:-1)*(steep?width():1),
        offy = (ny0<ny1?1:-1)*(steep?1:width()),
        ndx = dx>0?dx:1;
      const unsigned long wh = (unsigned long)_width*_height;

      if (opacity>=1) {
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          if (pattern&hatch) {
            const tzfloat z = Z0 + x*dz/ndx;
            if (z>=(tzfloat)*ptrz) {
              *ptrz = (tz)z;
              const float tx = Tx0 + x*dtx/ndx, ty = Ty0 + x*dty/ndx;
              T *ptrd = ptrd0; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)texture((int)(tx/z),(int)(ty/z),0,c); ptrd+=wh; }
            }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx; ptrz+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; ptrz+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          const tzfloat z = Z0 + x*dz/ndx;
          if (z>=(tzfloat)*ptrz) {
            *ptrz = (tz)z;
            const float tx = Tx0 + x*dtx/ndx, ty = Ty0 + x*dty/ndx;
            T *ptrd = ptrd0; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)texture((int)(tx/z),(int)(ty/z),0,c); ptrd+=wh; }
          }
          ptrd0+=offx; ptrz+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; ptrz+=offy; error+=dx; }
        }
      } else {
        const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
        if (~pattern) for (int error = dx>>1, x = 0; x<=dx; ++x) {
          if (pattern&hatch) {
            const tzfloat z = Z0 + x*dz/ndx;
            if (z>=(tzfloat)*ptrz) {
              *ptrz = (tz)z;
              const float tx = Tx0 + x*dtx/ndx, ty = Ty0 + x*dty/ndx;
              T *ptrd = ptrd0;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                *ptrd = (T)(nopacity*texture((int)(tx/z),(int)(ty/z),0,c) + *ptrd*copacity); ptrd+=wh;
              }
            }
          }
          hatch>>=1; if (!hatch) hatch = ~0U - (~0U>>1);
          ptrd0+=offx; ptrz+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; ptrz+=offy; error+=dx; }
        } else for (int error = dx>>1, x = 0; x<=dx; ++x) {
          const tzfloat z = Z0 + x*dz/ndx;
          if (z>=(tzfloat)*ptrz) {
            *ptrz = (tz)z;
            const float tx = Tx0 + x*dtx/ndx, ty = Ty0 + x*dty/ndx;
            T *ptrd = ptrd0;
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)(nopacity*texture((int)(tx/z),(int)(ty/z),0,c) + *ptrd*copacity); ptrd+=wh;
            }
          }
          ptrd0+=offx; ptrz+=offx;
          if ((error-=dy)<0) { ptrd0+=offy; ptrz+=offy; error+=dx; }
        }
      }
      return *this;
    }
# 31376 "../src/CImg.h"
    template<typename t, typename tc>
    CImg<T>& draw_line(const CImg<t>& points,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const bool init_hatch=true) {
      if (is_empty() || !points || points._width<2) return *this;
      bool ninit_hatch = init_hatch;
      switch (points._height) {
      case 0 : case 1 :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_line(): Invalid specified point set (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    points._width,points._height,points._depth,points._spectrum,points._data);

      case 2 : {
        const int x0 = (int)points(0,0), y0 = (int)points(0,1);
        int ox = x0, oy = y0;
        for (unsigned int i = 1; i<points._width; ++i) {
          const int x = (int)points(i,0), y = (int)points(i,1);
          draw_line(ox,oy,x,y,color,opacity,pattern,ninit_hatch);
          ninit_hatch = false;
          ox = x; oy = y;
        }
      } break;
      default : {
        const int x0 = (int)points(0,0), y0 = (int)points(0,1), z0 = (int)points(0,2);
        int ox = x0, oy = y0, oz = z0;
        for (unsigned int i = 1; i<points._width; ++i) {
          const int x = (int)points(i,0), y = (int)points(i,1), z = (int)points(i,2);
          draw_line(ox,oy,oz,x,y,z,color,opacity,pattern,ninit_hatch);
          ninit_hatch = false;
          ox = x; oy = y; oz = z;
        }
      }
      }
      return *this;
    }
# 31425 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_arrow(const int x0, const int y0,
                        const int x1, const int y1,
                        const tc *const color, const float opacity=1,
                        const float angle=30, const float length=-10,
                        const unsigned int pattern=~0U) {
      if (is_empty()) return *this;
      const float u = (float)(x0 - x1), v = (float)(y0 - y1), sq = u*u + v*v,
        deg = (float)(angle*cimg::PI/180), ang = (sq>0)?(float)std::atan2(v,u):0.0f,
        l = (length>=0)?length:-length*(float)std::sqrt(sq)/100;
      if (sq>0) {
        const float
            cl = (float)std::cos(ang - deg), sl = (float)std::sin(ang - deg),
            cr = (float)std::cos(ang + deg), sr = (float)std::sin(ang + deg);
        const int
          xl = x1 + (int)(l*cl), yl = y1 + (int)(l*sl),
          xr = x1 + (int)(l*cr), yr = y1 + (int)(l*sr),
          xc = x1 + (int)((l+1)*(cl+cr))/2, yc = y1 + (int)((l+1)*(sl+sr))/2;
        draw_line(x0,y0,xc,yc,color,opacity,pattern).draw_triangle(x1,y1,xl,yl,xr,yr,color,opacity);
      } else draw_point(x0,y0,color,opacity);
      return *this;
    }
# 31482 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_spline(const int x0, const int y0, const float u0, const float v0,
                         const int x1, const int y1, const float u1, const float v1,
                         const tc *const color, const float opacity=1,
                         const float precision=0.25, const unsigned int pattern=~0U,
                         const bool init_hatch=true) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_spline(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (x0==x1 && y0==y1) return draw_point(x0,y0,color,opacity);
      bool ninit_hatch = init_hatch;
      const float
        ax = u0 + u1 + 2*(x0 - x1),
        bx = 3*(x1 - x0) - 2*u0 - u1,
        ay = v0 + v1 + 2*(y0 - y1),
        by = 3*(y1 - y0) - 2*v0 - v1,
        _precision = 1/(std::sqrt(cimg::sqr((float)x0-x1)+cimg::sqr((float)y0-y1))*(precision>0?precision:1));
      int ox = x0, oy = y0;
      for (float t = 0; t<1; t+=_precision) {
        const float t2 = t*t, t3 = t2*t;
        const int
          nx = (int)(ax*t3 + bx*t2 + u0*t + x0),
          ny = (int)(ay*t3 + by*t2 + v0*t + y0);
        draw_line(ox,oy,nx,ny,color,opacity,pattern,ninit_hatch);
        ninit_hatch = false;
        ox = nx; oy = ny;
      }
      return draw_line(ox,oy,x1,y1,color,opacity,pattern,false);
    }






    template<typename tc>
    CImg<T>& draw_spline(const int x0, const int y0, const int z0, const float u0, const float v0, const float w0,
                         const int x1, const int y1, const int z1, const float u1, const float v1, const float w1,
                         const tc *const color, const float opacity=1,
                         const float precision=4, const unsigned int pattern=~0U,
                         const bool init_hatch=true) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_spline(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (x0==x1 && y0==y1 && z0==z1) return draw_point(x0,y0,z0,color,opacity);
      bool ninit_hatch = init_hatch;
      const float
        ax = u0 + u1 + 2*(x0 - x1),
        bx = 3*(x1 - x0) - 2*u0 - u1,
        ay = v0 + v1 + 2*(y0 - y1),
        by = 3*(y1 - y0) - 2*v0 - v1,
        az = w0 + w1 + 2*(z0 - z1),
        bz = 3*(z1 - z0) - 2*w0 - w1,
        _precision = 1/(std::sqrt(cimg::sqr(x0-x1)+cimg::sqr(y0-y1))*(precision>0?precision:1));
      int ox = x0, oy = y0, oz = z0;
      for (float t = 0; t<1; t+=_precision) {
        const float t2 = t*t, t3 = t2*t;
        const int
          nx = (int)(ax*t3 + bx*t2 + u0*t + x0),
          ny = (int)(ay*t3 + by*t2 + v0*t + y0),
          nz = (int)(az*t3 + bz*t2 + w0*t + z0);
        draw_line(ox,oy,oz,nx,ny,nz,color,opacity,pattern,ninit_hatch);
        ninit_hatch = false;
        ox = nx; oy = ny; oz = nz;
      }
      return draw_line(ox,oy,oz,x1,y1,z1,color,opacity,pattern,false);
    }
# 31574 "../src/CImg.h"
    template<typename t>
    CImg<T>& draw_spline(const int x0, const int y0, const float u0, const float v0,
                         const int x1, const int y1, const float u1, const float v1,
                         const CImg<t>& texture,
                         const int tx0, const int ty0, const int tx1, const int ty1,
                         const float opacity=1,
                         const float precision=4, const unsigned int pattern=~0U,
                         const bool init_hatch=true) {
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_spline(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_empty()) return *this;
      if (is_overlapped(texture))
        return draw_spline(x0,y0,u0,v0,x1,y1,u1,v1,+texture,tx0,ty0,tx1,ty1,precision,opacity,pattern,init_hatch);
      if (x0==x1 && y0==y1) return draw_point(x0,y0,texture.get_vector_at(x0,y0),opacity);
      bool ninit_hatch = init_hatch;
      const float
        ax = u0 + u1 + 2*(x0 - x1),
        bx = 3*(x1 - x0) - 2*u0 - u1,
        ay = v0 + v1 + 2*(y0 - y1),
        by = 3*(y1 - y0) - 2*v0 - v1,
        _precision = 1/(std::sqrt(cimg::sqr(x0-x1)+cimg::sqr(y0-y1))*(precision>0?precision:1));
      int ox = x0, oy = y0, otx = tx0, oty = ty0;
      for (float t1 = 0; t1<1; t1+=_precision) {
        const float t2 = t1*t1, t3 = t2*t1;
        const int
          nx = (int)(ax*t3 + bx*t2 + u0*t1 + x0),
          ny = (int)(ay*t3 + by*t2 + v0*t1 + y0),
          ntx = tx0 + (int)((tx1-tx0)*t1),
          nty = ty0 + (int)((ty1-ty0)*t1);
        draw_line(ox,oy,nx,ny,texture,otx,oty,ntx,nty,opacity,pattern,ninit_hatch);
        ninit_hatch = false;
        ox = nx; oy = ny; otx = ntx; oty = nty;
      }
      return draw_line(ox,oy,x1,y1,texture,otx,oty,tx1,ty1,opacity,pattern,false);
    }
# 31624 "../src/CImg.h"
    template<typename tp, typename tt, typename tc>
    CImg<T>& draw_spline(const CImg<tp>& points, const CImg<tt>& tangents,
                         const tc *const color, const float opacity=1,
                         const bool is_closed_set=false, const float precision=4,
                         const unsigned int pattern=~0U, const bool init_hatch=true) {
      if (is_empty() || !points || !tangents || points._width<2 || tangents._width<2) return *this;
      bool ninit_hatch = init_hatch;
      switch (points._height) {
      case 0 : case 1 :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_spline(): Invalid specified point set (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    points._width,points._height,points._depth,points._spectrum,points._data);

      case 2 : {
        const int x0 = (int)points(0,0), y0 = (int)points(0,1);
        const float u0 = (float)tangents(0,0), v0 = (float)tangents(0,1);
        int ox = x0, oy = y0;
        float ou = u0, ov = v0;
        for (unsigned int i = 1; i<points._width; ++i) {
          const int x = (int)points(i,0), y = (int)points(i,1);
          const float u = (float)tangents(i,0), v = (float)tangents(i,1);
          draw_spline(ox,oy,ou,ov,x,y,u,v,color,precision,opacity,pattern,ninit_hatch);
          ninit_hatch = false;
          ox = x; oy = y; ou = u; ov = v;
        }
        if (is_closed_set) draw_spline(ox,oy,ou,ov,x0,y0,u0,v0,color,precision,opacity,pattern,false);
      } break;
      default : {
        const int x0 = (int)points(0,0), y0 = (int)points(0,1), z0 = (int)points(0,2);
        const float u0 = (float)tangents(0,0), v0 = (float)tangents(0,1), w0 = (float)tangents(0,2);
        int ox = x0, oy = y0, oz = z0;
        float ou = u0, ov = v0, ow = w0;
        for (unsigned int i = 1; i<points._width; ++i) {
          const int x = (int)points(i,0), y = (int)points(i,1), z = (int)points(i,2);
          const float u = (float)tangents(i,0), v = (float)tangents(i,1), w = (float)tangents(i,2);
          draw_spline(ox,oy,oz,ou,ov,ow,x,y,z,u,v,w,color,opacity,pattern,ninit_hatch);
          ninit_hatch = false;
          ox = x; oy = y; oz = z; ou = u; ov = v; ow = w;
        }
        if (is_closed_set) draw_spline(ox,oy,oz,ou,ov,ow,x0,y0,z0,u0,v0,w0,color,precision,opacity,pattern,false);
      }
      }
      return *this;
    }





    template<typename tp, typename tc>
    CImg<T>& draw_spline(const CImg<tp>& points,
                         const tc *const color, const float opacity=1,
                         const bool is_closed_set=false, const float precision=4,
                         const unsigned int pattern=~0U, const bool init_hatch=true) {
      if (is_empty() || !points || points._width<2) return *this;
      CImg<Tfloat> tangents;
      switch (points._height) {
      case 0 : case 1 :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_spline(): Invalid specified point set (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    points._width,points._height,points._depth,points._spectrum,points._data);
      case 2 : {
        tangents.assign(points._width,points._height);
        for (int p = 0; p<(int)((points)._width); ++p) {
          const unsigned int
            p0 = is_closed_set?(p+points._width-1)%points._width:(p?p-1:0),
            p1 = is_closed_set?(p+1)%points._width:(p+1<points._width?p+1:p);
          const float
            x = (float)points(p,0),
            y = (float)points(p,1),
            x0 = (float)points(p0,0),
            y0 = (float)points(p0,1),
            x1 = (float)points(p1,0),
            y1 = (float)points(p1,1),
            u0 = x - x0,
            v0 = y - y0,
            n0 = 1e-8f + (float)std::sqrt(u0*u0 + v0*v0),
            u1 = x1 - x,
            v1 = y1 - y,
            n1 = 1e-8f + (float)std::sqrt(u1*u1 + v1*v1),
            u = u0/n0 + u1/n1,
            v = v0/n0 + v1/n1,
            n = 1e-8f + (float)std::sqrt(u*u + v*v),
            fact = 0.5f*(n0 + n1);
          tangents(p,0) = (Tfloat)(fact*u/n);
          tangents(p,1) = (Tfloat)(fact*v/n);
        }
      } break;
      default : {
        tangents.assign(points._width,points._height);
        for (int p = 0; p<(int)((points)._width); ++p) {
          const unsigned int
            p0 = is_closed_set?(p+points._width-1)%points._width:(p?p-1:0),
            p1 = is_closed_set?(p+1)%points._width:(p+1<points._width?p+1:p);
          const float
            x = (float)points(p,0),
            y = (float)points(p,1),
            z = (float)points(p,2),
            x0 = (float)points(p0,0),
            y0 = (float)points(p0,1),
            z0 = (float)points(p0,2),
            x1 = (float)points(p1,0),
            y1 = (float)points(p1,1),
            z1 = (float)points(p1,2),
            u0 = x - x0,
            v0 = y - y0,
            w0 = z - z0,
            n0 = 1e-8f + (float)std::sqrt(u0*u0 + v0*v0 + w0*w0),
            u1 = x1 - x,
            v1 = y1 - y,
            w1 = z1 - z,
            n1 = 1e-8f + (float)std::sqrt(u1*u1 + v1*v1 + w1*w1),
            u = u0/n0 + u1/n1,
            v = v0/n0 + v1/n1,
            w = w0/n0 + w1/n1,
            n = 1e-8f + (float)std::sqrt(u*u + v*v + w*w),
            fact = 0.5f*(n0 + n1);
          tangents(p,0) = (Tfloat)(fact*u/n);
          tangents(p,1) = (Tfloat)(fact*v/n);
          tangents(p,2) = (Tfloat)(fact*w/n);
        }
      }
      }
      return draw_spline(points,tangents,color,opacity,is_closed_set,precision,pattern,init_hatch);
    }
# 32047 "../src/CImg.h"
    template<typename tc>
    CImg<T>& _draw_triangle(const int x0, const int y0,
                            const int x1, const int y1,
                            const int x2, const int y2,
                            const tc *const color, const float opacity,
                            const float brightness) {
      const float _sc_nopacity = cimg::abs((float)opacity), _sc_copacity = 1 - cimg::max((float)opacity,0); const unsigned long _sc_whd = (unsigned long)_width*_height*_depth;
      const float nbrightness = brightness<0?0:(brightness>2?2:brightness);
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2);
      if (ny0<height() && ny2>=0) {
        if ((nx1 - nx0)*(ny2 - ny0) - (nx2 - nx0)*(ny1 - ny0)<0)
          for (int y = ny0<0?0:ny0, xr = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), xl = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), _sxn=1, _sxr=1, _sxl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter = (_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errr = _dyr/2, _errl = _dyl/2, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn); _counter>=0; --_counter, ++y, xr+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), xl+=(y!=ny1)?_rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xl))
            _draw_scanline(xl,xr,y,color,opacity,nbrightness,_sc_nopacity,_sc_copacity,_sc_whd);
        else
          for (int y = ny0<0?0:ny0, xr = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), xl = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), _sxn=1, _sxr=1, _sxl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter = (_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errr = _dyr/2, _errl = _dyl/2, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn); _counter>=0; --_counter, ++y, xr+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), xl+=(y!=ny1)?_rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xl))
            _draw_scanline(xr,xl,y,color,opacity,nbrightness,_sc_nopacity,_sc_copacity,_sc_whd);
      }
      return *this;
    }
# 32081 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const tc *const color, const float opacity=1) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      _draw_triangle(x0,y0,x1,y1,x2,y2,color,opacity,1);
      return *this;
    }
# 32107 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const tc *const color, const float opacity,
                           const unsigned int pattern) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      draw_line(x0,y0,x1,y1,color,opacity,pattern,true).
        draw_line(x1,y1,x2,y2,color,opacity,pattern,false).
        draw_line(x2,y2,x0,y0,color,opacity,pattern,false);
      return *this;
    }
# 32140 "../src/CImg.h"
    template<typename tz, typename tc>
    CImg<T>& draw_triangle(CImg<tz>& zbuffer,
                           const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const tc *const color, const float opacity=1,
                           const float brightness=1) {
      typedef typename cimg::superset<tz,float>::type tzfloat;
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (!is_sameXY(zbuffer))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    zbuffer._width,zbuffer._height,zbuffer._depth,zbuffer._spectrum,zbuffer._data);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float
        nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0),
        nbrightness = brightness<0?0:(brightness>2?2:brightness);
      const long whd = (long)_width*_height*_depth, offx = _spectrum*whd;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2;
      tzfloat nz0 = 1/(tzfloat)z0, nz1 = 1/(tzfloat)z1, nz2 = 1/(tzfloat)z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,nz0,nz2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,nz1,nz2);
      if (ny0>=height() || ny2<0) return *this;
      tzfloat
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), _sxn=1, _sxr=1, _sxl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter = (_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errr = _dyr/2, _errl = _dyl/2, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), xleft0+=(y!=ny1)?_rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0)) {
        if (y==ny1) { zl = nz1; pzl = pzn; }
        int xleft = xleft0, xright = xright0;
        tzfloat zleft = zl, zright = zr;
        if (xright<xleft) cimg::swap(xleft,xright,zleft,zright);
        const int dx = xright - xleft;
        const tzfloat pentez = (zright - zleft)/dx;
        if (xleft<0 && dx) zleft-=xleft*(zright - zleft)/dx;
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width() - 1;
        T* ptrd = data(xleft,y,0,0);
        tz *ptrz = zbuffer.data(xleft,y);
        if (opacity>=1) {
          if (nbrightness==1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
              const tc *col = color; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; }
              ptrd-=offx;
            }
            zleft+=pentez;
          } else if (nbrightness<1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
              const tc *col = color; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nbrightness*(*col++)); ptrd+=whd; }
              ptrd-=offx;
            }
            zleft+=pentez;
          } else for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
              const tc *col = color;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)((2-nbrightness)**(col++) + (nbrightness-1)*maxval); ptrd+=whd; }
              ptrd-=offx;
            }
            zleft+=pentez;
          }
        } else {
          if (nbrightness==1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
              const tc *col = color; for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity**(col++) + *ptrd*copacity); ptrd+=whd; }
              ptrd-=offx;
            }
            zleft+=pentez;
          } else if (nbrightness<1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
              const tc *col = color;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity*nbrightness**(col++) + *ptrd*copacity); ptrd+=whd; }
              ptrd-=offx;
            }
            zleft+=pentez;
          } else for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
              const tc *col = color;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)((2-nbrightness)**(col++) + (nbrightness-1)*maxval);
                *ptrd = (T)(nopacity*val + *ptrd*copacity);
                ptrd+=whd;
              }
              ptrd-=offx;
            }
            zleft+=pentez;
          }
        }
        zr+=pzr; zl+=pzl;
      }
      return *this;
    }
# 32261 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const tc *const color,
                           const float brightness0,
                           const float brightness1,
                           const float brightness2,
                           const float opacity=1) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, offx = _spectrum*whd-1;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        nc0 = (int)((brightness0<0.0f?0.0f:(brightness0>2.0f?2.0f:brightness0))*256.0f),
        nc1 = (int)((brightness1<0.0f?0.0f:(brightness1>2.0f?2.0f:brightness1))*256.0f),
        nc2 = (int)((brightness2<0.0f?0.0f:(brightness2>2.0f?2.0f:brightness2))*256.0f);
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nc0,nc1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,nc0,nc2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,nc1,nc2);
      if (ny0>=height() || ny2<0) return *this;
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), cright0 = ny0>=0?nc0:(nc0-ny0*(nc2-nc0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), cleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nc1:nc0):(nc0-ny0*(nc1-nc0)/(ny1-ny0))):(nc1-ny1*(nc2-nc1)/(ny2-ny1)), _sxn=1, _scn=1, _sxr=1, _scr=1, _sxl=1, _scl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dcn = nc2>nc1?nc2-nc1:(_scn=-1,nc1-nc2), _dcr = nc2>nc0?nc2-nc0:(_scr=-1,nc0-nc2), _dcl = nc1>nc0?nc1-nc0:(_scl=-1,nc0-nc1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dcn-=_dyn?_dyn*(_dcn/_dyn):0, _dcr-=_dyr?_dyr*(_dcr/_dyr):0, _dcl-=_dyl?_dyl*(_dcl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errcn = _errn, _errr = _dyr/2, _errcr = _errr, _errl = _dyl/2, _errcl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rcn = _dyn?(nc2-nc1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rcr = _dyr?(nc2-nc0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rcl = (ny0!=ny1 && ny1>0)?(_dyl?(nc1-nc0)/_dyl:0): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), cright0+=_rcr+((_errcr-=_dcr)<0?_errcr+=_dyr,_scr:0), xleft0+=(y!=ny1)?(cleft0+=_rcl+((_errcl-=_dcl)<0?(_errcl+=_dyl,_scl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcl=_rcn, cleft0=nc1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0)) {
        int xleft = xleft0, xright = xright0, cleft = cleft0, cright = cright0;
        if (xright<xleft) cimg::swap(xleft,xright,cleft,cright);
        const int
          dx = xright - xleft,
          dc = cright>cleft?cright - cleft:cleft - cright,
          rc = dx?(cright - cleft)/dx:0,
          sc = cright>cleft?1:-1,
          ndc = dc-(dx?dx*(dc/dx):0);
        int errc = dx>>1;
        if (xleft<0 && dx) cleft-=xleft*(cright - cleft)/dx;
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width() - 1;
        T* ptrd = data(xleft,y);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x) {
          const tc *col = color;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            *ptrd = (T)(cleft<256?cleft**(col++)/256:((512-cleft)**(col++)+(cleft-256)*maxval)/256);
            ptrd+=whd;
          }
          ptrd-=offx;
          cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
        } else for (int x = xleft; x<=xright; ++x) {
          const tc *col = color;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const T val = (T)(cleft<256?cleft**(col++)/256:((512-cleft)**(col++)+(cleft-256)*maxval)/256);
            *ptrd = (T)(nopacity*val + *ptrd*copacity);
            ptrd+=whd;
          }
          ptrd-=offx;
          cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
        }
      }
      return *this;
    }


    template<typename tz, typename tc>
    CImg<T>& draw_triangle(CImg<tz>& zbuffer,
                           const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const tc *const color,
                           const float brightness0,
                           const float brightness1,
                           const float brightness2,
                           const float opacity=1) {
      typedef typename cimg::superset<tz,float>::type tzfloat;
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (!is_sameXY(zbuffer))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    zbuffer._width,zbuffer._height,zbuffer._depth,zbuffer._spectrum,zbuffer._data);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, offx = _spectrum*whd;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        nc0 = (int)((brightness0<0.0f?0.0f:(brightness0>2.0f?2.0f:brightness0))*256.0f),
        nc1 = (int)((brightness1<0.0f?0.0f:(brightness1>2.0f?2.0f:brightness1))*256.0f),
        nc2 = (int)((brightness2<0.0f?0.0f:(brightness2>2.0f?2.0f:brightness2))*256.0f);
      tzfloat nz0 = 1/(tzfloat)z0, nz1 = 1/(tzfloat)z1, nz2 = 1/(tzfloat)z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1,nc0,nc1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,nz0,nz2,nc0,nc2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,nz1,nz2,nc1,nc2);
      if (ny0>=height() || ny2<0) return *this;
      tzfloat
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), cright0 = ny0>=0?nc0:(nc0-ny0*(nc2-nc0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), cleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nc1:nc0):(nc0-ny0*(nc1-nc0)/(ny1-ny0))):(nc1-ny1*(nc2-nc1)/(ny2-ny1)), _sxn=1, _scn=1, _sxr=1, _scr=1, _sxl=1, _scl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dcn = nc2>nc1?nc2-nc1:(_scn=-1,nc1-nc2), _dcr = nc2>nc0?nc2-nc0:(_scr=-1,nc0-nc2), _dcl = nc1>nc0?nc1-nc0:(_scl=-1,nc0-nc1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dcn-=_dyn?_dyn*(_dcn/_dyn):0, _dcr-=_dyr?_dyr*(_dcr/_dyr):0, _dcl-=_dyl?_dyl*(_dcl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errcn = _errn, _errr = _dyr/2, _errcr = _errr, _errl = _dyl/2, _errcl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rcn = _dyn?(nc2-nc1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rcr = _dyr?(nc2-nc0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rcl = (ny0!=ny1 && ny1>0)?(_dyl?(nc1-nc0)/_dyl:0): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), cright0+=_rcr+((_errcr-=_dcr)<0?_errcr+=_dyr,_scr:0), xleft0+=(y!=ny1)?(cleft0+=_rcl+((_errcl-=_dcl)<0?(_errcl+=_dyl,_scl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcl=_rcn, cleft0=nc1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0)) {
        if (y==ny1) { zl = nz1; pzl = pzn; }
        int xleft = xleft0, xright = xright0, cleft = cleft0, cright = cright0;
        tzfloat zleft = zl, zright = zr;
        if (xright<xleft) cimg::swap(xleft,xright,zleft,zright,cleft,cright);
        const int
          dx = xright - xleft,
          dc = cright>cleft?cright - cleft:cleft - cright,
          rc = dx?(cright-cleft)/dx:0,
          sc = cright>cleft?1:-1,
          ndc = dc-(dx?dx*(dc/dx):0);
        const tzfloat pentez = (zright - zleft)/dx;
        int errc = dx>>1;
        if (xleft<0 && dx) {
          cleft-=xleft*(cright - cleft)/dx;
          zleft-=xleft*(zright - zleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T *ptrd = data(xleft,y);
        tz *ptrz = zbuffer.data(xleft,y);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x, ++ptrd, ++ptrz) {
            if (zleft>=(tzfloat)*ptrz) {
              *ptrz = (tz)zleft;
              const tc *col = color;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                *ptrd = (T)(cleft<256?cleft**(col++)/256:((512-cleft)**(col++)+(cleft-256)*maxval)/256);
                ptrd+=whd;
              }
              ptrd-=offx;
            }
            zleft+=pentez;
            cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
          } else for (int x = xleft; x<=xright; ++x, ++ptrd, ++ptrz) {
            if (zleft>=(tzfloat)*ptrz) {
              *ptrz = (tz)zleft;
              const tc *col = color;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)(cleft<256?cleft**(col++)/256:((512-cleft)**(col++)+(cleft-256)*maxval)/256);
                *ptrd = (T)(nopacity*val + *ptrd*copacity);
                ptrd+=whd;
              }
              ptrd-=offx;
            }
            zleft+=pentez;
            cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
          }
        zr+=pzr; zl+=pzl;
      }
      return *this;
    }
# 32428 "../src/CImg.h"
    template<typename tc1, typename tc2, typename tc3>
    CImg<T>& draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const tc1 *const color1,
                           const tc2 *const color2,
                           const tc3 *const color3,
                           const float opacity=1) {
      const unsigned char one = 1;
      for (int c = 0; c<(int)((*this)._spectrum); ++c)
        get_shared_channel(c).draw_triangle(x0,y0,x1,y1,x2,y2,&one,color1[c],color2[c],color3[c],opacity);
      return *this;
    }
# 32460 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const float opacity=1,
                           const float brightness=1) {
      if (is_empty()) return *this;
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture))
        return draw_triangle(x0,y0,x1,y1,x2,y2,+texture,tx0,ty0,tx1,ty1,tx2,ty2,opacity,brightness);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float
        nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0),
        nbrightness = brightness<0?0:(brightness>2?2:brightness);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd-1;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        ntx0 = tx0, nty0 = ty0, ntx1 = tx1, nty1 = ty1, ntx2 = tx2, nty2 = ty2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2);
      if (ny0>=height() || ny2<0) return *this;
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), txright0 = ny0>=0?ntx0:(ntx0-ny0*(ntx2-ntx0)/(ny2-ny0)), tyright0 = ny0>=0?nty0:(nty0-ny0*(nty2-nty0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), txleft0 = ny1>=0?(ny0>=0?(ny0==ny1?ntx1:ntx0):(ntx0-ny0*(ntx1-ntx0)/(ny1-ny0))):(ntx1-ny1*(ntx2-ntx1)/(ny2-ny1)), tyleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nty1:nty0):(nty0-ny0*(nty1-nty0)/(ny1-ny0))):(nty1-ny1*(nty2-nty1)/(ny2-ny1)), _sxn=1, _stxn=1, _styn=1, _sxr=1, _stxr=1, _styr=1, _sxl=1, _stxl=1, _styl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dtxn = ntx2>ntx1?ntx2-ntx1:(_stxn=-1,ntx1-ntx2), _dtxr = ntx2>ntx0?ntx2-ntx0:(_stxr=-1,ntx0-ntx2), _dtxl = ntx1>ntx0?ntx1-ntx0:(_stxl=-1,ntx0-ntx1), _dtyn = nty2>nty1?nty2-nty1:(_styn=-1,nty1-nty2), _dtyr = nty2>nty0?nty2-nty0:(_styr=-1,nty0-nty2), _dtyl = nty1>nty0?nty1-nty0:(_styl=-1,nty0-nty1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dtxn-=_dyn?_dyn*(_dtxn/_dyn):0, _dtxr-=_dyr?_dyr*(_dtxr/_dyr):0, _dtxl-=_dyl?_dyl*(_dtxl/_dyl):0, _dtyn-=_dyn?_dyn*(_dtyn/_dyn):0, _dtyr-=_dyr?_dyr*(_dtyr/_dyr):0, _dtyl-=_dyl?_dyl*(_dtyl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errtxn = _errn, _errtyn = _errn, _errr = _dyr/2, _errtxr = _errr, _errtyr = _errr, _errl = _dyl/2, _errtxl = _errl, _errtyl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rtxn = _dyn?(ntx2-ntx1)/_dyn:0, _rtyn = _dyn?(nty2-nty1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rtxr = _dyr?(ntx2-ntx0)/_dyr:0, _rtyr = _dyr?(nty2-nty0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rtxl = (ny0!=ny1 && ny1>0)?(_dyl?(ntx1-ntx0)/_dyl:0): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxn ), _rtyl = (ny0!=ny1 && ny1>0)?(_dyl?(nty1-nty0)/_dyl:0): (_errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), txright0+=_rtxr+((_errtxr-=_dtxr)<0?_errtxr+=_dyr,_stxr:0), tyright0+=_rtyr+((_errtyr-=_dtyr)<0?_errtyr+=_dyr,_styr:0), xleft0+=(y!=ny1)?(txleft0+=_rtxl+((_errtxl-=_dtxl)<0?(_errtxl+=_dyl,_stxl):0), tyleft0+=_rtyl+((_errtyl-=_dtyl)<0?(_errtyl+=_dyl,_styl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxl=_rtxn, txleft0=ntx1, _errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyl=_rtyn, tyleft0=nty1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0))
                                                                                 {
        int
          xleft = xleft0, xright = xright0,
          txleft = txleft0, txright = txright0,
          tyleft = tyleft0, tyright = tyright0;
        if (xright<xleft) cimg::swap(xleft,xright,txleft,txright,tyleft,tyright);
        const int
          dx = xright - xleft,
          dtx = txright>txleft?txright - txleft:txleft - txright,
          dty = tyright>tyleft?tyright - tyleft:tyleft - tyright,
          rtx = dx?(txright - txleft)/dx:0,
          rty = dx?(tyright - tyleft)/dx:0,
          stx = txright>txleft?1:-1,
          sty = tyright>tyleft?1:-1,
          ndtx = dtx - (dx?dx*(dtx/dx):0),
          ndty = dty - (dx?dx*(dty/dx):0);
        int errtx = dx>>1, errty = errtx;
        if (xleft<0 && dx) {
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y,0,0);
        if (opacity>=1) {
          if (nbrightness==1) for (int x = xleft; x<=xright; ++x) {
            const tc *col = texture.data(txleft,tyleft);
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)*col;
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx;
            txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
            tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
          } else if (nbrightness<1) for (int x = xleft; x<=xright; ++x) {
            const tc *col = texture.data(txleft,tyleft);
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)(nbrightness**col);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx;
            txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
            tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
          } else for (int x = xleft; x<=xright; ++x) {
            const tc *col = texture.data(txleft,tyleft);
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)((2-nbrightness)**(col++) + (nbrightness-1)*maxval);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx;
            txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
            tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
          }
        } else {
          if (nbrightness==1) for (int x = xleft; x<=xright; ++x) {
            const tc *col = texture.data(txleft,tyleft);
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)(nopacity**col + *ptrd*copacity);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx;
            txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
            tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
          } else if (nbrightness<1) for (int x = xleft; x<=xright; ++x) {
            const tc *col = texture.data(txleft,tyleft);
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)(nopacity*nbrightness**col + *ptrd*copacity);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx;
            txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
            tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
          } else for (int x = xleft; x<=xright; ++x) {
            const tc *col = texture.data(txleft,tyleft);
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              const T val = (T)((2-nbrightness)**(col++) + (nbrightness-1)*maxval);
              *ptrd = (T)(nopacity*val + *ptrd*copacity);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx;
            txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
            tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
          }
        }
      }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_triangle(const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const float opacity=1,
                           const float brightness=1) {
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture))
        return draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,+texture,tx0,ty0,tx1,ty1,tx2,ty2,opacity,brightness);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float
        nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0),
        nbrightness = brightness<0?0:(brightness>2?2:brightness);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd-1;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2;
      float
        ntx0 = tx0/z0, nty0 = ty0/z0,
        ntx1 = tx1/z1, nty1 = ty1/z1,
        ntx2 = tx2/z2, nty2 = ty2/z2,
        nz0 = 1/z0, nz1 = 1/z1, nz2 = 1/z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nz0,nz1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nz0,nz2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nz1,nz2);
      if (ny0>=height() || ny2<0) return *this;
      float
        ptxl = (ntx1 - ntx0)/(ny1 - ny0),
        ptxr = (ntx2 - ntx0)/(ny2 - ny0),
        ptxn = (ntx2 - ntx1)/(ny2 - ny1),
        ptyl = (nty1 - nty0)/(ny1 - ny0),
        ptyr = (nty2 - nty0)/(ny2 - ny0),
        ptyn = (nty2 - nty1)/(ny2 - ny1),
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        txr = ny0>=0?ntx0:(ntx0 - ny0*(ntx2 - ntx0)/(ny2 - ny0)),
        tyr = ny0>=0?nty0:(nty0 - ny0*(nty2 - nty0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1))),
        txl = ny1>=0?(ny0>=0?ntx0:(ntx0 - ny0*(ntx1 - ntx0)/(ny1 - ny0))):
          (ptxl=ptxn,(ntx1 - ny1*(ntx2 - ntx1)/(ny2 - ny1))),
        tyl = ny1>=0?(ny0>=0?nty0:(nty0 - ny0*(nty1 - nty0)/(ny1 - ny0))):
          (ptyl=ptyn,(nty1 - ny1*(nty2 - nty1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), _sxn=1, _sxr=1, _sxl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter = (_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errr = _dyr/2, _errl = _dyl/2, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), xleft0+=(y!=ny1)?_rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0)) {
        if (y==ny1) { zl = nz1; txl = ntx1; tyl = nty1; pzl = pzn; ptxl = ptxn; ptyl = ptyn; }
        int xleft = xleft0, xright = xright0;
        float
          zleft = zl, zright = zr,
          txleft = txl, txright = txr,
          tyleft = tyl, tyright = tyr;
        if (xright<xleft) cimg::swap(xleft,xright,zleft,zright,txleft,txright,tyleft,tyright);
        const int dx = xright - xleft;
        const float
          pentez = (zright - zleft)/dx,
          pentetx = (txright - txleft)/dx,
          pentety = (tyright - tyleft)/dx;
        if (xleft<0 && dx) {
          zleft-=xleft*(zright - zleft)/dx;
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y,0,0);
        if (opacity>=1) {
          if (nbrightness==1) for (int x = xleft; x<=xright; ++x) {
            const float invz = 1/zleft;
            const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)*col;
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          } else if (nbrightness<1) for (int x=xleft; x<=xright; ++x) {
            const float invz = 1/zleft;
            const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)(nbrightness**col);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          } else for (int x = xleft; x<=xright; ++x) {
            const float invz = 1/zleft;
            const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)((2-nbrightness)**col + (nbrightness-1)*maxval);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          }
        } else {
          if (nbrightness==1) for (int x = xleft; x<=xright; ++x) {
            const float invz = 1/zleft;
            const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)(nopacity**col + *ptrd*copacity);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          } else if (nbrightness<1) for (int x = xleft; x<=xright; ++x) {
            const float invz = 1/zleft;
            const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              *ptrd = (T)(nopacity*nbrightness**col + *ptrd*copacity);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          } else for (int x = xleft; x<=xright; ++x) {
            const float invz = 1/zleft;
            const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
            for (int c = 0; c<(int)((*this)._spectrum); ++c) {
              const T val = (T)((2-nbrightness)**col + (nbrightness-1)*maxval);
              *ptrd = (T)(nopacity*val + *ptrd*copacity);
              ptrd+=whd; col+=twhd;
            }
            ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          }
        }
        zr+=pzr; txr+=ptxr; tyr+=ptyr; zl+=pzl; txl+=ptxl; tyl+=ptyl;
      }
      return *this;
    }


    template<typename tz, typename tc>
    CImg<T>& draw_triangle(CImg<tz>& zbuffer,
                           const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const float opacity=1,
                           const float brightness=1) {
      typedef typename cimg::superset<tz,float>::type tzfloat;
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (!is_sameXY(zbuffer))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    zbuffer._width,zbuffer._height,zbuffer._depth,zbuffer._spectrum,zbuffer._data);

      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture))
        return draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,+texture,tx0,ty0,tx1,ty1,tx2,ty2,opacity,brightness);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float
        nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0),
        nbrightness = brightness<0?0:(brightness>2?2:brightness);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2;
      float
        ntx0 = tx0/z0, nty0 = ty0/z0,
        ntx1 = tx1/z1, nty1 = ty1/z1,
        ntx2 = tx2/z2, nty2 = ty2/z2;
      tzfloat nz0 = 1/(tzfloat)z0, nz1 = 1/(tzfloat)z1, nz2 = 1/(tzfloat)z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nz0,nz1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nz0,nz2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nz1,nz2);
      if (ny0>=height() || ny2<0) return *this;
      float
        ptxl = (ntx1 - ntx0)/(ny1 - ny0),
        ptxr = (ntx2 - ntx0)/(ny2 - ny0),
        ptxn = (ntx2 - ntx1)/(ny2 - ny1),
        ptyl = (nty1 - nty0)/(ny1 - ny0),
        ptyr = (nty2 - nty0)/(ny2 - ny0),
        ptyn = (nty2 - nty1)/(ny2 - ny1),
        txr = ny0>=0?ntx0:(ntx0 - ny0*(ntx2 - ntx0)/(ny2 - ny0)),
        tyr = ny0>=0?nty0:(nty0 - ny0*(nty2 - nty0)/(ny2 - ny0)),
        txl = ny1>=0?(ny0>=0?ntx0:(ntx0 - ny0*(ntx1 - ntx0)/(ny1 - ny0))):
          (ptxl=ptxn,(ntx1 - ny1*(ntx2 - ntx1)/(ny2 - ny1))),
        tyl = ny1>=0?(ny0>=0?nty0:(nty0 - ny0*(nty1 - nty0)/(ny1 - ny0))):
          (ptyl=ptyn,(nty1 - ny1*(nty2 - nty1)/(ny2 - ny1)));
      tzfloat
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), _sxn=1, _sxr=1, _sxl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter = (_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errr = _dyr/2, _errl = _dyl/2, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), xleft0+=(y!=ny1)?_rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0)) {
        if (y==ny1) { zl = nz1; txl = ntx1; tyl = nty1; pzl = pzn; ptxl = ptxn; ptyl = ptyn; }
        int xleft = xleft0, xright = xright0;
        float txleft = txl, txright = txr, tyleft = tyl, tyright = tyr;
        tzfloat zleft = zl, zright = zr;
        if (xright<xleft) cimg::swap(xleft,xright,zleft,zright,txleft,txright,tyleft,tyright);
        const int dx = xright - xleft;
        const float pentetx = (txright - txleft)/dx, pentety = (tyright - tyleft)/dx;
        const tzfloat pentez = (zright - zleft)/dx;
        if (xleft<0 && dx) {
          zleft-=xleft*(zright - zleft)/dx;
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T *ptrd = data(xleft,y,0,0);
        tz *ptrz = zbuffer.data(xleft,y);
        if (opacity>=1) {
          if (nbrightness==1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
                const tzfloat invz = 1/zleft;
                const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
                for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                  *ptrd = (T)*col;
                  ptrd+=whd; col+=twhd;
                }
                ptrd-=offx;
              }
              zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            } else if (nbrightness<1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
                const tzfloat invz = 1/zleft;
                const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
                for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                  *ptrd = (T)(nbrightness**col);
                  ptrd+=whd; col+=twhd;
                }
                ptrd-=offx;
              }
              zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            } else for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
                const tzfloat invz = 1/zleft;
                const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
                for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                  *ptrd = (T)((2-nbrightness)**col + (nbrightness-1)*maxval);
                  ptrd+=whd; col+=twhd;
                }
                ptrd-=offx;
              }
              zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            }
        } else {
          if (nbrightness==1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
                const tzfloat invz = 1/zleft;
                const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
                for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                  *ptrd = (T)(nopacity**col + *ptrd*copacity);
                  ptrd+=whd; col+=twhd;
                }
                ptrd-=offx;
              }
              zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            } else if (nbrightness<1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
                const tzfloat invz = 1/zleft;
                const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
                for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                  *ptrd = (T)(nopacity*nbrightness**col + *ptrd*copacity);
                  ptrd+=whd; col+=twhd;
                }
                ptrd-=offx;
              }
              zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            } else for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
              if (zleft>=(tzfloat)*ptrz) {
                *ptrz = (tz)zleft;
                const tzfloat invz = 1/zleft;
                const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
                for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                  const T val = (T)((2-nbrightness)**col + (nbrightness-1)*maxval);
                  *ptrd = (T)(nopacity*val + *ptrd*copacity);
                  ptrd+=whd; col+=twhd;
                }
                ptrd-=offx;
              }
              zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            }
        }
        zr+=pzr; txr+=ptxr; tyr+=ptyr; zl+=pzl; txl+=ptxl; tyl+=ptyl;
      }
      return *this;
    }
# 32894 "../src/CImg.h"
    template<typename tc, typename tl>
    CImg<T>& draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const tc *const color,
                           const CImg<tl>& light,
                           const int lx0, const int ly0,
                           const int lx1, const int ly1,
                           const int lx2, const int ly2,
                           const float opacity=1) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (light._depth>1 || light._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified light texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),light._width,light._height,light._depth,light._spectrum,light._data);
      if (is_overlapped(light)) return draw_triangle(x0,y0,x1,y1,x2,y2,color,+light,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        nlx0 = lx0, nly0 = ly0, nlx1 = lx1, nly1 = ly1, nlx2 = lx2, nly2 = ly2;
      const long whd = (long)_width*_height*_depth, offx = _spectrum*whd-1;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nlx0,nlx1,nly0,nly1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,nlx0,nlx2,nly0,nly2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,nlx1,nlx2,nly1,nly2);
      if (ny0>=height() || ny2<0) return *this;
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), lxright0 = ny0>=0?nlx0:(nlx0-ny0*(nlx2-nlx0)/(ny2-ny0)), lyright0 = ny0>=0?nly0:(nly0-ny0*(nly2-nly0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), lxleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nlx1:nlx0):(nlx0-ny0*(nlx1-nlx0)/(ny1-ny0))):(nlx1-ny1*(nlx2-nlx1)/(ny2-ny1)), lyleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nly1:nly0):(nly0-ny0*(nly1-nly0)/(ny1-ny0))):(nly1-ny1*(nly2-nly1)/(ny2-ny1)), _sxn=1, _stxn=1, _styn=1, _sxr=1, _stxr=1, _styr=1, _sxl=1, _stxl=1, _styl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dtxn = nlx2>nlx1?nlx2-nlx1:(_stxn=-1,nlx1-nlx2), _dtxr = nlx2>nlx0?nlx2-nlx0:(_stxr=-1,nlx0-nlx2), _dtxl = nlx1>nlx0?nlx1-nlx0:(_stxl=-1,nlx0-nlx1), _dtyn = nly2>nly1?nly2-nly1:(_styn=-1,nly1-nly2), _dtyr = nly2>nly0?nly2-nly0:(_styr=-1,nly0-nly2), _dtyl = nly1>nly0?nly1-nly0:(_styl=-1,nly0-nly1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dtxn-=_dyn?_dyn*(_dtxn/_dyn):0, _dtxr-=_dyr?_dyr*(_dtxr/_dyr):0, _dtxl-=_dyl?_dyl*(_dtxl/_dyl):0, _dtyn-=_dyn?_dyn*(_dtyn/_dyn):0, _dtyr-=_dyr?_dyr*(_dtyr/_dyr):0, _dtyl-=_dyl?_dyl*(_dtyl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errtxn = _errn, _errtyn = _errn, _errr = _dyr/2, _errtxr = _errr, _errtyr = _errr, _errl = _dyl/2, _errtxl = _errl, _errtyl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rtxn = _dyn?(nlx2-nlx1)/_dyn:0, _rtyn = _dyn?(nly2-nly1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rtxr = _dyr?(nlx2-nlx0)/_dyr:0, _rtyr = _dyr?(nly2-nly0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rtxl = (ny0!=ny1 && ny1>0)?(_dyl?(nlx1-nlx0)/_dyl:0): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxn ), _rtyl = (ny0!=ny1 && ny1>0)?(_dyl?(nly1-nly0)/_dyl:0): (_errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), lxright0+=_rtxr+((_errtxr-=_dtxr)<0?_errtxr+=_dyr,_stxr:0), lyright0+=_rtyr+((_errtyr-=_dtyr)<0?_errtyr+=_dyr,_styr:0), xleft0+=(y!=ny1)?(lxleft0+=_rtxl+((_errtxl-=_dtxl)<0?(_errtxl+=_dyl,_stxl):0), lyleft0+=_rtyl+((_errtyl-=_dtyl)<0?(_errtyl+=_dyl,_styl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxl=_rtxn, lxleft0=nlx1, _errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyl=_rtyn, lyleft0=nly1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0))
                                                                                 {
        int
          xleft = xleft0, xright = xright0,
          lxleft = lxleft0, lxright = lxright0,
          lyleft = lyleft0, lyright = lyright0;
        if (xright<xleft) cimg::swap(xleft,xright,lxleft,lxright,lyleft,lyright);
        const int
          dx = xright - xleft,
          dlx = lxright>lxleft?lxright - lxleft:lxleft - lxright,
          dly = lyright>lyleft?lyright - lyleft:lyleft - lyright,
          rlx = dx?(lxright - lxleft)/dx:0,
          rly = dx?(lyright - lyleft)/dx:0,
          slx = lxright>lxleft?1:-1,
          sly = lyright>lyleft?1:-1,
          ndlx = dlx - (dx?dx*(dlx/dx):0),
          ndly = dly - (dx?dx*(dly/dx):0);
        int errlx = dx>>1, errly = errlx;
        if (xleft<0 && dx) {
          lxleft-=xleft*(lxright - lxleft)/dx;
          lyleft-=xleft*(lyright - lyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y,0,0);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x) {
          const tc *col = color;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const tl l = light(lxleft,lyleft,c);
            *ptrd = (T)(l<1?l**(col++):((2-l)**(col++)+(l-1)*maxval));
            ptrd+=whd;
          }
          ptrd-=offx;
          lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
          lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
        } else for (int x = xleft; x<=xright; ++x) {
          const tc *col = color;
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const tl l = light(lxleft,lyleft,c);
            const T val = (T)(l<1?l**(col++):((2-l)**(col++)+(l-1)*maxval));
            *ptrd = (T)(nopacity*val + *ptrd*copacity);
            ptrd+=whd;
          }
          ptrd-=offx;
          lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
          lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
        }
      }
      return *this;
    }


    template<typename tz, typename tc, typename tl>
    CImg<T>& draw_triangle(CImg<tz>& zbuffer,
                           const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const tc *const color,
                           const CImg<tl>& light,
                           const int lx0, const int ly0,
                           const int lx1, const int ly1,
                           const int lx2, const int ly2,
                           const float opacity=1) {
      typedef typename cimg::superset<tz,float>::type tzfloat;
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (light._depth>1 || light._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified light texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),light._width,light._height,light._depth,light._spectrum,light._data);
      if (!is_sameXY(zbuffer))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    zbuffer._width,zbuffer._height,zbuffer._depth,zbuffer._spectrum,zbuffer._data);
      if (is_overlapped(light)) return draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,
                                                     +light,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, offx = _spectrum*whd;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        nlx0 = lx0, nly0 = ly0, nlx1 = lx1, nly1 = ly1, nlx2 = lx2, nly2 = ly2;
      tzfloat nz0 = 1/(tzfloat)z0, nz1 = 1/(tzfloat)z1, nz2 = 1/(tzfloat)z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nlx0,nlx1,nly0,nly1,nz0,nz1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,nlx0,nlx2,nly0,nly2,nz0,nz2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,nlx1,nlx2,nly1,nly2,nz1,nz2);
      if (ny0>=height() || ny2<0) return *this;
      tzfloat
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), lxright0 = ny0>=0?nlx0:(nlx0-ny0*(nlx2-nlx0)/(ny2-ny0)), lyright0 = ny0>=0?nly0:(nly0-ny0*(nly2-nly0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), lxleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nlx1:nlx0):(nlx0-ny0*(nlx1-nlx0)/(ny1-ny0))):(nlx1-ny1*(nlx2-nlx1)/(ny2-ny1)), lyleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nly1:nly0):(nly0-ny0*(nly1-nly0)/(ny1-ny0))):(nly1-ny1*(nly2-nly1)/(ny2-ny1)), _sxn=1, _stxn=1, _styn=1, _sxr=1, _stxr=1, _styr=1, _sxl=1, _stxl=1, _styl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dtxn = nlx2>nlx1?nlx2-nlx1:(_stxn=-1,nlx1-nlx2), _dtxr = nlx2>nlx0?nlx2-nlx0:(_stxr=-1,nlx0-nlx2), _dtxl = nlx1>nlx0?nlx1-nlx0:(_stxl=-1,nlx0-nlx1), _dtyn = nly2>nly1?nly2-nly1:(_styn=-1,nly1-nly2), _dtyr = nly2>nly0?nly2-nly0:(_styr=-1,nly0-nly2), _dtyl = nly1>nly0?nly1-nly0:(_styl=-1,nly0-nly1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dtxn-=_dyn?_dyn*(_dtxn/_dyn):0, _dtxr-=_dyr?_dyr*(_dtxr/_dyr):0, _dtxl-=_dyl?_dyl*(_dtxl/_dyl):0, _dtyn-=_dyn?_dyn*(_dtyn/_dyn):0, _dtyr-=_dyr?_dyr*(_dtyr/_dyr):0, _dtyl-=_dyl?_dyl*(_dtyl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errtxn = _errn, _errtyn = _errn, _errr = _dyr/2, _errtxr = _errr, _errtyr = _errr, _errl = _dyl/2, _errtxl = _errl, _errtyl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rtxn = _dyn?(nlx2-nlx1)/_dyn:0, _rtyn = _dyn?(nly2-nly1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rtxr = _dyr?(nlx2-nlx0)/_dyr:0, _rtyr = _dyr?(nly2-nly0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rtxl = (ny0!=ny1 && ny1>0)?(_dyl?(nlx1-nlx0)/_dyl:0): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxn ), _rtyl = (ny0!=ny1 && ny1>0)?(_dyl?(nly1-nly0)/_dyl:0): (_errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), lxright0+=_rtxr+((_errtxr-=_dtxr)<0?_errtxr+=_dyr,_stxr:0), lyright0+=_rtyr+((_errtyr-=_dtyr)<0?_errtyr+=_dyr,_styr:0), xleft0+=(y!=ny1)?(lxleft0+=_rtxl+((_errtxl-=_dtxl)<0?(_errtxl+=_dyl,_stxl):0), lyleft0+=_rtyl+((_errtyl-=_dtyl)<0?(_errtyl+=_dyl,_styl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxl=_rtxn, lxleft0=nlx1, _errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyl=_rtyn, lyleft0=nly1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0))
                                                                                 {
        if (y==ny1) { zl = nz1; pzl = pzn; }
        int
          xleft = xleft0, xright = xright0,
          lxleft = lxleft0, lxright = lxright0,
          lyleft = lyleft0, lyright = lyright0;
        tzfloat zleft = zl, zright = zr;
        if (xright<xleft) cimg::swap(xleft,xright,zleft,zright,lxleft,lxright,lyleft,lyright);
        const int
          dx = xright - xleft,
          dlx = lxright>lxleft?lxright - lxleft:lxleft - lxright,
          dly = lyright>lyleft?lyright - lyleft:lyleft - lyright,
          rlx = dx?(lxright - lxleft)/dx:0,
          rly = dx?(lyright - lyleft)/dx:0,
          slx = lxright>lxleft?1:-1,
          sly = lyright>lyleft?1:-1,
          ndlx = dlx - (dx?dx*(dlx/dx):0),
          ndly = dly - (dx?dx*(dly/dx):0);
        const tzfloat pentez = (zright - zleft)/dx;
        int errlx = dx>>1, errly = errlx;
        if (xleft<0 && dx) {
          zleft-=xleft*(zright - zleft)/dx;
          lxleft-=xleft*(lxright - lxleft)/dx;
          lyleft-=xleft*(lyright - lyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T *ptrd = data(xleft,y,0,0);
        tz *ptrz = zbuffer.data(xleft,y);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
            if (zleft>=(tzfloat)*ptrz) {
              *ptrz = (tz)zleft;
              const tc *col = color;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const tl l = light(lxleft,lyleft,c);
                const tc cval = *(col++);
                *ptrd = (T)(l<1?l*cval:(2-l)*cval+(l-1)*maxval);
                ptrd+=whd;
              }
              ptrd-=offx;
            }
            zleft+=pentez;
            lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
            lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
          } else for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
            if (zleft>=(tzfloat)*ptrz) {
              *ptrz = (tz)zleft;
              const tc *col = color;
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const tl l = light(lxleft,lyleft,c);
                const tc cval = *(col++);
                const T val = (T)(l<1?l*cval:(2-l)*cval+(l-1)*maxval);
                *ptrd = (T)(nopacity*val + *ptrd*copacity);
                ptrd+=whd;
              }
              ptrd-=offx;
            }
            zleft+=pentez;
            lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
            lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
          }
        zr+=pzr; zl+=pzl;
      }
      return *this;
    }
# 33107 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const float brightness0,
                           const float brightness1,
                           const float brightness2,
                           const float opacity=1) {
      if (is_empty()) return *this;
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture))
        return draw_triangle(x0,y0,x1,y1,x2,y2,+texture,tx0,ty0,tx1,ty1,tx2,ty2,
                             brightness0,brightness1,brightness2,opacity);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd-1;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        ntx0 = tx0, nty0 = ty0, ntx1 = tx1, nty1 = ty1, ntx2 = tx2, nty2 = ty2,
        nc0 = (int)((brightness0<0.0f?0.0f:(brightness0>2.0f?2.0f:brightness0))*256.0f),
        nc1 = (int)((brightness1<0.0f?0.0f:(brightness1>2.0f?2.0f:brightness1))*256.0f),
        nc2 = (int)((brightness2<0.0f?0.0f:(brightness2>2.0f?2.0f:brightness2))*256.0f);
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nc0,nc1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nc0,nc2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nc1,nc2);
      if (ny0>=height() || ny2<0) return *this;
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), cright0 = ny0>=0?nc0:(nc0-ny0*(nc2-nc0)/(ny2-ny0)), txright0 = ny0>=0?ntx0:(ntx0-ny0*(ntx2-ntx0)/(ny2-ny0)), tyright0 = ny0>=0?nty0:(nty0-ny0*(nty2-nty0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), cleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nc1:nc0):(nc0-ny0*(nc1-nc0)/(ny1-ny0))):(nc1-ny1*(nc2-nc1)/(ny2-ny1)), txleft0 = ny1>=0?(ny0>=0?(ny0==ny1?ntx1:ntx0):(ntx0-ny0*(ntx1-ntx0)/(ny1-ny0))):(ntx1-ny1*(ntx2-ntx1)/(ny2-ny1)), tyleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nty1:nty0):(nty0-ny0*(nty1-nty0)/(ny1-ny0))):(nty1-ny1*(nty2-nty1)/(ny2-ny1)), _sxn=1, _scn=1, _stxn=1, _styn=1, _sxr=1, _scr=1, _stxr=1, _styr=1, _sxl=1, _scl=1, _stxl=1, _styl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dcn = nc2>nc1?nc2-nc1:(_scn=-1,nc1-nc2), _dcr = nc2>nc0?nc2-nc0:(_scr=-1,nc0-nc2), _dcl = nc1>nc0?nc1-nc0:(_scl=-1,nc0-nc1), _dtxn = ntx2>ntx1?ntx2-ntx1:(_stxn=-1,ntx1-ntx2), _dtxr = ntx2>ntx0?ntx2-ntx0:(_stxr=-1,ntx0-ntx2), _dtxl = ntx1>ntx0?ntx1-ntx0:(_stxl=-1,ntx0-ntx1), _dtyn = nty2>nty1?nty2-nty1:(_styn=-1,nty1-nty2), _dtyr = nty2>nty0?nty2-nty0:(_styr=-1,nty0-nty2), _dtyl = nty1>nty0?nty1-nty0:(_styl=-1,nty0-nty1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dcn-=_dyn?_dyn*(_dcn/_dyn):0, _dcr-=_dyr?_dyr*(_dcr/_dyr):0, _dcl-=_dyl?_dyl*(_dcl/_dyl):0, _dtxn-=_dyn?_dyn*(_dtxn/_dyn):0, _dtxr-=_dyr?_dyr*(_dtxr/_dyr):0, _dtxl-=_dyl?_dyl*(_dtxl/_dyl):0, _dtyn-=_dyn?_dyn*(_dtyn/_dyn):0, _dtyr-=_dyr?_dyr*(_dtyr/_dyr):0, _dtyl-=_dyl?_dyl*(_dtyl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errcn = _errn, _errtxn = _errn, _errtyn = _errn, _errr = _dyr/2, _errcr = _errr, _errtxr = _errr, _errtyr = _errr, _errl = _dyl/2, _errcl = _errl, _errtxl = _errl, _errtyl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rcn = _dyn?(nc2-nc1)/_dyn:0, _rtxn = _dyn?(ntx2-ntx1)/_dyn:0, _rtyn = _dyn?(nty2-nty1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rcr = _dyr?(nc2-nc0)/_dyr:0, _rtxr = _dyr?(ntx2-ntx0)/_dyr:0, _rtyr = _dyr?(nty2-nty0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rcl = (ny0!=ny1 && ny1>0)?(_dyl?(nc1-nc0)/_dyl:0): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcn ), _rtxl = (ny0!=ny1 && ny1>0)?(_dyl?(ntx1-ntx0)/_dyl:0): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxn ), _rtyl = (ny0!=ny1 && ny1>0)?(_dyl?(nty1-nty0)/_dyl:0): (_errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), cright0+=_rcr+((_errcr-=_dcr)<0?_errcr+=_dyr,_scr:0), txright0+=_rtxr+((_errtxr-=_dtxr)<0?_errtxr+=_dyr,_stxr:0), tyright0+=_rtyr+((_errtyr-=_dtyr)<0?_errtyr+=_dyr,_styr:0), xleft0+=(y!=ny1)?(cleft0+=_rcl+((_errcl-=_dcl)<0?(_errcl+=_dyl,_scl):0), txleft0+=_rtxl+((_errtxl-=_dtxl)<0?(_errtxl+=_dyl,_stxl):0), tyleft0+=_rtyl+((_errtyl-=_dtyl)<0?(_errtyl+=_dyl,_styl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcl=_rcn, cleft0=nc1, _errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxl=_rtxn, txleft0=ntx1, _errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyl=_rtyn, tyleft0=nty1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0))
                                                                                             {
        int
          xleft = xleft0, xright = xright0,
          cleft = cleft0, cright = cright0,
          txleft = txleft0, txright = txright0,
          tyleft = tyleft0, tyright = tyright0;
        if (xright<xleft) cimg::swap(xleft,xright,cleft,cright,txleft,txright,tyleft,tyright);
        const int
          dx = xright - xleft,
          dc = cright>cleft?cright - cleft:cleft - cright,
          dtx = txright>txleft?txright - txleft:txleft - txright,
          dty = tyright>tyleft?tyright - tyleft:tyleft - tyright,
          rc = dx?(cright - cleft)/dx:0,
          rtx = dx?(txright - txleft)/dx:0,
          rty = dx?(tyright - tyleft)/dx:0,
          sc = cright>cleft?1:-1,
          stx = txright>txleft?1:-1,
          sty = tyright>tyleft?1:-1,
          ndc = dc - (dx?dx*(dc/dx):0),
          ndtx = dtx - (dx?dx*(dtx/dx):0),
          ndty = dty - (dx?dx*(dty/dx):0);
        int errc = dx>>1, errtx = errc, errty = errc;
        if (xleft<0 && dx) {
          cleft-=xleft*(cright - cleft)/dx;
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y,0,0);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x) {
          const tc *col = texture.data(txleft,tyleft);
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            *ptrd = (T)(cleft<256?cleft**col/256:((512-cleft)**col+(cleft-256)*maxval)/256);
            ptrd+=whd; col+=twhd;
          }
          ptrd-=offx;
          cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
          txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
          tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
        } else for (int x = xleft; x<=xright; ++x) {
          const tc *col = texture.data(txleft,tyleft);
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const T val = (T)(cleft<256?cleft**col/256:((512-cleft)**col+(cleft-256)*maxval)/256);
            *ptrd = (T)(nopacity*val + *ptrd*copacity);
            ptrd+=whd; col+=twhd;
          }
          ptrd-=offx;
          cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
          txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
          tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
        }
      }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_triangle(const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const float brightness0,
                           const float brightness1,
                           const float brightness2,
                           const float opacity=1) {
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture)) return draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,+texture,tx0,ty0,tx1,ty1,tx2,ty2,
                                                       brightness0,brightness1,brightness2,opacity);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd-1;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        nc0 = (int)((brightness0<0.0f?0.0f:(brightness0>2.0f?2.0f:brightness0))*256.0f),
        nc1 = (int)((brightness1<0.0f?0.0f:(brightness1>2.0f?2.0f:brightness1))*256.0f),
        nc2 = (int)((brightness2<0.0f?0.0f:(brightness2>2.0f?2.0f:brightness2))*256.0f);
      float
        ntx0 = tx0/z0, nty0 = ty0/z0,
        ntx1 = tx1/z1, nty1 = ty1/z1,
        ntx2 = tx2/z2, nty2 = ty2/z2,
        nz0 = 1/z0, nz1 = 1/z1, nz2 = 1/z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nz0,nz1,nc0,nc1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nz0,nz2,nc0,nc2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nz1,nz2,nc1,nc2);
      if (ny0>=height() || ny2<0) return *this;
      float
        ptxl = (ntx1 - ntx0)/(ny1 - ny0),
        ptxr = (ntx2 - ntx0)/(ny2 - ny0),
        ptxn = (ntx2 - ntx1)/(ny2 - ny1),
        ptyl = (nty1 - nty0)/(ny1 - ny0),
        ptyr = (nty2 - nty0)/(ny2 - ny0),
        ptyn = (nty2 - nty1)/(ny2 - ny1),
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        txr = ny0>=0?ntx0:(ntx0 - ny0*(ntx2 - ntx0)/(ny2 - ny0)),
        tyr = ny0>=0?nty0:(nty0 - ny0*(nty2 - nty0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1))),
        txl = ny1>=0?(ny0>=0?ntx0:(ntx0 - ny0*(ntx1 - ntx0)/(ny1 - ny0))):
          (ptxl=ptxn,(ntx1 - ny1*(ntx2 - ntx1)/(ny2 - ny1))),
        tyl = ny1>=0?(ny0>=0?nty0:(nty0 - ny0*(nty1 - nty0)/(ny1 - ny0))):
          (ptyl=ptyn,(nty1 - ny1*(nty2 - nty1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), cright0 = ny0>=0?nc0:(nc0-ny0*(nc2-nc0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), cleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nc1:nc0):(nc0-ny0*(nc1-nc0)/(ny1-ny0))):(nc1-ny1*(nc2-nc1)/(ny2-ny1)), _sxn=1, _scn=1, _sxr=1, _scr=1, _sxl=1, _scl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dcn = nc2>nc1?nc2-nc1:(_scn=-1,nc1-nc2), _dcr = nc2>nc0?nc2-nc0:(_scr=-1,nc0-nc2), _dcl = nc1>nc0?nc1-nc0:(_scl=-1,nc0-nc1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dcn-=_dyn?_dyn*(_dcn/_dyn):0, _dcr-=_dyr?_dyr*(_dcr/_dyr):0, _dcl-=_dyl?_dyl*(_dcl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errcn = _errn, _errr = _dyr/2, _errcr = _errr, _errl = _dyl/2, _errcl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rcn = _dyn?(nc2-nc1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rcr = _dyr?(nc2-nc0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rcl = (ny0!=ny1 && ny1>0)?(_dyl?(nc1-nc0)/_dyl:0): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), cright0+=_rcr+((_errcr-=_dcr)<0?_errcr+=_dyr,_scr:0), xleft0+=(y!=ny1)?(cleft0+=_rcl+((_errcl-=_dcl)<0?(_errcl+=_dyl,_scl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcl=_rcn, cleft0=nc1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0)) {
        if (y==ny1) { zl = nz1; txl = ntx1; tyl = nty1; pzl = pzn; ptxl = ptxn; ptyl = ptyn; }
        int
          xleft = xleft0, xright = xright0,
          cleft = cleft0, cright = cright0;
        float
          zleft = zl, zright = zr,
          txleft = txl, txright = txr,
          tyleft = tyl, tyright = tyr;
        if (xright<xleft) cimg::swap(xleft,xright,zleft,zright,txleft,txright,tyleft,tyright,cleft,cright);
        const int
          dx = xright - xleft,
          dc = cright>cleft?cright - cleft:cleft - cright,
          rc = dx?(cright - cleft)/dx:0,
          sc = cright>cleft?1:-1,
          ndc = dc - (dx?dx*(dc/dx):0);
        const float
          pentez = (zright - zleft)/dx,
          pentetx = (txright - txleft)/dx,
          pentety = (tyright - tyleft)/dx;
        int errc = dx>>1;
        if (xleft<0 && dx) {
          cleft-=xleft*(cright - cleft)/dx;
          zleft-=xleft*(zright - zleft)/dx;
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y,0,0);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x) {
          const float invz = 1/zleft;
          const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            *ptrd = (T)(cleft<256?cleft**col/256:((512-cleft)**col+(cleft-256)*maxval)/256);
            ptrd+=whd; col+=twhd;
          }
          ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
        } else for (int x = xleft; x<=xright; ++x) {
          const float invz = 1/zleft;
          const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const T val = (T)(cleft<256?cleft**col/256:((512-cleft)**col+(cleft-256)*maxval)/256);
            *ptrd = (T)(nopacity*val + *ptrd*copacity);
            ptrd+=whd; col+=twhd;
          }
          ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
        }
        zr+=pzr; txr+=ptxr; tyr+=ptyr; zl+=pzl; txl+=ptxl; tyl+=ptyl;
      }
      return *this;
    }


    template<typename tz, typename tc>
    CImg<T>& draw_triangle(CImg<tz>& zbuffer,
                           const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const float brightness0,
                           const float brightness1,
                           const float brightness2,
                           const float opacity=1) {
      typedef typename cimg::superset<tz,float>::type tzfloat;
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (!is_sameXY(zbuffer))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    zbuffer._width,zbuffer._height,zbuffer._depth,zbuffer._spectrum,zbuffer._data);
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (is_overlapped(texture))
        return draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,+texture,tx0,ty0,tx1,ty1,tx2,ty2,
                                                       brightness0,brightness1,brightness2,opacity);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        nc0 = (int)((brightness0<0.0f?0.0f:(brightness0>2.0f?2.0f:brightness0))*256.0f),
        nc1 = (int)((brightness1<0.0f?0.0f:(brightness1>2.0f?2.0f:brightness1))*256.0f),
        nc2 = (int)((brightness2<0.0f?0.0f:(brightness2>2.0f?2.0f:brightness2))*256.0f);
      float
        ntx0 = tx0/z0, nty0 = ty0/z0,
        ntx1 = tx1/z1, nty1 = ty1/z1,
        ntx2 = tx2/z2, nty2 = ty2/z2;
      tzfloat nz0 = 1/(tzfloat)z0, nz1 = 1/(tzfloat)z1, nz2 = 1/(tzfloat)z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nz0,nz1,nc0,nc1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nz0,nz2,nc0,nc2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nz1,nz2,nc1,nc2);
      if (ny0>=height() || ny2<0) return *this;
      float
        ptxl = (ntx1 - ntx0)/(ny1 - ny0),
        ptxr = (ntx2 - ntx0)/(ny2 - ny0),
        ptxn = (ntx2 - ntx1)/(ny2 - ny1),
        ptyl = (nty1 - nty0)/(ny1 - ny0),
        ptyr = (nty2 - nty0)/(ny2 - ny0),
        ptyn = (nty2 - nty1)/(ny2 - ny1),
        txr = ny0>=0?ntx0:(ntx0 - ny0*(ntx2 - ntx0)/(ny2 - ny0)),
        tyr = ny0>=0?nty0:(nty0 - ny0*(nty2 - nty0)/(ny2 - ny0)),
        txl = ny1>=0?(ny0>=0?ntx0:(ntx0 - ny0*(ntx1 - ntx0)/(ny1 - ny0))):
          (ptxl=ptxn,(ntx1 - ny1*(ntx2 - ntx1)/(ny2 - ny1))),
        tyl = ny1>=0?(ny0>=0?nty0:(nty0 - ny0*(nty1 - nty0)/(ny1 - ny0))):
          (ptyl=ptyn,(nty1 - ny1*(nty2 - nty1)/(ny2 - ny1)));
      tzfloat
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), cright0 = ny0>=0?nc0:(nc0-ny0*(nc2-nc0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), cleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nc1:nc0):(nc0-ny0*(nc1-nc0)/(ny1-ny0))):(nc1-ny1*(nc2-nc1)/(ny2-ny1)), _sxn=1, _scn=1, _sxr=1, _scr=1, _sxl=1, _scl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dcn = nc2>nc1?nc2-nc1:(_scn=-1,nc1-nc2), _dcr = nc2>nc0?nc2-nc0:(_scr=-1,nc0-nc2), _dcl = nc1>nc0?nc1-nc0:(_scl=-1,nc0-nc1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dcn-=_dyn?_dyn*(_dcn/_dyn):0, _dcr-=_dyr?_dyr*(_dcr/_dyr):0, _dcl-=_dyl?_dyl*(_dcl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errcn = _errn, _errr = _dyr/2, _errcr = _errr, _errl = _dyl/2, _errcl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rcn = _dyn?(nc2-nc1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rcr = _dyr?(nc2-nc0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rcl = (ny0!=ny1 && ny1>0)?(_dyl?(nc1-nc0)/_dyl:0): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), cright0+=_rcr+((_errcr-=_dcr)<0?_errcr+=_dyr,_scr:0), xleft0+=(y!=ny1)?(cleft0+=_rcl+((_errcl-=_dcl)<0?(_errcl+=_dyl,_scl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errcl=_errcn, _dcl=_dcn, _dyl=_dyn, _scl=_scn, _rcl=_rcn, cleft0=nc1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0)) {
        if (y==ny1) { zl = nz1; txl = ntx1; tyl = nty1; pzl = pzn; ptxl = ptxn; ptyl = ptyn; }
        int xleft = xleft0, xright = xright0, cleft = cleft0, cright = cright0;
        float txleft = txl, txright = txr, tyleft = tyl, tyright = tyr;
        tzfloat zleft = zl, zright = zr;
        if (xright<xleft) cimg::swap(xleft,xright,zleft,zright,txleft,txright,tyleft,tyright,cleft,cright);
        const int
          dx = xright - xleft,
          dc = cright>cleft?cright - cleft:cleft - cright,
          rc = dx?(cright - cleft)/dx:0,
          sc = cright>cleft?1:-1,
          ndc = dc - (dx?dx*(dc/dx):0);
        float pentetx = (txright - txleft)/dx, pentety = (tyright - tyleft)/dx;
        const tzfloat pentez = (zright - zleft)/dx;
        int errc = dx>>1;
        if (xleft<0 && dx) {
          cleft-=xleft*(cright - cleft)/dx;
          zleft-=xleft*(zright - zleft)/dx;
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y);
        tz *ptrz = zbuffer.data(xleft,y);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x, ++ptrd, ++ptrz) {
            if (zleft>=(tzfloat)*ptrz) {
              *ptrz = (tz)zleft;
              const tzfloat invz = 1/zleft;
              const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                *ptrd = (T)(cleft<256?cleft**col/256:((512-cleft)**col+(cleft-256)*maxval)/256);
                ptrd+=whd; col+=twhd;
              }
              ptrd-=offx;
            }
            zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
          } else for (int x = xleft; x<=xright; ++x, ++ptrd, ++ptrz) {
            if (zleft>=(tzfloat)*ptrz) {
              *ptrz = (tz)zleft;
              const tzfloat invz = 1/zleft;
              const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const T val = (T)(cleft<256?cleft**col/256:((512-cleft)**col+(cleft-256)*maxval)/256);
                *ptrd = (T)(nopacity*val + *ptrd*copacity);
                ptrd+=whd; col+=twhd;
              }
              ptrd-=offx;
            }
            zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            cleft+=rc+((errc-=ndc)<0?errc+=dx,sc:0);
          }
        zr+=pzr; txr+=ptxr; tyr+=ptyr; zl+=pzl; txl+=ptxl; tyl+=ptyl;
      }
      return *this;
    }
# 33457 "../src/CImg.h"
    template<typename tc, typename tl>
    CImg<T>& draw_triangle(const int x0, const int y0,
                           const int x1, const int y1,
                           const int x2, const int y2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const CImg<tl>& light,
                           const int lx0, const int ly0,
                           const int lx1, const int ly1,
                           const int lx2, const int ly2,
                           const float opacity=1) {
      if (is_empty()) return *this;
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (light._depth>1 || light._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified light texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),light._width,light._height,light._depth,light._spectrum,light._data);
      if (is_overlapped(texture))
        return draw_triangle(x0,y0,x1,y1,x2,y2,+texture,tx0,ty0,tx1,ty1,tx2,ty2,light,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
      if (is_overlapped(light))
        return draw_triangle(x0,y0,x1,y1,x2,y2,texture,tx0,ty0,tx1,ty1,tx2,ty2,+light,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd-1;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        ntx0 = tx0, nty0 = ty0, ntx1 = tx1, nty1 = ty1, ntx2 = tx2, nty2 = ty2,
        nlx0 = lx0, nly0 = ly0, nlx1 = lx1, nly1 = ly1, nlx2 = lx2, nly2 = ly2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nlx0,nlx1,nly0,nly1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nlx0,nlx2,nly0,nly2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nlx1,nlx2,nly1,nly2);
      if (ny0>=height() || ny2<0) return *this;
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), lxright0 = ny0>=0?nlx0:(nlx0-ny0*(nlx2-nlx0)/(ny2-ny0)), lyright0 = ny0>=0?nly0:(nly0-ny0*(nly2-nly0)/(ny2-ny0)), txright0 = ny0>=0?ntx0:(ntx0-ny0*(ntx2-ntx0)/(ny2-ny0)), tyright0 = ny0>=0?nty0:(nty0-ny0*(nty2-nty0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), lxleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nlx1:nlx0):(nlx0-ny0*(nlx1-nlx0)/(ny1-ny0))):(nlx1-ny1*(nlx2-nlx1)/(ny2-ny1)), lyleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nly1:nly0):(nly0-ny0*(nly1-nly0)/(ny1-ny0))):(nly1-ny1*(nly2-nly1)/(ny2-ny1)), txleft0 = ny1>=0?(ny0>=0?(ny0==ny1?ntx1:ntx0):(ntx0-ny0*(ntx1-ntx0)/(ny1-ny0))):(ntx1-ny1*(ntx2-ntx1)/(ny2-ny1)), tyleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nty1:nty0):(nty0-ny0*(nty1-nty0)/(ny1-ny0))):(nty1-ny1*(nty2-nty1)/(ny2-ny1)), _sxn=1, _stxn=1, _styn=1, _slxn=1, _slyn=1, _sxr=1, _stxr=1, _styr=1, _slxr=1, _slyr=1, _sxl=1, _stxl=1, _styl=1, _slxl=1, _slyl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dyn = ny2-ny1, _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dyr = ny2-ny0, _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dyl = ny1-ny0, _dtxn = nlx2>nlx1?nlx2-nlx1:(_stxn=-1,nlx1-nlx2), _dtxr = nlx2>nlx0?nlx2-nlx0:(_stxr=-1,nlx0-nlx2), _dtxl = nlx1>nlx0?nlx1-nlx0:(_stxl=-1,nlx0-nlx1), _dtyn = nly2>nly1?nly2-nly1:(_styn=-1,nly1-nly2), _dtyr = nly2>nly0?nly2-nly0:(_styr=-1,nly0-nly2), _dtyl = nly1>nly0?nly1-nly0:(_styl=-1,nly0-nly1), _dlxn = ntx2>ntx1?ntx2-ntx1:(_slxn=-1,ntx1-ntx2), _dlxr = ntx2>ntx0?ntx2-ntx0:(_slxr=-1,ntx0-ntx2), _dlxl = ntx1>ntx0?ntx1-ntx0:(_slxl=-1,ntx0-ntx1), _dlyn = nty2>nty1?nty2-nty1:(_slyn=-1,nty1-nty2), _dlyr = nty2>nty0?nty2-nty0:(_slyr=-1,nty0-nty2), _dlyl = nty1>nty0?nty1-nty0:(_slyl=-1,nty0-nty1), _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dtxn-=_dyn?_dyn*(_dtxn/_dyn):0, _dtxr-=_dyr?_dyr*(_dtxr/_dyr):0, _dtxl-=_dyl?_dyl*(_dtxl/_dyl):0, _dtyn-=_dyn?_dyn*(_dtyn/_dyn):0, _dtyr-=_dyr?_dyr*(_dtyr/_dyr):0, _dtyl-=_dyl?_dyl*(_dtyl/_dyl):0, _dlxn-=_dyn?_dyn*(_dlxn/_dyn):0, _dlxr-=_dyr?_dyr*(_dlxr/_dyr):0, _dlxl-=_dyl?_dyl*(_dlxl/_dyl):0, _dlyn-=_dyn?_dyn*(_dlyn/_dyn):0, _dlyr-=_dyr?_dyr*(_dlyr/_dyr):0, _dlyl-=_dyl?_dyl*(_dlyl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errtxn = _errn, _errtyn = _errn, _errlxn = _errn, _errlyn = _errn, _errr = _dyr/2, _errtxr = _errr, _errtyr = _errr, _errlxr = _errr, _errlyr = _errr, _errl = _dyl/2, _errtxl = _errl, _errtyl = _errl, _errlxl = _errl, _errlyl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rtxn = _dyn?(nlx2-nlx1)/_dyn:0, _rtyn = _dyn?(nly2-nly1)/_dyn:0, _rlxn = _dyn?(ntx2-ntx1)/_dyn:0, _rlyn = _dyn?(nty2-nty1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rtxr = _dyr?(nlx2-nlx0)/_dyr:0, _rtyr = _dyr?(nly2-nly0)/_dyr:0, _rlxr = _dyr?(ntx2-ntx0)/_dyr:0, _rlyr = _dyr?(nty2-nty0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rtxl = (ny0!=ny1 && ny1>0)?(_dyl?(nlx1-nlx0)/_dyl:0): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxn ), _rtyl = (ny0!=ny1 && ny1>0)?(_dyl?(nly1-nly0)/_dyl:0): (_errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyn ), _rlxl = (ny0!=ny1 && ny1>0)?(_dyl?(ntx1-ntx0)/_dyl:0): (_errlxl=_errlxn, _dlxl=_dlxn, _dyl=_dyn, _slxl=_slxn, _rlxn ), _rlyl = (ny0!=ny1 && ny1>0)?(_dyl?(nty1-nty0)/_dyl:0): (_errlyl=_errlyn, _dlyl=_dlyn, _dyl=_dyn, _slyl=_slyn, _rlyn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), lxright0+=_rtxr+((_errtxr-=_dtxr)<0?_errtxr+=_dyr,_stxr:0), lyright0+=_rtyr+((_errtyr-=_dtyr)<0?_errtyr+=_dyr,_styr:0), txright0+=_rlxr+((_errlxr-=_dlxr)<0?_errlxr+=_dyr,_slxr:0), tyright0+=_rlyr+((_errlyr-=_dlyr)<0?_errlyr+=_dyr,_slyr:0), xleft0+=(y!=ny1)?(lxleft0+=_rtxl+((_errtxl-=_dtxl)<0?(_errtxl+=_dyl,_stxl):0), lyleft0+=_rtyl+((_errtyl-=_dtyl)<0?(_errtyl+=_dyl,_styl):0), txleft0+=_rlxl+((_errlxl-=_dlxl)<0?(_errlxl+=_dyl,_slxl):0), tyleft0+=_rlyl+((_errlyl-=_dlyl)<0?(_errlyl+=_dyl,_slyl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxl=_rtxn, lxleft0=nlx1, _errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyl=_rtyn, lyleft0=nly1, _errlxl=_errlxn, _dlxl=_dlxn, _dyl=_dyn, _slxl=_slxn, _rlxl=_rlxn, txleft0=ntx1, _errlyl=_errlyn, _dlyl=_dlyn, _dyl=_dyn, _slyl=_slyn, _rlyl=_rlyn, tyleft0=nty1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0))
                                                                                                               {
        int
          xleft = xleft0, xright = xright0,
          lxleft = lxleft0, lxright = lxright0,
          lyleft = lyleft0, lyright = lyright0,
          txleft = txleft0, txright = txright0,
          tyleft = tyleft0, tyright = tyright0;
        if (xright<xleft) cimg::swap(xleft,xright,lxleft,lxright,lyleft,lyright,txleft,txright,tyleft,tyright);
        const int
          dx = xright - xleft,
          dlx = lxright>lxleft?lxright - lxleft:lxleft - lxright,
          dly = lyright>lyleft?lyright - lyleft:lyleft - lyright,
          dtx = txright>txleft?txright - txleft:txleft - txright,
          dty = tyright>tyleft?tyright - tyleft:tyleft - tyright,
          rlx = dx?(lxright - lxleft)/dx:0,
          rly = dx?(lyright - lyleft)/dx:0,
          rtx = dx?(txright - txleft)/dx:0,
          rty = dx?(tyright - tyleft)/dx:0,
          slx = lxright>lxleft?1:-1,
          sly = lyright>lyleft?1:-1,
          stx = txright>txleft?1:-1,
          sty = tyright>tyleft?1:-1,
          ndlx = dlx - (dx?dx*(dlx/dx):0),
          ndly = dly - (dx?dx*(dly/dx):0),
          ndtx = dtx - (dx?dx*(dtx/dx):0),
          ndty = dty - (dx?dx*(dty/dx):0);
        int errlx = dx>>1, errly = errlx, errtx = errlx, errty = errlx;
        if (xleft<0 && dx) {
          lxleft-=xleft*(lxright - lxleft)/dx;
          lyleft-=xleft*(lyright - lyleft)/dx;
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y,0,0);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x) {
          const tc *col = texture.data(txleft,tyleft);
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const tl l = light(lxleft,lyleft,c);
            *ptrd = (T)(l<1?l**col:(2-l)**col+(l-1)*maxval);
            ptrd+=whd; col+=twhd;
          }
          ptrd-=offx;
          lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
          lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
          txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
          tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
        } else for (int x = xleft; x<=xright; ++x) {
          const tc *col = texture.data(txleft,tyleft);
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const tl l = light(lxleft,lyleft,c);
            const T val = (T)(l<1?l**col:(2-l)**col+(l-1)*maxval);
            *ptrd = (T)(nopacity*val + *ptrd*copacity);
            ptrd+=whd; col+=twhd;
          }
          ptrd-=offx;
          lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
          lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
          txleft+=rtx+((errtx-=ndtx)<0?errtx+=dx,stx:0);
          tyleft+=rty+((errty-=ndty)<0?errty+=dx,sty:0);
        }
      }
      return *this;
    }


    template<typename tc, typename tl>
    CImg<T>& draw_triangle(const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const CImg<tl>& light,
                           const int lx0, const int ly0,
                           const int lx1, const int ly1,
                           const int lx2, const int ly2,
                           const float opacity=1) {
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (light._depth>1 || light._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified light texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),light._width,light._height,light._depth,light._spectrum,light._data);
      if (is_overlapped(texture))
        return draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,+texture,tx0,ty0,tx1,ty1,tx2,ty2,
                             light,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
      if (is_overlapped(light))
        return draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,texture,tx0,ty0,tx1,ty1,tx2,ty2,
                             +light,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd-1;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        nlx0 = lx0, nly0 = ly0, nlx1 = lx1, nly1 = ly1, nlx2 = lx2, nly2 = ly2;
      float
        ntx0 = tx0/z0, nty0 = ty0/z0,
        ntx1 = tx1/z1, nty1 = ty1/z1,
        ntx2 = tx2/z2, nty2 = ty2/z2,
        nz0 = 1/z0, nz1 = 1/z1, nz2 = 1/z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nlx0,nlx1,nly0,nly1,nz0,nz1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nlx0,nlx2,nly0,nly2,nz0,nz2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nlx1,nlx2,nly1,nly2,nz1,nz2);
      if (ny0>=height() || ny2<0) return *this;
      float
        ptxl = (ntx1 - ntx0)/(ny1 - ny0),
        ptxr = (ntx2 - ntx0)/(ny2 - ny0),
        ptxn = (ntx2 - ntx1)/(ny2 - ny1),
        ptyl = (nty1 - nty0)/(ny1 - ny0),
        ptyr = (nty2 - nty0)/(ny2 - ny0),
        ptyn = (nty2 - nty1)/(ny2 - ny1),
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        txr = ny0>=0?ntx0:(ntx0 - ny0*(ntx2 - ntx0)/(ny2 - ny0)),
        tyr = ny0>=0?nty0:(nty0 - ny0*(nty2 - nty0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1))),
        txl = ny1>=0?(ny0>=0?ntx0:(ntx0 - ny0*(ntx1 - ntx0)/(ny1 - ny0))):
          (ptxl=ptxn,(ntx1 - ny1*(ntx2 - ntx1)/(ny2 - ny1))),
        tyl = ny1>=0?(ny0>=0?nty0:(nty0 - ny0*(nty1 - nty0)/(ny1 - ny0))):
          (ptyl=ptyn,(nty1 - ny1*(nty2 - nty1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), lxright0 = ny0>=0?nlx0:(nlx0-ny0*(nlx2-nlx0)/(ny2-ny0)), lyright0 = ny0>=0?nly0:(nly0-ny0*(nly2-nly0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), lxleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nlx1:nlx0):(nlx0-ny0*(nlx1-nlx0)/(ny1-ny0))):(nlx1-ny1*(nlx2-nlx1)/(ny2-ny1)), lyleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nly1:nly0):(nly0-ny0*(nly1-nly0)/(ny1-ny0))):(nly1-ny1*(nly2-nly1)/(ny2-ny1)), _sxn=1, _stxn=1, _styn=1, _sxr=1, _stxr=1, _styr=1, _sxl=1, _stxl=1, _styl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dtxn = nlx2>nlx1?nlx2-nlx1:(_stxn=-1,nlx1-nlx2), _dtxr = nlx2>nlx0?nlx2-nlx0:(_stxr=-1,nlx0-nlx2), _dtxl = nlx1>nlx0?nlx1-nlx0:(_stxl=-1,nlx0-nlx1), _dtyn = nly2>nly1?nly2-nly1:(_styn=-1,nly1-nly2), _dtyr = nly2>nly0?nly2-nly0:(_styr=-1,nly0-nly2), _dtyl = nly1>nly0?nly1-nly0:(_styl=-1,nly0-nly1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dtxn-=_dyn?_dyn*(_dtxn/_dyn):0, _dtxr-=_dyr?_dyr*(_dtxr/_dyr):0, _dtxl-=_dyl?_dyl*(_dtxl/_dyl):0, _dtyn-=_dyn?_dyn*(_dtyn/_dyn):0, _dtyr-=_dyr?_dyr*(_dtyr/_dyr):0, _dtyl-=_dyl?_dyl*(_dtyl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errtxn = _errn, _errtyn = _errn, _errr = _dyr/2, _errtxr = _errr, _errtyr = _errr, _errl = _dyl/2, _errtxl = _errl, _errtyl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rtxn = _dyn?(nlx2-nlx1)/_dyn:0, _rtyn = _dyn?(nly2-nly1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rtxr = _dyr?(nlx2-nlx0)/_dyr:0, _rtyr = _dyr?(nly2-nly0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rtxl = (ny0!=ny1 && ny1>0)?(_dyl?(nlx1-nlx0)/_dyl:0): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxn ), _rtyl = (ny0!=ny1 && ny1>0)?(_dyl?(nly1-nly0)/_dyl:0): (_errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), lxright0+=_rtxr+((_errtxr-=_dtxr)<0?_errtxr+=_dyr,_stxr:0), lyright0+=_rtyr+((_errtyr-=_dtyr)<0?_errtyr+=_dyr,_styr:0), xleft0+=(y!=ny1)?(lxleft0+=_rtxl+((_errtxl-=_dtxl)<0?(_errtxl+=_dyl,_stxl):0), lyleft0+=_rtyl+((_errtyl-=_dtyl)<0?(_errtyl+=_dyl,_styl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxl=_rtxn, lxleft0=nlx1, _errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyl=_rtyn, lyleft0=nly1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0))
                                                                                 {
        if (y==ny1) { zl = nz1; txl = ntx1; tyl = nty1; pzl = pzn; ptxl = ptxn; ptyl = ptyn; }
        int
          xleft = xleft0, xright = xright0,
          lxleft = lxleft0, lxright = lxright0,
          lyleft = lyleft0, lyright = lyright0;
        float
          zleft = zl, zright = zr,
          txleft = txl, txright = txr,
          tyleft = tyl, tyright = tyr;
        if (xright<xleft)
          cimg::swap(xleft,xright,zleft,zright,txleft,txright,tyleft,tyright,lxleft,lxright,lyleft,lyright);
        const int
          dx = xright - xleft,
          dlx = lxright>lxleft?lxright - lxleft:lxleft - lxright,
          dly = lyright>lyleft?lyright - lyleft:lyleft - lyright,
          rlx = dx?(lxright - lxleft)/dx:0,
          rly = dx?(lyright - lyleft)/dx:0,
          slx = lxright>lxleft?1:-1,
          sly = lyright>lyleft?1:-1,
          ndlx = dlx - (dx?dx*(dlx/dx):0),
          ndly = dly - (dx?dx*(dly/dx):0);
        const float
          pentez = (zright - zleft)/dx,
          pentetx = (txright - txleft)/dx,
          pentety = (tyright - tyleft)/dx;
        int errlx = dx>>1, errly = errlx;
        if (xleft<0 && dx) {
          zleft-=xleft*(zright - zleft)/dx;
          lxleft-=xleft*(lxright - lxleft)/dx;
          lyleft-=xleft*(lyright - lyleft)/dx;
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y,0,0);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x) {
          const float invz = 1/zleft;
          const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const tl l = light(lxleft,lyleft,c);
            *ptrd = (T)(l<1?l**col:(2-l)**col+(l-1)*maxval);
            ptrd+=whd; col+=twhd;
          }
          ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
          lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
        } else for (int x = xleft; x<=xright; ++x) {
          const float invz = 1/zleft;
          const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
          for (int c = 0; c<(int)((*this)._spectrum); ++c) {
            const tl l = light(lxleft,lyleft,c);
            const T val = (T)(l<1?l**col:(2-l)**col+(l-1)*maxval);
            *ptrd = (T)(nopacity*val + *ptrd*copacity);
            ptrd+=whd; col+=twhd;
          }
          ptrd-=offx; zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
          lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
          lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
        }
        zr+=pzr; txr+=ptxr; tyr+=ptyr; zl+=pzl; txl+=ptxl; tyl+=ptyl;
      }
      return *this;
    }


    template<typename tz, typename tc, typename tl>
    CImg<T>& draw_triangle(CImg<tz>& zbuffer,
                           const int x0, const int y0, const float z0,
                           const int x1, const int y1, const float z1,
                           const int x2, const int y2, const float z2,
                           const CImg<tc>& texture,
                           const int tx0, const int ty0,
                           const int tx1, const int ty1,
                           const int tx2, const int ty2,
                           const CImg<tl>& light,
                           const int lx0, const int ly0,
                           const int lx1, const int ly1,
                           const int lx2, const int ly2,
                           const float opacity=1) {
      typedef typename cimg::superset<tz,float>::type tzfloat;
      if (is_empty() || z0<=0 || z1<=0 || z2<=0) return *this;
      if (!is_sameXY(zbuffer))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
                                    "different dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    zbuffer._width,zbuffer._height,zbuffer._depth,zbuffer._spectrum,zbuffer._data);
      if (texture._depth>1 || texture._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    texture._width,texture._height,texture._depth,texture._spectrum,texture._data);
      if (light._depth>1 || light._spectrum<_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_triangle(): Invalid specified light texture (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),light._width,light._height,light._depth,light._spectrum,light._data);
      if (is_overlapped(texture))
        return draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,
                             +texture,tx0,ty0,tx1,ty1,tx2,ty2,light,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
      if (is_overlapped(light))
        return draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,
                             texture,tx0,ty0,tx1,ty1,tx2,ty2,+light,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
      static const T maxval = (T)cimg::min(cimg::type<T>::max(),cimg::type<tc>::max());
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const long whd = (long)_width*_height*_depth, twhd = (long)texture._width*texture._height*texture._depth,
        offx = _spectrum*whd;
      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2,
        nlx0 = lx0, nly0 = ly0, nlx1 = lx1, nly1 = ly1, nlx2 = lx2, nly2 = ly2;
      float
        ntx0 = tx0/z0, nty0 = ty0/z0,
        ntx1 = tx1/z1, nty1 = ty1/z1,
        ntx2 = tx2/z2, nty2 = ty2/z2;
      tzfloat nz0 = 1/(tzfloat)z0, nz1 = 1/(tzfloat)z1, nz2 = 1/(tzfloat)z2;
      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nlx0,nlx1,nly0,nly1,nz0,nz1);
      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nlx0,nlx2,nly0,nly2,nz0,nz2);
      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nlx1,nlx2,nly1,nly2,nz1,nz2);
      if (ny0>=height() || ny2<0) return *this;
      float
        ptxl = (ntx1 - ntx0)/(ny1 - ny0),
        ptxr = (ntx2 - ntx0)/(ny2 - ny0),
        ptxn = (ntx2 - ntx1)/(ny2 - ny1),
        ptyl = (nty1 - nty0)/(ny1 - ny0),
        ptyr = (nty2 - nty0)/(ny2 - ny0),
        ptyn = (nty2 - nty1)/(ny2 - ny1),
        txr = ny0>=0?ntx0:(ntx0 - ny0*(ntx2 - ntx0)/(ny2 - ny0)),
        tyr = ny0>=0?nty0:(nty0 - ny0*(nty2 - nty0)/(ny2 - ny0)),
        txl = ny1>=0?(ny0>=0?ntx0:(ntx0 - ny0*(ntx1 - ntx0)/(ny1 - ny0))):
          (ptxl=ptxn,(ntx1 - ny1*(ntx2 - ntx1)/(ny2 - ny1))),
        tyl = ny1>=0?(ny0>=0?nty0:(nty0 - ny0*(nty1 - nty0)/(ny1 - ny0))):
          (ptyl=ptyn,(nty1 - ny1*(nty2 - nty1)/(ny2 - ny1)));
      tzfloat
        pzl = (nz1 - nz0)/(ny1 - ny0),
        pzr = (nz2 - nz0)/(ny2 - ny0),
        pzn = (nz2 - nz1)/(ny2 - ny1),
        zr = ny0>=0?nz0:(nz0 - ny0*(nz2 - nz0)/(ny2 - ny0)),
        zl = ny1>=0?(ny0>=0?nz0:(nz0 - ny0*(nz1 - nz0)/(ny1 - ny0))):(pzl=pzn,(nz1 - ny1*(nz2 - nz1)/(ny2 - ny1)));
      for (int y = ny0<0?0:ny0, xright0 = ny0>=0?nx0:(nx0-ny0*(nx2-nx0)/(ny2-ny0)), lxright0 = ny0>=0?nlx0:(nlx0-ny0*(nlx2-nlx0)/(ny2-ny0)), lyright0 = ny0>=0?nly0:(nly0-ny0*(nly2-nly0)/(ny2-ny0)), xleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nx1:nx0):(nx0-ny0*(nx1-nx0)/(ny1-ny0))):(nx1-ny1*(nx2-nx1)/(ny2-ny1)), lxleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nlx1:nlx0):(nlx0-ny0*(nlx1-nlx0)/(ny1-ny0))):(nlx1-ny1*(nlx2-nlx1)/(ny2-ny1)), lyleft0 = ny1>=0?(ny0>=0?(ny0==ny1?nly1:nly0):(nly0-ny0*(nly1-nly0)/(ny1-ny0))):(nly1-ny1*(nly2-nly1)/(ny2-ny1)), _sxn=1, _stxn=1, _styn=1, _sxr=1, _stxr=1, _styr=1, _sxl=1, _stxl=1, _styl=1, _dxn = nx2>nx1?nx2-nx1:(_sxn=-1,nx1-nx2), _dxr = nx2>nx0?nx2-nx0:(_sxr=-1,nx0-nx2), _dxl = nx1>nx0?nx1-nx0:(_sxl=-1,nx0-nx1), _dtxn = nlx2>nlx1?nlx2-nlx1:(_stxn=-1,nlx1-nlx2), _dtxr = nlx2>nlx0?nlx2-nlx0:(_stxr=-1,nlx0-nlx2), _dtxl = nlx1>nlx0?nlx1-nlx0:(_stxl=-1,nlx0-nlx1), _dtyn = nly2>nly1?nly2-nly1:(_styn=-1,nly1-nly2), _dtyr = nly2>nly0?nly2-nly0:(_styr=-1,nly0-nly2), _dtyl = nly1>nly0?nly1-nly0:(_styl=-1,nly0-nly1), _dyn = ny2-ny1, _dyr = ny2-ny0, _dyl = ny1-ny0, _counter =(_dxn-=_dyn?_dyn*(_dxn/_dyn):0, _dxr-=_dyr?_dyr*(_dxr/_dyr):0, _dxl-=_dyl?_dyl*(_dxl/_dyl):0, _dtxn-=_dyn?_dyn*(_dtxn/_dyn):0, _dtxr-=_dyr?_dyr*(_dtxr/_dyr):0, _dtxl-=_dyl?_dyl*(_dtxl/_dyl):0, _dtyn-=_dyn?_dyn*(_dtyn/_dyn):0, _dtyr-=_dyr?_dyr*(_dtyr/_dyr):0, _dtyl-=_dyl?_dyl*(_dtyl/_dyl):0, cimg::min((int)(*this)._height-y-1,ny2-y)), _errn = _dyn/2, _errtxn = _errn, _errtyn = _errn, _errr = _dyr/2, _errtxr = _errr, _errtyr = _errr, _errl = _dyl/2, _errtxl = _errl, _errtyl = _errl, _rxn = _dyn?(nx2-nx1)/_dyn:0, _rtxn = _dyn?(nlx2-nlx1)/_dyn:0, _rtyn = _dyn?(nly2-nly1)/_dyn:0, _rxr = _dyr?(nx2-nx0)/_dyr:0, _rtxr = _dyr?(nlx2-nlx0)/_dyr:0, _rtyr = _dyr?(nly2-nly0)/_dyr:0, _rxl = (ny0!=ny1 && ny1>0)?(_dyl?(nx1-nx0)/_dyl:0): (_errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxn), _rtxl = (ny0!=ny1 && ny1>0)?(_dyl?(nlx1-nlx0)/_dyl:0): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxn ), _rtyl = (ny0!=ny1 && ny1>0)?(_dyl?(nly1-nly0)/_dyl:0): (_errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyn ); _counter>=0; --_counter, ++y, xright0+=_rxr+((_errr-=_dxr)<0?_errr+=_dyr,_sxr:0), lxright0+=_rtxr+((_errtxr-=_dtxr)<0?_errtxr+=_dyr,_stxr:0), lyright0+=_rtyr+((_errtyr-=_dtyr)<0?_errtyr+=_dyr,_styr:0), xleft0+=(y!=ny1)?(lxleft0+=_rtxl+((_errtxl-=_dtxl)<0?(_errtxl+=_dyl,_stxl):0), lyleft0+=_rtyl+((_errtyl-=_dtyl)<0?(_errtyl+=_dyl,_styl):0), _rxl+((_errl-=_dxl)<0?(_errl+=_dyl,_sxl):0)): (_errtxl=_errtxn, _dtxl=_dtxn, _dyl=_dyn, _stxl=_stxn, _rtxl=_rtxn, lxleft0=nlx1, _errtyl=_errtyn, _dtyl=_dtyn, _dyl=_dyn, _styl=_styn, _rtyl=_rtyn, lyleft0=nly1, _errl=_errn, _dxl=_dxn, _dyl=_dyn, _sxl=_sxn, _rxl=_rxn, nx1-xleft0))
                                                                                 {
        if (y==ny1) { zl = nz1; txl = ntx1; tyl = nty1; pzl = pzn; ptxl = ptxn; ptyl = ptyn; }
        int
          xleft = xleft0, xright = xright0,
          lxleft = lxleft0, lxright = lxright0,
          lyleft = lyleft0, lyright = lyright0;
        float txleft = txl, txright = txr, tyleft = tyl, tyright = tyr;
        tzfloat zleft = zl, zright = zr;
        if (xright<xleft)
          cimg::swap(xleft,xright,zleft,zright,txleft,txright,tyleft,tyright,lxleft,lxright,lyleft,lyright);
        const int
          dx = xright - xleft,
          dlx = lxright>lxleft?lxright - lxleft:lxleft - lxright,
          dly = lyright>lyleft?lyright - lyleft:lyleft - lyright,
          rlx = dx?(lxright - lxleft)/dx:0,
          rly = dx?(lyright - lyleft)/dx:0,
          slx = lxright>lxleft?1:-1,
          sly = lyright>lyleft?1:-1,
          ndlx = dlx - (dx?dx*(dlx/dx):0),
          ndly = dly - (dx?dx*(dly/dx):0);
        float pentetx = (txright - txleft)/dx, pentety = (tyright - tyleft)/dx;
        const tzfloat pentez = (zright - zleft)/dx;
        int errlx = dx>>1, errly = errlx;
        if (xleft<0 && dx) {
          zleft-=xleft*(zright - zleft)/dx;
          lxleft-=xleft*(lxright - lxleft)/dx;
          lyleft-=xleft*(lyright - lyleft)/dx;
          txleft-=xleft*(txright - txleft)/dx;
          tyleft-=xleft*(tyright - tyleft)/dx;
        }
        if (xleft<0) xleft = 0;
        if (xright>=width()-1) xright = width()-1;
        T* ptrd = data(xleft,y);
        tz *ptrz = zbuffer.data(xleft,y);
        if (opacity>=1) for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
            if (zleft>=(tzfloat)*ptrz) {
              *ptrz = (tz)zleft;
              const tzfloat invz = 1/zleft;
              const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const tl l = light(lxleft,lyleft,c);
                *ptrd = (T)(l<1?l**col:(2-l)**col+(l-1)*maxval);
                ptrd+=whd; col+=twhd;
              }
              ptrd-=offx;
            }
            zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
            lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
          } else for (int x = xleft; x<=xright; ++x, ++ptrz, ++ptrd) {
            if (zleft>=(tzfloat)*ptrz) {
              *ptrz = (tz)zleft;
              const tzfloat invz = 1/zleft;
              const tc *col = texture.data((int)(txleft*invz),(int)(tyleft*invz));
              for (int c = 0; c<(int)((*this)._spectrum); ++c) {
                const tl l = light(lxleft,lyleft,c);
                const T val = (T)(l<1?l**col:(2-l)**col+(l-1)*maxval);
                *ptrd = (T)(nopacity*val + *ptrd*copacity);
                ptrd+=whd; col+=twhd;
              }
              ptrd-=offx;
            }
            zleft+=pentez; txleft+=pentetx; tyleft+=pentety;
            lxleft+=rlx+((errlx-=ndlx)<0?errlx+=dx,slx:0);
            lyleft+=rly+((errly-=ndly)<0?errly+=dx,sly:0);
          }
        zr+=pzr; txr+=ptxr; tyr+=ptyr; zl+=pzl; txl+=ptxl; tyl+=ptyl;
      }
      return *this;
    }
# 33849 "../src/CImg.h"
    CImg<T>& draw_rectangle(const int x0, const int y0, const int z0, const int c0,
                            const int x1, const int y1, const int z1, const int c1,
                            const T val, const float opacity=1) {
      if (is_empty()) return *this;
      const bool bx = (x0<x1), by = (y0<y1), bz = (z0<z1), bc = (c0<c1);
      const int
        nx0 = bx?x0:x1, nx1 = bx?x1:x0,
        ny0 = by?y0:y1, ny1 = by?y1:y0,
        nz0 = bz?z0:z1, nz1 = bz?z1:z0,
        nc0 = bc?c0:c1, nc1 = bc?c1:c0;
      const int
        lX = (1 + nx1 - nx0) + (nx1>=width()?width() - 1 - nx1:0) + (nx0<0?nx0:0),
        lY = (1 + ny1 - ny0) + (ny1>=height()?height() - 1 - ny1:0) + (ny0<0?ny0:0),
        lZ = (1 + nz1 - nz0) + (nz1>=depth()?depth() - 1 - nz1:0) + (nz0<0?nz0:0),
        lC = (1 + nc1 - nc0) + (nc1>=spectrum()?spectrum() - 1 - nc1:0) + (nc0<0?nc0:0);
      const unsigned long
        offX = (unsigned long)_width - lX,
        offY = (unsigned long)_width*(_height - lY),
        offZ = (unsigned long)_width*_height*(_depth - lZ);
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      T *ptrd = data(nx0<0?0:nx0,ny0<0?0:ny0,nz0<0?0:nz0,nc0<0?0:nc0);
      if (lX>0 && lY>0 && lZ>0 && lC>0)
        for (int v = 0; v<lC; ++v) {
          for (int z = 0; z<lZ; ++z) {
            for (int y = 0; y<lY; ++y) {
              if (opacity>=1) {
                if (sizeof(T)!=1) { for (int x = 0; x<lX; ++x) *(ptrd++) = val; ptrd+=offX; }
                else { std::memset(ptrd,(int)val,lX); ptrd+=_width; }
              } else { for (int x = 0; x<lX; ++x) { *ptrd = (T)(nopacity*val + *ptrd*copacity); ++ptrd; } ptrd+=offX; }
            }
            ptrd+=offY;
          }
          ptrd+=offZ;
        }
      return *this;
    }
# 33897 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_rectangle(const int x0, const int y0, const int z0,
                            const int x1, const int y1, const int z1,
                            const tc *const color, const float opacity=1) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_rectangle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      for (int c = 0; c<(int)((*this)._spectrum); ++c) draw_rectangle(x0,y0,z0,c,x1,y1,z1,c,(T)color[c],opacity);
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_rectangle(const int x0, const int y0, const int z0,
                            const int x1, const int y1, const int z1,
                            const tc *const color, const float opacity,
                            const unsigned int pattern) {
      return draw_line(x0,y0,z0,x1,y0,z0,color,opacity,pattern,true).
        draw_line(x1,y0,z0,x1,y1,z0,color,opacity,pattern,false).
        draw_line(x1,y1,z0,x0,y1,z0,color,opacity,pattern,false).
        draw_line(x0,y1,z0,x0,y0,z0,color,opacity,pattern,false).
        draw_line(x0,y0,z1,x1,y0,z1,color,opacity,pattern,true).
        draw_line(x1,y0,z1,x1,y1,z1,color,opacity,pattern,false).
        draw_line(x1,y1,z1,x0,y1,z1,color,opacity,pattern,false).
        draw_line(x0,y1,z1,x0,y0,z1,color,opacity,pattern,false).
        draw_line(x0,y0,z0,x0,y0,z1,color,opacity,pattern,true).
        draw_line(x1,y0,z0,x1,y0,z1,color,opacity,pattern,true).
        draw_line(x1,y1,z0,x1,y1,z1,color,opacity,pattern,true).
        draw_line(x0,y1,z0,x0,y1,z1,color,opacity,pattern,true);
    }
# 33939 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_rectangle(const int x0, const int y0,
                            const int x1, const int y1,
                            const tc *const color, const float opacity=1) {
      return draw_rectangle(x0,y0,0,x1,y1,_depth-1,color,opacity);
    }


    template<typename tc>
    CImg<T>& draw_rectangle(const int x0, const int y0,
                            const int x1, const int y1,
                            const tc *const color, const float opacity,
                            const unsigned int pattern) {
      if (is_empty()) return *this;
      if (y0==y1) return draw_line(x0,y0,x1,y0,color,opacity,pattern,true);
      if (x0==x1) return draw_line(x0,y0,x0,y1,color,opacity,pattern,true);
      const bool bx = (x0<x1), by = (y0<y1);
      const int
        nx0 = bx?x0:x1, nx1 = bx?x1:x0,
        ny0 = by?y0:y1, ny1 = by?y1:y0;
      if (ny1==ny0+1) return draw_line(nx0,ny0,nx1,ny0,color,opacity,pattern,true).
                      draw_line(nx1,ny1,nx0,ny1,color,opacity,pattern,false);
      return draw_line(nx0,ny0,nx1,ny0,color,opacity,pattern,true).
        draw_line(nx1,ny0+1,nx1,ny1-1,color,opacity,pattern,false).
        draw_line(nx1,ny1,nx0,ny1,color,opacity,pattern,false).
        draw_line(nx0,ny1-1,nx0,ny0+1,color,opacity,pattern,false);
    }







    template<typename t, typename tc>
    CImg<T>& draw_polygon(const CImg<t>& points,
                          const tc *const color, const float opacity=1) {
      if (is_empty() || !points) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_polygon(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());


      CImg<intT> npoints(points._width,2);
      unsigned int nb_points = 1, p = 0;
      int cx = npoints(0,0) = (int)points(0,0), cy = npoints(0,1) = (int)points(0,1);
      const int cx0 = cx, cy0 = cy;
      for (p = 1; p<points._width; ++p) {
        const int nx = (int)points(p,0), ny = (int)points(p,1);
        if (nx!=cx || ny!=cy) { npoints(nb_points,0) = nx; npoints(nb_points++,1) = ny; cx = nx; cy = ny; }
      }
      --p;
      if ((int)points(p,0)==cx0 && (int)points(p,1)==cy0) --nb_points;
      if (nb_points<=1) return draw_point((int)npoints(0,0),(int)npoints(0,1),color,opacity);
      if (nb_points==2) return draw_line((int)npoints(0,0),(int)npoints(0,1),
                                         (int)npoints(1,0),(int)npoints(1,1),color,opacity);
      if (nb_points==3) return draw_triangle((int)npoints(0,0),(int)npoints(0,1),
                                             (int)npoints(1,0),(int)npoints(1,1),
                                             (int)npoints(2,0),(int)npoints(2,1),color,opacity);


      if (npoints(0,1)==npoints(nb_points-1,1)) {
        const intT y0 = npoints(0,1);
        unsigned int off = 1;
        while ((int)npoints(off,1)==y0 && off<nb_points) ++off;
        if (off<nb_points) {
          npoints.get_shared_points(0,nb_points-1,0).shift(-(int)off,0,0,0,2);
          npoints.get_shared_points(0,nb_points-1,1).shift(-(int)off,0,0,0,2);
        }
      }

      const float _sc_nopacity = cimg::abs((float)1), _sc_copacity = 1 - cimg::max((float)1,0); const unsigned long _sc_whd = (unsigned long)_width*_height*_depth;

      if (opacity!=1) {
        npoints.resize(nb_points,2,1,1,0);
        CImg<intT> npoints_x = npoints.get_shared_row(0), npoints_y = npoints.get_shared_row(1);
        int xmax = 0, xmin = (int)npoints_x.min_max(xmax), ymax = 0, ymin = (int)npoints_y.min_max(ymax);
        if (xmax<0 || xmin>=width() || ymax<0 || ymin>=height()) return *this;
        if (ymin==ymax) return _draw_scanline(xmin,xmax,ymin,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
        const unsigned int
          nxmin = xmin<0?0:(unsigned int)xmin, nxmax = xmax>=width()?_width-1:(unsigned int)xmax,
          nymin = ymin<0?0:(unsigned int)ymin, nymax = ymax>=height()?_height-1:(unsigned int)ymax,
          dx = 1 + nxmax - nxmin,
          dy = 1 + nymax - nymin;
        npoints_x-=nxmin; npoints_y-=nymin;
        unsigned char one = 1;
        const CImg<unsigned char> mask = CImg<unsigned char>(dx,dy,1,1,0).draw_polygon(npoints,&one,1);
        CImg<T> _color(dx,dy,1,spectrum());
        for (int c = 0; c<(int)((_color)._spectrum); ++c) _color.get_shared_channel(c).fill(color[c]);
        return draw_image(nxmin,nymin,0,0,_color,mask,opacity,1);
      }


      int
        xmax = 0, xmin = (int)npoints.get_shared_points(0,nb_points-1,0).min_max(xmax),
        ymax = 0, ymin = (int)npoints.get_shared_points(0,nb_points-1,1).min_max(ymax);
      if (xmax<0 || xmin>=width() || ymax<0 || ymin>=height()) return *this;
      if (ymin==ymax) return _draw_scanline(xmin,xmax,ymin,color,1,1,_sc_nopacity,_sc_copacity,_sc_whd);
      const unsigned int
        nymin = ymin<0?0:(unsigned int)ymin,
        nymax = ymax>=height()?_height-1:(unsigned int)ymax,
        dy = 1 + nymax - nymin;
      CImg<intT> X(1+2*nb_points,dy,1,1,0), tmp;
      cx = (int)npoints(0,0), cy = (int)npoints(0,1);
      unsigned int cp = 0;
      for (unsigned int p = 0; p<nb_points; ++p) {
        const unsigned int np = (p!=nb_points-1)?p+1:0, ap = (np!=nb_points-1)?np+1:0;
        const int
          nx = (int)npoints(np,0), ny = (int)npoints(np,1), ay = (int)npoints(ap,1),
          y0 = cy - nymin, y1 = ny - nymin;
        if (y0!=y1) {
          const int countermin = ((ny<ay && cy<ny) || (ny>ay && cy>ny))?1:0;
          for (int x = cx, y = y0, _sx = 1, _sy = 1,
                 _dx = nx>cx?nx-cx:((_sx=-1),cx-nx),
                 _dy = y1>y0?y1-y0:((_sy=-1),y0-y1),
                 _counter = ((_dx-=_dy?_dy*(_dx/_dy):0),_dy),
                 _err = _dx>>1,
                 _rx = _dy?(nx-cx)/_dy:0;
               _counter>=countermin;
               --_counter, y+=_sy, x+=_rx + ((_err-=_dx)<0?_err+=_dy,_sx:0))
            if (y>=0 && y<(int)dy) X(++X(0,y),y) = x;
          cp = np; cx = nx; cy = ny;
        } else {
          const int pp = (cp?cp-1:nb_points-1), py = (int)npoints(pp,1);
          if (y0>=0 && y0<(int)dy) {
            _draw_scanline(cx<nx?cx:nx,cx<nx?nx:cx,y0+nymin,color,1,1,_sc_nopacity,_sc_copacity,_sc_whd);
            if ((cy>py && ay>cy) || (cy<py && ay<cy)) X(++X(0,y0),y0) = cx;
          }
          if (cy!=ay) { cp = np; cx = nx; cy = ny; }
        }
      }


      for (int y = 0; y<(int)dy; ++y) {
        tmp.assign(X.data(1,y),X(0,y),1,1,1,true).sort();
        for (int i = 1; i<=X(0,y); ) {
          const int xb = X(i++,y), xe = X(i++,y);
          _draw_scanline(xb,xe,nymin+y,color,1,1,_sc_nopacity,_sc_copacity,_sc_whd);
        }
      }
      return *this;
    }


    template<typename t, typename tc>
    CImg<T>& draw_polygon(const CImg<t>& points,
                          const tc *const color, const float opacity, const unsigned int pattern) {
      if (is_empty() || !points || points._width<3) return *this;
      bool ninit_hatch = true;
      switch (points._height) {
      case 0 : case 1 :
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_polygon(): Invalid specified point set.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      case 2 : {
        CImg<intT> npoints(points._width,2);
        int x = npoints(0,0) = (int)points(0,0), y = npoints(0,1) = (int)points(0,1);
        unsigned int nb_points = 1;
        for (unsigned int p = 1; p<points._width; ++p) {
          const int nx = (int)points(p,0), ny = (int)points(p,1);
          if (nx!=x || ny!=y) { npoints(nb_points,0) = nx; npoints(nb_points++,1) = ny; x = nx; y = ny; }
        }
        const int x0 = (int)npoints(0,0), y0 = (int)npoints(0,1);
        int ox = x0, oy = y0;
        for (unsigned int i = 1; i<nb_points; ++i) {
          const int x = (int)npoints(i,0), y = (int)npoints(i,1);
          draw_line(ox,oy,x,y,color,opacity,pattern,ninit_hatch);
          ninit_hatch = false;
          ox = x; oy = y;
        }
        draw_line(ox,oy,x0,y0,color,opacity,pattern,false);
      } break;
      default : {
        CImg<intT> npoints(points._width,3);
        int
          x = npoints(0,0) = (int)points(0,0),
          y = npoints(0,1) = (int)points(0,1),
          z = npoints(0,2) = (int)points(0,2);
        unsigned int nb_points = 1;
        for (unsigned int p = 1; p<points._width; ++p) {
          const int nx = (int)points(p,0), ny = (int)points(p,1), nz = (int)points(p,2);
          if (nx!=x || ny!=y || nz!=z) {
            npoints(nb_points,0) = nx; npoints(nb_points,1) = ny; npoints(nb_points++,2) = nz;
            x = nx; y = ny; z = nz;
          }
        }
        const int x0 = (int)npoints(0,0), y0 = (int)npoints(0,1), z0 = (int)npoints(0,2);
        int ox = x0, oy = y0, oz = z0;
        for (unsigned int i = 1; i<nb_points; ++i) {
          const int x = (int)npoints(i,0), y = (int)npoints(i,1), z = (int)npoints(i,2);
          draw_line(ox,oy,oz,x,y,z,color,opacity,pattern,ninit_hatch);
          ninit_hatch = false;
          ox = x; oy = y; oz = z;
        }
        draw_line(ox,oy,oz,x0,y0,z0,color,opacity,pattern,false);
      }
      }
      return *this;
    }
# 34150 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_ellipse(const int x0, const int y0, const float r1, const float r2, const float angle,
                          const tc *const color, const float opacity=1) {
      return _draw_ellipse(x0,y0,r1,r2,angle,color,opacity,0U);
    }
# 34164 "../src/CImg.h"
    template<typename t, typename tc>
    CImg<T>& draw_ellipse(const int x0, const int y0, const CImg<t> &tensor,
                          const tc *const color, const float opacity=1) {
      CImgList<t> eig = tensor.get_symmetric_eigen();
      const CImg<t> &val = eig[0], &vec = eig[1];
      return draw_ellipse(x0,y0,std::sqrt(val(0)),std::sqrt(val(1)),
                          std::atan2(vec(0,1),vec(0,0))*180/cimg::PI,
                          color,opacity);
    }
# 34185 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_ellipse(const int x0, const int y0, const float r1, const float r2, const float angle,
                          const tc *const color, const float opacity, const unsigned int pattern) {
      if (pattern) _draw_ellipse(x0,y0,r1,r2,angle,color,opacity,pattern);
      return *this;
    }
# 34201 "../src/CImg.h"
    template<typename t, typename tc>
    CImg<T>& draw_ellipse(const int x0, const int y0, const CImg<t> &tensor,
                          const tc *const color, const float opacity,
                          const unsigned int pattern) {
      CImgList<t> eig = tensor.get_symmetric_eigen();
      const CImg<t> &val = eig[0], &vec = eig[1];
      return draw_ellipse(x0,y0,std::sqrt(val(0)),std::sqrt(val(1)),
                          std::atan2(vec(0,1),vec(0,0))*180/cimg::PI,
                          color,opacity,pattern);
    }

    template<typename tc>
    CImg<T>& _draw_ellipse(const int x0, const int y0, const float r1, const float r2, const float angle,
                           const tc *const color, const float opacity,
                           const unsigned int pattern) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_ellipse(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (r1<=0 || r2<=0) return draw_point(x0,y0,color,opacity);
      const float _sc_nopacity = cimg::abs((float)opacity), _sc_copacity = 1 - cimg::max((float)opacity,0); const unsigned long _sc_whd = (unsigned long)_width*_height*_depth;
      const float
        nr1 = cimg::abs(r1), nr2 = cimg::abs(r2),
        nangle = (float)(angle*cimg::PI/180),
        u = (float)std::cos(nangle),
        v = (float)std::sin(nangle),
        rmax = cimg::max(nr1,nr2),
        l1 = (float)std::pow(rmax/(nr1>0?nr1:1e-6),2),
        l2 = (float)std::pow(rmax/(nr2>0?nr2:1e-6),2),
        a = l1*u*u + l2*v*v,
        b = u*v*(l1-l2),
        c = l1*v*v + l2*u*u;
      const int
        yb = (int)std::sqrt(a*rmax*rmax/(a*c - b*b)),
        tymin = y0 - yb - 1,
        tymax = y0 + yb + 1,
        ymin = tymin<0?0:tymin,
        ymax = tymax>=height()?height()-1:tymax;
      int oxmin = 0, oxmax = 0;
      bool first_line = true;
      for (int y = ymin; y<=ymax; ++y) {
        const float
          Y = y - y0 + (y<y0?0.5f:-0.5f),
          delta = b*b*Y*Y - a*(c*Y*Y - rmax*rmax),
          sdelta = delta>0?(float)std::sqrt(delta)/a:0.0f,
          bY = b*Y/a,
          fxmin = x0 - 0.5f - bY - sdelta,
          fxmax = x0 + 0.5f - bY + sdelta;
        const int xmin = (int)fxmin, xmax = (int)fxmax;
        if (!pattern) _draw_scanline(xmin,xmax,y,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
        else {
          if (first_line) {
            if (y0-yb>=0) _draw_scanline(xmin,xmax,y,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
            else draw_point(xmin,y,color,opacity).draw_point(xmax,y,color,opacity);
            first_line = false;
          } else {
            if (xmin<oxmin) _draw_scanline(xmin,oxmin-1,y,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
            else _draw_scanline(oxmin+(oxmin==xmin?0:1),xmin,y,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
            if (xmax<oxmax) _draw_scanline(xmax,oxmax-1,y,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
            else _draw_scanline(oxmax+(oxmax==xmax?0:1),xmax,y,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
            if (y==tymax) _draw_scanline(xmin+1,xmax-1,y,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
          }
        }
        oxmin = xmin; oxmax = xmax;
      }
      return *this;
    }
# 34280 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_circle(const int x0, const int y0, int radius,
                         const tc *const color, const float opacity=1) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_circle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      const float _sc_nopacity = cimg::abs((float)opacity), _sc_copacity = 1 - cimg::max((float)opacity,0); const unsigned long _sc_whd = (unsigned long)_width*_height*_depth;
      if (radius<0 || x0-radius>=width() || y0+radius<0 || y0-radius>=height()) return *this;
      if (y0>=0 && y0<height()) _draw_scanline(x0-radius,x0+radius,y0,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
      for (int f = 1-radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {
        if (f>=0) {
          const int x1 = x0-x, x2 = x0+x, y1 = y0-y, y2 = y0+y;
          if (y1>=0 && y1<height()) _draw_scanline(x1,x2,y1,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
          if (y2>=0 && y2<height()) _draw_scanline(x1,x2,y2,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
          f+=(ddFy+=2); --y;
        }
        const bool no_diag = y!=(x++);
        ++(f+=(ddFx+=2));
        const int x1 = x0-y, x2 = x0+y, y1 = y0-x, y2 = y0+x;
        if (no_diag) {
          if (y1>=0 && y1<height()) _draw_scanline(x1,x2,y1,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
          if (y2>=0 && y2<height()) _draw_scanline(x1,x2,y2,color,opacity,1,_sc_nopacity,_sc_copacity,_sc_whd);
        }
      }
      return *this;
    }
# 34318 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_circle(const int x0, const int y0, int radius,
                         const tc *const color, const float opacity,
                         const unsigned int pattern) {
      cimg::unused(pattern);
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_circle(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (radius<0 || x0-radius>=width() || y0+radius<0 || y0-radius>=height()) return *this;
      if (!radius) return draw_point(x0,y0,color,opacity);
      draw_point(x0-radius,y0,color,opacity).draw_point(x0+radius,y0,color,opacity).
        draw_point(x0,y0-radius,color,opacity).draw_point(x0,y0+radius,color,opacity);
      if (radius==1) return *this;
      for (int f = 1-radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {
        if (f>=0) { f+=(ddFy+=2); --y; }
        ++x; ++(f+=(ddFx+=2));
        if (x!=y+1) {
          const int x1 = x0-y, x2 = x0+y, y1 = y0-x, y2 = y0+x, x3 = x0-x, x4 = x0+x, y3 = y0-y, y4 = y0+y;
          draw_point(x1,y1,color,opacity).draw_point(x1,y2,color,opacity).
            draw_point(x2,y1,color,opacity).draw_point(x2,y2,color,opacity);
          if (x!=y)
            draw_point(x3,y3,color,opacity).draw_point(x4,y4,color,opacity).
              draw_point(x4,y3,color,opacity).draw_point(x3,y4,color,opacity);
        }
      }
      return *this;
    }
# 34357 "../src/CImg.h"
    template<typename t>
    CImg<T>& draw_image(const int x0, const int y0, const int z0, const int c0,
                        const CImg<t>& sprite, const float opacity=1) {
      if (is_empty() || !sprite) return *this;
      if (is_overlapped(sprite)) return draw_image(x0,y0,z0,c0,+sprite,opacity);
      if (x0==0 && y0==0 && z0==0 && c0==0 && is_sameXYZC(sprite) && opacity>=1 && !is_shared())
        return assign(sprite,false);
      const bool bx = (x0<0), by = (y0<0), bz = (z0<0), bc = (c0<0);
      const int
        lX = sprite.width() - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0) + (bx?x0:0),
        lY = sprite.height() - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0) + (by?y0:0),
        lZ = sprite.depth() - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0) + (bz?z0:0),
        lC = sprite.spectrum() - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0) + (bc?c0:0);
      const t
        *ptrs = sprite._data -
        (bx?x0:0) -
        (by?y0*sprite.width():0) -
        (bz?z0*sprite.width()*sprite.height():0) -
        (bc?c0*sprite.width()*sprite.height()*sprite.depth():0);
      const unsigned long
        offX = (unsigned long)_width - lX,
        soffX = (unsigned long)sprite._width - lX,
        offY = (unsigned long)_width*(_height - lY),
        soffY = (unsigned long)sprite._width*(sprite._height - lY),
        offZ = (unsigned long)_width*_height*(_depth - lZ),
        soffZ = (unsigned long)sprite._width*sprite._height*(sprite._depth - lZ);
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      if (lX>0 && lY>0 && lZ>0 && lC>0) {
        T *ptrd = data(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,c0<0?0:c0);
        for (int v = 0; v<lC; ++v) {
          for (int z = 0; z<lZ; ++z) {
            for (int y = 0; y<lY; ++y) {
              if (opacity>=1) for (int x = 0; x<lX; ++x) *(ptrd++) = (T)*(ptrs++);
              else for (int x = 0; x<lX; ++x) { *ptrd = (T)(nopacity*(*(ptrs++)) + *ptrd*copacity); ++ptrd; }
              ptrd+=offX; ptrs+=soffX;
            }
            ptrd+=offY; ptrs+=soffY;
          }
          ptrd+=offZ; ptrs+=soffZ;
        }
      }
      return *this;
    }


    CImg<T>& draw_image(const int x0, const int y0, const int z0, const int c0,
                        const CImg<T>& sprite, const float opacity=1) {
      if (is_empty() || !sprite) return *this;
      if (is_overlapped(sprite)) return draw_image(x0,y0,z0,c0,+sprite,opacity);
      if (x0==0 && y0==0 && z0==0 && c0==0 && is_sameXYZC(sprite) && opacity>=1 && !is_shared())
        return assign(sprite,false);
      const bool bx = (x0<0), by = (y0<0), bz = (z0<0), bc = (c0<0);
      const int
        lX = sprite.width() - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0) + (bx?x0:0),
        lY = sprite.height() - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0) + (by?y0:0),
        lZ = sprite.depth() - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0) + (bz?z0:0),
        lC = sprite.spectrum() - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0) + (bc?c0:0);
      const T
        *ptrs = sprite._data -
        (bx?x0:0) -
        (by?y0*sprite.width():0) -
        (bz?z0*sprite.width()*sprite.height():0) -
        (bc?c0*sprite.width()*sprite.height()*sprite.depth():0);
      const unsigned long
        offX = (unsigned long)_width - lX,
        soffX = (unsigned long)sprite._width - lX,
        offY = (unsigned long)_width*(_height - lY),
        soffY = (unsigned long)sprite._width*(sprite._height - lY),
        offZ = (unsigned long)_width*_height*(_depth - lZ),
        soffZ = (unsigned long)sprite._width*sprite._height*(sprite._depth - lZ),
        slX = lX*sizeof(T);
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      if (lX>0 && lY>0 && lZ>0 && lC>0) {
        T *ptrd = data(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,c0<0?0:c0);
        for (int v = 0; v<lC; ++v) {
          for (int z = 0; z<lZ; ++z) {
            if (opacity>=1)
              for (int y = 0; y<lY; ++y) { std::memcpy(ptrd,ptrs,slX); ptrd+=_width; ptrs+=sprite._width; }
            else for (int y = 0; y<lY; ++y) {
                for (int x = 0; x<lX; ++x) { *ptrd = (T)(nopacity*(*(ptrs++)) + *ptrd*copacity); ++ptrd; }
                ptrd+=offX; ptrs+=soffX;
              }
            ptrd+=offY; ptrs+=soffY;
          }
          ptrd+=offZ; ptrs+=soffZ;
        }
      }
      return *this;
    }


    template<typename t>
    CImg<T>& draw_image(const int x0, const int y0, const int z0,
                        const CImg<t>& sprite, const float opacity=1) {
      return draw_image(x0,y0,z0,0,sprite,opacity);
    }


    template<typename t>
    CImg<T>& draw_image(const int x0, const int y0,
                        const CImg<t>& sprite, const float opacity=1) {
      return draw_image(x0,y0,0,sprite,opacity);
    }


    template<typename t>
    CImg<T>& draw_image(const int x0,
                        const CImg<t>& sprite, const float opacity=1) {
      return draw_image(x0,0,sprite,opacity);
    }


    template<typename t>
    CImg<T>& draw_image(const CImg<t>& sprite, const float opacity=1) {
      return draw_image(0,sprite,opacity);
    }
# 34488 "../src/CImg.h"
    template<typename ti, typename tm>
    CImg<T>& draw_image(const int x0, const int y0, const int z0, const int c0,
                        const CImg<ti>& sprite, const CImg<tm>& mask, const float opacity=1,
                        const float mask_max_value=1) {
      if (is_empty() || !sprite || !mask) return *this;
      if (is_overlapped(sprite)) return draw_image(x0,y0,z0,c0,+sprite,mask,opacity,mask_max_value);
      if (is_overlapped(mask)) return draw_image(x0,y0,z0,c0,sprite,+mask,opacity,mask_max_value);
      if (mask._width!=sprite._width || mask._height!=sprite._height || mask._depth!=sprite._depth)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_image(): Sprite (%u,%u,%u,%u,%p) and mask (%u,%u,%u,%u,%p) have "
                                    "incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    sprite._width,sprite._height,sprite._depth,sprite._spectrum,sprite._data,
                                    mask._width,mask._height,mask._depth,mask._spectrum,mask._data);

      const bool bx = (x0<0), by = (y0<0), bz = (z0<0), bc = (c0<0);
      const int
        lX = sprite.width() - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0) + (bx?x0:0),
        lY = sprite.height() - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0) + (by?y0:0),
        lZ = sprite.depth() - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0) + (bz?z0:0),
        lC = sprite.spectrum() - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0) + (bc?c0:0);
      const int
        coff = -(bx?x0:0)-(by?y0*mask.width():0)-(bz?z0*mask.width()*mask.height():0)-
          (bc?c0*mask.width()*mask.height()*mask.depth():0),
        ssize = mask.width()*mask.height()*mask.depth()*mask.spectrum();
      const ti *ptrs = sprite._data + coff;
      const tm *ptrm = mask._data + coff;
      const unsigned long
        offX = (unsigned long)_width - lX,
        soffX = (unsigned long)sprite._width - lX,
        offY = (unsigned long)_width*(_height - lY),
        soffY = (unsigned long)sprite._width*(sprite._height - lY),
        offZ = (unsigned long)_width*_height*(_depth - lZ),
        soffZ = (unsigned long)sprite._width*sprite._height*(sprite._depth - lZ);
      if (lX>0 && lY>0 && lZ>0 && lC>0) {
        T *ptrd = data(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,c0<0?0:c0);
        for (int c = 0; c<lC; ++c) {
          ptrm = mask._data + (ptrm - mask._data)%ssize;
          for (int z = 0; z<lZ; ++z) {
            for (int y = 0; y<lY; ++y) {
              for (int x = 0; x<lX; ++x) {
                const float mopacity = (float)(*(ptrm++)*opacity),
                  nopacity = cimg::abs(mopacity), copacity = mask_max_value - cimg::max(mopacity,0);
                *ptrd = (T)((nopacity*(*(ptrs++)) + *ptrd*copacity)/mask_max_value);
                ++ptrd;
              }
              ptrd+=offX; ptrs+=soffX; ptrm+=soffX;
            }
            ptrd+=offY; ptrs+=soffY; ptrm+=soffY;
          }
          ptrd+=offZ; ptrs+=soffZ; ptrm+=soffZ;
        }
      }
      return *this;
    }


    template<typename ti, typename tm>
    CImg<T>& draw_image(const int x0, const int y0, const int z0,
                        const CImg<ti>& sprite, const CImg<tm>& mask, const float opacity=1,
                        const float mask_max_value=1) {
      return draw_image(x0,y0,z0,0,sprite,mask,opacity,mask_max_value);
    }


    template<typename ti, typename tm>
    CImg<T>& draw_image(const int x0, const int y0,
                        const CImg<ti>& sprite, const CImg<tm>& mask, const float opacity=1,
                        const float mask_max_value=1) {
      return draw_image(x0,y0,0,sprite,mask,opacity,mask_max_value);
    }


    template<typename ti, typename tm>
    CImg<T>& draw_image(const int x0,
                        const CImg<ti>& sprite, const CImg<tm>& mask, const float opacity=1,
                        const float mask_max_value=1) {
      return draw_image(x0,0,sprite,mask,opacity,mask_max_value);
    }


    template<typename ti, typename tm>
    CImg<T>& draw_image(const CImg<ti>& sprite, const CImg<tm>& mask, const float opacity=1,
                        const float mask_max_value=1) {
      return draw_image(0,sprite,mask,opacity,mask_max_value);
    }
# 34585 "../src/CImg.h"
    template<typename tc1, typename tc2, typename t>
    CImg<T>& draw_text(const int x0, const int y0,
                       const char *const text,
                       const tc1 *const foreground_color, const tc2 *const background_color,
                       const float opacity, const CImgList<t>& font, ...) {
      if (!font) return *this;
      char tmp[2048] = { 0 }; std::va_list ap; __builtin_va_start(ap,font);
      vsnprintf(tmp,sizeof(tmp),text,ap); __builtin_va_end(ap);
      return _draw_text(x0,y0,tmp,foreground_color,background_color,opacity,font,false);
    }





    template<typename tc, typename t>
    CImg<T>& draw_text(const int x0, const int y0,
                       const char *const text,
                       const tc *const foreground_color, const int,
                       const float opacity, const CImgList<t>& font, ...) {
      if (!font) return *this;
      char tmp[2048] = { 0 }; std::va_list ap; __builtin_va_start(ap,font);
      vsnprintf(tmp,sizeof(tmp),text,ap); __builtin_va_end(ap);
      return _draw_text(x0,y0,tmp,foreground_color,(tc*)0,opacity,font,false);
    }





    template<typename tc, typename t>
    CImg<T>& draw_text(const int x0, const int y0,
                       const char *const text,
                       const int, const tc *const background_color,
                       const float opacity, const CImgList<t>& font, ...) {
      if (!font) return *this;
      char tmp[2048] = { 0 }; std::va_list ap; __builtin_va_start(ap,font);
      vsnprintf(tmp,sizeof(tmp),text,ap); __builtin_va_end(ap);
      return _draw_text(x0,y0,tmp,(tc*)0,background_color,opacity,font,false);
    }
# 34638 "../src/CImg.h"
    template<typename tc1, typename tc2>
    CImg<T>& draw_text(const int x0, const int y0,
                       const char *const text,
                       const tc1 *const foreground_color, const tc2 *const background_color,
                       const float opacity=1, const unsigned int font_height=13, ...) {
      if (!font_height) return *this;
      char tmp[2048] = { 0 };
      std::va_list ap; __builtin_va_start(ap,font_height); vsnprintf(tmp,sizeof(tmp),text,ap); __builtin_va_end(ap);
      const CImgList<ucharT>& font = CImgList<ucharT>::font(font_height,true);
      _draw_text(x0,y0,tmp,foreground_color,background_color,opacity,font,true);
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_text(const int x0, const int y0,
                       const char *const text,
                       const tc *const foreground_color, const int background_color=0,
                       const float opacity=1, const unsigned int font_height=13, ...) {
      if (!font_height) return *this;
      cimg::unused(background_color);
      char tmp[2048] = { 0 };
      std::va_list ap; __builtin_va_start(ap,font_height); vsnprintf(tmp,sizeof(tmp),text,ap); __builtin_va_end(ap);
      return draw_text(x0,y0,"%s",foreground_color,(const tc*)0,opacity,font_height,tmp);
    }


    template<typename tc>
    CImg<T>& draw_text(const int x0, const int y0,
                       const char *const text,
                       const int, const tc *const background_color,
                       const float opacity=1, const unsigned int font_height=13, ...) {
      if (!font_height) return *this;
      char tmp[2048] = { 0 };
      std::va_list ap; __builtin_va_start(ap,font_height); vsnprintf(tmp,sizeof(tmp),text,ap); __builtin_va_end(ap);
      return draw_text(x0,y0,"%s",(tc*)0,background_color,opacity,font_height,tmp);
    }

    template<typename tc1, typename tc2, typename t>
    CImg<T>& _draw_text(const int x0, const int y0,
                        const char *const text,
                        const tc1 *const foreground_color, const tc2 *const background_color,
                        const float opacity, const CImgList<t>& font,
                        const bool is_native_font) {
      if (!text) return *this;
      if (!font)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_text(): Empty specified font.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const unsigned int text_length = (unsigned int)std::strlen(text);
      const bool _is_empty = is_empty();
      if (_is_empty) {

        int x = 0, y = 0, w = 0;
        unsigned char c = 0;
        for (unsigned int i = 0; i<text_length; ++i) {
          c = text[i];
          switch (c) {
          case '\n' : y+=font[0]._height; if (x>w) w = x; x = 0; break;
          case '\t' : x+=4*font[' ']._width; break;
          default : if (c<font._width) x+=font[c]._width;
          }
        }
        if (x!=0 || c=='\n') {
          if (x>w) w=x;
          y+=font[0]._height;
        }
        assign(x0+w,y0+y,1,is_native_font?1:font[0]._spectrum,0);
      }

      int x = x0, y = y0;
      for (unsigned int i = 0; i<text_length; ++i) {
        const unsigned char c = text[i];
        switch (c) {
        case '\n' : y+=font[0]._height; x = x0; break;
        case '\t' : x+=4*font[' ']._width; break;
        default : if (c<font._width) {
            CImg<T> letter = font[c];
            if (letter) {
              if (is_native_font && _spectrum>letter._spectrum) letter.resize(-100,-100,1,_spectrum,0,2);
              const unsigned int cmin = cimg::min(_spectrum,letter._spectrum);
              if (foreground_color)
                for (unsigned int c = 0; c<cmin; ++c)
                  if (foreground_color[c]!=1) letter.get_shared_channel(c)*=foreground_color[c];
              if (c+256<font.width()) {
                if (background_color)
                  for (unsigned int c = 0; c<cmin; ++c)
                    draw_rectangle(x,y,0,c,x+letter._width-1,y+letter._height-1,0,c,background_color[c],opacity);
                draw_image(x,y,letter,font[c+256],opacity,(T)255);
              } else draw_image(x,y,letter,opacity);
              x+=letter._width;
            }
          }
        }
      }
      return *this;
    }
# 34748 "../src/CImg.h"
    template<typename t1, typename t2>
    CImg<T>& draw_quiver(const CImg<t1>& flow,
                         const t2 *const color, const float opacity=1,
                         const unsigned int sampling=25, const float factor=-20,
                         const bool is_arrow=true, const unsigned int pattern=~0U) {
      return draw_quiver(flow,CImg<t2>(color,_spectrum,1,1,1,true),opacity,sampling,factor,is_arrow,pattern);
    }
# 34767 "../src/CImg.h"
    template<typename t1, typename t2>
    CImg<T>& draw_quiver(const CImg<t1>& flow,
                         const CImg<t2>& color, const float opacity=1,
                         const unsigned int sampling=25, const float factor=-20,
                         const bool is_arrow=true, const unsigned int pattern=~0U) {
      if (is_empty()) return *this;
      if (!flow || flow._spectrum!=2)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_quiver(): Invalid dimensions of specified flow (%u,%u,%u,%u,%p).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    flow._width,flow._height,flow._depth,flow._spectrum,flow._data);
      if (sampling<=0)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_quiver(): Invalid sampling value %g "
                                    "(should be >0)",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    sampling);
      const bool colorfield = (color._width==flow._width && color._height==flow._height &&
                               color._depth==1 && color._spectrum==_spectrum);
      if (is_overlapped(flow)) return draw_quiver(+flow,color,opacity,sampling,factor,is_arrow,pattern);
      float vmax,fact;
      if (factor<=0) {
        float m, M = (float)flow.get_norm(2).max_min(m);
        vmax = (float)cimg::max(cimg::abs(m),cimg::abs(M));
        if (!vmax) vmax = 1;
        fact = -factor;
      } else { fact = factor; vmax = 1; }

      for (unsigned int y = sampling/2; y<_height; y+=sampling)
        for (unsigned int x = sampling/2; x<_width; x+=sampling) {
          const unsigned int X = x*flow._width/_width, Y = y*flow._height/_height;
          float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
          if (is_arrow) {
            const int xx = x+(int)u, yy = y+(int)v;
            if (colorfield) draw_arrow(x,y,xx,yy,color.get_vector_at(X,Y)._data,opacity,45,sampling/5.0f,pattern);
            else draw_arrow(x,y,xx,yy,color._data,opacity,45,sampling/5.0f,pattern);
          } else {
            if (colorfield)
              draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),
                        color.get_vector_at(X,Y)._data,opacity,pattern);
            else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),
                           color._data,opacity,pattern);
          }
        }
      return *this;
    }
# 34824 "../src/CImg.h"
    template<typename t, typename tc>
    CImg<T>& draw_axis(const CImg<t>& values_x, const int y,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const unsigned int font_height=13,
                       const bool allow_zero=true) {
      if (is_empty()) return *this;
      const int yt = (y+3+font_height)<_height?(y+3):(y-2-font_height);
      const int siz = (int)values_x.size()-1;
      char txt[32] = { 0 };
      CImg<T> label;
      if (siz<=0) {
        draw_line(0,y,_width-1,y,color,opacity,pattern);
        if (!siz) {
          snprintf(txt,sizeof(txt),"%g",(double)*values_x);
          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);
          const int
            _xt = (width() - label.width())/2,
            xt = _xt<3?3:_xt+label.width()>=width()-2?width()-3-label.width():_xt;
          draw_point(width()/2,y-1,color,opacity).draw_point(width()/2,y+1,color,opacity);
          if (allow_zero || txt[0]!='0' || txt[1]!=0)
            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);
        }
      } else {
        if (values_x[0]<values_x[siz]) draw_arrow(0,y,_width-1,y,color,opacity,30,5,pattern);
        else draw_arrow(_width-1,y,0,y,color,opacity,30,5,pattern);
        for (unsigned long x = 0, _maxx = (values_x).size(); x<_maxx; ++x) {
          snprintf(txt,sizeof(txt),"%g",(double)values_x(x));
          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);
          const int
            xi = (int)(x*(_width-1)/siz),
            _xt = xi - label.width()/2,
            xt = _xt<3?3:_xt+label.width()>=width()-2?width()-3-label.width():_xt;
          draw_point(xi,y-1,color,opacity).draw_point(xi,y+1,color,opacity);
          if (allow_zero || txt[0]!='0' || txt[1]!=0)
            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);
        }
      }
      return *this;
    }
# 34874 "../src/CImg.h"
    template<typename t, typename tc>
    CImg<T>& draw_axis(const int x, const CImg<t>& values_y,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern=~0U, const unsigned int font_height=13,
                       const bool allow_zero=true) {
      if (is_empty()) return *this;
      int siz = (int)values_y.size()-1;
      char txt[32] = { 0 };
      CImg<T> label;
      if (siz<=0) {
        draw_line(x,0,x,_height-1,color,opacity,pattern);
        if (!siz) {
          snprintf(txt,sizeof(txt),"%g",(double)*values_y);
          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);
          const int
            _yt = (height() - label.height())/2,
            yt = _yt<0?0:_yt+label.height()>=height()?height()-1-label.height():_yt,
            _xt = x - 2 - label.width(),
            xt = _xt>=0?_xt:x+3;
          draw_point(x-1,height()/2,color,opacity).draw_point(x+1,height()/2,color,opacity);
          if (allow_zero || txt[0]!='0' || txt[1]!=0)
            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);
        }
      } else {
        if (values_y[0]<values_y[siz]) draw_arrow(x,0,x,_height-1,color,opacity,30,5,pattern);
        else draw_arrow(x,_height-1,x,0,color,opacity,30,5,pattern);
        for (unsigned long y = 0, _maxy = (values_y).size(); y<_maxy; ++y) {
          snprintf(txt,sizeof(txt),"%g",(double)values_y(y));
          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);
          const int
            yi = (int)(y*(_height-1)/siz),
            _yt = yi - label.height()/2,
            yt = _yt<0?0:_yt+label.height()>=height()?height()-1-label.height():_yt,
            _xt = x - 2 - label.width(),
            xt = _xt>=0?_xt:x+3;
          draw_point(x-1,yi,color,opacity).draw_point(x+1,yi,color,opacity);
          if (allow_zero || txt[0]!='0' || txt[1]!=0)
            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);
        }
      }
      return *this;
    }
# 34928 "../src/CImg.h"
    template<typename tx, typename ty, typename tc>
    CImg<T>& draw_axes(const CImg<tx>& values_x, const CImg<ty>& values_y,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern_x=~0U, const unsigned int pattern_y=~0U,
                       const unsigned int font_height=13, const bool allow_zero=true) {
      if (is_empty()) return *this;
      const CImg<tx> nvalues_x(values_x._data,values_x.size(),1,1,1,true);
      const int sizx = (int)values_x.size()-1, wm1 = width()-1;
      if (sizx>=0) {
        float ox = (float)*nvalues_x;
        for (unsigned int x = sizx?1:0; x<_width; ++x) {
          const float nx = (float)nvalues_x._linear_atX((float)x*sizx/wm1);
          if (nx*ox<=0) { draw_axis(nx==0?x:x-1,values_y,color,opacity,pattern_y,font_height,allow_zero); break; }
          ox = nx;
        }
      }
      const CImg<ty> nvalues_y(values_y._data,values_y.size(),1,1,1,true);
      const int sizy = (int)values_y.size()-1, hm1 = height()-1;
      if (sizy>0) {
        float oy = (float)nvalues_y[0];
        for (unsigned int y = sizy?1:0; y<_height; ++y) {
          const float ny = (float)nvalues_y._linear_atX((float)y*sizy/hm1);
          if (ny*oy<=0) { draw_axis(values_x,ny==0?y:y-1,color,opacity,pattern_x,font_height,allow_zero); break; }
          oy = ny;
        }
      }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_axes(const float x0, const float x1, const float y0, const float y1,
                       const tc *const color, const float opacity=1,
                       const int subdivisionx=-60, const int subdivisiony=-60,
                       const float precisionx=0, const float precisiony=0,
                       const unsigned int pattern_x=~0U, const unsigned int pattern_y=~0U,
                       const unsigned int font_height=13) {
      if (is_empty()) return *this;
      const bool allow_zero = (x0*x1>0) || (y0*y1>0);
      const float
        dx = cimg::abs(x1-x0), dy = cimg::abs(y1-y0),
        px = dx<=0?1:precisionx==0?(float)std::pow(10.0,(int)std::log10(dx)-2.0):precisionx,
        py = dy<=0?1:precisiony==0?(float)std::pow(10.0,(int)std::log10(dy)-2.0):precisiony;
      if (x0!=x1 && y0!=y1)
        draw_axes(CImg<floatT>::sequence(subdivisionx>0?subdivisionx:1-width()/subdivisionx,x0,x1).round(px),
                  CImg<floatT>::sequence(subdivisiony>0?subdivisiony:1-height()/subdivisiony,y0,y1).round(py),
                  color,opacity,pattern_x,pattern_y,font_height,allow_zero);
      else if (x0==x1 && y0!=y1)
        draw_axis((int)x0,CImg<floatT>::sequence(subdivisiony>0?subdivisiony:1-height()/subdivisiony,y0,y1).round(py),
                  color,opacity,pattern_y,font_height);
      else if (x0!=x1 && y0==y1)
        draw_axis(CImg<floatT>::sequence(subdivisionx>0?subdivisionx:1-width()/subdivisionx,x0,x1).round(px),(int)y0,
                  color,opacity,pattern_x,font_height);
      return *this;
    }
# 34993 "../src/CImg.h"
    template<typename tx, typename ty, typename tc>
    CImg<T>& draw_grid(const CImg<tx>& values_x, const CImg<ty>& values_y,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern_x=~0U, const unsigned int pattern_y=~0U) {
      if (is_empty()) return *this;
      if (values_x) for (unsigned long x = 0, _maxx = (values_x).size(); x<_maxx; ++x) {
          const int xi = (int)values_x[x];
          if (xi>=0 && xi<width()) draw_line(xi,0,xi,_height-1,color,opacity,pattern_x);
        }
      if (values_y) for (unsigned long y = 0, _maxy = (values_y).size(); y<_maxy; ++y) {
          const int yi = (int)values_y[y];
          if (yi>=0 && yi<height()) draw_line(0,yi,_width-1,yi,color,opacity,pattern_y);
        }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_grid(const float delta_x, const float delta_y,
                       const float offsetx, const float offsety,
                       const bool invertx, const bool inverty,
                       const tc *const color, const float opacity=1,
                       const unsigned int pattern_x=~0U, const unsigned int pattern_y=~0U) {
      if (is_empty()) return *this;
      CImg<uintT> seqx, seqy;
      if (delta_x!=0) {
        const float dx = delta_x>0?delta_x:_width*-delta_x/100;
        const unsigned int nx = (unsigned int)(_width/dx);
        seqx = CImg<uintT>::sequence(1+nx,0,(unsigned int)(dx*nx));
        if (offsetx) for (unsigned long x = 0, _maxx = (seqx).size(); x<_maxx; ++x) seqx(x) = (unsigned int)cimg::mod(seqx(x)+offsetx,(float)_width);
        if (invertx) for (unsigned long x = 0, _maxx = (seqx).size(); x<_maxx; ++x) seqx(x) = _width - 1 - seqx(x);
      }
      if (delta_y!=0) {
        const float dy = delta_y>0?delta_y:_height*-delta_y/100;
        const unsigned int ny = (unsigned int)(_height/dy);
        seqy = CImg<uintT>::sequence(1+ny,0,(unsigned int)(dy*ny));
        if (offsety) for (unsigned long y = 0, _maxy = (seqy).size(); y<_maxy; ++y) seqy(y) = (unsigned int)cimg::mod(seqy(y)+offsety,(float)_height);
        if (inverty) for (unsigned long y = 0, _maxy = (seqy).size(); y<_maxy; ++y) seqy(y) = _height - 1 - seqy(y);
     }
      return draw_grid(seqx,seqy,color,opacity,pattern_x,pattern_y);
    }
# 35061 "../src/CImg.h"
    template<typename t, typename tc>
    CImg<T>& draw_graph(const CImg<t>& data,
                        const tc *const color, const float opacity=1,
                        const unsigned int plot_type=1, const int vertex_type=1,
                        const double ymin=0, const double ymax=0, const unsigned int pattern=~0U) {
      if (is_empty() || _height<=1) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_graph(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());


      CImg<tc> color1, color2;
      if (plot_type==3) {
        color1.assign(_spectrum); color2.assign(_spectrum);
        for (int c = 0; c<(int)((*this)._spectrum); ++c) {
          color1[c] = (tc)cimg::min((float)cimg::type<tc>::max(),color[c]*1.2f);
          color2[c] = (tc)(color[c]*0.4f);
        }
      }


      const unsigned long
        siz = data.size(),
        _siz1 = siz - (plot_type!=3?1:0),
        siz1 = _siz1?_siz1:1;
      const unsigned int
        _width1 = _width - (plot_type!=3?1:0),
        width1 = _width1?_width1:1;
      double m = ymin, M = ymax;
      if (ymin==ymax) m = (double)data.max_min(M);
      if (m==M) { --m; ++M; }
      const float ca = (float)(M-m)/(_height-1);
      bool init_hatch = true;


      switch (plot_type%4) {
      case 1 : {
        int oX = 0, oY = (int)((data[0]-m)/ca);
        const float fx = (float)_width1/siz1;
        if (siz==1) {
          const int Y = (int)((*data-m)/ca);
          draw_line(0,Y,width()-1,Y,color,opacity,pattern);
        } else for (unsigned long off = 1; off<siz; ++off) {
            const int
              X = (int)(off*fx),
              Y = (int)((data[off]-m)/ca);
            draw_line(oX,oY,X,Y,color,opacity,pattern,init_hatch);
            oX = X; oY = Y;
            init_hatch = false;
          }
      } break;
      case 2 : {
        const CImg<t> ndata(data._data,siz,1,1,1,true);
        int oY = (int)((data[0]-m)/ca);
        for (int x = 0; x<(int)((*this)._width); ++x) {
          const int Y = (int)((ndata._cubic_atX((float)x*siz1/width1)-m)/ca);
          if (x>0) draw_line(x,oY,x+1,Y,color,opacity,pattern,init_hatch);
          init_hatch = false;
          oY = Y;
        }
      } break;
      case 3 : {
        const int Y0 = (int)(-m/ca);
        const float fx = (float)_width/(siz-1);
        int oX = 0;
        for (unsigned long off = 0, _maxoff = (data).size(); off<_maxoff; ++off) {
          const int
            X = (int)((off+1)*fx),
            Y = (int)((data[off]-m)/ca);
          draw_rectangle(oX,Y0,X,Y,color,opacity).
            draw_line(oX,Y,oX,Y0,color2.data(),opacity).
            draw_line(oX,Y0,X,Y0,Y<=Y0?color2.data():color1.data(),opacity).
            draw_line(X,Y,X,Y0,color1.data(),opacity).
            draw_line(oX,Y,X,Y,Y<=Y0?color1.data():color2.data(),opacity);
          oX = X+1;
        }
      } break;
      default : break;
      }


      const unsigned int wb2 = plot_type==3?_width1/(2*siz):0;
      const float fx = (float)_width1/siz1;
      switch (vertex_type%8) {
      case 1 : {
        for (unsigned long off = 0, _maxoff = (data).size(); off<_maxoff; ++off) {
          const int
            X = (int)(off*fx) + wb2,
            Y = (int)((data[off]-m)/ca);
          draw_point(X,Y,color,opacity);
        }
      } break;
      case 2 : {
        for (unsigned long off = 0, _maxoff = (data).size(); off<_maxoff; ++off) {
          const int
            X = (int)(off*fx) + wb2,
            Y = (int)((data[off]-m)/ca);
          draw_line(X-3,Y,X+3,Y,color,opacity).draw_line(X,Y-3,X,Y+3,color,opacity);
        }
      } break;
      case 3 : {
        for (unsigned long off = 0, _maxoff = (data).size(); off<_maxoff; ++off) {
          const int
            X = (int)(off*fx) + wb2,
            Y = (int)((data[off]-m)/ca);
          draw_line(X-3,Y-3,X+3,Y+3,color,opacity).draw_line(X-3,Y+3,X+3,Y-3,color,opacity);
        }
      } break;
      case 4 : {
        for (unsigned long off = 0, _maxoff = (data).size(); off<_maxoff; ++off) {
          const int
            X = (int)(off*fx) + wb2,
            Y = (int)((data[off]-m)/ca);
          draw_circle(X,Y,3,color,opacity);
        }
      } break;
      case 5 : {
        for (unsigned long off = 0, _maxoff = (data).size(); off<_maxoff; ++off) {
          const int
            X = (int)(off*fx) + wb2,
            Y = (int)((data[off]-m)/ca);
          draw_circle(X,Y,3,color,opacity,0U);
        }
      } break;
      case 6 : {
        for (unsigned long off = 0, _maxoff = (data).size(); off<_maxoff; ++off) {
          const int
            X = (int)(off*fx) + wb2,
            Y = (int)((data[off]-m)/ca);
          draw_rectangle(X-3,Y-3,X+3,Y+3,color,opacity,~0U);
        }
      } break;
      case 7 : {
        for (unsigned long off = 0, _maxoff = (data).size(); off<_maxoff; ++off) {
          const int
            X = (int)(off*fx) + wb2,
            Y = (int)((data[off]-m)/ca);
          draw_line(X,Y-4,X+4,Y,color,opacity).
            draw_line(X+4,Y,X,Y+4,color,opacity).
            draw_line(X,Y+4,X-4,Y,color,opacity).
            draw_line(X-4,Y,X,Y-4,color,opacity);
        }
      } break;
      default : break;
      }
      return *this;
    }
# 35222 "../src/CImg.h"
    template<typename tc, typename t>
    CImg<T>& draw_fill(const int x, const int y, const int z,
                       const tc *const color, const float opacity,
                       CImg<t>& region, const float sigma=0,
                       const bool is_high_connexity=false) {
# 35253 "../src/CImg.h"
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_fill(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      region.assign(_width,_height,_depth,1,(t)0);
      if (x>=0 && x<width() && y>=0 && y<height() && z>=0 && z<depth()) {
        const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
        const unsigned long whd = (unsigned long)_width*_height*_depth, siz = (unsigned long)_spectrum*whd;
        const unsigned int W1 = _width-1, H1 = _height-1, D1 = _depth-1;
        const bool is_3d = (_depth>1);
        const CImg<T> reference_color = get_vector_at(x,y,z);
        CImg<uintT> remaining(3,512,1,1,0);
        remaining(0,0) = x; remaining(1,0) = y; remaining(2,0) = z;
        unsigned int posr0 = 0, posr1 = 1;
        region(x,y,z) = (t)1;
        const t noregion = ((t)1==(t)2)?(t)0:(t)(-1);
        if (is_3d) do {
          const unsigned int *pcurr = remaining.data(0,posr0++), xc = *(pcurr++), yc = *(pcurr++), zc = *(pcurr++);
          if (posr0>=512) { remaining.shift(0,-(int)posr0); posr1-=posr0; posr0 = 0; }
          bool cont, res;
          unsigned int nxc = xc;
          do {
            { const tc *col = color; T *ptrd = data(nxc,yc,zc); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
            if (yc!=0) { const unsigned int tx = nxc, ty = yc-1, tz = zc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            if (yc<H1) { const unsigned int tx = nxc, ty = yc+1, tz = zc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            if (zc!=0) { const unsigned int tx = nxc, ty = yc, tz = zc-1; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            if (zc<D1) { const unsigned int tx = nxc, ty = yc, tz = zc+1; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            if (nxc) { --nxc; if (region(nxc,yc,zc)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(nxc,yc,zc) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(nxc,yc,zc) = (t)(cont?1:noregion); }; } else cont = false;
          } while (cont);
          nxc = xc;
          do {
            if ((++nxc)<=W1) { if (region(nxc,yc,zc)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(nxc,yc,zc) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(nxc,yc,zc) = (t)(cont?1:noregion); }; } else cont = false;
            if (cont) {
              { const tc *col = color; T *ptrd = data(nxc,yc,zc); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
              if (yc!=0) { const unsigned int tx = nxc, ty = yc-1, tz = zc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (yc<H1) { const unsigned int tx = nxc, ty = yc+1, tz = zc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (zc!=0) { const unsigned int tx = nxc, ty = yc, tz = zc-1; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (zc<D1) { const unsigned int tx = nxc, ty = yc, tz = zc+1; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            }
          } while (cont);
          unsigned int nyc = yc;
          do {
            if (nyc) { --nyc; if (region(xc,nyc,zc)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(xc,nyc,zc) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(xc,nyc,zc) = (t)(cont?1:noregion); }; } else cont = false;
            if (cont) {
              { const tc *col = color; T *ptrd = data(xc,nyc,zc); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
              if (xc!=0) { const unsigned int tx = xc-1, ty = nyc, tz = zc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (xc<W1) { const unsigned int tx = xc+1, ty = nyc, tz = zc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (zc!=0) { const unsigned int tx = xc, ty = nyc, tz = zc-1; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (zc<D1) { const unsigned int tx = xc, ty = nyc, tz = zc+1; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            }
          } while (cont);
          nyc = yc;
          do {
            if ((++nyc)<=H1) { if (region(xc,nyc,zc)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(xc,nyc,zc) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(xc,nyc,zc) = (t)(cont?1:noregion); }; } else cont = false;
            if (cont) {
              { const tc *col = color; T *ptrd = data(xc,nyc,zc); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
              if (xc!=0) { const unsigned int tx = xc-1, ty = nyc, tz = zc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (xc<W1) { const unsigned int tx = xc+1, ty = nyc, tz = zc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (zc!=0) { const unsigned int tx = xc, ty = nyc, tz = zc-1; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (zc<D1) { const unsigned int tx = xc, ty = nyc, tz = zc+1; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            }
          } while (cont);
          unsigned int nzc = zc;
          do {
            if (nzc) { --nzc; if (region(xc,yc,nzc)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(xc,yc,nzc) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(xc,yc,nzc) = (t)(cont?1:noregion); }; } else cont = false;
            if (cont) {
              { const tc *col = color; T *ptrd = data(xc,yc,nzc); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
              if (xc!=0) { const unsigned int tx = xc-1, ty = yc, tz = nzc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (xc<W1) { const unsigned int tx = xc+1, ty = yc, tz = nzc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (yc!=0) { const unsigned int tx = xc, ty = yc-1, tz = nzc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (yc<H1) { const unsigned int tx = xc, ty = yc+1, tz = nzc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            }
          } while (cont);
          nzc = zc;
          do {
            if ((++nzc)<=D1) { if (region(xc,yc,nzc)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(xc,yc,nzc) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(xc,yc,nzc) = (t)(cont?1:noregion); }; } else cont = false;
            if (cont) {
              { const tc *col = color; T *ptrd = data(xc,nyc,zc); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
              if (xc!=0) { const unsigned int tx = xc-1, ty = yc, tz = nzc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (xc<W1) { const unsigned int tx = xc+1, ty = yc, tz = nzc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (yc!=0) { const unsigned int tx = xc, ty = yc-1, tz = nzc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (yc<H1) { const unsigned int tx = xc, ty = yc+1, tz = nzc; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            }
          } while (cont);
        } while (posr1>posr0);
        else do {
          const unsigned int *pcurr = remaining.data(0,posr0++), xc = *(pcurr++), yc = *(pcurr++);
          if (posr0>=512) { remaining.shift(0,-(int)posr0); posr1-=posr0; posr0 = 0; }
          bool cont, res;
          unsigned int nxc = xc;
          do {
            { const tc *col = color; T *ptrd = data(nxc,yc,0); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
            if (yc!=0) { const unsigned int tx = nxc, ty = yc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            if (yc<H1) { const unsigned int tx = nxc, ty = yc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            if (is_high_connexity) {
              if ((nxc!=0 && yc!=0)) { const unsigned int tx = nxc-1, ty = yc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if ((nxc<W1 && yc!=0)) { const unsigned int tx = nxc+1, ty = yc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if ((nxc!=0 && yc<H1)) { const unsigned int tx = nxc-1, ty = yc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if ((nxc<W1 && yc<H1)) { const unsigned int tx = nxc+1, ty = yc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
            }
            if (nxc) { --nxc; if (region(nxc,yc,0)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(nxc,yc,0) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(nxc,yc,0) = (t)(cont?1:noregion); }; } else cont = false;
          } while (cont);
          nxc = xc;
          do {
            if ((++nxc)<=W1) { if (region(nxc,yc,0)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(nxc,yc,0) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(nxc,yc,0) = (t)(cont?1:noregion); }; } else cont = false;
            if (cont) {
              { const tc *col = color; T *ptrd = data(nxc,yc,0); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
              if (yc!=0) { const unsigned int tx = nxc, ty = yc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (yc<H1) { const unsigned int tx = nxc, ty = yc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (is_high_connexity) {
                if ((nxc!=0 && yc!=0)) { const unsigned int tx = nxc-1, ty = yc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((nxc<W1 && yc!=0)) { const unsigned int tx = nxc+1, ty = yc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((nxc!=0 && yc<H1)) { const unsigned int tx = nxc-1, ty = yc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((nxc<W1 && yc<H1)) { const unsigned int tx = nxc+1, ty = yc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              }
            }
          } while (cont);
          unsigned int nyc = yc;
          do {
            if (nyc) { --nyc; if (region(xc,nyc,0)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(xc,nyc,0) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(xc,nyc,0) = (t)(cont?1:noregion); }; } else cont = false;
            if (cont) {
              { const tc *col = color; T *ptrd = data(xc,nyc,0); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
              if (xc!=0) { const unsigned int tx = xc-1, ty = nyc, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (xc<W1) { const unsigned int tx = xc+1, ty = nyc, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (is_high_connexity) {
                if ((xc!=0 && nyc!=0)) { const unsigned int tx = xc-1, ty = nyc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((xc<W1 && nyc!=0)) { const unsigned int tx = xc+1, ty = nyc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((xc!=0 && nyc<H1)) { const unsigned int tx = xc-1, ty = nyc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((xc<W1 && nyc<H1)) { const unsigned int tx = xc+1, ty = nyc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              }
            }
          } while (cont);
          nyc = yc;
          do {
            if ((++nyc)<=H1) { if (region(xc,nyc,0)) cont = false; else { cont = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(xc,nyc,0) + siz; for (unsigned int i = _spectrum; cont && i; --i) { ptrs-=whd; cont = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(xc,nyc,0) = (t)(cont?1:noregion); }; } else cont = false;
            if (cont) {
              { const tc *col = color; T *ptrd = data(xc,nyc,0); if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)*(col++); ptrd+=whd; } else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whd; } };
              if (xc!=0) { const unsigned int tx = xc-1, ty = nyc, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (xc<W1) { const unsigned int tx = xc+1, ty = nyc, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              if (is_high_connexity) {
                if ((xc!=0 && nyc!=0)) { const unsigned int tx = xc-1, ty = nyc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((xc<W1 && nyc!=0)) { const unsigned int tx = xc+1, ty = nyc-1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((xc!=0 && nyc<H1)) { const unsigned int tx = xc-1, ty = nyc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
                if ((xc<W1 && nyc<H1)) { const unsigned int tx = xc+1, ty = nyc+1, tz = 0; if (region(tx,ty,tz)) res = false; else { res = true; const T *reference_col = reference_color._data + _spectrum, *ptrs = data(tx,ty,tz) + siz; for (unsigned int i = _spectrum; res && i; --i) { ptrs-=whd; res = (cimg::abs(*ptrs - *(--reference_col))<=sigma); } region(tx,ty,tz) = (t)(res?1:noregion); }; if (res) { if (posr1>=remaining._height) remaining.resize(3,remaining._height<<1,1,1,0); unsigned int *ptrr = remaining.data(0,posr1); *(ptrr++) = tx; *(ptrr++) = ty; *(ptrr++) = tz; ++posr1; }; };
              }
            }
          } while (cont);
        } while (posr1>posr0);
        if (noregion) for (t *ptrd = (region)._data, *_maxptrd = (region)._data + (region).size(); ptrd<_maxptrd; ++ptrd) if (*ptrd==noregion) *ptrd = (t)0;
      }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_fill(const int x, const int y, const int z,
                       const tc *const color, const float opacity=1,
                       const float sigma=0, const bool is_high_connexity=false) {
      CImg<boolT> tmp;
      return draw_fill(x,y,z,color,opacity,tmp,sigma,is_high_connexity);
    }


    template<typename tc>
    CImg<T>& draw_fill(const int x, const int y,
                       const tc *const color, const float opacity=1,
                       const float sigma=0, const bool is_high_connexity=false) {
      CImg<boolT> tmp;
      return draw_fill(x,y,0,color,opacity,tmp,sigma,is_high_connexity);
    }
# 35432 "../src/CImg.h"
    CImg<T>& draw_plasma(const float alpha=1, const float beta=0, const unsigned int scale=8) {
      if (is_empty()) return *this;
      const int w = width(), h = height();
      const Tfloat m = (Tfloat)cimg::type<T>::min(), M = (Tfloat)cimg::type<T>::max();
      for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) {
        CImg<T> ref = get_shared_slice(z,c);
        for (int delta = 1<<cimg::min(scale,31U); delta>1; delta>>=1) {
          const int delta2 = delta>>1;
          const float r = alpha*delta + beta;


          for (int y0 = 0; y0<h; y0+=delta)
            for (int x0 = 0; x0<w; x0+=delta) {
              const int x1 = (x0 + delta)%w, y1 = (y0 + delta)%h, xc = (x0 + delta2)%w, yc = (y0 + delta2)%h;
              const Tfloat val = (Tfloat)(0.25f*(ref(x0,y0) + ref(x0,y1) + ref(x0,y1) + ref(x1,y1)) + r*cimg::crand());
              ref(xc,yc) = (T)(val<m?m:val>M?M:val);
            }


          for (int y = -delta2; y<h; y+=delta)
            for (int x0=0; x0<w; x0+=delta) {
              const int y0 = cimg::mod(y,h), x1 = (x0 + delta)%w, y1 = (y + delta)%h,
                xc = (x0 + delta2)%w, yc = (y + delta2)%h;
              const Tfloat val = (Tfloat)(0.25f*(ref(xc,y0) + ref(x0,yc) + ref(xc,y1) + ref(x1,yc)) + r*cimg::crand());
              ref(xc,yc) = (T)(val<m?m:val>M?M:val);
            }
          for (int y0 = 0; y0<h; y0+=delta)
            for (int x = -delta2; x<w; x+=delta) {
              const int x0 = cimg::mod(x,w), x1 = (x + delta)%w, y1 = (y0 + delta)%h,
                xc = (x + delta2)%w, yc = (y0 + delta2)%h;
              const Tfloat val = (Tfloat)(0.25f*(ref(xc,y0) + ref(x0,yc) + ref(xc,y1) + ref(x1,yc)) + r*cimg::crand());
              ref(xc,yc) = (T)(val<m?m:val>M?M:val);
            }
          for (int y = -delta2; y<h; y+=delta)
            for (int x = -delta2; x<w; x+=delta) {
              const int x0 = cimg::mod(x,w), y0 = cimg::mod(y,h), x1 = (x + delta)%w, y1 = (y + delta)%h,
                xc = (x + delta2)%w, yc = (y + delta2)%h;
              const Tfloat val = (Tfloat)(0.25f*(ref(xc,y0) + ref(x0,yc) + ref(xc,y1) + ref(x1,yc)) + r*cimg::crand());
                ref(xc,yc) = (T)(val<m?m:val>M?M:val);
            }
        }
      }
      return *this;
    }
# 35496 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_mandelbrot(const int x0, const int y0, const int x1, const int y1,
                             const CImg<tc>& colormap, const float opacity=1,
                             const double z0r=-2, const double z0i=-2, const double z1r=2, const double z1i=2,
                             const unsigned int iteration_max=255,
                             const bool is_normalized_iteration=false,
                             const bool is_julia_set=false,
                             const double param_r=0, const double param_i=0) {
      if (is_empty()) return *this;
      CImg<tc> palette;
      if (colormap) palette.assign(colormap._data,colormap.size()/colormap._spectrum,1,1,colormap._spectrum,true);
      if (palette && palette._spectrum!=_spectrum)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_mandelbrot(): Instance and specified colormap (%u,%u,%u,%u,%p) have "
                                    "incompatible dimensions.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    colormap._width,colormap._height,colormap._depth,colormap._spectrum,colormap._data);

      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0), ln2 = (float)std::log(2.0);
      const int
        _x0 = x0<0?0:x0>=width()?width()-1:x0,
        _y0 = y0<0?0:y0>=height()?height()-1:y0,
        _x1 = x1<0?1:x1>=width()?width()-1:x1,
        _y1 = y1<0?1:y1>=height()?height()-1:y1;



      for (int q = _y0; q<=_y1; ++q)
        for (int p = _x0; p<=_x1; ++p) {
          unsigned int iteration = 0;
          const double x = z0r + p*(z1r-z0r)/_width, y = z0i + q*(z1i-z0i)/_height;
          double zr, zi, cr, ci;
          if (is_julia_set) { zr = x; zi = y; cr = param_r; ci = param_i; }
          else { zr = param_r; zi = param_i; cr = x; ci = y; }
          for (iteration=1; zr*zr + zi*zi<=4 && iteration<=iteration_max; ++iteration) {
            const double temp = zr*zr - zi*zi + cr;
            zi = 2*zr*zi + ci;
            zr = temp;
          }
          if (iteration>iteration_max) {
            if (palette) {
              if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)palette(0,c);
              else for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)(palette(0,c)*nopacity + (*this)(p,q,0,c)*copacity);
            } else {
              if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)0;
              else for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)((*this)(p,q,0,c)*copacity);
            }
          } else if (is_normalized_iteration) {
            const float
              normz = (float)cimg::abs(zr*zr+zi*zi),
              niteration = (float)(iteration + 1 - std::log(std::log(normz))/ln2);
            if (palette) {
              if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)palette._linear_atX(niteration,c);
              else for (int c = 0; c<(int)((*this)._spectrum); ++c)
                     (*this)(p,q,0,c) = (T)(palette._linear_atX(niteration,c)*nopacity + (*this)(p,q,0,c)*copacity);
            } else {
              if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)niteration;
              else for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)(niteration*nopacity + (*this)(p,q,0,c)*copacity);
            }
          } else {
            if (palette) {
              if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)palette._atX(iteration,c);
              else for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)(palette(iteration,c)*nopacity + (*this)(p,q,0,c)*copacity);
            } else {
              if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)iteration;
              else for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(p,q,0,c) = (T)(iteration*nopacity + (*this)(p,q,0,c)*copacity);
            }
          }
        }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_mandelbrot(const CImg<tc>& colormap, const float opacity=1,
                             const double z0r=-2, const double z0i=-2, const double z1r=2, const double z1i=2,
                             const unsigned int iteration_max=255,
                             const bool is_normalized_iteration=false,
                             const bool is_julia_set=false,
                             const double param_r=0, const double param_i=0) {
      return draw_mandelbrot(0,0,_width-1,_height-1,colormap,opacity,
                             z0r,z0i,z1r,z1i,iteration_max,is_normalized_iteration,is_julia_set,param_r,param_i);
    }
# 35587 "../src/CImg.h"
    template<typename tc>
    CImg<T>& draw_gaussian(const float xc, const float sigma,
                           const tc *const color, const float opacity=1) {
      if (is_empty()) return *this;
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_gaussian(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      const float sigma2 = 2*sigma*sigma, nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      const tc *col = color;
      for (int x = 0; x<(int)((*this)._width); ++x) {
        const float dx = (x - xc), val = (float)std::exp(-dx*dx/sigma2);
        T *ptrd = data(x,0,0,0);
        if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(val*(*col++)); ptrd+=whd; }
        else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity*val*(*col++) + *ptrd*copacity); ptrd+=whd; }
        col-=_spectrum;
      }
      return *this;
    }
# 35616 "../src/CImg.h"
    template<typename t, typename tc>
    CImg<T>& draw_gaussian(const float xc, const float yc, const CImg<t>& tensor,
                           const tc *const color, const float opacity=1) {
      if (is_empty()) return *this;
      if (tensor._width!=2 || tensor._height!=2 || tensor._depth!=1 || tensor._spectrum!=1)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_gaussian(): Specified tensor (%u,%u,%u,%u,%p) is not a 2x2 matrix.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    tensor._width,tensor._height,tensor._depth,tensor._spectrum,tensor._data);
      if (!color)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_gaussian(): Specified color is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      typedef typename CImg<t>::Tfloat tfloat;
      const CImg<tfloat> invT = tensor.get_invert(), invT2 = (invT*invT)/(-2.0);
      const tfloat a = invT2(0,0), b = 2*invT2(1,0), c = invT2(1,1);
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      const tc *col = color;
      float dy = -yc;
      for (int y = 0; y<(int)((*this)._height); ++y) {
        float dx = -xc;
        for (int x = 0; x<(int)((*this)._width); ++x) {
          const float val = (float)std::exp(a*dx*dx + b*dx*dy + c*dy*dy);
          T *ptrd = data(x,y,0,0);
          if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(val*(*col++)); ptrd+=whd; }
          else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity*val*(*col++) + *ptrd*copacity); ptrd+=whd; }
          col-=_spectrum;
          ++dx;
        }
        ++dy;
      }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_gaussian(const int xc, const int yc, const float r1, const float r2, const float ru, const float rv,
                           const tc *const color, const float opacity=1) {
      const double
        a = r1*ru*ru + r2*rv*rv,
        b = (r1-r2)*ru*rv,
        c = r1*rv*rv + r2*ru*ru;
      const CImg<Tfloat> tensor(2,2,1,1, a,b,b,c);
      return draw_gaussian(xc,yc,tensor,color,opacity);
    }


    template<typename tc>
    CImg<T>& draw_gaussian(const float xc, const float yc, const float sigma,
                           const tc *const color, const float opacity=1) {
      return draw_gaussian(xc,yc,CImg<floatT>::diagonal(sigma,sigma),color,opacity);
    }


    template<typename t, typename tc>
    CImg<T>& draw_gaussian(const float xc, const float yc, const float zc, const CImg<t>& tensor,
                           const tc *const color, const float opacity=1) {
      if (is_empty()) return *this;
      typedef typename CImg<t>::Tfloat tfloat;
      if (tensor._width!=3 || tensor._height!=3 || tensor._depth!=1 || tensor._spectrum!=1)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_gaussian(): Specified tensor (%u,%u,%u,%u,%p) is not a 3x3 matrix.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    tensor._width,tensor._height,tensor._depth,tensor._spectrum,tensor._data);

      const CImg<tfloat> invT = tensor.get_invert(), invT2 = (invT*invT)/(-2.0);
      const tfloat a = invT2(0,0), b = 2*invT2(1,0), c = 2*invT2(2,0), d = invT2(1,1), e = 2*invT2(2,1), f = invT2(2,2);
      const float nopacity = cimg::abs(opacity), copacity = 1 - cimg::max(opacity,0);
      const unsigned long whd = (unsigned long)_width*_height*_depth;
      const tc *col = color;
      for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
        const float
          dx = (x - xc), dy = (y - yc), dz = (z - zc),
          val = (float)std::exp(a*dx*dx + b*dx*dy + c*dx*dz + d*dy*dy + e*dy*dz + f*dz*dz);
        T *ptrd = data(x,y,z,0);
        if (opacity>=1) for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(val*(*col++)); ptrd+=whd; }
        else for (int c = 0; c<(int)((*this)._spectrum); ++c) { *ptrd = (T)(nopacity*val*(*col++) + *ptrd*copacity); ptrd+=whd; }
        col-=_spectrum;
      }
      return *this;
    }


    template<typename tc>
    CImg<T>& draw_gaussian(const float xc, const float yc, const float zc, const float sigma,
                           const tc *const color, const float opacity=1) {
      return draw_gaussian(xc,yc,zc,CImg<floatT>::diagonal(sigma,sigma,sigma),color,opacity);
    }
# 35724 "../src/CImg.h"
    template<typename tp, typename tf, typename tc, typename to>
    CImg<T>& draw_object3d(const float x0, const float y0, const float z0,
                           const CImg<tp>& vertices, const CImgList<tf>& primitives,
                           const CImgList<tc>& colors, const CImg<to>& opacities,
                           const unsigned int render_type=4,
                           const bool is_double_sided=false, const float focale=700,
                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
                           const float specular_lightness=0.2f, const float specular_shininess=0.1f) {
      return draw_object3d(x0,y0,z0,vertices,primitives,colors,opacities,render_type,
                           is_double_sided,focale,lightx,lighty,lightz,
                           specular_lightness,specular_shininess,CImg<floatT>::empty());
    }


    template<typename tp, typename tf, typename tc, typename to, typename tz>
    CImg<T>& draw_object3d(const float x0, const float y0, const float z0,
                           const CImg<tp>& vertices, const CImgList<tf>& primitives,
                           const CImgList<tc>& colors, const CImg<to>& opacities,
                           const unsigned int render_type,
                           const bool is_double_sided, const float focale,
                           const float lightx, const float lighty, const float lightz,
                           const float specular_lightness, const float specular_shininess,
                           CImg<tz>& zbuffer) {
      return _draw_object3d(0,zbuffer,x0,y0,z0,vertices,primitives,colors,opacities,
                            render_type,is_double_sided,focale,lightx,lighty,lightz,
                            specular_lightness,specular_shininess,1);
    }
# 35784 "../src/CImg.h"
    template<typename tp, typename tf, typename tc, typename to>
    CImg<T>& draw_object3d(const float x0, const float y0, const float z0,
                           const CImg<tp>& vertices, const CImgList<tf>& primitives,
                           const CImgList<tc>& colors, const CImgList<to>& opacities,
                           const unsigned int render_type=4,
                           const bool is_double_sided=false, const float focale=700,
                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
                           const float specular_lightness=0.2f, const float specular_shininess=0.1f) {
      return draw_object3d(x0,y0,z0,vertices,primitives,colors,opacities,render_type,
                           is_double_sided,focale,lightx,lighty,lightz,
                           specular_lightness,specular_shininess,CImg<floatT>::empty());
    }


    template<typename tp, typename tf, typename tc, typename to, typename tz>
    CImg<T>& draw_object3d(const float x0, const float y0, const float z0,
                           const CImg<tp>& vertices, const CImgList<tf>& primitives,
                           const CImgList<tc>& colors, const CImgList<to>& opacities,
                           const unsigned int render_type,
                           const bool is_double_sided, const float focale,
                           const float lightx, const float lighty, const float lightz,
                           const float specular_lightness, const float specular_shininess,
                           CImg<tz>& zbuffer) {
      return _draw_object3d(0,zbuffer,x0,y0,z0,vertices,primitives,colors,opacities,
                            render_type,is_double_sided,focale,lightx,lighty,lightz,
                            specular_lightness,specular_shininess,1);
    }
# 35844 "../src/CImg.h"
    template<typename tp, typename tf, typename tc>
    CImg<T>& draw_object3d(const float x0, const float y0, const float z0,
                           const CImg<tp>& vertices, const CImgList<tf>& primitives,
                           const CImgList<tc>& colors,
                           const unsigned int render_type=4,
                           const bool is_double_sided=false, const float focale=700,
                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
                           const float specular_lightness=0.2f, const float specular_shininess=0.1f) {
      return draw_object3d(x0,y0,z0,vertices,primitives,colors,CImg<floatT>::empty(),
                           render_type,is_double_sided,focale,lightx,lighty,lightz,
                           specular_lightness,specular_shininess,CImg<floatT>::empty());
    }


    template<typename tp, typename tf, typename tc, typename tz>
    CImg<T>& draw_object3d(const float x0, const float y0, const float z0,
                           const CImg<tp>& vertices, const CImgList<tf>& primitives,
                           const CImgList<tc>& colors,
                           const unsigned int render_type,
                           const bool is_double_sided, const float focale,
                           const float lightx, const float lighty, const float lightz,
                           const float specular_lightness, const float specular_shininess,
                           CImg<tz>& zbuffer) {
      return draw_object3d(x0,y0,z0,vertices,primitives,colors,CImg<floatT>::empty(),
                           render_type,is_double_sided,focale,lightx,lighty,lightz,
                           specular_lightness,specular_shininess,zbuffer);
    }
# 35903 "../src/CImg.h"
    template<typename t, typename to>
    static float __draw_object3d(const CImgList<t>& opacities, const unsigned int n_primitive, CImg<to>& opacity) {
      if (n_primitive>=opacities._width || opacities[n_primitive].is_empty()) { opacity.assign(); return 1; }
      if (opacities[n_primitive].size()==1) { opacity.assign(); return opacities(n_primitive,0); }
      opacity.assign(opacities[n_primitive],true);
      return 1.0f;
    }

    template<typename t, typename to>
    static float __draw_object3d(const CImg<t>& opacities, const unsigned int n_primitive, CImg<to>& opacity) {
      opacity.assign();
      return n_primitive>=opacities._width?1.0f:(float)opacities[n_primitive];
    }

    template<typename tz, typename tp, typename tf, typename tc, typename to>
    CImg<T>& _draw_object3d(void *const pboard, CImg<tz>& zbuffer,
                            const float X, const float Y, const float Z,
                            const CImg<tp>& vertices,
                            const CImgList<tf>& primitives,
                            const CImgList<tc>& colors,
                            const to& opacities,
                            const unsigned int render_type,
                            const bool is_double_sided, const float focale,
                            const float lightx, const float lighty, const float lightz,
                            const float specular_lightness, const float specular_shininess,
                            const float sprite_scale) {
      typedef typename cimg::superset2<tp,tz,float>::type tpfloat;
      if (is_empty() || !vertices || !primitives) return *this;
      char error_message[1024] = { 0 };
      if (!vertices.is_object3d(primitives,colors,opacities,false,error_message))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "draw_object3d(): Invalid specified 3d object (%u,%u) (%s).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),vertices._width,primitives._width,error_message);
      if (render_type==5) cimg::mutex(10);


      if (pboard) return *this;

      const float
        nspec = 1 - (specular_lightness<0.0f?0.0f:(specular_lightness>1.0f?1.0f:specular_lightness)),
        nspec2 = 1 + (specular_shininess<0.0f?0.0f:specular_shininess),
        nsl1 = (nspec2 - 1)/cimg::sqr(nspec - 1),
        nsl2 = 1 - 2*nsl1*nspec,
        nsl3 = nspec2 - nsl1 - nsl2;


      CImg<floatT> light_texture;
      if (render_type==5) {
        if (colors._width>primitives._width) {
          static CImg<floatT> default_light_texture;
          static const tc *lptr = 0;
          static tc ref_values[64] = { 0 };
          const CImg<tc>& img = colors.back();
          bool is_same_texture = (lptr==img._data);
          if (is_same_texture)
            for (unsigned int r = 0, j = 0; j<8; ++j)
              for (unsigned int i = 0; i<8; ++i)
                if (ref_values[r++]!=img(i*img._width/9,j*img._height/9,0,(i+j)%img._spectrum)) {
                  is_same_texture = false; break;
                }
          if (!is_same_texture || default_light_texture._spectrum<_spectrum) {
            (default_light_texture.assign(img,false)/=255).resize(-100,-100,1,_spectrum);
            lptr = colors.back().data();
            for (unsigned int r = 0, j = 0; j<8; ++j)
              for (unsigned int i = 0; i<8; ++i)
                ref_values[r++] = img(i*img._width/9,j*img._height/9,0,(i+j)%img._spectrum);
          }
          light_texture.assign(default_light_texture,true);
        } else {
          static CImg<floatT> default_light_texture;
          static float olightx = 0, olighty = 0, olightz = 0, ospecular_shininess = 0;
          if (!default_light_texture ||
              lightx!=olightx || lighty!=olighty || lightz!=olightz ||
              specular_shininess!=ospecular_shininess || default_light_texture._spectrum<_spectrum) {
            default_light_texture.assign(512,512);
            const float
              dlx = lightx - X,
              dly = lighty - Y,
              dlz = lightz - Z,
              nl = (float)std::sqrt(dlx*dlx + dly*dly + dlz*dlz),
              nlx = (default_light_texture._width - 1)/2*(1 + dlx/nl),
              nly = (default_light_texture._height - 1)/2*(1 + dly/nl),
              white[] = { 1 };
            default_light_texture.draw_gaussian(nlx,nly,default_light_texture._width/3.0f,white);
            for (int y = 0; y<(int)((default_light_texture)._height); ++y) for (int x = 0; x<(int)((default_light_texture)._width); ++x) {
              const float factor = default_light_texture(x,y);
              if (factor>nspec) default_light_texture(x,y) = cimg::min(2,nsl1*factor*factor + nsl2*factor + nsl3);
            }
            default_light_texture.resize(-100,-100,1,_spectrum);
            olightx = lightx; olighty = lighty; olightz = lightz; ospecular_shininess = specular_shininess;
          }
          light_texture.assign(default_light_texture,true);
        }
      }


      CImg<tpfloat> projections(vertices._width,2);
      tpfloat parallzmin = cimg::type<tpfloat>::max();
      const float absfocale = focale?cimg::abs(focale):0;
      if (absfocale) {



        for (int l = 0; l<(int)((projections)._width); ++l) {
          const tpfloat
            x = (tpfloat)vertices(l,0),
            y = (tpfloat)vertices(l,1),
            z = (tpfloat)vertices(l,2);
          const tpfloat projectedz = z + Z + absfocale;
          projections(l,1) = Y + absfocale*y/projectedz;
          projections(l,0) = X + absfocale*x/projectedz;
        }

      } else {



        for (int l = 0; l<(int)((projections)._width); ++l) {
          const tpfloat
            x = (tpfloat)vertices(l,0),
            y = (tpfloat)vertices(l,1),
            z = (tpfloat)vertices(l,2);
          if (z<parallzmin) parallzmin = z;
          projections(l,1) = Y + y;
          projections(l,0) = X + x;
        }
      }
      const float _focale = absfocale?absfocale:(1e5f-parallzmin);


      CImg<uintT> visibles(primitives._width,1,1,1,~0U);
      CImg<tpfloat> zrange(primitives._width);
      const tpfloat zmin = absfocale?(tpfloat)(1.5f - absfocale):cimg::type<tpfloat>::min();




      for (int l = 0; l<(int)(primitives)._width; ++l) {
        const CImg<tf>& primitive = primitives[l];
        switch (primitive.size()) {
        case 1 : {
          const unsigned int i0 = (unsigned int)primitive(0);
          const tpfloat z0 = Z + vertices(i0,2);
          if (z0>zmin) {
            visibles(l) = (unsigned int)l;
            zrange(l) = z0;
          }
        } break;
        case 5 : {
          const unsigned int
            i0 = (unsigned int)primitive(0),
            i1 = (unsigned int)primitive(1);
          const tpfloat
            Xc = 0.5f*((float)vertices(i0,0) + (float)vertices(i1,0)),
            Yc = 0.5f*((float)vertices(i0,1) + (float)vertices(i1,1)),
            Zc = 0.5f*((float)vertices(i0,2) + (float)vertices(i1,2)),
            _zc = Z + Zc,
            zc = _zc + _focale,
            xc = X + Xc*(absfocale?absfocale/zc:1),
            yc = Y + Yc*(absfocale?absfocale/zc:1),
            radius = 0.5f*std::sqrt(cimg::sqr(vertices(i1,0) - vertices(i0,0)) +
                                    cimg::sqr(vertices(i1,1) - vertices(i0,1)) +
                                    cimg::sqr(vertices(i1,2) - vertices(i0,2)))*(absfocale?absfocale/zc:1),
            xm = xc - radius,
            ym = yc - radius,
            xM = xc + radius,
            yM = yc + radius;
          if (xM>=0 && xm<_width && yM>=0 && ym<_height && _zc>zmin) {
            visibles(l) = (unsigned int)l;
            zrange(l) = _zc;
          }
        } break;
        case 2 :
        case 6 : {
          const unsigned int
            i0 = (unsigned int)primitive(0),
            i1 = (unsigned int)primitive(1);
          const tpfloat
            x0 = projections(i0,0), y0 = projections(i0,1), z0 = Z + vertices(i0,2),
            x1 = projections(i1,0), y1 = projections(i1,1), z1 = Z + vertices(i1,2);
          tpfloat xm, xM, ym, yM;
          if (x0<x1) { xm = x0; xM = x1; } else { xm = x1; xM = x0; }
          if (y0<y1) { ym = y0; yM = y1; } else { ym = y1; yM = y0; }
          if (xM>=0 && xm<_width && yM>=0 && ym<_height && z0>zmin && z1>zmin) {
            visibles(l) = (unsigned int)l;
            zrange(l) = (z0 + z1)/2;
          }
        } break;
        case 3 :
        case 9 : {
          const unsigned int
            i0 = (unsigned int)primitive(0),
            i1 = (unsigned int)primitive(1),
            i2 = (unsigned int)primitive(2);
          const tpfloat
            x0 = projections(i0,0), y0 = projections(i0,1), z0 = Z + vertices(i0,2),
            x1 = projections(i1,0), y1 = projections(i1,1), z1 = Z + vertices(i1,2),
            x2 = projections(i2,0), y2 = projections(i2,1), z2 = Z + vertices(i2,2);
          tpfloat xm, xM, ym, yM;
          if (x0<x1) { xm = x0; xM = x1; } else { xm = x1; xM = x0; }
          if (x2<xm) xm = x2;
          if (x2>xM) xM = x2;
          if (y0<y1) { ym = y0; yM = y1; } else { ym = y1; yM = y0; }
          if (y2<ym) ym = y2;
          if (y2>yM) yM = y2;
          if (xM>=0 && xm<_width && yM>=0 && ym<_height && z0>zmin && z1>zmin && z2>zmin) {
            const tpfloat d = (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
            if (is_double_sided || d<0) {
              visibles(l) = (unsigned int)l;
              zrange(l) = (z0 + z1 + z2)/3;
            }
          }
        } break;
        case 4 :
        case 12 : {
          const unsigned int
            i0 = (unsigned int)primitive(0),
            i1 = (unsigned int)primitive(1),
            i2 = (unsigned int)primitive(2),
            i3 = (unsigned int)primitive(3);
          const tpfloat
            x0 = projections(i0,0), y0 = projections(i0,1), z0 = Z + vertices(i0,2),
            x1 = projections(i1,0), y1 = projections(i1,1), z1 = Z + vertices(i1,2),
            x2 = projections(i2,0), y2 = projections(i2,1), z2 = Z + vertices(i2,2),
            x3 = projections(i3,0), y3 = projections(i3,1), z3 = Z + vertices(i3,2);
          tpfloat xm, xM, ym, yM;
          if (x0<x1) { xm = x0; xM = x1; } else { xm = x1; xM = x0; }
          if (x2<xm) xm = x2;
          if (x2>xM) xM = x2;
          if (x3<xm) xm = x3;
          if (x3>xM) xM = x3;
          if (y0<y1) { ym = y0; yM = y1; } else { ym = y1; yM = y0; }
          if (y2<ym) ym = y2;
          if (y2>yM) yM = y2;
          if (y3<ym) ym = y3;
          if (y3>yM) yM = y3;
          if (xM>=0 && xm<_width && yM>=0 && ym<_height && z0>zmin && z1>zmin && z2>zmin) {
            const float d = (x1 - x0)*(y2 - y0) - (x2 - x0)*(y1 - y0);
            if (is_double_sided || d<0) {
              visibles(l) = (unsigned int)l;
              zrange(l) = (z0 + z1 + z2 + z3)/4;
            }
          }
        } break;
        default :
          throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "draw_object3d(): Invalid primitive[%u] with size %u "
                                      "(should have size 1,2,3,4,5,6,9 or 12).",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      l,primitive.size());
        }
      }


      unsigned int *p_visibles = visibles._data;
      float *p_zrange = zrange._data;
      const float *ptrz = p_zrange;
      for (unsigned int *ptr = (visibles)._data, *_maxptr = (visibles)._data + (visibles).size(); ptr<_maxptr; ++ptr) {
        if (*ptr!=~0U) { *(p_visibles++) = *ptr; *(p_zrange++) = *ptrz; }
        ++ptrz;
      }
      const unsigned int nb_visibles = p_zrange - zrange._data;
      if (!nb_visibles) return *this;
      CImg<uintT> permutations;
      CImg<tpfloat>(zrange._data,nb_visibles,1,1,1,true).sort(permutations,false);


      CImg<floatT> lightprops;
      switch (render_type) {
      case 3 : {
        lightprops.assign(nb_visibles);



        for (int l = 0; l<(int)((lightprops)._width); ++l) {
          const CImg<tf>& primitive = primitives(visibles(permutations(l)));
          const unsigned int psize = primitive.size();
          if (psize==3 || psize==4 || psize==9 || psize==12) {
            const unsigned int
              i0 = (unsigned int)primitive(0),
              i1 = (unsigned int)primitive(1),
              i2 = (unsigned int)primitive(2);
            const tpfloat
              x0 = (tpfloat)vertices(i0,0), y0 = (tpfloat)vertices(i0,1), z0 = (tpfloat)vertices(i0,2),
              x1 = (tpfloat)vertices(i1,0), y1 = (tpfloat)vertices(i1,1), z1 = (tpfloat)vertices(i1,2),
              x2 = (tpfloat)vertices(i2,0), y2 = (tpfloat)vertices(i2,1), z2 = (tpfloat)vertices(i2,2),
              dx1 = x1 - x0, dy1 = y1 - y0, dz1 = z1 - z0,
              dx2 = x2 - x0, dy2 = y2 - y0, dz2 = z2 - z0,
              nx = dy1*dz2 - dz1*dy2,
              ny = dz1*dx2 - dx1*dz2,
              nz = dx1*dy2 - dy1*dx2,
              norm = (tpfloat)std::sqrt(1e-5f + nx*nx + ny*ny + nz*nz),
              lx = X + (x0 + x1 + x2)/3 - lightx,
              ly = Y + (y0 + y1 + y2)/3 - lighty,
              lz = Z + (z0 + z1 + z2)/3 - lightz,
              nl = (tpfloat)std::sqrt(1e-5f + lx*lx + ly*ly + lz*lz),
              factor = cimg::max(cimg::abs(-lx*nx-ly*ny-lz*nz)/(norm*nl),0);
            lightprops[l] = factor<=nspec?factor:(nsl1*factor*factor + nsl2*factor + nsl3);
          } else lightprops[l] = 1;
        }
      } break;

      case 4 :
      case 5 : {
        CImg<tpfloat> vertices_normals(vertices._width,3,1,1,0);



        for (unsigned int l = 0; l<nb_visibles; ++l) {
          const CImg<tf>& primitive = primitives[visibles(l)];
          const unsigned int psize = primitive.size();
          const bool
            triangle_flag = (psize==3) || (psize==9),
            rectangle_flag = (psize==4) || (psize==12);
          if (triangle_flag || rectangle_flag) {
            const unsigned int
              i0 = (unsigned int)primitive(0),
              i1 = (unsigned int)primitive(1),
              i2 = (unsigned int)primitive(2),
              i3 = rectangle_flag?(unsigned int)primitive(3):0;
            const tpfloat
              x0 = (tpfloat)vertices(i0,0), y0 = (tpfloat)vertices(i0,1), z0 = (tpfloat)vertices(i0,2),
              x1 = (tpfloat)vertices(i1,0), y1 = (tpfloat)vertices(i1,1), z1 = (tpfloat)vertices(i1,2),
              x2 = (tpfloat)vertices(i2,0), y2 = (tpfloat)vertices(i2,1), z2 = (tpfloat)vertices(i2,2),
              dx1 = x1 - x0, dy1 = y1 - y0, dz1 = z1 - z0,
              dx2 = x2 - x0, dy2 = y2 - y0, dz2 = z2 - z0,
              nnx = dy1*dz2 - dz1*dy2,
              nny = dz1*dx2 - dx1*dz2,
              nnz = dx1*dy2 - dy1*dx2,
              norm = (tpfloat)(1e-5f + std::sqrt(nnx*nnx + nny*nny + nnz*nnz)),
              nx = nnx/norm,
              ny = nny/norm,
              nz = nnz/norm;
            vertices_normals(i0,0)+=nx; vertices_normals(i0,1)+=ny; vertices_normals(i0,2)+=nz;
            vertices_normals(i1,0)+=nx; vertices_normals(i1,1)+=ny; vertices_normals(i1,2)+=nz;
            vertices_normals(i2,0)+=nx; vertices_normals(i2,1)+=ny; vertices_normals(i2,2)+=nz;
            if (rectangle_flag) { vertices_normals(i3,0)+=nx; vertices_normals(i3,1)+=ny; vertices_normals(i3,2)+=nz; }
          }
        }

        if (is_double_sided) for (int p = 0; p<(int)((vertices_normals)._width); ++p) if (vertices_normals(p,2)>0) {
          vertices_normals(p,0) = -vertices_normals(p,0);
          vertices_normals(p,1) = -vertices_normals(p,1);
          vertices_normals(p,2) = -vertices_normals(p,2);
        }

        if (render_type==4) {
          lightprops.assign(vertices._width);



          for (int l = 0; l<(int)((lightprops)._width); ++l) {
            const tpfloat
              nx = vertices_normals(l,0),
              ny = vertices_normals(l,1),
              nz = vertices_normals(l,2),
              norm = (tpfloat)std::sqrt(1e-5f + nx*nx + ny*ny + nz*nz),
              lx = X + vertices(l,0) - lightx,
              ly = Y + vertices(l,1) - lighty,
              lz = Z + vertices(l,2) - lightz,
              nl = (tpfloat)std::sqrt(1e-5f + lx*lx + ly*ly + lz*lz),
              factor = cimg::max((-lx*nx-ly*ny-lz*nz)/(norm*nl),0);
            lightprops[l] = factor<=nspec?factor:(nsl1*factor*factor + nsl2*factor + nsl3);
          }
        } else {
          const unsigned int
            lw2 = light_texture._width/2 - 1,
            lh2 = light_texture._height/2 - 1;
          lightprops.assign(vertices._width,2);



          for (int l = 0; l<(int)((lightprops)._width); ++l) {
            const tpfloat
              nx = vertices_normals(l,0),
              ny = vertices_normals(l,1),
              nz = vertices_normals(l,2),
              norm = (tpfloat)std::sqrt(1e-5f + nx*nx + ny*ny + nz*nz),
              nnx = nx/norm,
              nny = ny/norm;
            lightprops(l,0) = lw2*(1 + nnx);
            lightprops(l,1) = lh2*(1 + nny);
          }
        }
      } break;
      }


      const CImg<tc> default_color(1,_spectrum,1,1,(tc)200);
      typedef typename to::value_type _to;
      CImg<_to> _opacity;

      for (unsigned int l = 0; l<nb_visibles; ++l) {
        const unsigned int n_primitive = visibles(permutations(l));
        const CImg<tf>& primitive = primitives[n_primitive];
        const CImg<tc>
          &__color = n_primitive<colors._width?colors[n_primitive]:CImg<tc>(),
          _color = (__color && __color.size()!=_spectrum && __color._spectrum<_spectrum)?
            __color.get_resize(-100,-100,-100,_spectrum,0):CImg<tc>(),
          &color = _color?_color:(__color?__color:default_color);
        const tc *const pcolor = color._data;
        const float opacity = __draw_object3d(opacities,n_primitive,_opacity);





        switch (primitive.size()) {
        case 1 : {
          const unsigned int n0 = (unsigned int)primitive[0];
          const int x0 = (int)projections(n0,0), y0 = (int)projections(n0,1);

          if (_opacity.is_empty()) {

            if (color.size()==_spectrum) {
              draw_point(x0,y0,pcolor,opacity);






            } else {
              const tpfloat z = Z + vertices(n0,2);
              const float factor = focale<0?1:sprite_scale*(absfocale?absfocale/(z + absfocale):1);
              const unsigned int
                _sw = (unsigned int)(color._width*factor),
                _sh = (unsigned int)(color._height*factor),
                sw = _sw?_sw:1, sh = _sh?_sh:1;
              const int nx0 = x0 - (int)sw/2, ny0 = y0 - (int)sh/2;
              if (sw<=3*_width/2 && sh<=3*_height/2 &&
                  (nx0+(int)sw/2>=0 || nx0-(int)sw/2<width() || ny0+(int)sh/2>=0 || ny0-(int)sh/2<height())) {
                const CImg<tc>
                  _sprite = (sw!=color._width || sh!=color._height)?
                    color.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<tc>(),
                  &sprite = _sprite?_sprite:color;
                draw_image(nx0,ny0,sprite,opacity);







              }
            }
          } else {
            const tpfloat z = Z + vertices(n0,2);
            const float factor = focale<0?1:sprite_scale*(absfocale?absfocale/(z + absfocale):1);
            const unsigned int
              _sw = (unsigned int)(cimg::max(color._width,_opacity._width)*factor),
              _sh = (unsigned int)(cimg::max(color._height,_opacity._height)*factor),
              sw = _sw?_sw:1, sh = _sh?_sh:1;
            const int nx0 = x0 - (int)sw/2, ny0 = y0 - (int)sh/2;
            if (sw<=3*_width/2 && sh<=3*_height/2 &&
                (nx0+(int)sw/2>=0 || nx0-(int)sw/2<width() || ny0+(int)sh/2>=0 || ny0-(int)sh/2<height())) {
              const CImg<tc>
                _sprite = (sw!=color._width || sh!=color._height)?
                  color.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<tc>(),
                &sprite = _sprite?_sprite:color;
              const CImg<_to>
                _nopacity = (sw!=_opacity._width || sh!=_opacity._height)?
                  _opacity.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<_to>(),
                &nopacity = _nopacity?_nopacity:_opacity;
              draw_image(nx0,ny0,sprite,nopacity);







            }
          }
        } break;
        case 2 : {
          const unsigned int
            n0 = (unsigned int)primitive[0],
            n1 = (unsigned int)primitive[1];
          const int
            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1);
          const float
            z0 = vertices(n0,2) + Z + _focale,
            z1 = vertices(n1,2) + Z + _focale;
          if (render_type) {
            if (zbuffer) draw_line(zbuffer,x0,y0,z0,x1,y1,z1,pcolor,opacity);
            else draw_line(x0,y0,x1,y1,pcolor,opacity);






          } else {
            draw_point(x0,y0,pcolor,opacity).draw_point(x1,y1,pcolor,opacity);







          }
        } break;
        case 5 : {
          const unsigned int
            n0 = (unsigned int)primitive[0],
            n1 = (unsigned int)primitive[1],
            is_wireframe = (unsigned int)primitive[2];
          const float
            Xc = 0.5f*((float)vertices(n0,0) + (float)vertices(n1,0)),
            Yc = 0.5f*((float)vertices(n0,1) + (float)vertices(n1,1)),
            Zc = 0.5f*((float)vertices(n0,2) + (float)vertices(n1,2)),
            zc = Z + Zc + _focale,
            xc = X + Xc*(absfocale?absfocale/zc:1),
            yc = Y + Yc*(absfocale?absfocale/zc:1),
            radius = 0.5f*std::sqrt(cimg::sqr(vertices(n1,0) - vertices(n0,0)) +
                                    cimg::sqr(vertices(n1,1) - vertices(n0,1)) +
                                    cimg::sqr(vertices(n1,2) - vertices(n0,2)))*(absfocale?absfocale/zc:1);
          switch (render_type) {
          case 0 :
            draw_point((int)xc,(int)yc,pcolor,opacity);






            break;
          case 1 :
            draw_circle((int)xc,(int)yc,(int)radius,pcolor,opacity,~0U);







            break;
          default :
            if (is_wireframe) draw_circle((int)xc,(int)yc,(int)radius,pcolor,opacity,~0U);
            else draw_circle((int)xc,(int)yc,(int)radius,pcolor,opacity);
# 36456 "../src/CImg.h"
            break;
          }
        } break;
        case 6 : {
          if (!__color)
            throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "draw_object3d(): Undefined texture for line primitive [%u].",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),n_primitive);
          const unsigned int
            n0 = (unsigned int)primitive[0],
            n1 = (unsigned int)primitive[1],
            tx0 = (unsigned int)primitive[2],
            ty0 = (unsigned int)primitive[3],
            tx1 = (unsigned int)primitive[4],
            ty1 = (unsigned int)primitive[5];
          const int
            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1);
          const float
            z0 = vertices(n0,2) + Z + _focale,
            z1 = vertices(n1,2) + Z + _focale;
          if (render_type) {
            if (zbuffer) draw_line(zbuffer,x0,y0,z0,x1,y1,z1,color,tx0,ty0,tx1,ty1,opacity);
            else draw_line(x0,y0,x1,y1,color,tx0,ty0,tx1,ty1,opacity);






          } else {
            draw_point(x0,y0,color.get_vector_at(tx0,ty0)._data,opacity).
              draw_point(x1,y1,color.get_vector_at(tx1,ty1)._data,opacity);







          }
        } break;
        case 3 : {
          const unsigned int
            n0 = (unsigned int)primitive[0],
            n1 = (unsigned int)primitive[1],
            n2 = (unsigned int)primitive[2];
          const int
            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1),
            x2 = (int)projections(n2,0), y2 = (int)projections(n2,1);
          const float
            z0 = vertices(n0,2) + Z + _focale,
            z1 = vertices(n1,2) + Z + _focale,
            z2 = vertices(n2,2) + Z + _focale;
          switch (render_type) {
          case 0 :
            draw_point(x0,y0,pcolor,opacity).draw_point(x1,y1,pcolor,opacity).draw_point(x2,y2,pcolor,opacity);
# 36522 "../src/CImg.h"
            break;
          case 1 :
            if (zbuffer)
              draw_line(zbuffer,x0,y0,z0,x1,y1,z1,pcolor,opacity).draw_line(zbuffer,x0,y0,z0,x2,y2,z2,pcolor,opacity).
                draw_line(zbuffer,x1,y1,z1,x2,y2,z2,pcolor,opacity);
            else
              draw_line(x0,y0,x1,y1,pcolor,opacity).draw_line(x0,y0,x2,y2,pcolor,opacity).
                draw_line(x1,y1,x2,y2,pcolor,opacity);
# 36538 "../src/CImg.h"
            break;
          case 2 :
            if (zbuffer) draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,pcolor,opacity);
            else draw_triangle(x0,y0,x1,y1,x2,y2,pcolor,opacity);
# 36550 "../src/CImg.h"
            break;
          case 3 :
            if (zbuffer) draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,pcolor,opacity,lightprops(l));
            else _draw_triangle(x0,y0,x1,y1,x2,y2,pcolor,opacity,lightprops(l));
# 36566 "../src/CImg.h"
            break;
          case 4 :
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,pcolor,
                            lightprops(n0),lightprops(n1),lightprops(n2),opacity);
            else draw_triangle(x0,y0,x1,y1,x2,y2,pcolor,lightprops(n0),lightprops(n1),lightprops(n2),opacity);
# 36583 "../src/CImg.h"
            break;
          case 5 : {
            const unsigned int
              lx0 = (unsigned int)lightprops(n0,0), ly0 = (unsigned int)lightprops(n0,1),
              lx1 = (unsigned int)lightprops(n1,0), ly1 = (unsigned int)lightprops(n1,1),
              lx2 = (unsigned int)lightprops(n2,0), ly2 = (unsigned int)lightprops(n2,1);
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,pcolor,light_texture,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
            else draw_triangle(x0,y0,x1,y1,x2,y2,pcolor,light_texture,lx0,ly0,lx1,ly1,lx2,ly2,opacity);
# 36610 "../src/CImg.h"
          } break;
          }
        } break;
        case 4 : {
          const unsigned int
            n0 = (unsigned int)primitive[0],
            n1 = (unsigned int)primitive[1],
            n2 = (unsigned int)primitive[2],
            n3 = (unsigned int)primitive[3];
          const int
            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1),
            x2 = (int)projections(n2,0), y2 = (int)projections(n2,1),
            x3 = (int)projections(n3,0), y3 = (int)projections(n3,1);
          const float
            z0 = vertices(n0,2) + Z + _focale,
            z1 = vertices(n1,2) + Z + _focale,
            z2 = vertices(n2,2) + Z + _focale,
            z3 = vertices(n3,2) + Z + _focale;

          switch (render_type) {
          case 0 :
            draw_point(x0,y0,pcolor,opacity).draw_point(x1,y1,pcolor,opacity).
              draw_point(x2,y2,pcolor,opacity).draw_point(x3,y3,pcolor,opacity);
# 36643 "../src/CImg.h"
            break;
          case 1 :
            if (zbuffer)
              draw_line(zbuffer,x0,y0,z0,x1,y1,z1,pcolor,opacity).draw_line(zbuffer,x1,y1,z1,x2,y2,z2,pcolor,opacity).
                draw_line(zbuffer,x2,y2,z2,x3,y3,z3,pcolor,opacity).draw_line(zbuffer,x3,y3,z3,x0,y0,z0,pcolor,opacity);
            else
              draw_line(x0,y0,x1,y1,pcolor,opacity).draw_line(x1,y1,x2,y2,pcolor,opacity).
                draw_line(x2,y2,x3,y3,pcolor,opacity).draw_line(x3,y3,x0,y0,pcolor,opacity);
# 36660 "../src/CImg.h"
            break;
          case 2 :
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,pcolor,opacity).
                draw_triangle(zbuffer,x0,y0,z0,x2,y2,z2,x3,y3,z3,pcolor,opacity);
            else
              draw_triangle(x0,y0,x1,y1,x2,y2,pcolor,opacity).draw_triangle(x0,y0,x2,y2,x3,y3,pcolor,opacity);
# 36678 "../src/CImg.h"
            break;
          case 3 :
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,pcolor,opacity,lightprops(l)).
                draw_triangle(zbuffer,x0,y0,z0,x2,y2,z2,x3,y3,z3,pcolor,opacity,lightprops(l));
            else
              _draw_triangle(x0,y0,x1,y1,x2,y2,pcolor,opacity,lightprops(l)).
                _draw_triangle(x0,y0,x2,y2,x3,y3,pcolor,opacity,lightprops(l));
# 36700 "../src/CImg.h"
            break;
          case 4 : {
            const float
              lightprop0 = lightprops(n0), lightprop1 = lightprops(n1),
              lightprop2 = lightprops(n2), lightprop3 = lightprops(n3);
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,pcolor,lightprop0,lightprop1,lightprop2,opacity).
                draw_triangle(zbuffer,x0,y0,z0,x2,y2,z2,x3,y3,z3,pcolor,lightprop0,lightprop2,lightprop3,opacity);
            else
              draw_triangle(x0,y0,x1,y1,x2,y2,pcolor,lightprop0,lightprop1,lightprop2,opacity).
                draw_triangle(x0,y0,x2,y2,x3,y3,pcolor,lightprop0,lightprop2,lightprop3,opacity);
# 36725 "../src/CImg.h"
          } break;
          case 5 : {
            const unsigned int
              lx0 = (unsigned int)lightprops(n0,0), ly0 = (unsigned int)lightprops(n0,1),
              lx1 = (unsigned int)lightprops(n1,0), ly1 = (unsigned int)lightprops(n1,1),
              lx2 = (unsigned int)lightprops(n2,0), ly2 = (unsigned int)lightprops(n2,1),
              lx3 = (unsigned int)lightprops(n3,0), ly3 = (unsigned int)lightprops(n3,1);
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,pcolor,light_texture,lx0,ly0,lx1,ly1,lx2,ly2,opacity).
                draw_triangle(zbuffer,x0,y0,z0,x2,y2,z2,x3,y3,z3,pcolor,light_texture,lx0,ly0,lx2,ly2,lx3,ly3,opacity);
            else
              draw_triangle(x0,y0,x1,y1,x2,y2,pcolor,light_texture,lx0,ly0,lx1,ly1,lx2,ly2,opacity).
                draw_triangle(x0,y0,x2,y2,x3,y3,pcolor,light_texture,lx0,ly0,lx2,ly2,lx3,ly3,opacity);
# 36757 "../src/CImg.h"
          } break;
          }
        } break;
        case 9 : {
          if (!__color)
            throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "draw_object3d(): Undefined texture for triangle primitive [%u].",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),n_primitive);
          const unsigned int
            n0 = (unsigned int)primitive[0],
            n1 = (unsigned int)primitive[1],
            n2 = (unsigned int)primitive[2],
            tx0 = (unsigned int)primitive[3],
            ty0 = (unsigned int)primitive[4],
            tx1 = (unsigned int)primitive[5],
            ty1 = (unsigned int)primitive[6],
            tx2 = (unsigned int)primitive[7],
            ty2 = (unsigned int)primitive[8];
          const int
            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1),
            x2 = (int)projections(n2,0), y2 = (int)projections(n2,1);
          const float
            z0 = vertices(n0,2) + Z + _focale,
            z1 = vertices(n1,2) + Z + _focale,
            z2 = vertices(n2,2) + Z + _focale;
          switch (render_type) {
          case 0 :
            draw_point(x0,y0,color.get_vector_at(tx0,ty0)._data,opacity).
              draw_point(x1,y1,color.get_vector_at(tx1,ty1)._data,opacity).
              draw_point(x2,y2,color.get_vector_at(tx2,ty2)._data,opacity);
# 36796 "../src/CImg.h"
            break;
          case 1 :
            if (zbuffer)
              draw_line(zbuffer,x0,y0,z0,x1,y1,z1,color,tx0,ty0,tx1,ty1,opacity).
                draw_line(zbuffer,x0,y0,z0,x2,y2,z2,color,tx0,ty0,tx2,ty2,opacity).
                draw_line(zbuffer,x1,y1,z1,x2,y2,z2,color,tx1,ty1,tx2,ty2,opacity);
            else
              draw_line(x0,y0,z0,x1,y1,z1,color,tx0,ty0,tx1,ty1,opacity).
                draw_line(x0,y0,z0,x2,y2,z2,color,tx0,ty0,tx2,ty2,opacity).
                draw_line(x1,y1,z1,x2,y2,z2,color,tx1,ty1,tx2,ty2,opacity);
# 36814 "../src/CImg.h"
            break;
          case 2 :
            if (zbuffer) draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,opacity);
            else draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,opacity);
# 36826 "../src/CImg.h"
            break;
          case 3 :
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,opacity,lightprops(l));
            else draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,opacity,lightprops(l));
# 36843 "../src/CImg.h"
            break;
          case 4 :
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,
                            lightprops(n0),lightprops(n1),lightprops(n2),opacity);
            else
              draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,
                            lightprops(n0),lightprops(n1),lightprops(n2),opacity);
# 36859 "../src/CImg.h"
            break;
          case 5 :
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,light_texture,
                            (unsigned int)lightprops(n0,0),(unsigned int)lightprops(n0,1),
                            (unsigned int)lightprops(n1,0),(unsigned int)lightprops(n1,1),
                            (unsigned int)lightprops(n2,0),(unsigned int)lightprops(n2,1),
                            opacity);
            else
              draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,light_texture,
                            (unsigned int)lightprops(n0,0),(unsigned int)lightprops(n0,1),
                            (unsigned int)lightprops(n1,0),(unsigned int)lightprops(n1,1),
                            (unsigned int)lightprops(n2,0),(unsigned int)lightprops(n2,1),
                            opacity);
# 36888 "../src/CImg.h"
            break;
          }
        } break;
        case 12 : {
          if (!__color)
            throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                        "draw_object3d(): Undefined texture for quadrangle primitive [%u].",
                                        _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),n_primitive);
          const unsigned int
            n0 = (unsigned int)primitive[0],
            n1 = (unsigned int)primitive[1],
            n2 = (unsigned int)primitive[2],
            n3 = (unsigned int)primitive[3],
            tx0 = (unsigned int)primitive[4],
            ty0 = (unsigned int)primitive[5],
            tx1 = (unsigned int)primitive[6],
            ty1 = (unsigned int)primitive[7],
            tx2 = (unsigned int)primitive[8],
            ty2 = (unsigned int)primitive[9],
            tx3 = (unsigned int)primitive[10],
            ty3 = (unsigned int)primitive[11];
          const int
            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1),
            x2 = (int)projections(n2,0), y2 = (int)projections(n2,1),
            x3 = (int)projections(n3,0), y3 = (int)projections(n3,1);
          const float
            z0 = vertices(n0,2) + Z + _focale,
            z1 = vertices(n1,2) + Z + _focale,
            z2 = vertices(n2,2) + Z + _focale,
            z3 = vertices(n3,2) + Z + _focale;

          switch (render_type) {
          case 0 :
            draw_point(x0,y0,color.get_vector_at(tx0,ty0)._data,opacity).
              draw_point(x1,y1,color.get_vector_at(tx1,ty1)._data,opacity).
              draw_point(x2,y2,color.get_vector_at(tx2,ty2)._data,opacity).
              draw_point(x3,y3,color.get_vector_at(tx3,ty3)._data,opacity);
# 36935 "../src/CImg.h"
            break;
          case 1 :
            if (zbuffer)
              draw_line(zbuffer,x0,y0,z0,x1,y1,z1,color,tx0,ty0,tx1,ty1,opacity).
                draw_line(zbuffer,x1,y1,z1,x2,y2,z2,color,tx1,ty1,tx2,ty2,opacity).
                draw_line(zbuffer,x2,y2,z2,x3,y3,z3,color,tx2,ty2,tx3,ty3,opacity).
                draw_line(zbuffer,x3,y3,z3,x0,y0,z0,color,tx3,ty3,tx0,ty0,opacity);
            else
              draw_line(x0,y0,z0,x1,y1,z1,color,tx0,ty0,tx1,ty1,opacity).
                draw_line(x1,y1,z1,x2,y2,z2,color,tx1,ty1,tx2,ty2,opacity).
                draw_line(x2,y2,z2,x3,y3,z3,color,tx2,ty2,tx3,ty3,opacity).
                draw_line(x3,y3,z3,x0,y0,z0,color,tx3,ty3,tx0,ty0,opacity);
# 36956 "../src/CImg.h"
            break;
          case 2 :
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,opacity).
                draw_triangle(zbuffer,x0,y0,z0,x2,y2,z2,x3,y3,z3,color,tx0,ty0,tx2,ty2,tx3,ty3,opacity);
            else
              draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,opacity).
                draw_triangle(x0,y0,z0,x2,y2,z2,x3,y3,z3,color,tx0,ty0,tx2,ty2,tx3,ty3,opacity);
# 36975 "../src/CImg.h"
            break;
          case 3 :
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,opacity,lightprops(l)).
                draw_triangle(zbuffer,x0,y0,z0,x2,y2,z2,x3,y3,z3,color,tx0,ty0,tx2,ty2,tx3,ty3,opacity,lightprops(l));
            else
              draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,opacity,lightprops(l)).
                draw_triangle(x0,y0,z0,x2,y2,z2,x3,y3,z3,color,tx0,ty0,tx2,ty2,tx3,ty3,opacity,lightprops(l));
# 36998 "../src/CImg.h"
            break;
          case 4 : {
            const float
              lightprop0 = lightprops(n0), lightprop1 = lightprops(n1),
              lightprop2 = lightprops(n2), lightprop3 = lightprops(n3);
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,
                            lightprop0,lightprop1,lightprop2,opacity).
                draw_triangle(zbuffer,x0,y0,z0,x2,y2,z2,x3,y3,z3,color,tx0,ty0,tx2,ty2,tx3,ty3,
                              lightprop0,lightprop2,lightprop3,opacity);
            else
              draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,
                            lightprop0,lightprop1,lightprop2,opacity).
                draw_triangle(x0,y0,z0,x2,y2,z2,x3,y3,z3,color,tx0,ty0,tx2,ty2,tx3,ty3,
                              lightprop0,lightprop2,lightprop3,opacity);
# 37024 "../src/CImg.h"
          } break;
          case 5 : {
            const unsigned int
              lx0 = (unsigned int)lightprops(n0,0), ly0 = (unsigned int)lightprops(n0,1),
              lx1 = (unsigned int)lightprops(n1,0), ly1 = (unsigned int)lightprops(n1,1),
              lx2 = (unsigned int)lightprops(n2,0), ly2 = (unsigned int)lightprops(n2,1),
              lx3 = (unsigned int)lightprops(n3,0), ly3 = (unsigned int)lightprops(n3,1);
            if (zbuffer)
              draw_triangle(zbuffer,x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,
                            light_texture,lx0,ly0,lx1,ly1,lx2,ly2,opacity).
                draw_triangle(zbuffer,x0,y0,z0,x2,y2,z2,x3,y3,z3,color,tx0,ty0,tx2,ty2,tx3,ty3,
                              light_texture,lx0,ly0,lx2,ly2,lx3,ly3,opacity);
            else
              draw_triangle(x0,y0,z0,x1,y1,z1,x2,y2,z2,color,tx0,ty0,tx1,ty1,tx2,ty2,
                            light_texture,lx0,ly0,lx1,ly1,lx2,ly2,opacity).
                draw_triangle(x0,y0,z0,x2,y2,z2,x3,y3,z3,color,tx0,ty0,tx2,ty2,tx3,ty3,
                              light_texture,lx0,ly0,lx2,ly2,lx3,ly3,opacity);
# 37057 "../src/CImg.h"
          } break;
          }
        } break;
        }
      }

      if (render_type==5) cimg::mutex(10,0);
      return *this;
    }
# 37080 "../src/CImg.h"
    CImg<T>& select(CImgDisplay &disp,
                    const unsigned int feature_type=2, unsigned int *const XYZ=0) {
      return get_select(disp,feature_type,XYZ).move_to(*this);
    }


    CImg<T>& select(const char *const title,
                    const unsigned int feature_type=2, unsigned int *const XYZ=0) {
      return get_select(title,feature_type,XYZ).move_to(*this);
    }


    CImg<intT> get_select(CImgDisplay &disp,
                          const unsigned int feature_type=2, unsigned int *const XYZ=0) const {
      return _get_select(disp,0,feature_type,XYZ,0,0,0,true,false);
    }


    CImg<intT> get_select(const char *const title,
                          const unsigned int feature_type=2, unsigned int *const XYZ=0) const {
      CImgDisplay disp;
      return _get_select(disp,title,feature_type,XYZ,0,0,0,true,false);
    }

    CImg<intT> _get_select(CImgDisplay &disp, const char *const title,
                           const unsigned int feature_type, unsigned int *const XYZ,
                           const int origX, const int origY, const int origZ,
                           const bool reset_view3d,
                           const bool force_display_z_coord) const {
      if (is_empty()) return CImg<intT>(1,feature_type==0?3:6,1,1,-1);
      if (!disp) {
        disp.assign(CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,false), CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,true),title?title:0,1);
        if (!title) disp.set_title("CImg<%s> (%ux%ux%ux%u)",pixel_type(),_width,_height,_depth,_spectrum);
      } else if (title) disp.set_title("%s",title);

      const unsigned int old_normalization = disp.normalization();
      bool old_is_resized = disp.is_resized();
      disp._normalization = 0;
      disp.show().set_key(0).set_wheel().show_mouse();

      unsigned char foreground_color[] = { 255,255,255 }, background_color[] = { 0,0,0 };

      int area = 0, starting_area = 0, clicked_area = 0, phase = 0,
        X0 = (int)((XYZ?XYZ[0]:(_width-1)/2)%_width),
        Y0 = (int)((XYZ?XYZ[1]:(_height-1)/2)%_height),
        Z0 = (int)((XYZ?XYZ[2]:(_depth-1)/2)%_depth),
        X1 =-1, Y1 = -1, Z1 = -1,
        X3d = -1, Y3d = -1,
        oX3d = X3d, oY3d = -1,
        omx = -1, omy = -1;
      float X = -1, Y = -1, Z = -1;
      unsigned int old_button = 0, key = 0;

      bool shape_selected = false, text_down = false, visible_cursor = true;
      static CImg<floatT> pose3d;
      static bool is_view3d = false, is_axes = true;
      if (reset_view3d) { pose3d.assign(); is_view3d = false; }
      CImg<floatT> points3d, opacities3d, sel_opacities3d;
      CImgList<uintT> primitives3d, sel_primitives3d;
      CImgList<ucharT> colors3d, sel_colors3d;
      CImg<ucharT> visu, visu0, view3d;
      char text[1024] = { 0 };

      while (!key && !disp.is_closed() && !shape_selected) {


        int
          mx = disp.mouse_x(),
          my = disp.mouse_y();

        const float
          mX = mx<0?-1.0f:(float)mx*(width()+(depth()>1?depth():0))/disp.width(),
          mY = my<0?-1.0f:(float)my*(height()+(depth()>1?depth():0))/disp.height();

        area = 0;
        if (mX>=0 && mY>=0 && mX<width() && mY<height()) { area = 1; X = mX; Y = mY; Z = (float)(phase?Z1:Z0); }
        if (mX>=0 && mX<width() && mY>=height()) { area = 2; X = mX; Z = mY - _height; Y = (float)(phase?Y1:Y0); }
        if (mY>=0 && mX>=width() && mY<height()) { area = 3; Y = mY; Z = mX - _width; X = (float)(phase?X1:X0); }
        if (mX>=width() && mY>=height()) area = 4;
        if (disp.button()) { if (!clicked_area) clicked_area = area; } else clicked_area = 0;

        switch (key = disp.key()) {

        case cimg::keyCTRLRIGHT :

        case 0 : case cimg::keyCTRLLEFT : key = 0; break;
        case cimg::keyPAGEUP :
          if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { disp.set_wheel(1); key = 0; } break;
        case cimg::keyPAGEDOWN :
          if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { disp.set_wheel(-1); key = 0; } break;
        case cimg::keyA : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            is_axes = !is_axes; disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyD : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).
              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
              _is_resized = true;
            disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyC : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).
              resize(CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,false), CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,true),false)._is_resized = true;
            disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyR : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).resize(CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,false), CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,true),false)._is_resized = true;
            disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyF : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.resize(disp.screen_width(),disp.screen_height(),false).toggle_fullscreen()._is_resized = true;
            disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyV : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            is_view3d = !is_view3d; disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyS : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            char filename[32] = { 0 };
            std::FILE *file;
            do {
              snprintf(filename,sizeof(filename),"CImg" "_%.4u.bmp",snap_number++);
              if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
            } while (file);
            if (visu0) {
              (+visu0).draw_text(0,0," Saving snapshot... ",foreground_color,background_color,0.7f,13).display(disp);
              visu0.save(filename);
              (+visu0).draw_text(0,0," Snapshot '%s' saved. ",foreground_color,background_color,0.7f,13,filename).
                display(disp);
            }
            disp.set_key(key,false); key = 0;
          } break;
        case cimg::keyO : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            char filename[32] = { 0 };
            std::FILE *file;
            do {



              snprintf(filename,sizeof(filename),"CImg" "_%.4u.cimg",snap_number++);

              if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
            } while (file);
            (+visu0).draw_text(0,0," Saving instance... ",foreground_color,background_color,0.7f,13).display(disp);
            save(filename);
            (+visu0).draw_text(0,0," Instance '%s' saved. ",foreground_color,background_color,0.7f,13,filename).
              display(disp);
            disp.set_key(key,false); key = 0;
          } break;
        }

        switch (area) {

        case 0 :
          mx = my = -1; X = Y = Z = -1;
          break;

        case 1 : case 2 : case 3 :
          if (disp.button()&1 && phase<2 && clicked_area==area) {
            if (_depth>1 && (X1!=(int)X || Y1!=(int)Y || Z1!=(int)Z)) visu0.assign();
            X1 = (int)X; Y1 = (int)Y; Z1 = (int)Z;
          }
          if (!(disp.button()&1) && phase>=2 && clicked_area!=area) {
            switch (starting_area) {
            case 1 : if (Z1!=(int)Z) visu0.assign(); Z1 = (int)Z; break;
            case 2 : if (Y1!=(int)Y) visu0.assign(); Y1 = (int)Y; break;
            case 3 : if (X1!=(int)X) visu0.assign(); X1 = (int)X; break;
            }
          }
          if (disp.button()&2 && clicked_area==area) {
            if (phase) {
              if (_depth>1 && (X1!=(int)X || Y1!=(int)Y || Z1!=(int)Z)) visu0.assign();
              X1 = (int)X; Y1 = (int)Y; Z1 = (int)Z;
            } else {
              if (_depth>1 && (X0!=(int)X || Y0!=(int)Y || Z0!=(int)Z)) visu0.assign();
              X0 = (int)X; Y0 = (int)Y; Z0 = (int)Z;
            }
          }
          if (disp.button()&4) {
            X = (float)X0; Y = (float)Y0; Z = (float)Z0; phase = area = clicked_area = starting_area = 0;
            visu0.assign();
          }
          if (disp.wheel()) {
            if (_depth>1 && !disp.is_keyCTRLLEFT() && !disp.is_keyCTRLRIGHT() &&
                !disp.is_keySHIFTLEFT() && !disp.is_keySHIFTRIGHT() &&
                !disp.is_keyALT() && !disp.is_keyALTGR()) {
              switch (area) {
              case 1 :
                if (phase) Z = (float)(Z1+=disp.wheel()); else Z = (float)(Z0+=disp.wheel());
                visu0.assign(); break;
              case 2 :
                if (phase) Y = (float)(Y1+=disp.wheel()); else Y = (float)(Y0+=disp.wheel());
                visu0.assign(); break;
              case 3 :
                if (phase) X = (float)(X1+=disp.wheel()); else X = (float)(X0+=disp.wheel());
                visu0.assign(); break;
              }
              disp.set_wheel();
            } else key = ~0U;
          }
          if ((disp.button()&1)!=old_button) {
            switch (phase) {
            case 0 :
              if (area==clicked_area) {
                X0 = X1 = (int)X; Y0 = Y1 = (int)Y; Z0 = Z1 = (int)Z; starting_area = area; ++phase;
              } break;
            case 1 :
              if (area==starting_area) {
                X1 = (int)X; Y1 = (int)Y; Z1 = (int)Z; ++phase;
              } else if (!(disp.button()&1)) { X = (float)X0; Y = (float)Y0; Z = (float)Z0; phase = 0; visu0.assign(); }
              break;
            case 2 : ++phase; break;
            }
            old_button = disp.button()&1;
          }
          break;

        case 4 :
          if (is_view3d && points3d) {
            X3d = mx - _width*disp.width()/(_width+(_depth>1?_depth:0));
            Y3d = my - _height*disp.height()/(_height+(_depth>1?_depth:0));
            if (oX3d<0) { oX3d = X3d; oY3d = Y3d; }

            if ((disp.button()&3)==3) { pose3d.assign(); view3d.assign(); oX3d = oY3d = X3d = Y3d = -1; }
            else if (disp.button()&1 && pose3d && (oX3d!=X3d || oY3d!=Y3d)) {
              const float
                R = 0.45f*cimg::min(view3d._width,view3d._height),
                R2 = R*R,
                u0 = (float)(oX3d-view3d.width()/2),
                v0 = (float)(oY3d-view3d.height()/2),
                u1 = (float)(X3d-view3d.width()/2),
                v1 = (float)(Y3d-view3d.height()/2),
                n0 = (float)std::sqrt(u0*u0+v0*v0),
                n1 = (float)std::sqrt(u1*u1+v1*v1),
                nu0 = n0>R?(u0*R/n0):u0,
                nv0 = n0>R?(v0*R/n0):v0,
                nw0 = (float)std::sqrt(cimg::max(0,R2-nu0*nu0-nv0*nv0)),
                nu1 = n1>R?(u1*R/n1):u1,
                nv1 = n1>R?(v1*R/n1):v1,
                nw1 = (float)std::sqrt(cimg::max(0,R2-nu1*nu1-nv1*nv1)),
                u = nv0*nw1 - nw0*nv1,
                v = nw0*nu1 - nu0*nw1,
                w = nv0*nu1 - nu0*nv1,
                n = (float)std::sqrt(u*u+v*v+w*w),
                alpha = (float)std::asin(n/R2);
              pose3d.draw_image(CImg<floatT>::rotation_matrix(u,v,w,alpha)*pose3d.get_crop(0,0,2,2));
              view3d.assign();
            } else if (disp.button()&2 && pose3d && oY3d!=Y3d) {
              pose3d(3,2)-=(oY3d - Y3d)*1.5f; view3d.assign();
            }
            if (disp.wheel()) {
              pose3d(3,2)-=disp.wheel()*15; view3d.assign(); disp.set_wheel();
            }
            if (disp.button()&4 && pose3d && (oX3d!=X3d || oY3d!=Y3d)) {
              pose3d(3,0)-=oX3d - X3d; pose3d(3,1)-=oY3d - Y3d; view3d.assign();
            }
            oX3d = X3d; oY3d = Y3d;
          }
          mx = my = -1; X = Y = Z = -1;
          break;
        }

        if (phase) {
          if (!feature_type) shape_selected = phase?true:false;
          else {
            if (_depth>1) shape_selected = (phase==3)?true:false;
            else shape_selected = (phase==2)?true:false;
          }
        }

        if (X0<0) X0 = 0; if (X0>=width()) X0 = width() - 1;
        if (Y0<0) Y0 = 0; if (Y0>=height()) Y0 = height() - 1;
        if (Z0<0) Z0 = 0; if (Z0>=depth()) Z0 = depth() - 1;
        if (X1<1) X1 = 0; if (X1>=width()) X1 = width() - 1;
        if (Y1<0) Y1 = 0; if (Y1>=height()) Y1 = height() - 1;
        if (Z1<0) Z1 = 0; if (Z1>=depth()) Z1 = depth() - 1;


        if (mx!=omx || my!=omy || !visu0 || (_depth>1 && !view3d)) {

          if (!visu0) {
            __get_select(disp,old_normalization,phase?X1:X0,phase?Y1:Y0,phase?Z1:Z0).move_to(visu0).resize(disp);
            view3d.assign();
            points3d.assign();
          }

          if (is_view3d && _depth>1 && !view3d) {
            const unsigned int
              _x3d = (unsigned int)cimg::round((float)_width*visu0._width/(_width+_depth),1,1),
              _y3d = (unsigned int)cimg::round((float)_height*visu0._height/(_height+_depth),1,1),
              x3d = _x3d>=visu0._width?visu0._width-1:_x3d,
              y3d = _y3d>=visu0._height?visu0._height-1:_y3d;
            CImg<ucharT>(1,2,1,1,64,128).resize(visu0._width-x3d,visu0._height-y3d,1,visu0._spectrum,3).move_to(view3d);
            if (!points3d) {
              get_projections3d(primitives3d,colors3d,phase?X1:X0,phase?Y1:Y0,phase?Z1:Z0,true).move_to(points3d);
              points3d.append(CImg<floatT>(8,3,1,1,
                                           0,_width-1,_width-1,0,0,_width-1,_width-1,0,
                                           0,0,_height-1,_height-1,0,0,_height-1,_height-1,
                                           0,0,0,0,_depth-1,_depth-1,_depth-1,_depth-1),'x');
              CImg<uintT>::vector(12,13).move_to(primitives3d); CImg<uintT>::vector(13,14).move_to(primitives3d);
              CImg<uintT>::vector(14,15).move_to(primitives3d); CImg<uintT>::vector(15,12).move_to(primitives3d);
              CImg<uintT>::vector(16,17).move_to(primitives3d); CImg<uintT>::vector(17,18).move_to(primitives3d);
              CImg<uintT>::vector(18,19).move_to(primitives3d); CImg<uintT>::vector(19,16).move_to(primitives3d);
              CImg<uintT>::vector(12,16).move_to(primitives3d); CImg<uintT>::vector(13,17).move_to(primitives3d);
              CImg<uintT>::vector(14,18).move_to(primitives3d); CImg<uintT>::vector(15,19).move_to(primitives3d);
              colors3d.insert(12,CImg<ucharT>::vector(255,255,255));
              opacities3d.assign(primitives3d.width(),1,1,1,0.5f);
              if (!phase) {
                opacities3d[0] = opacities3d[1] = opacities3d[2] = 0.8f;
                sel_primitives3d.assign();
                sel_colors3d.assign();
                sel_opacities3d.assign();
              } else {
                if (feature_type==2) {
                  points3d.append(CImg<floatT>(8,3,1,1,
                                               X0,X1,X1,X0,X0,X1,X1,X0,
                                               Y0,Y0,Y1,Y1,Y0,Y0,Y1,Y1,
                                               Z0,Z0,Z0,Z0,Z1,Z1,Z1,Z1),'x');
                  sel_primitives3d.assign();
                  CImg<uintT>::vector(20,21).move_to(sel_primitives3d);
                  CImg<uintT>::vector(21,22).move_to(sel_primitives3d);
                  CImg<uintT>::vector(22,23).move_to(sel_primitives3d);
                  CImg<uintT>::vector(23,20).move_to(sel_primitives3d);
                  CImg<uintT>::vector(24,25).move_to(sel_primitives3d);
                  CImg<uintT>::vector(25,26).move_to(sel_primitives3d);
                  CImg<uintT>::vector(26,27).move_to(sel_primitives3d);
                  CImg<uintT>::vector(27,24).move_to(sel_primitives3d);
                  CImg<uintT>::vector(20,24).move_to(sel_primitives3d);
                  CImg<uintT>::vector(21,25).move_to(sel_primitives3d);
                  CImg<uintT>::vector(22,26).move_to(sel_primitives3d);
                  CImg<uintT>::vector(23,27).move_to(sel_primitives3d);
                } else {
                  points3d.append(CImg<floatT>(2,3,1,1,
                                               X0,X1,
                                               Y0,Y1,
                                               Z0,Z1),'x');
                  sel_primitives3d.assign(CImg<uintT>::vector(20,21));
                }
                sel_colors3d.assign(sel_primitives3d._width,CImg<ucharT>::vector(255,255,255));
                sel_opacities3d.assign(sel_primitives3d._width,1,1,1,0.8f);
              }
              points3d.shift_object3d(-0.5f*(_width-1),-0.5f*(_height-1),-0.5f*(_depth-1)).resize_object3d();
              points3d*=0.75f*cimg::min(view3d._width,view3d._height);
            }

            if (!pose3d) CImg<floatT>(4,3,1,1, 1,0,0,0, 0,1,0,0, 0,0,1,0).move_to(pose3d);
            CImg<floatT> zbuffer3d(view3d._width,view3d._height,1,1,0);
            const CImg<floatT> rotated_points3d = pose3d.get_crop(0,0,2,2)*points3d;
            if (sel_primitives3d)
              view3d.draw_object3d(pose3d(3,0) + 0.5f*view3d._width,
                                   pose3d(3,1) + 0.5f*view3d._height,
                                   pose3d(3,2),
                                   rotated_points3d,sel_primitives3d,sel_colors3d,sel_opacities3d,
                                   2,true,500,0,0,0,0,0,zbuffer3d);
            view3d.draw_object3d(pose3d(3,0) + 0.5f*view3d._width,
                                 pose3d(3,1) + 0.5f*view3d._height,
                                 pose3d(3,2),
                                 rotated_points3d,primitives3d,colors3d,opacities3d,
                                 2,true,500,0,0,0,0,0,zbuffer3d);
            visu0.draw_image(x3d,y3d,view3d);
          }
          visu = visu0;

          if (X<0 || Y<0 || Z<0) { if (!visible_cursor) { disp.show_mouse(); visible_cursor = true; }}
          else {
            if (is_axes) { if (visible_cursor) { disp.hide_mouse(); visible_cursor = false; }}
            else { if (!visible_cursor) { disp.show_mouse(); visible_cursor = true; }}
            const int d = (_depth>1)?_depth:0;
            int
              w = disp.width(), W = width() + d,
              h = disp.height(), H = height() + d,
              _xp = (int)X*w/W, xp = _xp + (_xp*W/w!=(int)X?1:0),
              _yp = (int)Y*h/H, yp = _yp + (_yp*H/h!=(int)Y?1:0),
              _xn = (int)(X+1)*w/W-1, xn = _xn + ((_xn+1)*W/w!=(int)X+1?1:0),
              _yn = (int)(Y+1)*h/H-1, yn = _yn + ((_yn+1)*H/h!=(int)Y+1?1:0),
              _zxp = ((int)Z+width())*w/W, zxp = _zxp + (_zxp*W/w!=(int)Z+width()?1:0),
              _zyp = ((int)Z+height())*h/H, zyp = _zyp + (_zyp*H/h!=(int)Z+height()?1:0),
              _zxn = ((int)Z+width()+1)*w/W-1, zxn = _zxn + ((_zxn+1)*W/w!=(int)Z+width()+1?1:0),
              _zyn = ((int)Z+height()+1)*h/H-1, zyn = _zyn + ((_zyn+1)*H/h!=(int)Z+height()+1?1:0),
              _xM = width()*w/W-1, xM = _xM + ((_xM+1)*W/w!=width()?1:0),
              _yM = height()*h/H-1, yM = _yM + ((_yM+1)*H/h!=height()?1:0),
              xc = (xp + xn)/2,
              yc = (yp + yn)/2,
              zxc = (zxp + zxn)/2,
              zyc = (zyp + zyn)/2,
              xf = (int)(X*w/W),
              yf = (int)(Y*h/H),
              zxf = (int)((Z+width())*w/W),
              zyf = (int)((Z+height())*h/H);

            if (is_axes) {
              visu.draw_line(0,yf,visu.width()-1,yf,foreground_color,0.7f,0xFF00FF00).
                draw_line(0,yf,visu.width()-1,yf,background_color,0.7f,0x00FF00FF).
                draw_line(xf,0,xf,visu.height()-1,foreground_color,0.7f,0xFF00FF00).
                draw_line(xf,0,xf,visu.height()-1,background_color,0.7f,0x00FF00FF);
              if (_depth>1)
                visu.draw_line(zxf,0,zxf,yM,foreground_color,0.7f,0xFF00FF00).
                  draw_line(zxf,0,zxf,yM,background_color,0.7f,0x00FF00FF).
                  draw_line(0,zyf,xM,zyf,foreground_color,0.7f,0xFF00FF00).
                  draw_line(0,zyf,xM,zyf,background_color,0.7f,0x00FF00FF);
            }


            if (xn-xp>=4 && yn-yp>=4) visu.draw_rectangle(xp,yp,xn,yn,foreground_color,0.2f).
                                        draw_rectangle(xp,yp,xn,yn,foreground_color,1,0xAAAAAAAA).
                                        draw_rectangle(xp,yp,xn,yn,background_color,1,0x55555555);
            if (_depth>1) {
              if (yn-yp>=4 && zxn-zxp>=4) visu.draw_rectangle(zxp,yp,zxn,yn,background_color,0.2f).
                                            draw_rectangle(zxp,yp,zxn,yn,foreground_color,1,0xAAAAAAAA).
                                            draw_rectangle(zxp,yp,zxn,yn,background_color,1,0x55555555);
              if (xn-xp>=4 && zyn-zyp>=4) visu.draw_rectangle(xp,zyp,xn,zyn,background_color,0.2f).
                                            draw_rectangle(xp,zyp,xn,zyn,foreground_color,1,0xAAAAAAAA).
                                            draw_rectangle(xp,zyp,xn,zyn,background_color,1,0x55555555);
            }


            if (phase) {
              const int
                _xp0 = X0*w/W, xp0 = _xp0 + (_xp0*W/w!=X0?1:0),
                _yp0 = Y0*h/H, yp0 = _yp0 + (_yp0*H/h!=Y0?1:0),
                _xn0 = (X0+1)*w/W-1, xn0 = _xn0 + ((_xn0+1)*W/w!=X0+1?1:0),
                _yn0 = (Y0+1)*h/H-1, yn0 = _yn0 + ((_yn0+1)*H/h!=Y0+1?1:0),
                _zxp0 = (Z0+width())*w/W, zxp0 = _zxp0 + (_zxp0*W/w!=Z0+width()?1:0),
                _zyp0 = (Z0+height())*h/H, zyp0 = _zyp0 + (_zyp0*H/h!=Z0+height()?1:0),
                _zxn0 = (Z0+width()+1)*w/W-1, zxn0 = _zxn0 + ((_zxn0+1)*W/w!=Z0+width()+1?1:0),
                _zyn0 = (Z0+height()+1)*h/H-1, zyn0 = _zyn0 + ((_zyn0+1)*H/h!=Z0+height()+1?1:0),
                xc0 = (xp0 + xn0)/2,
                yc0 = (yp0 + yn0)/2,
                zxc0 = (zxp0 + zxn0)/2,
                zyc0 = (zyp0 + zyn0)/2;

              switch (feature_type) {
              case 1 : {
                visu.draw_arrow(xc0,yc0,xc,yc,background_color,0.9f,30,5,0x55555555).
                  draw_arrow(xc0,yc0,xc,yc,foreground_color,0.9f,30,5,0xAAAAAAAA);
                if (d) {
                  visu.draw_arrow(zxc0,yc0,zxc,yc,background_color,0.9f,30,5,0x55555555).
                    draw_arrow(zxc0,yc0,zxc,yc,foreground_color,0.9f,30,5,0xAAAAAAAA).
                    draw_arrow(xc0,zyc0,xc,zyc,background_color,0.9f,30,5,0x55555555).
                    draw_arrow(xc0,zyc0,xc,zyc,foreground_color,0.9f,30,5,0xAAAAAAAA);
                }
              } break;
              case 2 : {
                visu.draw_rectangle(X0<X1?xp0:xp,Y0<Y1?yp0:yp,X0<X1?xn:xn0,Y0<Y1?yn:yn0,background_color,0.2f).
                  draw_rectangle(X0<X1?xp0:xp,Y0<Y1?yp0:yp,X0<X1?xn:xn0,Y0<Y1?yn:yn0,foreground_color,0.9f,0xAAAAAAAA).
                  draw_rectangle(X0<X1?xp0:xp,Y0<Y1?yp0:yp,X0<X1?xn:xn0,Y0<Y1?yn:yn0,background_color,0.9f,0x55555555);
                if (d) {
                  visu.draw_rectangle(Z0<Z1?zxp0:zxp,Y0<Y1?yp0:yp,Z0<Z1?zxn:zxn0,Y0<Y1?yn:yn0,background_color,0.2f).
                    draw_rectangle(Z0<Z1?zxp0:zxp,Y0<Y1?yp0:yp,Z0<Z1?zxn:zxn0,Y0<Y1?yn:yn0,
                                   foreground_color,0.9f,0xAAAAAAAA).
                    draw_rectangle(Z0<Z1?zxp0:zxp,Y0<Y1?yp0:yp,Z0<Z1?zxn:zxn0,Y0<Y1?yn:yn0,
                                   background_color,0.9f,0x55555555).
                    draw_rectangle(X0<X1?xp0:xp,Z0<Z1?zyp0:zyp,X0<X1?xn:xn0,Z0<Z1?zyn:zyn0,
                                   background_color,0.2f).
                    draw_rectangle(X0<X1?xp0:xp,Z0<Z1?zyp0:zyp,X0<X1?xn:xn0,Z0<Z1?zyn:zyn0,
                                   foreground_color,0.9f,0xAAAAAAAA).
                    draw_rectangle(X0<X1?xp0:xp,Z0<Z1?zyp0:zyp,X0<X1?xn:xn0,Z0<Z1?zyn:zyn0,
                                   background_color,0.9f,0x55555555);
                }
              } break;
              case 3 : {
                visu.draw_ellipse(xc0,yc0,(float)cimg::abs(xc-xc0),(float)cimg::abs(yc-yc0),0,background_color,0.2f).
                  draw_ellipse(xc0,yc0,(float)cimg::abs(xc-xc0),(float)cimg::abs(yc-yc0),0,foreground_color,0.9f,~0U).
                  draw_point(xc0,yc0,foreground_color,0.9f);
                if (d) {
                  visu.draw_ellipse(zxc0,yc0,(float)cimg::abs(zxc-zxc0),(float)cimg::abs(yc-yc0),0,
                                    background_color,0.2f).
                    draw_ellipse(zxc0,yc0,(float)cimg::abs(zxc-zxc0),(float)cimg::abs(yc-yc0),0,
                                 foreground_color,0.9f,~0U).
                    draw_point(zxc0,yc0,foreground_color,0.9f).
                    draw_ellipse(xc0,zyc0,(float)cimg::abs(xc-xc0),(float)cimg::abs(zyc-zyc0),0,
                                 background_color,0.2f).
                    draw_ellipse(xc0,zyc0,(float)cimg::abs(xc-xc0),(float)cimg::abs(zyc-zyc0),0,
                                 foreground_color,0.9f,~0U).
                    draw_point(xc0,zyc0,foreground_color,0.9f);
                }
              } break;
              }
            }


            if (my>=0 && my<13) text_down = true; else if (my>=visu.height()-13) text_down = false;
            if (!feature_type || !phase) {
              if (X>=0 && Y>=0 && Z>=0 && X<width() && Y<height() && Z<depth()) {
                if (_depth>1 || force_display_z_coord)
                  snprintf(text,sizeof(text)," Point (%d,%d,%d) = [ ",origX+(int)X,origY+(int)Y,origZ+(int)Z);
                else snprintf(text,sizeof(text)," Point (%d,%d) = [ ",origX+(int)X,origY+(int)Y);
                char *ctext = text + std::strlen(text), *const ltext = text + 512;
                for (unsigned int c = 0; c<_spectrum && ctext<ltext; ++c) {
                  snprintf(ctext,sizeof(text)/2,cimg::type<T>::format(),
                                cimg::type<T>::format((*this)((int)X,(int)Y,(int)Z,c)));
                  ctext = text + std::strlen(text);
                  *(ctext++) = ' '; *ctext = 0;
                }
                std::strcpy(text + std::strlen(text),"] ");
              }
            } else switch (feature_type) {
              case 1 : {
                const double dX = (double)(X0 - X1), dY = (double)(Y0 - Y1), dZ = (double)(Z0 - Z1),
                  norm = std::sqrt(dX*dX+dY*dY+dZ*dZ);
                if (_depth>1 || force_display_z_coord)
                  snprintf(text,sizeof(text)," Vect (%d,%d,%d)-(%d,%d,%d), Norm = %g ",
                                origX+X0,origY+Y0,origZ+Z0,origX+X1,origY+Y1,origZ+Z1,norm);
                else snprintf(text,sizeof(text)," Vect (%d,%d)-(%d,%d), Norm = %g ",
                                   origX+X0,origY+Y0,origX+X1,origY+Y1,norm);
              } break;
              case 2 :
                if (_depth>1 || force_display_z_coord)
                  snprintf(text,sizeof(text)," Box (%d,%d,%d)-(%d,%d,%d), Size = (%d,%d,%d) ",
                                origX+(X0<X1?X0:X1),origY+(Y0<Y1?Y0:Y1),origZ+(Z0<Z1?Z0:Z1),
                                origX+(X0<X1?X1:X0),origY+(Y0<Y1?Y1:Y0),origZ+(Z0<Z1?Z1:Z0),
                                1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1),1+cimg::abs(Z0-Z1));
                else snprintf(text,sizeof(text)," Box (%d,%d)-(%d,%d), Size = (%d,%d) ",
                                   origX+(X0<X1?X0:X1),origY+(Y0<Y1?Y0:Y1),origX+(X0<X1?X1:X0),origY+(Y0<Y1?Y1:Y0),
                                   1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1));
                break;
              default :
                if (_depth>1 || force_display_z_coord)
                  snprintf(text,sizeof(text)," Ellipse (%d,%d,%d)-(%d,%d,%d), Radii = (%d,%d,%d) ",
                                origX+X0,origY+Y0,origZ+Z0,origX+X1,origY+Y1,origZ+Z1,
                                1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1),1+cimg::abs(Z0-Z1));
                else snprintf(text,sizeof(text)," Ellipse (%d,%d)-(%d,%d), Radii = (%d,%d) ",
                                   origX+X0,origY+Y0,origX+X1,origY+Y1,1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1));
              }
            if (phase || (mx>=0 && my>=0))
              visu.draw_text(0,text_down?visu.height()-13:0,text,foreground_color,background_color,0.7f,13);
          }

          disp.display(visu).wait();
        } else if (!shape_selected) disp.wait();
        if (disp.is_resized()) { disp.resize(false)._is_resized = false; old_is_resized = true; visu0.assign(); }
        omx = mx; omy = my;
      }


      CImg<intT> res(1,feature_type==0?3:6,1,1,-1);
      if (XYZ) { XYZ[0] = (unsigned int)X0; XYZ[1] = (unsigned int)Y0; XYZ[2] = (unsigned int)Z0; }
      if (shape_selected) {
        if (feature_type==2) {
          if (X0>X1) cimg::swap(X0,X1);
          if (Y0>Y1) cimg::swap(Y0,Y1);
          if (Z0>Z1) cimg::swap(Z0,Z1);
        }
        if (X1<0 || Y1<0 || Z1<0) X0 = Y0 = Z0 = X1 = Y1 = Z1 = -1;
        switch (feature_type) {
        case 1 : case 2 : res[0] = X0; res[1] = Y0; res[2] = Z0; res[3] = X1; res[4] = Y1; res[5] = Z1; break;
        case 3 :
          res[3] = cimg::abs(X1-X0); res[4] = cimg::abs(Y1-Y0); res[5] = cimg::abs(Z1-Z0);
        default : res[0] = X0; res[1] = Y0; res[2] = Z0;
        }
      }
      disp.set_button();
      if (!visible_cursor) disp.show_mouse();
      disp._normalization = old_normalization;
      disp._is_resized = old_is_resized;
      if (key!=~0U) disp.set_key(key);
      return res;
    }


    CImg<ucharT> __get_select(const CImgDisplay& disp, const int normalization,
                              const int x, const int y, const int z) const {
      if (is_empty()) return CImg<ucharT>(1,1,1,1,0);
      const CImg<T> crop = get_shared_channels(0,cimg::min(2,spectrum()-1));
      CImg<Tuchar> img2d;
      if (_depth>1) crop.get_projections2d(x,y,z).move_to(img2d);
      else CImg<Tuchar>(crop,false).move_to(img2d);

      if (cimg::type<T>::is_float()) {
        bool is_inf = false, is_nan = false;
        for (Tuchar *ptr = (img2d)._data, *_maxptr = (img2d)._data + (img2d).size(); ptr<_maxptr; ++ptr)
          if (cimg::type<T>::is_inf(*ptr)) { is_inf = true; break; }
          else if (cimg::type<T>::is_nan(*ptr)) { is_nan = true; break; }
        if (is_inf || is_nan) {
          T m0 = cimg::type<T>::max(), M0 = cimg::type<T>::min();
          if (!normalization) { m0 = 0; M0 = 255; }
          else if (normalization==2) { m0 = (T)disp._min; M0 = (T)disp._max; }
          else
            for (Tuchar *ptr = (img2d)._data, *_maxptr = (img2d)._data + (img2d).size(); ptr<_maxptr; ++ptr)
              if (!cimg::type<T>::is_inf(*ptr) && !cimg::type<T>::is_nan(*ptr)) {
                if (*ptr<m0) m0 = *ptr; if (*ptr>M0) M0 = *ptr;
              }
          const T
            val_minf = (normalization==1 || normalization==3)?m0-(M0-m0)*20-1:m0,
            val_pinf = (normalization==1 || normalization==3)?M0+(M0-m0)*20+1:M0;
          if (is_nan)
            for (Tuchar *ptr = (img2d)._data, *_maxptr = (img2d)._data + (img2d).size(); ptr<_maxptr; ++ptr)
              if (cimg::type<T>::is_nan(*ptr)) *ptr = val_minf;
          if (is_inf)
            for (Tuchar *ptr = (img2d)._data, *_maxptr = (img2d)._data + (img2d).size(); ptr<_maxptr; ++ptr)
              if (cimg::type<T>::is_inf(*ptr)) *ptr = (float)*ptr<0?val_minf:val_pinf;
        }
      }

      switch (normalization) {
      case 1 : img2d.normalize(0,255); break;
      case 2 : {
        const float m = disp._min, M = disp._max;
        (img2d-=m)*=255.0f/(M-m>0?M-m:1);
      } break;
      case 3 :
        if (cimg::type<T>::is_float()) img2d.normalize(0,255);
        else {
          const float m = (float)cimg::type<T>::min(), M = (float)cimg::type<T>::max();
          (img2d-=m)*=255.0f/(M-m>0?M-m:1);
        } break;
      }

      if (img2d.spectrum()==2) img2d.channels(0,2);
      return img2d;
    }


    CImg<intT> get_select_graph(CImgDisplay &disp,
                                const unsigned int plot_type=1, const unsigned int vertex_type=1,
                                const char *const labelx=0, const double xmin=0, const double xmax=0,
                                const char *const labely=0, const double ymin=0, const double ymax=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "select_graph(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (!disp) disp.assign(CImgDisplay::_fitscreen(CImgDisplay::screen_width()/2,CImgDisplay::screen_height()/2,1,128,-85,false), CImgDisplay::_fitscreen(CImgDisplay::screen_width()/2,CImgDisplay::screen_height()/2,1,128,-85,true),0,0).
                   set_title("CImg<%s>",pixel_type());
      const unsigned long siz = (unsigned long)_width*_height*_depth;
      const unsigned int old_normalization = disp.normalization();
      disp.show().set_button().set_wheel()._normalization = 0;

      double nymin = ymin, nymax = ymax, nxmin = xmin, nxmax = xmax;
      if (nymin==nymax) { nymin = (Tfloat)min_max(nymax); const double dy = nymax - nymin; nymin-=dy/20; nymax+=dy/20; }
      if (nymin==nymax) { --nymin; ++nymax; }
      if (nxmin==nxmax && nxmin==0) { nxmin = 0; nxmax = siz - 1.0; }

      const unsigned char black[] = { 0, 0, 0 }, white[] = { 255, 255, 255 }, gray[] = { 220, 220, 220 };
      const unsigned char gray2[] = { 110, 110, 110 }, ngray[] = { 35, 35, 35 };
      static unsigned int odimv = 0;
      static CImg<ucharT> colormap;
      if (odimv!=_spectrum) {
        odimv = _spectrum;
        colormap = CImg<ucharT>(3,_spectrum,1,1,120).noise(70,1);
        if (_spectrum==1) { colormap[0] = colormap[1] = 120; colormap[2] = 200; }
        else {
          colormap(0,0) = 220; colormap(1,0) = 10; colormap(2,0) = 10;
          if (_spectrum>1) { colormap(0,1) = 10; colormap(1,1) = 220; colormap(2,1) = 10; }
          if (_spectrum>2) { colormap(0,2) = 10; colormap(1,2) = 10; colormap(2,2) = 220; }
        }
      }

      CImg<ucharT> visu0, visu, graph, text, axes;
      int x0 = -1, x1 = -1, y0 = -1, y1 = -1, omouse_x = -2, omouse_y = -2;
      const unsigned int one = plot_type==3?0:1;
      unsigned int okey = 0, obutton = 0;
      char message[1024] = { 0 };
      unsigned char I[9]; unsigned char& Ipp = I[0]; unsigned char& Icp = I[1]; unsigned char& Inp = I[2]; unsigned char& Ipc = I[3]; unsigned char& Icc = I[4]; unsigned char& Inc = I[5]; unsigned char& Ipn = I[6]; unsigned char& Icn = I[7]; unsigned char& Inn = I[8]; Ipp = Icp = Inp = Ipc = Icc = Inc = Ipn = Icn = Inn = 0;

      for (bool selected = false; !selected && !disp.is_closed() && !okey && !disp.wheel(); ) {
        const int mouse_x = disp.mouse_x(), mouse_y = disp.mouse_y();
        const unsigned int key = disp.key(), button = disp.button();


        if (!visu0) {
          visu0.assign(disp.width(),disp.height(),1,3,220);
          const int gdimx = disp.width() - 32, gdimy = disp.height() - 32;
          if (gdimx>0 && gdimy>0) {
            graph.assign(gdimx,gdimy,1,3,255);
            if (siz<32) {
              if (siz>1) graph.draw_grid(gdimx/(float)(siz - one),gdimy/(float)(siz - one),0,0,
                                         false,true,black,0.2f,0x33333333,0x33333333);
            } else graph.draw_grid(-10,-10,0,0,false,true,black,0.2f,0x33333333,0x33333333);
            for (int c = 0; c<(int)((*this)._spectrum); ++c)
              graph.draw_graph(get_shared_channel(c),&colormap(0,c),(plot_type!=3 || _spectrum==1)?1:0.6f,
                               plot_type,vertex_type,nymax,nymin);

            axes.assign(gdimx,gdimy,1,1,0);
            const float
              dx = (float)cimg::abs(nxmax-nxmin), dy = (float)cimg::abs(nymax-nymin),
              px = (float)std::pow(10.0,(int)std::log10(dx?dx:1)-2.0),
              py = (float)std::pow(10.0,(int)std::log10(dy?dy:1)-2.0);
            const CImg<Tdouble>
              seqx = dx<=0?CImg<Tdouble>::vector(nxmin):
                CImg<Tdouble>::sequence(1 + gdimx/60,nxmin,one?nxmax:nxmin+(nxmax-nxmin)*(siz+1)/siz).round(px),
              seqy = CImg<Tdouble>::sequence(1 + gdimy/60,nymax,nymin).round(py);

            const bool allow_zero = (nxmin*nxmax>0) || (nymin*nymax>0);
            axes.draw_axes(seqx,seqy,white,1,~0U,~0U,13,allow_zero);
            if (nymin>0) axes.draw_axis(seqx,gdimy-1,gray,1,~0U,13,allow_zero);
            if (nymax<0) axes.draw_axis(seqx,0,gray,1,~0U,13,allow_zero);
            if (nxmin>0) axes.draw_axis(0,seqy,gray,1,~0U,13,allow_zero);
            if (nxmax<0) axes.draw_axis(gdimx-1,seqy,gray,1,~0U,13,allow_zero);

            for (int y = 0, _p1y = 0, _n1y = 1>=((axes)._height)?(int)((axes)._height)-1:1; _n1y<(int)((axes)._height) || y==--_n1y; _p1y = y++, ++_n1y) for (int x = 0, _p1x = 0, _n1x = (int)( (I[0] = I[1] = (unsigned char)(axes)(_p1x,_p1y,0,0)), (I[3] = I[4] = (unsigned char)(axes)(0,y,0,0)), (I[6] = I[7] = (unsigned char)(axes)(0,_n1y,0,0)), 1>=(axes)._width?(axes).width()-1:1); (_n1x<(axes).width() && ( (I[2] = (unsigned char)(axes)(_n1x,_p1y,0,0)), (I[5] = (unsigned char)(axes)(_n1x,y,0,0)), (I[8] = (unsigned char)(axes)(_n1x,_n1y,0,0)),1)) || x==--_n1x; I[0] = I[1], I[1] = I[2], I[3] = I[4], I[4] = I[5], I[6] = I[7], I[7] = I[8], _p1x = x++, ++_n1x)
              if (Icc) {
                if (Icc==255) for (int c = 0; c<(int)((graph)._spectrum); ++c) graph(x,y,c) = 0;
                else for (int c = 0; c<(int)((graph)._spectrum); ++c) graph(x,y,c) = (unsigned char)(2*graph(x,y,c)/3);
              }
              else if (Ipc || Inc || Icp || Icn || Ipp || Inn || Ipn || Inp)
                for (int c = 0; c<(int)((graph)._spectrum); ++c) graph(x,y,c) = (graph(x,y,c)+511)/3;

            visu0.draw_image(16,16,graph);
            visu0.draw_line(15,15,16+gdimx,15,gray2).draw_line(16+gdimx,15,16+gdimx,16+gdimy,gray2).
              draw_line(16+gdimx,16+gdimy,15,16+gdimy,white).draw_line(15,16+gdimy,15,15,white);
          } else graph.assign();
          text.assign().draw_text(0,0,labelx?labelx:"X-axis",white,ngray,1,13).resize(-100,-100,1,3);
          visu0.draw_image((visu0.width()-text.width())/2,visu0.height()-14,~text);
          text.assign().draw_text(0,0,labely?labely:"Y-axis",white,ngray,1,13).rotate(-90).resize(-100,-100,1,3);
          visu0.draw_image(1,(visu0.height()-text.height())/2,~text);
          visu.assign();
        }


        if (!visu) {
          visu.assign(visu0);
          if (graph && x0>=0 && x1>=0) {
            const int
              nx0 = x0<=x1?x0:x1,
              nx1 = x0<=x1?x1:x0,
              ny0 = y0<=y1?y0:y1,
              ny1 = y0<=y1?y1:y0,
              sx0 = 16 + nx0*(visu.width()-32)/cimg::max(1U,siz-one),
              sx1 = 15 + (nx1+1)*(visu.width()-32)/cimg::max(1U,siz-one),
              sy0 = 16 + ny0,
              sy1 = 16 + ny1;
            if (y0>=0 && y1>=0)
              visu.draw_rectangle(sx0,sy0,sx1,sy1,gray,0.5f).draw_rectangle(sx0,sy0,sx1,sy1,black,0.5f,0xCCCCCCCCU);
            else visu.draw_rectangle(sx0,0,sx1,visu.height()-17,gray,0.5f).
                   draw_line(sx0,16,sx0,visu.height()-17,black,0.5f,0xCCCCCCCCU).
                   draw_line(sx1,16,sx1,visu.height()-17,black,0.5f,0xCCCCCCCCU);
          }
          if (mouse_x>=16 && mouse_y>=16 && mouse_x<visu.width()-16 && mouse_y<visu.height()-16) {
            if (graph) visu.draw_line(mouse_x,16,mouse_x,visu.height()-17,black,0.5f,0x55555555U);
            const unsigned int x = (unsigned int)cimg::round((mouse_x-16.0f)*(siz-one)/(disp.width()-32),1,one?0:-1);
            const double cx = nxmin + x*(nxmax-nxmin)/cimg::max(1U,siz-1);
            if (_spectrum>=7)
              snprintf(message,sizeof(message),"Value[%u:%g] = ( %g %g %g ... %g %g %g )",x,cx,
                            (double)(*this)(x,0,0,0),(double)(*this)(x,0,0,1),(double)(*this)(x,0,0,2),
                            (double)(*this)(x,0,0,_spectrum-4),(double)(*this)(x,0,0,_spectrum-3),
                            (double)(*this)(x,0,0,_spectrum-1));
            else {
              snprintf(message,sizeof(message),"Value[%u:%g] = ( ",x,cx);
              for (int c = 0; c<(int)((*this)._spectrum); ++c) std::sprintf(message + std::strlen(message),"%g ",(double)(*this)(x,0,0,c));
              std::sprintf(message + std::strlen(message),")");
            }
            if (x0>=0 && x1>=0) {
              const unsigned int
                nx0 = x0<=x1?x0:x1,
                nx1 = x0<=x1?x1:x0,
                ny0 = y0<=y1?y0:y1,
                ny1 = y0<=y1?y1:y0;
              const double
                cx0 = nxmin + nx0*(nxmax-nxmin)/cimg::max(1U,siz-1),
                cx1 = nxmin + (nx1+one)*(nxmax-nxmin)/cimg::max(1U,siz-1),
                cy0 = nymax - ny0*(nymax-nymin)/(visu._height-32),
                cy1 = nymax - ny1*(nymax-nymin)/(visu._height-32);
              if (y0>=0 && y1>=0)
                std::sprintf(message + std::strlen(message)," - Range ( %u:%g, %g ) - ( %u:%g, %g )",
                             x0,cx0,cy0,x1+one,cx1,cy1);
              else
                std::sprintf(message + std::strlen(message)," - Range [ %u:%g - %u:%g ]",
                             x0,cx0,x1+one,cx1);
            }
            text.assign().draw_text(0,0,message,white,ngray,1,13).resize(-100,-100,1,3);
            visu.draw_image((visu.width()-text.width())/2,1,~text);
          }
          visu.display(disp);
        }


        switch (okey = key) {

        case cimg::keyCTRLRIGHT : case cimg::keySHIFTRIGHT :

        case cimg::keyCTRLLEFT : case cimg::keySHIFTLEFT : okey = 0; break;
        case cimg::keyD : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
          disp.set_fullscreen(false).
            resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
                   CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
            _is_resized = true;
          disp.set_key(key,false); okey = 0;
        } break;
        case cimg::keyC : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
          disp.set_fullscreen(false).
            resize(CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,false), CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,true),false)._is_resized = true;
          disp.set_key(key,false); okey = 0;
        } break;
        case cimg::keyR : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).
              resize(CImgDisplay::_fitscreen(CImgDisplay::screen_width()/2,CImgDisplay::screen_height()/2,1,128,-85,false), CImgDisplay::_fitscreen(CImgDisplay::screen_width()/2,CImgDisplay::screen_height()/2,1,128,-85,true)
                                                                     ,false)._is_resized = true;
            disp.set_key(key,false); okey = 0;
          } break;
        case cimg::keyF : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.resize(disp.screen_width(),disp.screen_height(),false).toggle_fullscreen()._is_resized = true;
            disp.set_key(key,false); okey = 0;
          } break;
        case cimg::keyS : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            if (visu || visu0) {
              CImg<ucharT> &screen = visu?visu:visu0;
              char filename[32] = { 0 };
              std::FILE *file;
              do {
                snprintf(filename,sizeof(filename),"CImg" "_%.4u.bmp",snap_number++);
                if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
              } while (file);
              (+screen).draw_text(0,0," Saving snapshot... ",black,gray,1,13).display(disp);
              screen.save(filename);
              (+screen).draw_text(0,0," Snapshot '%s' saved. ",black,gray,1,13,filename).display(disp);
            }
            disp.set_key(key,false); okey = 0;
          } break;
        case cimg::keyO : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            if (visu || visu0) {
              CImg<ucharT> &screen = visu?visu:visu0;
              char filename[32] = { 0 };
              std::FILE *file;
              do {



                snprintf(filename,sizeof(filename),"CImg" "_%.4u.cimg",snap_number++);

                if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
              } while (file);
              (+screen).draw_text(0,0," Saving instance... ",black,gray,1,13).display(disp);
              save(filename);
              (+screen).draw_text(0,0," Instance '%s' saved. ",black,gray,1,13,filename).display(disp);
            }
            disp.set_key(key,false); okey = 0;
          } break;
        }


        if (obutton!=button || omouse_x!=mouse_x || omouse_y!=mouse_y) {
          visu.assign();
          if (disp.mouse_x()>=0 && disp.mouse_y()>=0) {
            const int
              mx = (mouse_x -16)*(int)(siz-one)/(disp.width()-32),
              cx = mx<0?0:(mx>=(int)(siz-one)?(int)(siz-1-one):mx),
              my = mouse_y - 16,
              cy = my<=0?0:(my>=(disp.height()-32)?(disp.height()-32):my);
            if (button&1) {
              if (!obutton) { x0 = cx; y0 = -1; } else { x1 = cx; y1 = -1; }
            }
            else if (button&2) {
              if (!obutton) { x0 = cx; y0 = cy; } else { x1 = cx; y1 = cy; }
            }
            else if (obutton) { x1 = x1>=0?cx:-1; y1 = y1>=0?cy:-1; selected = true; }
          } else if (!button && obutton) selected = true;
          obutton = button; omouse_x = mouse_x; omouse_y = mouse_y;
        }
        if (disp.is_resized()) { disp.resize(false); visu0.assign(); }
        if (visu && visu0) disp.wait();
      }

      disp._normalization = old_normalization;
      if (x1>=0 && x1<x0) cimg::swap(x0,x1);
      if (y1<y0) cimg::swap(y0,y1);
      disp.set_key(okey);
      return CImg<intT>(4,1,1,1,x0,y0,x1>=0?x1+(int)one:-1,y1);
    }







    CImg<T>& load(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      if (!cimg::strncasecmp(filename,"http://",7) || !cimg::strncasecmp(filename,"https://",8)) {
        char filename_local[1024] = { 0 };
        load(cimg::load_network_external(filename,filename_local));
        std::remove(filename_local);
        return *this;
      }

      const char *const ext = cimg::split_filename(filename);
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
# 37993 "../src/CImg.h"
        if (!cimg::strcasecmp(ext,"asc")) load_ascii(filename);
        else if (!cimg::strcasecmp(ext,"dlm") ||
                 !cimg::strcasecmp(ext,"txt")) load_dlm(filename);


        else if (!cimg::strcasecmp(ext,"bmp")) load_bmp(filename);
        else if (!cimg::strcasecmp(ext,"jpg") ||
                 !cimg::strcasecmp(ext,"jpeg") ||
                 !cimg::strcasecmp(ext,"jpe") ||
                 !cimg::strcasecmp(ext,"jfif") ||
                 !cimg::strcasecmp(ext,"jif")) load_jpeg(filename);
        else if (!cimg::strcasecmp(ext,"png")) load_png(filename);
        else if (!cimg::strcasecmp(ext,"ppm") ||
                 !cimg::strcasecmp(ext,"pgm") ||
                 !cimg::strcasecmp(ext,"pnm") ||
                 !cimg::strcasecmp(ext,"pbm") ||
                 !cimg::strcasecmp(ext,"pnk")) load_pnm(filename);
        else if (!cimg::strcasecmp(ext,"pfm")) load_pfm(filename);
        else if (!cimg::strcasecmp(ext,"tif") ||
                 !cimg::strcasecmp(ext,"tiff")) load_tiff(filename);
        else if (!cimg::strcasecmp(ext,"exr")) load_exr(filename);
        else if (!cimg::strcasecmp(ext,"cr2") ||
                 !cimg::strcasecmp(ext,"crw") ||
                 !cimg::strcasecmp(ext,"dcr") ||
                 !cimg::strcasecmp(ext,"mrw") ||
                 !cimg::strcasecmp(ext,"nef") ||
                 !cimg::strcasecmp(ext,"orf") ||
                 !cimg::strcasecmp(ext,"pix") ||
                 !cimg::strcasecmp(ext,"ptx") ||
                 !cimg::strcasecmp(ext,"raf") ||
                 !cimg::strcasecmp(ext,"srf")) load_dcraw_external(filename);
        else if (!cimg::strcasecmp(ext,"gif")) load_gif_external(filename);


        else if (!cimg::strcasecmp(ext,"dcm") ||
                 !cimg::strcasecmp(ext,"dicom")) load_medcon_external(filename);
        else if (!cimg::strcasecmp(ext,"hdr") ||
                 !cimg::strcasecmp(ext,"nii")) load_analyze(filename);
        else if (!cimg::strcasecmp(ext,"par") ||
                 !cimg::strcasecmp(ext,"rec")) load_parrec(filename);
        else if (!cimg::strcasecmp(ext,"mnc")) load_minc2(filename);
        else if (!cimg::strcasecmp(ext,"inr")) load_inr(filename);
        else if (!cimg::strcasecmp(ext,"pan")) load_pandore(filename);
        else if (!cimg::strcasecmp(ext,"cimg") ||
                 !cimg::strcasecmp(ext,"cimgz") ||
                 !*ext) return load_cimg(filename);


        else if (!cimg::strcasecmp(ext,"gz")) load_gzip_external(filename);


        else if (!cimg::strcasecmp(ext,"avi") ||
                 !cimg::strcasecmp(ext,"mov") ||
                 !cimg::strcasecmp(ext,"asf") ||
                 !cimg::strcasecmp(ext,"divx") ||
                 !cimg::strcasecmp(ext,"flv") ||
                 !cimg::strcasecmp(ext,"mpg") ||
                 !cimg::strcasecmp(ext,"m1v") ||
                 !cimg::strcasecmp(ext,"m2v") ||
                 !cimg::strcasecmp(ext,"m4v") ||
                 !cimg::strcasecmp(ext,"mjp") ||
                 !cimg::strcasecmp(ext,"mp4") ||
                 !cimg::strcasecmp(ext,"mkv") ||
                 !cimg::strcasecmp(ext,"mpe") ||
                 !cimg::strcasecmp(ext,"movie") ||
                 !cimg::strcasecmp(ext,"ogm") ||
                 !cimg::strcasecmp(ext,"ogg") ||
                 !cimg::strcasecmp(ext,"ogv") ||
                 !cimg::strcasecmp(ext,"qt") ||
                 !cimg::strcasecmp(ext,"rm") ||
                 !cimg::strcasecmp(ext,"vob") ||
                 !cimg::strcasecmp(ext,"wmv") ||
                 !cimg::strcasecmp(ext,"xvid") ||
                 !cimg::strcasecmp(ext,"mpeg")) load_ffmpeg(filename);
        else throw CImgIOException("CImg<%s>::load()",
                                   pixel_type());
      } catch (CImgIOException&) {
        std::FILE *file = 0;
        try {
          file = cimg::fopen(filename,"rb");
        } catch (CImgIOException&) {
          cimg::exception_mode() = omode;
          throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                "load(): Failed to open file '%s'.",
                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                filename);
        }

        try {
          const char *const f_type = cimg::file_type(file,filename);
          std::fclose(file);
          if (!cimg::strcasecmp(f_type,"pnm")) load_pnm(filename);
          else if (!cimg::strcasecmp(f_type,"pfm")) load_pfm(filename);
          else if (!cimg::strcasecmp(f_type,"bmp")) load_bmp(filename);
          else if (!cimg::strcasecmp(f_type,"jpg")) load_jpeg(filename);
          else if (!cimg::strcasecmp(f_type,"pan")) load_pandore(filename);
          else if (!cimg::strcasecmp(f_type,"png")) load_png(filename);
          else if (!cimg::strcasecmp(f_type,"tif")) load_tiff(filename);
          else if (!cimg::strcasecmp(f_type,"inr")) load_inr(filename);
          else if (!cimg::strcasecmp(f_type,"dcm")) load_medcon_external(filename);
          else throw CImgIOException("CImg<%s>::load()",
                                     pixel_type());
        } catch (CImgIOException&) {
          try {
            load_other(filename);
          } catch (CImgIOException&) {
            cimg::exception_mode() = omode;
            throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                  "load(): Failed to recognize format of file '%s'.",
                                  _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                  filename);
          }
        }
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    static CImg<T> get_load(const char *const filename) {
      return CImg<T>().load(filename);
    }





    CImg<T>& load_ascii(const char *const filename) {
      return _load_ascii(0,filename);
    }


    static CImg<T> get_load_ascii(const char *const filename) {
      return CImg<T>().load_ascii(filename);
    }


    CImg<T>& load_ascii(std::FILE *const file) {
      return _load_ascii(file,0);
    }


    static CImg<T> get_load_ascii(std::FILE *const file) {
      return CImg<T>().load_ascii(file);
    }

    CImg<T>& _load_ascii(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_ascii(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      char line[256] = { 0 };
      int err = std::fscanf(nfile,"%255[^\n]",line);
      unsigned int dx = 0, dy = 1, dz = 1, dc = 1;
      std::sscanf(line,"%u%*c%u%*c%u%*c%u",&dx,&dy,&dz,&dc);
      err = std::fscanf(nfile,"%*[^0-9.eE+-]");
      if (!dx || !dy || !dz || !dc) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_ascii(): Invalid ascii header in file '%s', image dimensions are set "
                              "to (%u,%u,%u,%u).",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)",dx,dy,dz,dc);
      }
      assign(dx,dy,dz,dc);
      const unsigned long siz = size();
      unsigned long off = 0;
      double val;
      T *ptr = _data;
      for (err = 1, off = 0; off<siz && err==1; ++off) {
        err = std::fscanf(nfile,"%lf%*[^0-9.eE+-]",&val);
        *(ptr++) = (T)val;
      }
      if (err!=1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "load_ascii(): Only %lu/%lu values read from file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   off-1,siz,filename?filename:"(FILE*)");

      if (!file) cimg::fclose(nfile);
      return *this;
    }





    CImg<T>& load_dlm(const char *const filename) {
      return _load_dlm(0,filename);
    }


    static CImg<T> get_load_dlm(const char *const filename) {
      return CImg<T>().load_dlm(filename);
    }


    CImg<T>& load_dlm(std::FILE *const file) {
      return _load_dlm(file,0);
    }


    static CImg<T> get_load_dlm(std::FILE *const file) {
      return CImg<T>().load_dlm(file);
    }

    CImg<T>& _load_dlm(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_dlm(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *const nfile = file?file:cimg::fopen(filename,"r");
      char delimiter[256] = { 0 }, tmp[256] = { 0 };
      unsigned int cdx = 0, dx = 0, dy = 0;
      int err = 0;
      double val;
      assign(256,256);
      while ((err = std::fscanf(nfile,"%lf%255[^0-9.+-]",&val,delimiter))>0) {
        if (err>0) (*this)(cdx++,dy) = (T)val;
        if (cdx>=_width) resize(3*_width/2,_height,1,1,0);
        char c = 0;
        if (!std::sscanf(delimiter,"%255[^\n]%c",tmp,&c) || c=='\n') {
          dx = cimg::max(cdx,dx);
          if (++dy>=_height) resize(_width,3*_height/2,1,1,0);
          cdx = 0;
        }
      }
      if (cdx && err==1) { dx = cdx; ++dy; }
      if (!dx || !dy) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_dlm(): Invalid DLM file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }
      resize(dx,dy,1,1,0);
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    CImg<T>& load_bmp(const char *const filename) {
      return _load_bmp(0,filename);
    }


    static CImg<T> get_load_bmp(const char *const filename) {
      return CImg<T>().load_bmp(filename);
    }


    CImg<T>& load_bmp(std::FILE *const file) {
      return _load_bmp(file,0);
    }


    static CImg<T> get_load_bmp(std::FILE *const file) {
      return CImg<T>().load_bmp(file);
    }

    CImg<T>& _load_bmp(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_bmp(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      unsigned char header[64] = { 0 };
      cimg::fread(header,54,nfile);
      if (*header!='B' || header[1]!='M') {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_bmp(): Invalid BMP file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }


      int
        file_size = header[0x02] + (header[0x03]<<8) + (header[0x04]<<16) + (header[0x05]<<24),
        offset = header[0x0A] + (header[0x0B]<<8) + (header[0x0C]<<16) + (header[0x0D]<<24),
        header_size = header[0x0E] + (header[0x0F]<<8) + (header[0x10]<<16) + (header[0x11]<<24),
        dx = header[0x12] + (header[0x13]<<8) + (header[0x14]<<16) + (header[0x15]<<24),
        dy = header[0x16] + (header[0x17]<<8) + (header[0x18]<<16) + (header[0x19]<<24),
        compression = header[0x1E] + (header[0x1F]<<8) + (header[0x20]<<16) + (header[0x21]<<24),
        nb_colors = header[0x2E] + (header[0x2F]<<8) + (header[0x30]<<16) + (header[0x31]<<24),
        bpp = header[0x1C] + (header[0x1D]<<8);

      if (!file_size || file_size==offset) {
        std::fseek(nfile,0,2);
        file_size = (int)std::ftell(nfile);
        std::fseek(nfile,54,0);
      }
      if (header_size>40) std::fseek(nfile, header_size - 40, 1);

      const int
        cimg_iobuffer = 12*1024*1024,
        dx_bytes = (bpp==1)?(dx/8+(dx%8?1:0)):((bpp==4)?(dx/2+(dx%2?1:0)):(dx*bpp/8)),
        align_bytes = (4-dx_bytes%4)%4,
        buf_size = cimg::min(cimg::abs(dy)*(dx_bytes + align_bytes),file_size - offset);

      CImg<intT> colormap;
      if (bpp<16) { if (!nb_colors) nb_colors = 1<<bpp; } else nb_colors = 0;
      if (nb_colors) { colormap.assign(nb_colors); cimg::fread(colormap._data,nb_colors,nfile); }
      const int xoffset = offset - 14 - header_size - 4*nb_colors;
      if (xoffset>0) std::fseek(nfile,xoffset,1);

      CImg<ucharT> buffer;
      if (buf_size<cimg_iobuffer) { buffer.assign(buf_size); cimg::fread(buffer._data,buf_size,nfile); }
      else buffer.assign(dx_bytes + align_bytes);
      unsigned char *ptrs = buffer;


      if (compression) {
        if (file)
          throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                "load_bmp(): Unable to load compressed data from '(*FILE)' inputs.",
                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
        else {
          if (!file) cimg::fclose(nfile);
          return load_other(filename);
        }
      }


      assign(dx,cimg::abs(dy),1,3);
      switch (bpp) {
      case 1 : {
        for (int y = height()-1; y>=0; --y) {
          if (buf_size>=cimg_iobuffer) {
            cimg::fread(ptrs=buffer._data,dx_bytes,nfile);
            std::fseek(nfile,align_bytes,1);
          }
          unsigned char mask = 0x80, val = 0;
          for (int x = 0; x<(int)((*this)._width); ++x) {
            if (mask==0x80) val = *(ptrs++);
            const unsigned char *col = (unsigned char*)(colormap._data + (val&mask?1:0));
            (*this)(x,y,2) = (T)*(col++);
            (*this)(x,y,1) = (T)*(col++);
            (*this)(x,y,0) = (T)*(col++);
            mask = cimg::ror(mask);
          }
          ptrs+=align_bytes;
        }
      } break;
      case 4 : {
        for (int y = height()-1; y>=0; --y) {
          if (buf_size>=cimg_iobuffer) {
            cimg::fread(ptrs=buffer._data,dx_bytes,nfile);
            std::fseek(nfile,align_bytes,1);
          }
          unsigned char mask = 0xF0, val = 0;
          for (int x = 0; x<(int)((*this)._width); ++x) {
            if (mask==0xF0) val = *(ptrs++);
            const unsigned char color = (unsigned char)((mask<16)?(val&mask):((val&mask)>>4));
            const unsigned char *col = (unsigned char*)(colormap._data + color);
            (*this)(x,y,2) = (T)*(col++);
            (*this)(x,y,1) = (T)*(col++);
            (*this)(x,y,0) = (T)*(col++);
            mask = cimg::ror(mask,4);
          }
          ptrs+=align_bytes;
        }
      } break;
      case 8 : {
        for (int y = height()-1; y>=0; --y) {
          if (buf_size>=cimg_iobuffer) {
            cimg::fread(ptrs=buffer._data,dx_bytes,nfile);
            std::fseek(nfile,align_bytes,1);
          }
          for (int x = 0; x<(int)((*this)._width); ++x) {
            const unsigned char *col = (unsigned char*)(colormap._data + *(ptrs++));
            (*this)(x,y,2) = (T)*(col++);
            (*this)(x,y,1) = (T)*(col++);
            (*this)(x,y,0) = (T)*(col++);
          }
          ptrs+=align_bytes;
        }
      } break;
      case 16 : {
        for (int y = height()-1; y>=0; --y) {
          if (buf_size>=cimg_iobuffer) {
            cimg::fread(ptrs=buffer._data,dx_bytes,nfile);
            std::fseek(nfile,align_bytes,1);
          }
          for (int x = 0; x<(int)((*this)._width); ++x) {
            const unsigned char c1 = *(ptrs++), c2 = *(ptrs++);
            const unsigned short col = (unsigned short)(c1|(c2<<8));
            (*this)(x,y,2) = (T)(col&0x1F);
            (*this)(x,y,1) = (T)((col>>5)&0x1F);
            (*this)(x,y,0) = (T)((col>>10)&0x1F);
          }
          ptrs+=align_bytes;
        }
      } break;
      case 24 : {
        for (int y = height()-1; y>=0; --y) {
          if (buf_size>=cimg_iobuffer) {
            cimg::fread(ptrs=buffer._data,dx_bytes,nfile);
            std::fseek(nfile,align_bytes,1);
          }
          for (int x = 0; x<(int)((*this)._width); ++x) {
            (*this)(x,y,2) = (T)*(ptrs++);
            (*this)(x,y,1) = (T)*(ptrs++);
            (*this)(x,y,0) = (T)*(ptrs++);
          }
          ptrs+=align_bytes;
        }
      } break;
      case 32 : {
        for (int y = height()-1; y>=0; --y) {
          if (buf_size>=cimg_iobuffer) {
            cimg::fread(ptrs=buffer._data,dx_bytes,nfile);
            std::fseek(nfile,align_bytes,1);
          }
          for (int x = 0; x<(int)((*this)._width); ++x) {
            (*this)(x,y,2) = (T)*(ptrs++);
            (*this)(x,y,1) = (T)*(ptrs++);
            (*this)(x,y,0) = (T)*(ptrs++);
            ++ptrs;
          }
          ptrs+=align_bytes;
        }
      } break;
      }
      if (dy<0) mirror('y');
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    CImg<T>& load_jpeg(const char *const filename) {
      return _load_jpeg(0,filename);
    }


    static CImg<T> get_load_jpeg(const char *const filename) {
      return CImg<T>().load_jpeg(filename);
    }


    CImg<T>& load_jpeg(std::FILE *const file) {
      return _load_jpeg(file,0);
    }


    static CImg<T> get_load_jpeg(std::FILE *const file) {
      return CImg<T>().load_jpeg(file);
    }
# 38470 "../src/CImg.h"
    CImg<T>& _load_jpeg(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_jpeg(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());


      if (file)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_jpeg(): Unable to load data from '(FILE*)' unless libjpeg is enabled.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      else return load_other(filename);
# 38550 "../src/CImg.h"
    }







    CImg<T>& load_magick(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_magick(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
# 38615 "../src/CImg.h"
      throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                            "load_magick(): Unable to load file '%s' unless libMagick++ is enabled.",
                            _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                            filename);

    }


    static CImg<T> get_load_magick(const char *const filename) {
      return CImg<T>().load_magick(filename);
    }





    CImg<T>& load_png(const char *const filename) {
      return _load_png(0,filename);
    }


    static CImg<T> get_load_png(const char *const filename) {
      return CImg<T>().load_png(filename);
    }


    CImg<T>& load_png(std::FILE *const file) {
      return _load_png(file,0);
    }


    static CImg<T> get_load_png(std::FILE *const file) {
      return CImg<T>().load_png(file);
    }


    CImg<T>& _load_png(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_png(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());


      if (file)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_png(): Unable to load data from '(FILE*)' unless libpng is enabled.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      else return load_other(filename);
# 38817 "../src/CImg.h"
    }





    CImg<T>& load_pnm(const char *const filename) {
      return _load_pnm(0,filename);
    }


    static CImg<T> get_load_pnm(const char *const filename) {
      return CImg<T>().load_pnm(filename);
    }


    CImg<T>& load_pnm(std::FILE *const file) {
      return _load_pnm(file,0);
    }


    static CImg<T> get_load_pnm(std::FILE *const file) {
      return CImg<T>().load_pnm(file);
    }

    CImg<T>& _load_pnm(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_pnm(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      unsigned int ppm_type, W, H, D = 1, colormax = 255;
      CImg<charT> item(16384,1,1,1,0);
      int err, rval, gval, bval;
      const long cimg_iobuffer = 12*1024*1024;
      while ((err=std::fscanf(nfile,"%16383[^\n]",item.data()))!=(-1) && (*item=='#' || !err)) std::fgetc(nfile);
      if (std::sscanf(item," P%u",&ppm_type)!=1) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_pnm(): PNM header not found in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }
      while ((err=std::fscanf(nfile," %16383[^\n]",item.data()))!=(-1) && (*item=='#' || !err)) std::fgetc(nfile);
      if ((err=std::sscanf(item," %u %u %u %u",&W,&H,&D,&colormax))<2) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_pnm(): WIDTH and HEIGHT fields undefined in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }
      if (ppm_type!=1 && ppm_type!=4) {
        if (err==2 || (err==3 && (ppm_type==5 || ppm_type==7 || ppm_type==8 || ppm_type==9))) {
          while ((err=std::fscanf(nfile," %16383[^\n]",item.data()))!=(-1) && (*item=='#' || !err)) std::fgetc(nfile);
          if (std::sscanf(item,"%u",&colormax)!=1)
            cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                       "load_pnm(): COLORMAX field is undefined in file '%s'.",
                       _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                       filename?filename:"(FILE*)");
        } else { colormax = D; D = 1; }
      }
      std::fgetc(nfile);

      switch (ppm_type) {
      case 1 : {
        assign(W,H,1,1);
        T* ptrd = _data;
        for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) { if (std::fscanf(nfile,"%d",&rval)>0) *(ptrd++) = (T)(rval?0:255); else break; }
      } break;
      case 2 : {
        assign(W,H,1,1);
        T* ptrd = _data;
        for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) { if (std::fscanf(nfile,"%d",&rval)>0) *(ptrd++) = (T)rval; else break; }
      } break;
      case 3 : {
        assign(W,H,1,3);
        T *ptrd = data(0,0,0,0), *ptr_g = data(0,0,0,1), *ptr_b = data(0,0,0,2);
        for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          if (std::fscanf(nfile,"%d %d %d",&rval,&gval,&bval)==3) {
            *(ptrd++) = (T)rval; *(ptr_g++) = (T)gval; *(ptr_b++) = (T)bval;
          } else break;
        }
      } break;
      case 4 : {
        CImg<ucharT> raw;
        assign(W,H,D,1);
        T *ptrd = data(0,0,0,0);
        unsigned int w = 0, h = 0, d = 0;
        for (long to_read = (long)((W/8 + (W%8?1:0))*H*D); to_read>0; ) {
          raw.assign(cimg::min(to_read,cimg_iobuffer));
          cimg::fread(raw._data,raw._width,nfile);
          to_read-=raw._width;
          const unsigned char *ptrs = raw._data;
          unsigned char mask = 0, val = 0;
          for (unsigned long off = (unsigned long)raw._width; off || mask; mask>>=1) {
            if (!mask) { if (off--) val = *(ptrs++); mask = 128; }
            *(ptrd++) = (T)((val&mask)?0:255);
            if (++w==W) { w = 0; mask = 0; if (++h==H) { h = 0; if (++d==D) break; }}
          }
        }
      } break;
      case 5 : case 7 : {
        if (colormax<256) {
          CImg<ucharT> raw;
          assign(W,H,D,1);
          T *ptrd = data(0,0,0,0);
          for (long to_read = (long)size(); to_read>0; ) {
            raw.assign(cimg::min(to_read,cimg_iobuffer));
            cimg::fread(raw._data,raw._width,nfile);
            to_read-=raw._width;
            const unsigned char *ptrs = raw._data;
            for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
          }
        } else {
          CImg<ushortT> raw;
          assign(W,H,D,1);
          T *ptrd = data(0,0,0,0);
          for (long to_read = (long)size(); to_read>0; ) {
            raw.assign(cimg::min(to_read,cimg_iobuffer/2));
            cimg::fread(raw._data,raw._width,nfile);
            if (!cimg::endianness()) cimg::invert_endianness(raw._data,raw._width);
            to_read-=raw._width;
            const unsigned short *ptrs = raw._data;
            for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
          }
        }
      } break;
      case 6 : {
        if (colormax<256) {
          CImg<ucharT> raw;
          assign(W,H,1,3);
          T
            *ptr_r = data(0,0,0,0),
            *ptr_g = data(0,0,0,1),
            *ptr_b = data(0,0,0,2);
          for (long to_read = (long)size(); to_read>0; ) {
            raw.assign(cimg::min(to_read,cimg_iobuffer));
            cimg::fread(raw._data,raw._width,nfile);
            to_read-=raw._width;
            const unsigned char *ptrs = raw._data;
            for (unsigned long off = (unsigned long)raw._width/3; off; --off) {
              *(ptr_r++) = (T)*(ptrs++);
              *(ptr_g++) = (T)*(ptrs++);
              *(ptr_b++) = (T)*(ptrs++);
            }
          }
        } else {
          CImg<ushortT> raw;
          assign(W,H,1,3);
          T
            *ptr_r = data(0,0,0,0),
            *ptr_g = data(0,0,0,1),
            *ptr_b = data(0,0,0,2);
          for (long to_read = (int)size(); to_read>0; ) {
            raw.assign(cimg::min(to_read,cimg_iobuffer/2));
            cimg::fread(raw._data,raw._width,nfile);
            if (!cimg::endianness()) cimg::invert_endianness(raw._data,raw._width);
            to_read-=raw._width;
            const unsigned short *ptrs = raw._data;
            for (unsigned long off = (unsigned long)raw._width/3; off; --off) {
              *(ptr_r++) = (T)*(ptrs++);
              *(ptr_g++) = (T)*(ptrs++);
              *(ptr_b++) = (T)*(ptrs++);
            }
          }
        }
      } break;
      case 8 : {
        CImg<intT> raw;
        assign(W,H,D,1);
        T *ptrd = data(0,0,0,0);
        for (long to_read = (long)size(); to_read>0; ) {
          raw.assign(cimg::min(to_read,cimg_iobuffer));
          cimg::fread(raw._data,raw._width,nfile);
          to_read-=raw._width;
          const int *ptrs = raw._data;
          for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
        }
      } break;
      case 9 : {
        CImg<floatT> raw;
        assign(W,H,D,1);
        T *ptrd = data(0,0,0,0);
        for (long to_read = (long)size(); to_read>0; ) {
          raw.assign(cimg::min(to_read,cimg_iobuffer));
          cimg::fread(raw._data,raw._width,nfile);
          to_read-=raw._width;
          const float *ptrs = raw._data;
          for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
        }
      } break;
      default :
        assign();
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_pnm(): PNM type 'P%d' found, but type is not supported.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)",ppm_type);
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    CImg<T>& load_pfm(const char *const filename) {
      return _load_pfm(0,filename);
    }


    static CImg<T> get_load_pfm(const char *const filename) {
      return CImg<T>().load_pfm(filename);
    }


    CImg<T>& load_pfm(std::FILE *const file) {
      return _load_pfm(file,0);
    }


    static CImg<T> get_load_pfm(std::FILE *const file) {
      return CImg<T>().load_pfm(file);
    }

    CImg<T>& _load_pfm(std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_pfm(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      char pfm_type;
      CImg<charT> item(16384,1,1,1,0);
      int W = 0, H = 0, err = 0;
      double scale = 0;
      while ((err=std::fscanf(nfile,"%16383[^\n]",item.data()))!=(-1) && (*item=='#' || !err)) std::fgetc(nfile);
      if (std::sscanf(item," P%c",&pfm_type)!=1) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_pfm(): PFM header not found in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }
      while ((err=std::fscanf(nfile," %16383[^\n]",item.data()))!=(-1) && (*item=='#' || !err)) std::fgetc(nfile);
      if ((err=std::sscanf(item," %d %d",&W,&H))<2) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_pfm(): WIDTH and HEIGHT fields are undefined in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }
      if (err==2) {
        while ((err=std::fscanf(nfile," %16383[^\n]",item.data()))!=(-1) && (*item=='#' || !err)) std::fgetc(nfile);
        if (std::sscanf(item,"%lf",&scale)!=1)
          cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                     "load_pfm(): SCALE field is undefined in file '%s'.",
                     _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                     filename?filename:"(FILE*)");
      }
      std::fgetc(nfile);
      const bool is_color = (pfm_type=='F'), is_inverted = (scale>0)!=cimg::endianness();
      if (is_color) {
        assign(W,H,1,3,0);
        CImg<floatT> buf(3*W);
        T *ptr_r = data(0,0,0,0), *ptr_g = data(0,0,0,1), *ptr_b = data(0,0,0,2);
        for (int y = 0; y<(int)((*this)._height); ++y) {
          cimg::fread(buf._data,3*W,nfile);
          if (is_inverted) cimg::invert_endianness(buf._data,3*W);
          const float *ptrs = buf._data;
          for (int x = 0; x<(int)((*this)._width); ++x) {
            *(ptr_r++) = (T)*(ptrs++);
            *(ptr_g++) = (T)*(ptrs++);
            *(ptr_b++) = (T)*(ptrs++);
          }
        }
      } else {
        assign(W,H,1,1,0);
        CImg<floatT> buf(W);
        T *ptrd = data(0,0,0,0);
        for (int y = 0; y<(int)((*this)._height); ++y) {
          cimg::fread(buf._data,W,nfile);
          if (is_inverted) cimg::invert_endianness(buf._data,W);
          const float *ptrs = buf._data;
          for (int x = 0; x<(int)((*this)._width); ++x) *(ptrd++) = (T)*(ptrs++);
        }
      }
      if (!file) cimg::fclose(nfile);
      return mirror('y');
    }







    CImg<T>& load_rgb(const char *const filename, const unsigned int dimw, const unsigned int dimh=1) {
      return _load_rgb(0,filename,dimw,dimh);
    }


    static CImg<T> get_load_rgb(const char *const filename, const unsigned int dimw, const unsigned int dimh=1) {
      return CImg<T>().load_rgb(filename,dimw,dimh);
    }


    CImg<T>& load_rgb(std::FILE *const file, const unsigned int dimw, const unsigned int dimh=1) {
      return _load_rgb(file,0,dimw,dimh);
    }


    static CImg<T> get_load_rgb(std::FILE *const file, const unsigned int dimw, const unsigned int dimh=1) {
      return CImg<T>().load_rgb(file,dimw,dimh);
    }

    CImg<T>& _load_rgb(std::FILE *const file, const char *const filename,
                       const unsigned int dimw, const unsigned int dimh) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_rgb(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      if (!dimw || !dimh) return assign();
      const long cimg_iobuffer = 12*1024*1024;
      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      CImg<ucharT> raw;
      assign(dimw,dimh,1,3);
      T
        *ptr_r = data(0,0,0,0),
        *ptr_g = data(0,0,0,1),
        *ptr_b = data(0,0,0,2);
      for (long to_read = (long)size(); to_read>0; ) {
        raw.assign(cimg::min(to_read,cimg_iobuffer));
        cimg::fread(raw._data,raw._width,nfile);
        to_read-=raw._width;
        const unsigned char *ptrs = raw._data;
        for (unsigned long off = raw._width/3UL; off; --off) {
          *(ptr_r++) = (T)*(ptrs++);
          *(ptr_g++) = (T)*(ptrs++);
          *(ptr_b++) = (T)*(ptrs++);
        }
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }







    CImg<T>& load_rgba(const char *const filename, const unsigned int dimw, const unsigned int dimh=1) {
      return _load_rgba(0,filename,dimw,dimh);
    }


    static CImg<T> get_load_rgba(const char *const filename, const unsigned int dimw, const unsigned int dimh=1) {
      return CImg<T>().load_rgba(filename,dimw,dimh);
    }


    CImg<T>& load_rgba(std::FILE *const file, const unsigned int dimw, const unsigned int dimh=1) {
      return _load_rgba(file,0,dimw,dimh);
    }


    static CImg<T> get_load_rgba(std::FILE *const file, const unsigned int dimw, const unsigned int dimh=1) {
      return CImg<T>().load_rgba(file,dimw,dimh);
    }

    CImg<T>& _load_rgba(std::FILE *const file, const char *const filename,
                        const unsigned int dimw, const unsigned int dimh) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_rgba(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      if (!dimw || !dimh) return assign();
      const long cimg_iobuffer = 12*1024*1024;
      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      CImg<ucharT> raw;
      assign(dimw,dimh,1,4);
      T
        *ptr_r = data(0,0,0,0),
        *ptr_g = data(0,0,0,1),
        *ptr_b = data(0,0,0,2),
        *ptr_a = data(0,0,0,3);
      for (long to_read = (long)size(); to_read>0; ) {
        raw.assign(cimg::min(to_read,cimg_iobuffer));
        cimg::fread(raw._data,raw._width,nfile);
        to_read-=raw._width;
        const unsigned char *ptrs = raw._data;
        for (unsigned long off = raw._width/4UL; off; --off) {
          *(ptr_r++) = (T)*(ptrs++);
          *(ptr_g++) = (T)*(ptrs++);
          *(ptr_b++) = (T)*(ptrs++);
          *(ptr_a++) = (T)*(ptrs++);
        }
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }
# 39239 "../src/CImg.h"
    CImg<T>& load_tiff(const char *const filename,
                       const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                       const unsigned int step_frame=1,
                       float *const voxel_size=0,
                       CImg<charT> *const description=0) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_tiff(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const unsigned int
        nfirst_frame = first_frame<last_frame?first_frame:last_frame,
        nstep_frame = step_frame?step_frame:1;
      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;


      cimg::unused(voxel_size,description);
      if (nfirst_frame || nlast_frame!=~0U || nstep_frame>1)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_tiff(): Unable to read sub-images from file '%s' unless libtiff is enabled.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    filename);
      return load_other(filename);
# 39294 "../src/CImg.h"
    }


    static CImg<T> get_load_tiff(const char *const filename,
                                 const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                 const unsigned int step_frame=1,
                                 float *const voxel_size=0,
                                 CImg<charT> *const description=0) {
      return CImg<T>().load_tiff(filename,first_frame,last_frame,step_frame,voxel_size,description);
    }
# 39563 "../src/CImg.h"
    CImg<T>& load_minc2(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_minc2(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      return load_other(filename);
# 39588 "../src/CImg.h"
    }


    static CImg<T> get_load_minc2(const char *const filename) {
      return CImg<T>().load_analyze(filename);
    }






    CImg<T>& load_analyze(const char *const filename, float *const voxel_size=0) {
      return _load_analyze(0,filename,voxel_size);
    }


    static CImg<T> get_load_analyze(const char *const filename, float *const voxel_size=0) {
      return CImg<T>().load_analyze(filename,voxel_size);
    }


    CImg<T>& load_analyze(std::FILE *const file, float *const voxel_size=0) {
      return _load_analyze(file,0,voxel_size);
    }


    static CImg<T> get_load_analyze(std::FILE *const file, float *const voxel_size=0) {
      return CImg<T>().load_analyze(file,voxel_size);
    }

    CImg<T>& _load_analyze(std::FILE *const file, const char *const filename, float *const voxel_size=0) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_analyze(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *nfile_header = 0, *nfile = 0;
      if (!file) {
        char body[1024] = { 0 };
        const char *const ext = cimg::split_filename(filename,body);
        if (!cimg::strcasecmp(ext,"hdr")) {
          nfile_header = cimg::fopen(filename,"rb");
          std::sprintf(body + std::strlen(body),".img");
          nfile = cimg::fopen(body,"rb");
        } else if (!cimg::strcasecmp(ext,"img")) {
          nfile = cimg::fopen(filename,"rb");
          std::sprintf(body + std::strlen(body),".hdr");
          nfile_header = cimg::fopen(body,"rb");
        } else nfile_header = nfile = cimg::fopen(filename,"rb");
      } else nfile_header = nfile = file;
      if (!nfile || !nfile_header)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_analyze(): Invalid Analyze7.5 or NIFTI header in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");


      bool endian = false;
      unsigned int header_size;
      cimg::fread(&header_size,1,nfile_header);
      if (!header_size)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_analyze(): Invalid zero-sized header in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");

      if (header_size>=4096) { endian = true; cimg::invert_endianness(header_size); }
      unsigned char *const header = new unsigned char[header_size];
      cimg::fread(header+4,header_size-4,nfile_header);
      if (!file && nfile_header!=nfile) cimg::fclose(nfile_header);
      if (endian) {
        cimg::invert_endianness((short*)(header+40),5);
        cimg::invert_endianness((short*)(header+70),1);
        cimg::invert_endianness((short*)(header+72),1);
        cimg::invert_endianness((float*)(header+76),4);
        cimg::invert_endianness((float*)(header+112),1);
      }
      unsigned short *dim = (unsigned short*)(header+40), dimx = 1, dimy = 1, dimz = 1, dimv = 1;
      if (!dim[0])
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "load_analyze(): File '%s' defines an image with zero dimensions.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");

      if (dim[0]>4)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "load_analyze(): File '%s' defines an image with %u dimensions, reading only the 4 first.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)",dim[0]);

      if (dim[0]>=1) dimx = dim[1];
      if (dim[0]>=2) dimy = dim[2];
      if (dim[0]>=3) dimz = dim[3];
      if (dim[0]>=4) dimv = dim[4];
      float scalefactor = *(float*)(header+112); if (scalefactor==0) scalefactor=1;
      const unsigned short datatype = *(short*)(header+70);
      if (voxel_size) {
        const float *vsize = (float*)(header+76);
        voxel_size[0] = vsize[1]; voxel_size[1] = vsize[2]; voxel_size[2] = vsize[3];
      }
      delete[] header;


      assign(dimx,dimy,dimz,dimv);
      switch (datatype) {
      case 2 : {
        unsigned char *const buffer = new unsigned char[dimx*dimy*dimz*dimv];
        cimg::fread(buffer,dimx*dimy*dimz*dimv,nfile);
        for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) _data[off] = (T)(buffer[off]*scalefactor);
        delete[] buffer;
      } break;
      case 4 : {
        short *const buffer = new short[dimx*dimy*dimz*dimv];
        cimg::fread(buffer,dimx*dimy*dimz*dimv,nfile);
        if (endian) cimg::invert_endianness(buffer,dimx*dimy*dimz*dimv);
        for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) _data[off] = (T)(buffer[off]*scalefactor);
        delete[] buffer;
      } break;
      case 8 : {
        int *const buffer = new int[dimx*dimy*dimz*dimv];
        cimg::fread(buffer,dimx*dimy*dimz*dimv,nfile);
        if (endian) cimg::invert_endianness(buffer,dimx*dimy*dimz*dimv);
        for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) _data[off] = (T)(buffer[off]*scalefactor);
        delete[] buffer;
      } break;
      case 16 : {
        float *const buffer = new float[dimx*dimy*dimz*dimv];
        cimg::fread(buffer,dimx*dimy*dimz*dimv,nfile);
        if (endian) cimg::invert_endianness(buffer,dimx*dimy*dimz*dimv);
        for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) _data[off] = (T)(buffer[off]*scalefactor);
        delete[] buffer;
      } break;
      case 64 : {
        double *const buffer = new double[dimx*dimy*dimz*dimv];
        cimg::fread(buffer,dimx*dimy*dimz*dimv,nfile);
        if (endian) cimg::invert_endianness(buffer,dimx*dimy*dimz*dimv);
        for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) _data[off] = (T)(buffer[off]*scalefactor);
        delete[] buffer;
      } break;
      default :
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_analyze(): Unable to load datatype %d in file '%s'",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              datatype,filename?filename:"(FILE*)");
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }







    CImg<T>& load_cimg(const char *const filename, const char axis='z', const float align=0) {
      CImgList<T> list;
      list.load_cimg(filename);
      if (list._width==1) return list[0].move_to(*this);
      return assign(list.get_append(axis,align));
    }


    static CImg<T> get_load_cimg(const char *const filename, const char axis='z', const float align=0) {
      return CImg<T>().load_cimg(filename,axis,align);
    }


    CImg<T>& load_cimg(std::FILE *const file, const char axis='z', const float align=0) {
      CImgList<T> list;
      list.load_cimg(file);
      if (list._width==1) return list[0].move_to(*this);
      return assign(list.get_append(axis,align));
    }


    static CImg<T> get_load_cimg(std::FILE *const file, const char axis='z', const float align=0) {
      return CImg<T>().load_cimg(file,axis,align);
    }
# 39786 "../src/CImg.h"
    CImg<T>& load_cimg(const char *const filename,
                       const unsigned int n0, const unsigned int n1,
                       const unsigned int x0, const unsigned int y0,
                       const unsigned int z0, const unsigned int c0,
                       const unsigned int x1, const unsigned int y1,
                       const unsigned int z1, const unsigned int c1,
                       const char axis='z', const float align=0) {
      CImgList<T> list;
      list.load_cimg(filename,n0,n1,x0,y0,z0,c0,x1,y1,z1,c1);
      if (list._width==1) return list[0].move_to(*this);
      return assign(list.get_append(axis,align));
    }


    static CImg<T> get_load_cimg(const char *const filename,
                                 const unsigned int n0, const unsigned int n1,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0,
                                 const unsigned int x1, const unsigned int y1,
                                 const unsigned int z1, const unsigned int c1,
                                 const char axis='z', const float align=0) {
      return CImg<T>().load_cimg(filename,n0,n1,x0,y0,z0,c0,x1,y1,z1,c1,axis,align);
    }


    CImg<T>& load_cimg(std::FILE *const file,
                       const unsigned int n0, const unsigned int n1,
                       const unsigned int x0, const unsigned int y0,
                       const unsigned int z0, const unsigned int c0,
                       const unsigned int x1, const unsigned int y1,
                       const unsigned int z1, const unsigned int c1,
                       const char axis='z', const float align=0) {
      CImgList<T> list;
      list.load_cimg(file,n0,n1,x0,y0,z0,c0,x1,y1,z1,c1);
      if (list._width==1) return list[0].move_to(*this);
      return assign(list.get_append(axis,align));
    }


    static CImg<T> get_load_cimg(std::FILE *const file,
                                 const unsigned int n0, const unsigned int n1,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0,
                                 const unsigned int x1, const unsigned int y1,
                                 const unsigned int z1, const unsigned int c1,
                                 const char axis='z', const float align=0) {
      return CImg<T>().load_cimg(file,n0,n1,x0,y0,z0,c0,x1,y1,z1,c1,axis,align);
    }






    CImg<T>& load_inr(const char *const filename, float *const voxel_size=0) {
      return _load_inr(0,filename,voxel_size);
    }


    static CImg<T> get_load_inr(const char *const filename, float *const voxel_size=0) {
      return CImg<T>().load_inr(filename,voxel_size);
    }


    CImg<T>& load_inr(std::FILE *const file, float *const voxel_size=0) {
      return _load_inr(file,0,voxel_size);
    }


    static CImg<T> get_load_inr(std::FILE *const file, float *voxel_size=0) {
      return CImg<T>().load_inr(file,voxel_size);
    }

    static void _load_inr_header(std::FILE *file, int out[8], float *const voxel_size) {
      char item[1024] = { 0 }, tmp1[64] = { 0 }, tmp2[64] = { 0 };
      out[0] = std::fscanf(file,"%63s",item);
      out[0] = out[1] = out[2] = out[3] = out[5] = 1; out[4] = out[6] = out[7] = -1;
      if(cimg::strncasecmp(item,"#INRIMAGE-4#{",13)!=0)
        throw CImgIOException("CImg<%s>::load_inr(): INRIMAGE-4 header not found.",
                              pixel_type());

      while (std::fscanf(file," %63[^\n]%*c",item)!=(-1) && std::strncmp(item,"##}",3)) {
        std::sscanf(item," XDIM%*[^0-9]%d",out);
        std::sscanf(item," YDIM%*[^0-9]%d",out+1);
        std::sscanf(item," ZDIM%*[^0-9]%d",out+2);
        std::sscanf(item," VDIM%*[^0-9]%d",out+3);
        std::sscanf(item," PIXSIZE%*[^0-9]%d",out+6);
        if (voxel_size) {
          std::sscanf(item," VX%*[^0-9.+-]%f",voxel_size);
          std::sscanf(item," VY%*[^0-9.+-]%f",voxel_size+1);
          std::sscanf(item," VZ%*[^0-9.+-]%f",voxel_size+2);
        }
        if (std::sscanf(item," CPU%*[ =]%s",tmp1)) out[7]=cimg::strncasecmp(tmp1,"sun",3)?0:1;
        switch (std::sscanf(item," TYPE%*[ =]%s %s",tmp1,tmp2)) {
        case 0 : break;
        case 2 : out[5] = cimg::strncasecmp(tmp1,"unsigned",8)?1:0; std::strncpy(tmp1,tmp2,sizeof(tmp1)-1);
        case 1 :
          if (!cimg::strncasecmp(tmp1,"int",3) || !cimg::strncasecmp(tmp1,"fixed",5)) out[4] = 0;
          if (!cimg::strncasecmp(tmp1,"float",5) || !cimg::strncasecmp(tmp1,"double",6)) out[4] = 1;
          if (!cimg::strncasecmp(tmp1,"packed",6)) out[4] = 2;
          if (out[4]>=0) break;
        default :
          throw CImgIOException("CImg<%s>::load_inr(): Invalid pixel type '%s' defined in header.",
                                pixel_type(),
                                tmp2);
        }
      }
      if(out[0]<0 || out[1]<0 || out[2]<0 || out[3]<0)
        throw CImgIOException("CImg<%s>::load_inr(): Invalid dimensions (%d,%d,%d,%d) defined in header.",
                              pixel_type(),
                              out[0],out[1],out[2],out[3]);
      if(out[4]<0 || out[5]<0)
        throw CImgIOException("CImg<%s>::load_inr(): Incomplete pixel type defined in header.",
                              pixel_type());
      if(out[6]<0)
        throw CImgIOException("CImg<%s>::load_inr(): Incomplete PIXSIZE field defined in header.",
                              pixel_type());
      if(out[7]<0)
        throw CImgIOException("CImg<%s>::load_inr(): Big/Little Endian coding type undefined in header.",
                              pixel_type());
    }

    CImg<T>& _load_inr(std::FILE *const file, const char *const filename, float *const voxel_size) {
# 39921 "../src/CImg.h"
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_inr(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      int fopt[8], endian=cimg::endianness()?1:0;
      bool loaded = false;
      if (voxel_size) voxel_size[0] = voxel_size[1] = voxel_size[2] = 1;
      _load_inr_header(nfile,fopt,voxel_size);
      assign(fopt[0],fopt[1],fopt[2],fopt[3]);
      if (!loaded && fopt[6]==8 && fopt[4]==0 && fopt[5]==0) { unsigned char *xval, *const val = new unsigned char[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==8 && fopt[4]==0 && fopt[5]==1) { char *xval, *const val = new char[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==16 && fopt[4]==0 && fopt[5]==0) { unsigned short *xval, *const val = new unsigned short[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==16 && fopt[4]==0 && fopt[5]==1) { short *xval, *const val = new short[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==32 && fopt[4]==0 && fopt[5]==0) { unsigned int *xval, *const val = new unsigned int[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==32 && fopt[4]==0 && fopt[5]==1) { int *xval, *const val = new int[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==32 && fopt[4]==1 && fopt[5]==0) { float *xval, *const val = new float[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==32 && fopt[4]==1 && fopt[5]==1) { float *xval, *const val = new float[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==64 && fopt[4]==1 && fopt[5]==0) { double *xval, *const val = new double[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded && fopt[6]==64 && fopt[4]==1 && fopt[5]==1) { double *xval, *const val = new double[fopt[0]*fopt[3]]; for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) { cimg::fread(val,fopt[0]*fopt[3],nfile); if (fopt[7]!=endian) cimg::invert_endianness(val,fopt[0]*fopt[3]); xval = val; for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) (*this)(x,y,z,c) = (T)*(xval++); } delete[] val; loaded = true; };
      if (!loaded) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_inr(): Unknown pixel type defined in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    CImg<T>& load_exr(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_exr(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());


      return load_other(filename);
# 39985 "../src/CImg.h"
    }


    static CImg<T> get_load_exr(const char *const filename) {
      return CImg<T>().load_exr(filename);
    }





    CImg<T>& load_pandore(const char *const filename) {
      return _load_pandore(0,filename);
    }


    static CImg<T> get_load_pandore(const char *const filename) {
      return CImg<T>().load_pandore(filename);
    }


    CImg<T>& load_pandore(std::FILE *const file) {
      return _load_pandore(file,0);
    }


    static CImg<T> get_load_pandore(std::FILE *const file) {
      return CImg<T>().load_pandore(file);
    }

    CImg<T>& _load_pandore(std::FILE *const file, const char *const filename) {
# 40038 "../src/CImg.h"
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_pandore(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      char header[32] = { 0 };
      cimg::fread(header,12,nfile);
      if (cimg::strncasecmp("PANDORE",header,7)) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_pandore(): PANDORE header not found in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }
      unsigned int imageid, dims[8] = { 0 };
      cimg::fread(&imageid,1,nfile);
      const bool endian = (imageid>255);
      if (endian) cimg::invert_endianness(imageid);
      cimg::fread(header,20,nfile);

      switch (imageid) {
      case 2: { if (sizeof(unsigned char)==1) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 3: { if (sizeof(long)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); long *buffer = new long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(int)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); int *buffer = new int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(short)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); short *buffer = new short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 4: { if (sizeof(double)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); double *buffer = new double[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,1); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 5: { if (sizeof(unsigned char)==1) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 6: { if (sizeof(long)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); long *buffer = new long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(int)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); int *buffer = new int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(short)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); short *buffer = new short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 7: { if (sizeof(double)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); double *buffer = new double[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,1); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 8: { if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 9: { if (sizeof(long)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); long *buffer = new long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(int)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); int *buffer = new int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(short)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); short *buffer = new short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 10: { if (sizeof(double)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); double *buffer = new double[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],1); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 11 : {
        cimg::fread(dims,3,nfile);
        if (endian) cimg::invert_endianness(dims,3);
        assign(dims[1],1,1,1);
        const unsigned siz = size();
        if (dims[2]<256) {
          unsigned char *buffer = new unsigned char[siz];
          cimg::fread(buffer,siz,nfile);
          T *ptrd = _data;
          for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
          buffer-=siz;
          delete[] buffer;
        } else {
          if (dims[2]<65536) {
            unsigned short *buffer = new unsigned short[siz];
            cimg::fread(buffer,siz,nfile);
            if (endian) cimg::invert_endianness(buffer,siz);
            T *ptrd = _data;
            for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
            buffer-=siz;
            delete[] buffer;
          } else {
            unsigned int *buffer = new unsigned int[siz];
            cimg::fread(buffer,siz,nfile);
            if (endian) cimg::invert_endianness(buffer,siz);
            T *ptrd = _data;
            for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
            buffer-=siz;
            delete[] buffer;
          }
        }
      }
        break;
      case 12 : {
        cimg::fread(dims,4,nfile);
        if (endian) cimg::invert_endianness(dims,4);
        assign(dims[2],dims[1],1,1);
        const unsigned int siz = size();
        if (dims[3]<256) {
          unsigned char *buffer = new unsigned char[siz];
          cimg::fread(buffer,siz,nfile);
          T *ptrd = _data;
          for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
          buffer-=siz;
          delete[] buffer;
        } else {
          if (dims[3]<65536) {
            unsigned short *buffer = new unsigned short[siz];
            cimg::fread(buffer,siz,nfile);
            if (endian) cimg::invert_endianness(buffer,siz);
            T *ptrd = _data;
            for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
            buffer-=siz;
            delete[] buffer;
          } else {
            unsigned long *buffer = new unsigned long[siz];
            cimg::fread(buffer,siz,nfile);
            if (endian) cimg::invert_endianness(buffer,siz);
            T *ptrd = _data;
            for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
            buffer-=siz;
            delete[] buffer;
          }
        }
      }
        break;
      case 13 : {
        cimg::fread(dims,5,nfile);
        if (endian) cimg::invert_endianness(dims,5);
        assign(dims[3],dims[2],dims[1],1);
        const unsigned int siz = size();
        if (dims[4]<256) {
          unsigned char *buffer = new unsigned char[siz];
          cimg::fread(buffer,siz,nfile);
          T *ptrd = _data;
          for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
          buffer-=siz;
          delete[] buffer;
        } else {
          if (dims[4]<65536) {
            unsigned short *buffer = new unsigned short[siz];
            cimg::fread(buffer,siz,nfile);
            if (endian) cimg::invert_endianness(buffer,siz);
            T *ptrd = _data;
            for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
            buffer-=siz;
            delete[] buffer;
          } else {
            unsigned int *buffer = new unsigned int[siz];
            cimg::fread(buffer,siz,nfile);
            if (endian) cimg::invert_endianness(buffer,siz);
            T *ptrd = _data;
            for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++);
            buffer-=siz;
            delete[] buffer;
          }
        }
      }
        break;
      case 16: { if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 17: { if (sizeof(long)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); long *buffer = new long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(int)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); int *buffer = new int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(short)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); short *buffer = new short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 18: { if (sizeof(double)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); double *buffer = new double[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[2],dims[1],1,3); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 19: { if (sizeof(unsigned char)==1) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 20: { if (sizeof(long)==4) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); long *buffer = new long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(int)==4) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); int *buffer = new int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(short)==4) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); short *buffer = new short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 21: { if (sizeof(double)==4) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); double *buffer = new double[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,5,nfile); if (endian) cimg::invert_endianness(dims,5); assign(dims[3],dims[2],dims[1],3); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 22: { if (sizeof(unsigned char)==1) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 23: { if (sizeof(long)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); long *buffer = new long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(int)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); int *buffer = new int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(short)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); short *buffer = new short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); };
      case 24: { if (sizeof(unsigned long)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); unsigned long *buffer = new unsigned long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned int)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); unsigned int *buffer = new unsigned int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned short)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); unsigned short *buffer = new unsigned short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 25: { if (sizeof(double)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); double *buffer = new double[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,2,nfile); if (endian) cimg::invert_endianness(dims,2); assign(dims[1],1,1,dims[0]); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 26: { if (sizeof(unsigned char)==1) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 27: { if (sizeof(long)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); long *buffer = new long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(int)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); int *buffer = new int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(short)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); short *buffer = new short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 28: { if (sizeof(unsigned long)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); unsigned long *buffer = new unsigned long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned int)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); unsigned int *buffer = new unsigned int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned short)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); unsigned short *buffer = new unsigned short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 29: { if (sizeof(double)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); double *buffer = new double[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,3,nfile); if (endian) cimg::invert_endianness(dims,3); assign(dims[2],dims[1],1,dims[0]); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 30: { if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned char)==1) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); unsigned char *buffer = new unsigned char[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); };
        break;
      case 31: { if (sizeof(long)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); long *buffer = new long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(int)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); int *buffer = new int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(short)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); short *buffer = new short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 32: { if (sizeof(unsigned long)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); unsigned long *buffer = new unsigned long[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned int)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); unsigned int *buffer = new unsigned int[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(unsigned short)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); unsigned short *buffer = new unsigned short[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); };
        break;
      case 33: { if (sizeof(double)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); double *buffer = new double[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else if (sizeof(float)==4) { cimg::fread(dims,4,nfile); if (endian) cimg::invert_endianness(dims,4); assign(dims[3],dims[2],dims[1],dims[0]); const unsigned int siz = size(); float *buffer = new float[siz]; cimg::fread(buffer,siz,nfile); if (endian) cimg::invert_endianness(buffer,siz); T *ptrd = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(ptrd++) = (T)*(buffer++); buffer-=siz; delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "load_pandore(): Unknown pixel datatype in file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); }; break;
      case 34 : {
        int ptbuf[4] = { 0 };
        cimg::fread(ptbuf,1,nfile);
        if (endian) cimg::invert_endianness(ptbuf,1);
        assign(1); (*this)(0) = (T)ptbuf[0];
      } break;
      case 35 : {
        int ptbuf[4] = { 0 };
        cimg::fread(ptbuf,2,nfile);
        if (endian) cimg::invert_endianness(ptbuf,2);
        assign(2); (*this)(0) = (T)ptbuf[1]; (*this)(1) = (T)ptbuf[0];
      } break;
      case 36 : {
        int ptbuf[4] = { 0 };
        cimg::fread(ptbuf,3,nfile);
        if (endian) cimg::invert_endianness(ptbuf,3);
        assign(3); (*this)(0) = (T)ptbuf[2]; (*this)(1) = (T)ptbuf[1]; (*this)(2) = (T)ptbuf[0];
      } break;
      default :
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_pandore(): Unable to load data with ID_type %u in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              imageid,filename?filename:"(FILE*)");
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }







    CImg<T>& load_parrec(const char *const filename, const char axis='c', const float align=0) {
      CImgList<T> list;
      list.load_parrec(filename);
      if (list._width==1) return list[0].move_to(*this);
      return assign(list.get_append(axis,align));
    }


    static CImg<T> get_load_parrec(const char *const filename, const char axis='c', const float align=0) {
      return CImg<T>().load_parrec(filename,axis,align);
    }
# 40246 "../src/CImg.h"
    CImg<T>& load_raw(const char *const filename,
                      const unsigned int size_x=0, const unsigned int size_y=1,
                      const unsigned int size_z=1, const unsigned int size_c=1,
                      const bool is_multiplexed=false, const bool invert_endianness=false,
                      const unsigned long offset=0) {
      return _load_raw(0,filename,size_x,size_y,size_z,size_c,is_multiplexed,invert_endianness,offset);
    }


    static CImg<T> get_load_raw(const char *const filename,
                                const unsigned int size_x=0, const unsigned int size_y=1,
                                const unsigned int size_z=1, const unsigned int size_c=1,
                                const bool is_multiplexed=false, const bool invert_endianness=false,
                                const unsigned long offset=0) {
      return CImg<T>().load_raw(filename,size_x,size_y,size_z,size_c,is_multiplexed,invert_endianness,offset);
    }


    CImg<T>& load_raw(std::FILE *const file,
                      const unsigned int size_x=0, const unsigned int size_y=1,
                      const unsigned int size_z=1, const unsigned int size_c=1,
                      const bool is_multiplexed=false, const bool invert_endianness=false,
                      const unsigned long offset=0) {
      return _load_raw(file,0,size_x,size_y,size_z,size_c,is_multiplexed,invert_endianness,offset);
    }


    static CImg<T> get_load_raw(std::FILE *const file,
                                const unsigned int size_x=0, const unsigned int size_y=1,
                                const unsigned int size_z=1, const unsigned int size_c=1,
                                const bool is_multiplexed=false, const bool invert_endianness=false,
                                const unsigned long offset=0) {
      return CImg<T>().load_raw(file,size_x,size_y,size_z,size_c,is_multiplexed,invert_endianness,offset);
    }

    CImg<T>& _load_raw(std::FILE *const file, const char *const filename,
                       const unsigned int size_x, const unsigned int size_y,
                       const unsigned int size_z, const unsigned int size_c,
                       const bool is_multiplexed, const bool invert_endianness,
                       const unsigned long offset) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_raw(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (cimg::is_directory(filename))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_raw(): Specified filename '%s' is a directory.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),filename);

      unsigned int siz = size_x*size_y*size_z*size_c,
        _size_x = size_x, _size_y = size_y, _size_z = size_z, _size_c = size_c;
      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      if (!siz) {
        const long fpos = std::ftell(nfile);
        if (fpos<0) throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                                "load_raw(): Cannot determine size of input file '%s'.",
                                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),filename?filename:"(FILE*)");
        std::fseek(nfile,0,2);
        siz = _size_y = (unsigned int)std::ftell(nfile)/sizeof(T);
        _size_x = _size_z = _size_c = 1;
        std::fseek(nfile,fpos,0);
      }
      std::fseek(nfile,(long)offset,0);
      assign(_size_x,_size_y,_size_z,_size_c,0);
      if (!is_multiplexed || size_c==1) {
        cimg::fread(_data,siz,nfile);
        if (invert_endianness) cimg::invert_endianness(_data,siz);
      } else {
        CImg<T> buf(1,1,1,_size_c);
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          cimg::fread(buf._data,_size_c,nfile);
          if (invert_endianness) cimg::invert_endianness(buf._data,_size_c);
          set_vector_at(buf,x,y,z);
        }
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }
# 40336 "../src/CImg.h"
    CImg<T>& load_ffmpeg(const char *const filename,
                         const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                         const unsigned int step_frame=1, const bool pixel_format=true, const bool resume=false,
                         const char axis='z', const float align=0) {
      return get_load_ffmpeg(filename,first_frame,last_frame,step_frame,pixel_format,resume,axis,align).move_to(*this);
    }


    static CImg<T> get_load_ffmpeg(const char *const filename,
                                   const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                   const unsigned int step_frame=1, const bool pixel_format=true,
                                   const bool resume=false,
                                   const char axis='z', const float align=0) {
      return CImgList<T>().load_ffmpeg(filename,first_frame,last_frame,step_frame,pixel_format,resume).
        get_append(axis,align);
    }
# 40364 "../src/CImg.h"
    CImg<T>& load_yuv(const char *const filename,
                      const unsigned int size_x, const unsigned int size_y=1,
                      const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                      const unsigned int step_frame=1, const bool yuv2rgb=true, const char axis='z') {
      return get_load_yuv(filename,size_x,size_y,first_frame,last_frame,step_frame,yuv2rgb,axis).move_to(*this);
    }


    static CImg<T> get_load_yuv(const char *const filename,
                                const unsigned int size_x, const unsigned int size_y=1,
                                const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                const unsigned int step_frame=1, const bool yuv2rgb=true, const char axis='z') {
      return CImgList<T>().load_yuv(filename,size_x,size_y,first_frame,last_frame,step_frame,yuv2rgb).get_append(axis);
    }


    CImg<T>& load_yuv(std::FILE *const file,
                      const unsigned int size_x, const unsigned int size_y=1,
                      const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                      const unsigned int step_frame=1, const bool yuv2rgb=true, const char axis='z') {
      return get_load_yuv(file,size_x,size_y,first_frame,last_frame,step_frame,yuv2rgb,axis).move_to(*this);
    }


    static CImg<T> get_load_yuv(std::FILE *const file,
                                const unsigned int size_x, const unsigned int size_y=1,
                                const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                const unsigned int step_frame=1, const bool yuv2rgb=true, const char axis='z') {
      return CImgList<T>().load_yuv(file,size_x,size_y,first_frame,last_frame,step_frame,yuv2rgb).get_append(axis);
    }







    template<typename tf, typename tc>
    CImg<T>& load_off(CImgList<tf>& primitives, CImgList<tc>& colors, const char *const filename) {
      return _load_off(primitives,colors,0,filename);
    }


    template<typename tf, typename tc>
    static CImg<T> get_load_off(CImgList<tf>& primitives, CImgList<tc>& colors, const char *const filename) {
      return CImg<T>().load_off(primitives,colors,filename);
    }


    template<typename tf, typename tc>
    CImg<T>& load_off(CImgList<tf>& primitives, CImgList<tc>& colors, std::FILE *const file) {
      return _load_off(primitives,colors,file,0);
    }


    template<typename tf, typename tc>
    static CImg<T> get_load_off(CImgList<tf>& primitives, CImgList<tc>& colors, std::FILE *const file) {
      return CImg<T>().load_off(primitives,colors,file);
    }

    template<typename tf, typename tc>
    CImg<T>& _load_off(CImgList<tf>& primitives, CImgList<tc>& colors,
                       std::FILE *const file, const char *const filename) {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_off(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      std::FILE *const nfile = file?file:cimg::fopen(filename,"r");
      unsigned int nb_points = 0, nb_primitives = 0, nb_read = 0;
      char line[256] = { 0 };
      int err;


      do { err = std::fscanf(nfile,"%255[^\n] ",line); } while (!err || (err==1 && *line=='#'));
      if (cimg::strncasecmp(line,"OFF",3) && cimg::strncasecmp(line,"COFF",4)) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_off(): OFF header not found in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }
      do { err = std::fscanf(nfile,"%255[^\n] ",line); } while (!err || (err==1 && *line=='#'));
      if ((err = std::sscanf(line,"%u%u%*[^\n] ",&nb_points,&nb_primitives))!=2) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_off(): Invalid number of vertices or primitives specified in file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename?filename:"(FILE*)");
      }


      assign(nb_points,3);
      float X = 0, Y = 0, Z = 0;
      for (int l = 0; l<(int)((*this)._width); ++l) {
        do { err = std::fscanf(nfile,"%255[^\n] ",line); } while (!err || (err==1 && *line=='#'));
        if ((err = std::sscanf(line,"%f%f%f%*[^\n] ",&X,&Y,&Z))!=3) {
          if (!file) cimg::fclose(nfile);
          throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                "load_off(): Failed to read vertex %u/%u in file '%s'.",
                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                l+1,nb_points,filename?filename:"(FILE*)");
        }
        (*this)(l,0) = (T)X; (*this)(l,1) = (T)Y; (*this)(l,2) = (T)Z;
      }


      primitives.assign();
      colors.assign();
      bool stop_flag = false;
      while (!stop_flag) {
        float c0 = 0.7f, c1 = 0.7f, c2 = 0.7f;
        unsigned int prim = 0, i0 = 0, i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0;
        *line = 0;
        if ((err = std::fscanf(nfile,"%u",&prim))!=1) stop_flag = true;
        else {
          ++nb_read;
          switch (prim) {
          case 1 : {
            if ((err = std::fscanf(nfile,"%u%255[^\n] ",&i0,line))<2) {
              cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                         "load_off(): Failed to read primitive %u/%u from file '%s'.",
                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                         nb_read,nb_primitives,filename?filename:"(FILE*)");

              err = std::fscanf(nfile,"%*[^\n] ");
            } else {
              err = std::sscanf(line,"%f%f%f",&c0,&c1,&c2);
              CImg<tf>::vector(i0).move_to(primitives);
              CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)).move_to(colors);
            }
          } break;
          case 2 : {
            if ((err = std::fscanf(nfile,"%u%u%255[^\n] ",&i0,&i1,line))<2) {
              cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                         "load_off(): Failed to read primitive %u/%u from file '%s'.",
                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                         nb_read,nb_primitives,filename?filename:"(FILE*)");

              err = std::fscanf(nfile,"%*[^\n] ");
            } else {
              err = std::sscanf(line,"%f%f%f",&c0,&c1,&c2);
              CImg<tf>::vector(i0,i1).move_to(primitives);
              CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)).move_to(colors);
            }
          } break;
          case 3 : {
            if ((err = std::fscanf(nfile,"%u%u%u%255[^\n] ",&i0,&i1,&i2,line))<3) {
              cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                         "load_off(): Failed to read primitive %u/%u from file '%s'.",
                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                         nb_read,nb_primitives,filename?filename:"(FILE*)");

              err = std::fscanf(nfile,"%*[^\n] ");
            } else {
              err = std::sscanf(line,"%f%f%f",&c0,&c1,&c2);
              CImg<tf>::vector(i0,i2,i1).move_to(primitives);
              CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)).move_to(colors);
            }
          } break;
          case 4 : {
            if ((err = std::fscanf(nfile,"%u%u%u%u%255[^\n] ",&i0,&i1,&i2,&i3,line))<4) {
              cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                         "load_off(): Failed to read primitive %u/%u from file '%s'.",
                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                         nb_read,nb_primitives,filename?filename:"(FILE*)");

              err = std::fscanf(nfile,"%*[^\n] ");
            } else {
              err = std::sscanf(line,"%f%f%f",&c0,&c1,&c2);
              CImg<tf>::vector(i0,i3,i2,i1).move_to(primitives);
              CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)).move_to(colors);
            }
          } break;
          case 5 : {
            if ((err = std::fscanf(nfile,"%u%u%u%u%u%255[^\n] ",&i0,&i1,&i2,&i3,&i4,line))<5) {
              cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                         "load_off(): Failed to read primitive %u/%u from file '%s'.",
                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                         nb_read,nb_primitives,filename?filename:"(FILE*)");

              err = std::fscanf(nfile,"%*[^\n] ");
            } else {
              err = std::sscanf(line,"%f%f%f",&c0,&c1,&c2);
              CImg<tf>::vector(i0,i3,i2,i1).move_to(primitives);
              CImg<tf>::vector(i0,i4,i3).move_to(primitives);
              colors.insert(2,CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)));
              ++nb_primitives;
            }
          } break;
          case 6 : {
            if ((err = std::fscanf(nfile,"%u%u%u%u%u%u%255[^\n] ",&i0,&i1,&i2,&i3,&i4,&i5,line))<6) {
              cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                         "load_off(): Failed to read primitive %u/%u from file '%s'.",
                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                         nb_read,nb_primitives,filename?filename:"(FILE*)");

              err = std::fscanf(nfile,"%*[^\n] ");
            } else {
              err = std::sscanf(line,"%f%f%f",&c0,&c1,&c2);
              CImg<tf>::vector(i0,i3,i2,i1).move_to(primitives);
              CImg<tf>::vector(i0,i5,i4,i3).move_to(primitives);
              colors.insert(2,CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)));
              ++nb_primitives;
            }
          } break;
          case 7 : {
            if ((err = std::fscanf(nfile,"%u%u%u%u%u%u%u%255[^\n] ",&i0,&i1,&i2,&i3,&i4,&i5,&i6,line))<7) {
              cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                         "load_off(): Failed to read primitive %u/%u from file '%s'.",
                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                         nb_read,nb_primitives,filename?filename:"(FILE*)");

              err = std::fscanf(nfile,"%*[^\n] ");
            } else {
              err = std::sscanf(line,"%f%f%f",&c0,&c1,&c2);
              CImg<tf>::vector(i0,i4,i3,i1).move_to(primitives);
              CImg<tf>::vector(i0,i6,i5,i4).move_to(primitives);
              CImg<tf>::vector(i3,i2,i1).move_to(primitives);
              colors.insert(3,CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)));
              ++(++nb_primitives);
            }
          } break;
          case 8 : {
            if ((err = std::fscanf(nfile,"%u%u%u%u%u%u%u%u%255[^\n] ",&i0,&i1,&i2,&i3,&i4,&i5,&i6,&i7,line))<7) {
              cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                         "load_off(): Failed to read primitive %u/%u from file '%s'.",
                         _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                         nb_read,nb_primitives,filename?filename:"(FILE*)");

              err = std::fscanf(nfile,"%*[^\n] ");
            } else {
              err = std::sscanf(line,"%f%f%f",&c0,&c1,&c2);
              CImg<tf>::vector(i0,i3,i2,i1).move_to(primitives);
              CImg<tf>::vector(i0,i5,i4,i3).move_to(primitives);
              CImg<tf>::vector(i0,i7,i6,i5).move_to(primitives);
              colors.insert(3,CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)));
              ++(++nb_primitives);
            }
          } break;
          default :
            cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                       "load_off(): Failed to read primitive %u/%u (%u vertices) from file '%s'.",
                       _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                       nb_read,nb_primitives,prim,filename?filename:"(FILE*)");

            err = std::fscanf(nfile,"%*[^\n] ");
          }
        }
      }
      if (!file) cimg::fclose(nfile);
      if (primitives._width!=nb_primitives)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "load_off(): Only %u/%u primitives read from file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   primitives._width,nb_primitives,filename?filename:"(FILE*)");
      return *this;
    }







    CImg<T>& load_ffmpeg_external(const char *const filename, const char axis='z', const float align=0) {
      return get_load_ffmpeg_external(filename,axis,align).move_to(*this);
    }


    static CImg<T> get_load_ffmpeg_external(const char *const filename, const char axis='z', const float align=0) {
      return CImgList<T>().load_ffmpeg_external(filename).get_append(axis,align);
    }
# 40645 "../src/CImg.h"
    CImg<T>& load_gif_external(const char *const filename,
                               const char axis='z', const float align=0) {
      return get_load_gif_external(filename,axis,align).move_to(*this);
    }


    static CImg<T> get_load_gif_external(const char *const filename,
                                         const char axis='z', const float align=0) {
      return CImgList<T>().load_gif_external(filename).get_append(axis,align);
    }





    CImg<T>& load_graphicsmagick_external(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_graphicsmagick_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      std::fclose(cimg::fopen(filename,"rb"));
      char command[1024] = { 0 }, filetmp[512] = { 0 };
      std::FILE *file = 0;
      const CImg<charT> s_filename = CImg<charT>::string(filename)._system_strescape();

      snprintf(command,sizeof(command),"%s convert \"%s\" pnm:-",
                    cimg::graphicsmagick_path(),s_filename.data());
      file = popen(command,"r");
      if (file) {
        const unsigned int omode = cimg::exception_mode();
        cimg::exception_mode() = 0;
        try { load_pnm(file); } catch (...) {
          pclose(file);
          cimg::exception_mode() = omode;
          throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                "load_graphicsmagick_external(): Failed to load file '%s' with external command 'gm'.",
                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                filename);
        }
        pclose(file);
        return *this;
      }

      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s.pnm",
                      cimg::temporary_path(),'/',cimg::filenamerand());
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);
      snprintf(command,sizeof(command),"%s convert \"%s\" \"%s\"",
                    cimg::graphicsmagick_path(),s_filename.data(),
                    CImg<charT>::string(filetmp)._system_strescape().data());
      cimg::system(command,cimg::graphicsmagick_path());
      if (!(file = std::fopen(filetmp,"rb"))) {
        cimg::fclose(cimg::fopen(filename,"r"));
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_graphicsmagick_external(): Failed to load file '%s' with external command 'gm'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename);

      } else cimg::fclose(file);
      load_pnm(filetmp);
      std::remove(filetmp);
      return *this;
    }


    static CImg<T> get_load_graphicsmagick_external(const char *const filename) {
      return CImg<T>().load_graphicsmagick_external(filename);
    }





    CImg<T>& load_gzip_external(const char *const filename) {
      if (!filename)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_gzip_external(): Specified filename is (null).",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      std::fclose(cimg::fopen(filename,"rb"));
      char command[1024] = { 0 }, filetmp[512] = { 0 }, body[512] = { 0 };
      const char
        *const ext = cimg::split_filename(filename,body),
        *const ext2 = cimg::split_filename(body,0);

      std::FILE *file = 0;
      do {
        if (!cimg::strcasecmp(ext,"gz")) {
          if (*ext2) snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                                   cimg::temporary_path(),'/',cimg::filenamerand(),ext2);
          else snprintf(filetmp,sizeof(filetmp),"%s%c%s",
                             cimg::temporary_path(),'/',cimg::filenamerand());
        } else {
          if (*ext) snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                                  cimg::temporary_path(),'/',cimg::filenamerand(),ext);
          else snprintf(filetmp,sizeof(filetmp),"%s%c%s",
                             cimg::temporary_path(),'/',cimg::filenamerand());
        }
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);
      snprintf(command,sizeof(command),"%s -c \"%s\" > \"%s\"",
                    cimg::gunzip_path(),
                    CImg<charT>::string(filename)._system_strescape().data(),
                    CImg<charT>::string(filetmp)._system_strescape().data());
      cimg::system(command);
      if (!(file = std::fopen(filetmp,"rb"))) {
        cimg::fclose(cimg::fopen(filename,"r"));
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_gzip_external(): Failed to load file '%s' with external command 'gunzip'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename);

      } else cimg::fclose(file);
      load(filetmp);
      std::remove(filetmp);
      return *this;
    }


    static CImg<T> get_load_gzip_external(const char *const filename) {
      return CImg<T>().load_gzip_external(filename);
    }





    CImg<T>& load_imagemagick_external(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_imagemagick_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      std::fclose(cimg::fopen(filename,"rb"));
      char command[1024] = { 0 }, filetmp[512] = { 0 };
      std::FILE *file = 0;
      const CImg<charT> s_filename = CImg<charT>::string(filename)._system_strescape();

      snprintf(command,sizeof(command),"%s%s \"%s\" pnm:-",
                    cimg::imagemagick_path(),
                    !cimg::strcasecmp(cimg::split_filename(filename),"pdf")?" -density 400x400":"",
                    s_filename.data());
      file = popen(command,"r");
      if (file) {
        const unsigned int omode = cimg::exception_mode();
        cimg::exception_mode() = 0;
        try { load_pnm(file); } catch (...) {
          pclose(file);
          cimg::exception_mode() = omode;
          throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                "load_imagemagick_external(): Failed to load file '%s' with "
                                "external command 'convert'.",
                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                filename);
        }
        pclose(file);
        return *this;
      }

      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s.pnm",
                      cimg::temporary_path(),'/',cimg::filenamerand());
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);
      snprintf(command,sizeof(command),"%s%s \"%s\" \"%s\"",
                    cimg::imagemagick_path(),
                    !cimg::strcasecmp(cimg::split_filename(filename),"pdf")?" -density 400x400":"",
                    s_filename.data(),CImg<charT>::string(filetmp)._system_strescape().data());
      cimg::system(command,cimg::imagemagick_path());
      if (!(file = std::fopen(filetmp,"rb"))) {
        cimg::fclose(cimg::fopen(filename,"r"));
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_imagemagick_external(): Failed to load file '%s' with external command 'convert'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename);

      } else cimg::fclose(file);
      load_pnm(filetmp);
      std::remove(filetmp);
      return *this;
    }


    static CImg<T> get_load_imagemagick_external(const char *const filename) {
      return CImg<T>().load_imagemagick_external(filename);
    }





    CImg<T>& load_medcon_external(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_medcon_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      std::fclose(cimg::fopen(filename,"rb"));
      char command[1024] = { 0 }, filetmp[512] = { 0 }, body[512] = { 0 };
      cimg::fclose(cimg::fopen(filename,"r"));
      std::FILE *file = 0;
      do {
        snprintf(filetmp,sizeof(filetmp),"%s.hdr",cimg::filenamerand());
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);
      snprintf(command,sizeof(command),"%s -w -c anlz -o \"%s\" -f \"%s\"",
                    cimg::medcon_path(),
                    CImg<charT>::string(filetmp)._system_strescape().data(),
                    CImg<charT>::string(filename)._system_strescape().data());
      cimg::system(command);
      cimg::split_filename(filetmp,body);

      snprintf(command,sizeof(command),"%s.hdr",body);
      file = std::fopen(command,"rb");
      if (!file) {
        snprintf(command,sizeof(command),"m000-%s.hdr",body);
        file = std::fopen(command,"rb");
        if (!file) {
          throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                "load_medcon_external(): Failed to load file '%s' with external command 'medcon'.",
                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                filename);
        }
      }
      cimg::fclose(file);
      load_analyze(command);
      std::remove(command);
      cimg::split_filename(command,body);
      snprintf(command,sizeof(command),"%s.img",body);
      std::remove(command);
      return *this;
    }


    static CImg<T> get_load_medcon_external(const char *const filename) {
      return CImg<T>().load_medcon_external(filename);
    }





    CImg<T>& load_dcraw_external(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_dcraw_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      std::fclose(cimg::fopen(filename,"rb"));
      char command[1024] = { 0 }, filetmp[512] = { 0 };
      std::FILE *file = 0;
      const CImg<charT> s_filename = CImg<charT>::string(filename)._system_strescape();

      snprintf(command,sizeof(command),"%s -w -4 -c \"%s\"",
                    cimg::dcraw_path(),s_filename.data());
      file = popen(command,"r");
      if (file) {
        const unsigned int omode = cimg::exception_mode();
        cimg::exception_mode() = 0;
        try { load_pnm(file); } catch (...) {
          pclose(file);
          cimg::exception_mode() = omode;
          throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                "load_dcraw_external(): Failed to load file '%s' with external command 'dcraw'.",
                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                filename);
        }
        pclose(file);
        return *this;
      }

      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s.ppm",
                      cimg::temporary_path(),'/',cimg::filenamerand());
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);
      snprintf(command,sizeof(command),"%s -w -4 -c \"%s\" > \"%s\"",
                    cimg::dcraw_path(),s_filename.data(),CImg<charT>::string(filetmp)._system_strescape().data());
      cimg::system(command,cimg::dcraw_path());
      if (!(file = std::fopen(filetmp,"rb"))) {
        cimg::fclose(cimg::fopen(filename,"r"));
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "load_dcraw_external(): Failed to load file '%s' with external command 'dcraw'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename);

      } else cimg::fclose(file);
      load_pnm(filetmp);
      std::remove(filetmp);
      return *this;
    }


    static CImg<T> get_load_dcraw_external(const char *const filename) {
      return CImg<T>().load_dcraw_external(filename);
    }







    CImg<T>& load_camera(const unsigned int camera_index=0, const unsigned int skip_frames=0,
                         const bool release_camera=true, const unsigned int capture_width=0,
                         const unsigned int capture_height=0) {
# 40989 "../src/CImg.h"
      cimg::unused(camera_index,skip_frames,release_camera,capture_width,capture_height);
      throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                            "load_camera(): This function requires the OpenCV library to run "
                            "(macro 'cimg_use_opencv' must be defined).",
                            _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

    }


    static CImg<T> get_load_camera(const unsigned int camera_index=0, const unsigned int skip_frames=0,
                                   const bool release_camera=true,
                                   const unsigned int capture_width=0, const unsigned int capture_height=0) {
      return CImg<T>().load_camera(camera_index,skip_frames,release_camera,capture_width,capture_height);
    }





    CImg<T>& load_other(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_other(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try { load_magick(filename); }
      catch (CImgException&) {
        try { load_imagemagick_external(filename); }
        catch (CImgException&) {
          try { load_graphicsmagick_external(filename); }
          catch (CImgException&) {
            try { load_cimg(filename); }
            catch (CImgException&) {
              try {
                std::fclose(cimg::fopen(filename,"rb"));
              } catch (CImgException&) {
                cimg::exception_mode() = omode;
                throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                      "load_other(): Failed to open file '%s'.",
                                      _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                      filename);
              }
              cimg::exception_mode() = omode;
              throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "load_other(): Failed to recognize format of file '%s'.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    filename);
            }
          }
        }
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    static CImg<T> get_load_other(const char *const filename) {
      return CImg<T>().load_other(filename);
    }
# 41063 "../src/CImg.h"
    const CImg<T>& print(const char *const title=0, const bool display_stats=true) const {
      int xm = 0, ym = 0, zm = 0, vm = 0, xM = 0, yM = 0, zM = 0, vM = 0;
      CImg<doubleT> st;
      if (!is_empty() && display_stats) {
        st = get_stats();
        xm = (int)st[4]; ym = (int)st[5], zm = (int)st[6], vm = (int)st[7];
        xM = (int)st[8]; yM = (int)st[9], zM = (int)st[10], vM = (int)st[11];
      }
      const unsigned long siz = size(), msiz = siz*sizeof(T), siz1 = siz-1,
        mdisp = msiz<8*1024?0:(msiz<8*1024*1024?1:2), width1 = _width-1;

      char _title[64] = { 0 };
      if (!title) snprintf(_title,sizeof(_title),"CImg<%s>",pixel_type());

      std::fprintf(cimg::output(),"%s%s%s%s: %sthis%s = %p, %ssize%s = (%u,%u,%u,%u) [%lu %s], %sdata%s = (%s*)%p",
                   cimg::t_magenta,cimg::t_bold,title?title:_title,cimg::t_normal,
                   cimg::t_bold,cimg::t_normal,(void*)this,
                   cimg::t_bold,cimg::t_normal,_width,_height,_depth,_spectrum,
                   mdisp==0?msiz:(mdisp==1?(msiz>>10):(msiz>>20)),
                   mdisp==0?"b":(mdisp==1?"Kio":"Mio"),
                   cimg::t_bold,cimg::t_normal,pixel_type(),(void*)begin());
      if (_data) std::fprintf(cimg::output(),"..%p (%s) = [ ",(void*)((char*)end()-1),_is_shared?"shared":"non-shared");
      else std::fprintf(cimg::output()," (%s) = [ ",_is_shared?"shared":"non-shared");

      if (!is_empty()) for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) {
        std::fprintf(cimg::output(),cimg::type<T>::format(),cimg::type<T>::format(_data[off]));
        if (off!=siz1) std::fprintf(cimg::output(),"%s",off%_width==width1?" ; ":" ");
        if (off==7 && siz>16) { off = siz1-8; std::fprintf(cimg::output(),"... "); }
      }
      if (!is_empty() && display_stats)
        std::fprintf(cimg::output(),
                     " ], %smin%s = %g, %smax%s = %g, %smean%s = %g, %sstd%s = %g, %scoords_min%s = (%u,%u,%u,%u), "
                     "%scoords_max%s = (%u,%u,%u,%u).\n",
                     cimg::t_bold,cimg::t_normal,st[0],
                     cimg::t_bold,cimg::t_normal,st[1],
                     cimg::t_bold,cimg::t_normal,st[2],
                     cimg::t_bold,cimg::t_normal,std::sqrt(st[3]),
                     cimg::t_bold,cimg::t_normal,xm,ym,zm,vm,
                     cimg::t_bold,cimg::t_normal,xM,yM,zM,vM);
      else std::fprintf(cimg::output(),"%s].\n",is_empty()?"":" ");
      std::fflush(cimg::output());
      return *this;
    }





    const CImg<T>& display(CImgDisplay& disp) const {
      disp.display(*this);
      return *this;
    }






    const CImg<T>& display(CImgDisplay &disp, const bool display_info, unsigned int *const XYZ=0) const {
      return _display(disp,0,display_info,XYZ,false);
    }






    const CImg<T>& display(const char *const title=0, const bool display_info=true, unsigned int *const XYZ=0) const {
      CImgDisplay disp;
      return _display(disp,title,display_info,XYZ,false);
    }

    const CImg<T>& _display(CImgDisplay &disp, const char *const title,
                            const bool display_info, unsigned int *const XYZ,
                            const bool exit_on_simpleclick) const {
      unsigned int oldw = 0, oldh = 0, _XYZ[3] = { 0 }, key = 0;
      int x0 = 0, y0 = 0, z0 = 0, x1 = width()-1, y1 = height()-1, z1 = depth()-1;

      if (!disp) {
        disp.assign(CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,false), CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,true),title?title:0,1);
        if (!title) disp.set_title("CImg<%s> (%ux%ux%ux%u)",pixel_type(),_width,_height,_depth,_spectrum);
        else disp.set_title("%s",title);
      } else if (title) disp.set_title("%s",title);
      disp.show().flush();

      const CImg<char> dtitle = CImg<char>::string(disp.title());
      if (display_info) print(dtitle);

      CImg<T> zoom;
      for (bool reset_view = true, resize_disp = false, is_first_select = true; !key && !disp.is_closed(); ) {
        if (reset_view) {
          if (XYZ) { _XYZ[0] = XYZ[0]; _XYZ[1] = XYZ[1]; _XYZ[2] = XYZ[2]; }
          else { _XYZ[0] = (x0 + x1)/2; _XYZ[1] = (y0 + y1)/2; _XYZ[2] = (z0 + z1)/2; }
          x0 = 0; y0 = 0; z0 = 0; x1 = width()-1; y1 = height()-1; z1 = depth()-1;
          oldw = disp.width(); oldh = disp.height();
          reset_view = false;
        }
        if (!x0 && !y0 && !z0 && x1==width()-1 && y1==height()-1 && z1==depth()-1) {
          if (is_empty()) zoom.assign(1,1,1,1,0); else zoom.assign();
        } else zoom = get_crop(x0,y0,z0,x1,y1,z1);

        const unsigned int
          dx = 1 + x1 - x0, dy = 1 + y1 - y0, dz = 1 + z1 - z0,
          tw = dx + (dz>1?dz:0), th = dy + (dz>1?dz:0);
        if (!is_empty() && !disp.is_fullscreen() && resize_disp) {
          const unsigned int
            ttw = tw*disp.width()/oldw, tth = th*disp.height()/oldh,
            dM = cimg::max(ttw,tth), diM = (unsigned int)cimg::max(disp.width(),disp.height()),
            imgw = cimg::max(16U,ttw*diM/dM), imgh = cimg::max(16U,tth*diM/dM);
          disp.set_fullscreen(false).resize(CImgDisplay::_fitscreen(imgw,imgh,1,128,-85,false), CImgDisplay::_fitscreen(imgw,imgh,1,128,-85,true),false);
          resize_disp = false;
        }
        oldw = tw; oldh = th;

        bool
          go_up = false, go_down = false, go_left = false, go_right = false,
          go_inc = false, go_dec = false, go_in = false, go_out = false,
          go_in_center = false;
        const CImg<T>& visu = zoom?zoom:*this;

        disp.set_title("%s",dtitle._data);
        if (_width>1 && visu._width==1) disp.set_title("%s | x=%u",disp._title,x0);
        if (_height>1 && visu._height==1) disp.set_title("%s | y=%u",disp._title,y0);
        if (_depth>1 && visu._depth==1) disp.set_title("%s | z=%u",disp._title,z0);

        if (!is_first_select) { _XYZ[0] = (x1-x0)/2; _XYZ[1] = (y1-y0)/2; _XYZ[2] = (z1-z0)/2; }
        const CImg<intT> selection = visu._get_select(disp,0,2,_XYZ,x0,y0,z0,is_first_select,_depth>1);
        is_first_select = false;

        if (disp.wheel()) {
          if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            go_out = !(go_in = disp.wheel()>0); go_in_center = false;
          } else if (disp.is_keySHIFTLEFT() || disp.is_keySHIFTRIGHT()) { go_left = !(go_right = disp.wheel()>0); }
          else if (disp.is_keyALT() || disp.is_keyALTGR() || _depth==1) { go_down = !(go_up = disp.wheel()>0); }
          disp.set_wheel();
        }

        const int
          sx0 = selection(0), sy0 = selection(1), sz0 = selection(2),
          sx1 = selection(3), sy1 = selection(4), sz1 = selection(5);
        if (sx0>=0 && sy0>=0 && sz0>=0 && sx1>=0 && sy1>=0 && sz1>=0) {
          x1 = x0 + sx1; y1 = y0 + sy1; z1 = z0 + sz1;
          x0+=sx0; y0+=sy0; z0+=sz0;
          if (sx0==sx1 && sy0==sy1 && sz0==sz1) {
            if (exit_on_simpleclick && (!zoom || is_empty())) break; else reset_view = true;
          }
          resize_disp = true;
        } else switch (key = disp.key()) {

          case cimg::keyCTRLRIGHT : case cimg::keySHIFTRIGHT :

          case 0 : case cimg::keyCTRLLEFT : case cimg::keyPAD5 : case cimg::keySHIFTLEFT :

          case cimg::keyALTGR :

          case cimg::keyALT : key = 0; break;
          case cimg::keyP : if (visu._depth>1 && (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT())) {

              const unsigned int
                w1 = visu._width*disp.width()/(visu._width+(visu._depth>1?visu._depth:0)),
                h1 = visu._height*disp.height()/(visu._height+(visu._depth>1?visu._depth:0));
              float frame_timing = 5;
              bool is_stopped = false;
              disp.set_key(key,false).set_wheel().resize(CImgDisplay::_fitscreen(w1,h1,1,128,-85,false), CImgDisplay::_fitscreen(w1,h1,1,128,-85,true),false); key = 0;
              for (unsigned int timer = 0; !key && !disp.is_closed() && !disp.button(); ) {
                if (disp.is_resized()) disp.resize(false);
                if (!timer) {
                  visu.get_slice((int)_XYZ[2]).display(disp.set_title("%s | z=%d",dtitle.data(),_XYZ[2]));
                  (++_XYZ[2])%=visu._depth;
                }
                if (!is_stopped) { if (++timer>(unsigned int)frame_timing) timer = 0; } else timer = ~0U;
                if (disp.wheel()) { frame_timing-=disp.wheel()/3.0f; disp.set_wheel(); }
                switch (key = disp.key()) {

                case cimg::keyCTRLRIGHT :

                case cimg::keyCTRLLEFT : key = 0; break;
                case cimg::keyPAGEUP : frame_timing-=0.3f; key = 0; break;
                case cimg::keyPAGEDOWN : frame_timing+=0.3f; key = 0; break;
                case cimg::keySPACE : is_stopped = !is_stopped; disp.set_key(key,false); key = 0; break;
                case cimg::keyARROWLEFT : case cimg::keyARROWUP : is_stopped = true; timer = 0; key = 0; break;
                case cimg::keyARROWRIGHT : case cimg::keyARROWDOWN : is_stopped = true;
                  (_XYZ[2]+=visu._depth-2)%=visu._depth; timer = 0; key = 0; break;
                case cimg::keyD : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
                    disp.set_fullscreen(false).
                      resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
                             CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false);
                    disp.set_key(key,false); key = 0;
                  } break;
                case cimg::keyC : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
                    disp.set_fullscreen(false).
                      resize(CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,false), CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,true),false).set_key(key,false); key = 0;
                  } break;
                case cimg::keyR : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
                    disp.set_fullscreen(false).
                      resize(CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,false), CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,true),false).set_key(key,false); key = 0;
                  } break;
                case cimg::keyF : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
                    disp.resize(disp.screen_width(),disp.screen_height(),false).
                      toggle_fullscreen().set_key(key,false); key = 0;
                  } break;
                }
                frame_timing = frame_timing<1?1:(frame_timing>39?39:frame_timing);
                disp.wait(20);
              }
              const unsigned int
                w2 = (visu._width + (visu._depth>1?visu._depth:0))*disp.width()/visu._width,
                h2 = (visu._height + (visu._depth>1?visu._depth:0))*disp.height()/visu._height;
              disp.resize(CImgDisplay::_fitscreen(w2,h2,1,128,-85,false), CImgDisplay::_fitscreen(w2,h2,1,128,-85,true),false).set_title(dtitle.data()).set_key().set_button().set_wheel();
              key = 0;
            } break;
          case cimg::keyHOME : reset_view = resize_disp = true; key = 0; break;
          case cimg::keyPADADD : go_in = true; go_in_center = true; key = 0; break;
          case cimg::keyPADSUB : go_out = true; key = 0; break;
          case cimg::keyARROWLEFT : case cimg::keyPAD4: go_left = true; key = 0; break;
          case cimg::keyARROWRIGHT : case cimg::keyPAD6: go_right = true; key = 0; break;
          case cimg::keyARROWUP : case cimg::keyPAD8: go_up = true; key = 0; break;
          case cimg::keyARROWDOWN : case cimg::keyPAD2: go_down = true; key = 0; break;
          case cimg::keyPAD7 : go_up = go_left = true; key = 0; break;
          case cimg::keyPAD9 : go_up = go_right = true; key = 0; break;
          case cimg::keyPAD1 : go_down = go_left = true; key = 0; break;
          case cimg::keyPAD3 : go_down = go_right = true; key = 0; break;
          case cimg::keyPAGEUP : go_inc = true; key = 0; break;
          case cimg::keyPAGEDOWN : go_dec = true; key = 0; break;
          }
        if (go_in) {
          const int
            mx = go_in_center?disp.width()/2:disp.mouse_x(),
            my = go_in_center?disp.height()/2:disp.mouse_y(),
            mX = mx*(_width+(_depth>1?_depth:0))/disp.width(),
            mY = my*(_height+(_depth>1?_depth:0))/disp.height();
          int X = _XYZ[0], Y = _XYZ[1], Z = _XYZ[2];
          if (mX<width() && mY<height()) {
            X = x0 + mX*(1+x1-x0)/_width; Y = y0 + mY*(1+y1-y0)/_height; Z = _XYZ[2];
          }
          if (mX<width() && mY>=height()) {
            X = x0 + mX*(1+x1-x0)/_width; Z = z0 + (mY-_height)*(1+z1-z0)/_depth; Y = _XYZ[1];
          }
          if (mX>=width() && mY<height()) {
            Y = y0 + mY*(1+y1-y0)/_height; Z = z0 + (mX-_width)*(1+z1-z0)/_depth; X = _XYZ[0];
          }
          if (x1-x0>4) { x0 = X - 3*(X-x0)/4; x1 = X + 3*(x1-X)/4; }
          if (y1-y0>4) { y0 = Y - 3*(Y-y0)/4; y1 = Y + 3*(y1-Y)/4; }
          if (z1-z0>4) { z0 = Z - 3*(Z-z0)/4; z1 = Z + 3*(z1-Z)/4; }
        }
        if (go_out) {
          const int
            delta_x = (x1-x0)/8, delta_y = (y1-y0)/8, delta_z = (z1-z0)/8,
            ndelta_x = delta_x?delta_x:(_width>1?1:0),
            ndelta_y = delta_y?delta_y:(_height>1?1:0),
            ndelta_z = delta_z?delta_z:(_depth>1?1:0);
          x0-=ndelta_x; y0-=ndelta_y; z0-=ndelta_z;
          x1+=ndelta_x; y1+=ndelta_y; z1+=ndelta_z;
          if (x0<0) { x1-=x0; x0 = 0; if (x1>=width()) x1 = width() - 1; }
          if (y0<0) { y1-=y0; y0 = 0; if (y1>=height()) y1 = height() - 1; }
          if (z0<0) { z1-=z0; z0 = 0; if (z1>=depth()) z1 = depth() - 1; }
          if (x1>=width()) { x0-=(x1-width()+1); x1 = width()-1; if (x0<0) x0 = 0; }
          if (y1>=height()) { y0-=(y1-height()+1); y1 = height()-1; if (y0<0) y0 = 0; }
          if (z1>=depth()) { z0-=(z1-depth()+1); z1 = depth()-1; if (z0<0) z0 = 0; }
        }
        if (go_left) {
          const int delta = (x1-x0)/4, ndelta = delta?delta:(_width>1?1:0);
          if (x0-ndelta>=0) { x0-=ndelta; x1-=ndelta; }
          else { x1-=x0; x0 = 0; }
        }
        if (go_right) {
          const int delta = (x1-x0)/4, ndelta = delta?delta:(_width>1?1:0);
          if (x1+ndelta<width()) { x0+=ndelta; x1+=ndelta; }
          else { x0+=(width()-1-x1); x1 = width()-1; }
        }
        if (go_up) {
          const int delta = (y1-y0)/4, ndelta = delta?delta:(_height>1?1:0);
          if (y0-ndelta>=0) { y0-=ndelta; y1-=ndelta; }
          else { y1-=y0; y0 = 0; }
        }
        if (go_down) {
          const int delta = (y1-y0)/4, ndelta = delta?delta:(_height>1?1:0);
          if (y1+ndelta<height()) { y0+=ndelta; y1+=ndelta; }
          else { y0+=(height()-1-y1); y1 = height()-1; }
        }
        if (go_inc) {
          const int delta = (z1-z0)/4, ndelta = delta?delta:(_depth>1?1:0);
          if (z0-ndelta>=0) { z0-=ndelta; z1-=ndelta; }
          else { z1-=z0; z0 = 0; }
        }
        if (go_dec) {
          const int delta = (z1-z0)/4, ndelta = delta?delta:(_depth>1?1:0);
          if (z1+ndelta<depth()) { z0+=ndelta; z1+=ndelta; }
          else { z0+=(depth()-1-z1); z1 = depth()-1; }
        }
        disp.wait(100);
      }
      disp.set_key(key);
      if (XYZ) { XYZ[0] = _XYZ[0]; XYZ[1] = _XYZ[1]; XYZ[2] = _XYZ[2]; }
      return *this;
    }
# 41380 "../src/CImg.h"
    template<typename tp, typename tf, typename tc, typename to>
    const CImg<T>& display_object3d(CImgDisplay& disp,
                                    const CImg<tp>& vertices,
                                    const CImgList<tf>& primitives,
                                    const CImgList<tc>& colors,
                                    const to& opacities,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0) const {
      return _display_object3d(disp,0,vertices,primitives,colors,opacities,centering,render_static,
                               render_motion,is_double_sided,focale,
                               light_x,light_y,light_z,specular_lightness,specular_shininess,
                               display_axes,pose_matrix);
    }


    template<typename tp, typename tf, typename tc, typename to>
    const CImg<T>& display_object3d(const char *const title,
                                    const CImg<tp>& vertices,
                                    const CImgList<tf>& primitives,
                                    const CImgList<tc>& colors,
                                    const to& opacities,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0) const {
      CImgDisplay disp;
      return _display_object3d(disp,title,vertices,primitives,colors,opacities,centering,render_static,
                               render_motion,is_double_sided,focale,
                               light_x,light_y,light_z,specular_lightness,specular_shininess,
                               display_axes,pose_matrix);
    }


    template<typename tp, typename tf, typename tc>
    const CImg<T>& display_object3d(CImgDisplay &disp,
                                    const CImg<tp>& vertices,
                                    const CImgList<tf>& primitives,
                                    const CImgList<tc>& colors,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0) const {
      return display_object3d(disp,vertices,primitives,colors,CImgList<floatT>(),centering,
                              render_static,render_motion,is_double_sided,focale,
                              light_x,light_y,light_z,specular_lightness,specular_shininess,
                              display_axes,pose_matrix);
    }


    template<typename tp, typename tf, typename tc>
    const CImg<T>& display_object3d(const char *const title,
                                    const CImg<tp>& vertices,
                                    const CImgList<tf>& primitives,
                                    const CImgList<tc>& colors,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0) const {
      return display_object3d(title,vertices,primitives,colors,CImgList<floatT>(),centering,
                              render_static,render_motion,is_double_sided,focale,
                              light_x,light_y,light_z,specular_lightness,specular_shininess,
                              display_axes,pose_matrix);
    }


    template<typename tp, typename tf>
    const CImg<T>& display_object3d(CImgDisplay &disp,
                                    const CImg<tp>& vertices,
                                    const CImgList<tf>& primitives,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0) const {
      return display_object3d(disp,vertices,primitives,CImgList<T>(),centering,
                              render_static,render_motion,is_double_sided,focale,
                              light_x,light_y,light_z,specular_lightness,specular_shininess,
                              display_axes,pose_matrix);
    }



    template<typename tp, typename tf>
    const CImg<T>& display_object3d(const char *const title,
                                    const CImg<tp>& vertices,
                                    const CImgList<tf>& primitives,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0) const {
      return display_object3d(title,vertices,primitives,CImgList<T>(),centering,
                              render_static,render_motion,is_double_sided,focale,
                              light_x,light_y,light_z,specular_lightness,specular_shininess,
                              display_axes,pose_matrix);
    }


    template<typename tp>
    const CImg<T>& display_object3d(CImgDisplay &disp,
                                    const CImg<tp>& vertices,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0) const {
      return display_object3d(disp,vertices,CImgList<uintT>(),centering,
                              render_static,render_motion,is_double_sided,focale,
                              light_x,light_y,light_z,specular_lightness,specular_shininess,
                              display_axes,pose_matrix);
    }


    template<typename tp>
    const CImg<T>& display_object3d(const char *const title,
                                    const CImg<tp>& vertices,
                                    const bool centering=true,
                                    const int render_static=4, const int render_motion=1,
                                    const bool is_double_sided=true, const float focale=700,
                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
                                    const float specular_lightness=0.2f, const float specular_shininess=0.1f,
                                    const bool display_axes=true, float *const pose_matrix=0) const {
      return display_object3d(title,vertices,CImgList<uintT>(),centering,
                              render_static,render_motion,is_double_sided,focale,
                              light_x,light_y,light_z,specular_lightness,specular_shininess,
                              display_axes,pose_matrix);
    }

    template<typename tp, typename tf, typename tc, typename to>
    const CImg<T>& _display_object3d(CImgDisplay& disp, const char *const title,
                                     const CImg<tp>& vertices,
                                     const CImgList<tf>& primitives,
                                     const CImgList<tc>& colors,
                                     const to& opacities,
                                     const bool centering,
                                     const int render_static, const int render_motion,
                                     const bool is_double_sided, const float focale,
                                     const float light_x, const float light_y, const float light_z,
                                     const float specular_lightness, const float specular_shininess,
                                     const bool display_axes, float *const pose_matrix) const {
      typedef typename cimg::superset<tp,float>::type tpfloat;


      if (is_empty()) {
        if (disp) return CImg<T>(disp.width(),disp.height(),1,(colors && colors[0].size()==1)?1:3,0).
                    _display_object3d(disp,title,vertices,primitives,colors,opacities,centering,
                                      render_static,render_motion,is_double_sided,focale,
                                      light_x,light_y,light_z,specular_lightness,specular_shininess,
                                      display_axes,pose_matrix);
        else return CImg<T>(1,2,1,1,64,128).resize(CImgDisplay::_fitscreen(CImgDisplay::screen_width()/2,CImgDisplay::screen_height()/2,1,128,-85,false), CImgDisplay::_fitscreen(CImgDisplay::screen_width()/2,CImgDisplay::screen_height()/2,1,128,-85,true)
                                                                                                   ,
                                                   1,(colors && colors[0].size()==1)?1:3,3).
               _display_object3d(disp,title,vertices,primitives,colors,opacities,centering,
                                 render_static,render_motion,is_double_sided,focale,
                                 light_x,light_y,light_z,specular_lightness,specular_shininess,
                                 display_axes,pose_matrix);
      } else { if (disp) disp.resize(*this,false); }
      char error_message[1024] = { 0 };
      if (!vertices.is_object3d(primitives,colors,opacities,true,error_message))
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "display_object3d(): Invalid specified 3d object (%u,%u) (%s).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),vertices._width,primitives._width,error_message);
      if (vertices._width && !primitives) {
        CImgList<tf> nprimitives(vertices._width,1,1,1,1);
        for (int l = 0; l<(int)(nprimitives)._width; ++l) nprimitives(l,0) = l;
        return _display_object3d(disp,title,vertices,nprimitives,colors,opacities,centering,
                                 render_static,render_motion,is_double_sided,focale,
                                 light_x,light_y,light_z,specular_lightness,specular_shininess,
                                 display_axes,pose_matrix);
      }
      if (!disp) {
        disp.assign(CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,false), CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,true),title?title:0,3);
        if (!title) disp.set_title("CImg<%s> (%u vertices, %u primitives)",
                                   pixel_type(),vertices._width,primitives._width);
      } else if (title) disp.set_title("%s",title);


      CImg<floatT>
        pose,
        rotated_vertices(vertices._width,3),
        bbox_vertices, rotated_bbox_vertices,
        axes_vertices, rotated_axes_vertices,
        bbox_opacities, axes_opacities;
      CImgList<uintT> bbox_primitives, axes_primitives;
      CImgList<tf> reverse_primitives;
      CImgList<T> bbox_colors, bbox_colors2, axes_colors;
      unsigned int ns_width = 0, ns_height = 0;
      int _is_double_sided = (int)is_double_sided;
      bool ndisplay_axes = display_axes;
      const CImg<T>
        background_color(1,1,1,_spectrum,0),
        foreground_color(1,1,1,_spectrum,255);
      float
        Xoff = 0, Yoff = 0, Zoff = 0, sprite_scale = 1,
        xm = 0, xM = vertices?vertices.get_shared_row(0).max_min(xm):0,
        ym = 0, yM = vertices?vertices.get_shared_row(1).max_min(ym):0,
        zm = 0, zM = vertices?vertices.get_shared_row(2).max_min(zm):0;
      const float delta = cimg::max(xM-xm,yM-ym,zM-zm);

      rotated_bbox_vertices = bbox_vertices.assign(8,3,1,1,
                                                   xm,xM,xM,xm,xm,xM,xM,xm,
                                                   ym,ym,yM,yM,ym,ym,yM,yM,
                                                   zm,zm,zm,zm,zM,zM,zM,zM);
      bbox_primitives.assign(6,1,4,1,1, 0,3,2,1, 4,5,6,7, 1,2,6,5, 0,4,7,3, 0,1,5,4, 2,3,7,6);
      bbox_colors.assign(6,_spectrum,1,1,1,background_color[0]);
      bbox_colors2.assign(6,_spectrum,1,1,1,foreground_color[0]);
      bbox_opacities.assign(bbox_colors._width,1,1,1,0.3f);

      rotated_axes_vertices = axes_vertices.assign(7,3,1,1,
                                                   0,20,0,0,22,-6,-6,
                                                   0,0,20,0,-6,22,-6,
                                                   0,0,0,20,0,0,22);
      axes_opacities.assign(3,1,1,1,1);
      axes_colors.assign(3,_spectrum,1,1,1,foreground_color[0]);
      axes_primitives.assign(3,1,2,1,1, 0,1, 0,2, 0,3);


      CImg<T> visu0(*this), visu;
      CImg<tpfloat> zbuffer(visu0.width(),visu0.height(),1,1,0);
      bool init_pose = true, clicked = false, redraw = true;
      unsigned int key = 0;
      int
        x0 = 0, y0 = 0, x1 = 0, y1 = 0,
        nrender_static = render_static,
        nrender_motion = render_motion;
      disp.show().flush();

      while (!disp.is_closed() && !key) {


        if (init_pose) {
          const float
            ratio = delta>0?(2.0f*cimg::min(disp.width(),disp.height())/(3.0f*delta)):1,
            dx = (xM + xm)/2, dy = (yM + ym)/2, dz = (zM + zm)/2;
          if (centering)
            CImg<floatT>(4,3,1,1, ratio,0.,0.,-ratio*dx, 0.,ratio,0.,-ratio*dy, 0.,0.,ratio,-ratio*dz).move_to(pose);
          else CImg<floatT>(4,3,1,1, 1,0,0,0, 0,1,0,0, 0,0,1,0).move_to(pose);
          if (pose_matrix) {
            CImg<floatT> pose0(pose_matrix,4,3,1,1,false);
            pose0.resize(4,4,1,1,0); pose.resize(4,4,1,1,0);
            pose0(3,3) = pose(3,3) = 1;
            (pose0*pose).get_crop(0,0,3,2).move_to(pose);
            Xoff = pose_matrix[12]; Yoff = pose_matrix[13]; Zoff = pose_matrix[14]; sprite_scale = pose_matrix[15];
          } else { Xoff = Yoff = Zoff = 0; sprite_scale = 1; }
          init_pose = false;
          redraw = true;
        }


        if (redraw) {
          const float
            r00 = pose(0,0), r10 = pose(1,0), r20 = pose(2,0), r30 = pose(3,0),
            r01 = pose(0,1), r11 = pose(1,1), r21 = pose(2,1), r31 = pose(3,1),
            r02 = pose(0,2), r12 = pose(1,2), r22 = pose(2,2), r32 = pose(3,2);
          if ((clicked && nrender_motion>=0) || (!clicked && nrender_static>=0))
            for (int l = 0; l<(int)((vertices)._width); ++l) {
              const float x = (float)vertices(l,0), y = (float)vertices(l,1), z = (float)vertices(l,2);
              rotated_vertices(l,0) = r00*x + r10*y + r20*z + r30;
              rotated_vertices(l,1) = r01*x + r11*y + r21*z + r31;
              rotated_vertices(l,2) = r02*x + r12*y + r22*z + r32;
            }
          else for (int l = 0; l<(int)((bbox_vertices)._width); ++l) {
              const float x = bbox_vertices(l,0), y = bbox_vertices(l,1), z = bbox_vertices(l,2);
              rotated_bbox_vertices(l,0) = r00*x + r10*y + r20*z + r30;
              rotated_bbox_vertices(l,1) = r01*x + r11*y + r21*z + r31;
              rotated_bbox_vertices(l,2) = r02*x + r12*y + r22*z + r32;
            }





          const bool render_with_zbuffer = !clicked && nrender_static>0;

          visu = visu0;
          if ((clicked && nrender_motion<0) || (!clicked && nrender_static<0))
            visu.draw_object3d(Xoff + visu._width/2.0f,Yoff + visu._height/2.0f,Zoff,
                               rotated_bbox_vertices,bbox_primitives,bbox_colors,bbox_opacities,2,false,focale).
              draw_object3d(Xoff + visu._width/2.0f,Yoff + visu._height/2.0f,Zoff,
                            rotated_bbox_vertices,bbox_primitives,bbox_colors2,1,false,focale);
          else visu._draw_object3d((void*)0,render_with_zbuffer?zbuffer.fill(0):CImg<tpfloat>::empty(),
                                   Xoff + visu._width/2.0f,Yoff + visu._height/2.0f,Zoff,
                                   rotated_vertices,reverse_primitives?reverse_primitives:primitives,
                                   colors,opacities,clicked?nrender_motion:nrender_static,_is_double_sided==1,focale,
                                   width()/2.0f+light_x,height()/2.0f+light_y,light_z+Zoff,
                                   specular_lightness,specular_shininess,sprite_scale);

          if (ndisplay_axes) {
            const float
              n = (float)std::sqrt(1e-8 + r00*r00 + r01*r01 + r02*r02),
              _r00 = r00/n, _r10 = r10/n, _r20 = r20/n,
              _r01 = r01/n, _r11 = r11/n, _r21 = r21/n,
              _r02 = r01/n, _r12 = r12/n, _r22 = r22/n,
              Xaxes = 25, Yaxes = visu._height - 38.0f;
            for (int l = 0; l<(int)((axes_vertices)._width); ++l) {
              const float
                x = axes_vertices(l,0),
                y = axes_vertices(l,1),
                z = axes_vertices(l,2);
              rotated_axes_vertices(l,0) = _r00*x + _r10*y + _r20*z;
              rotated_axes_vertices(l,1) = _r01*x + _r11*y + _r21*z;
              rotated_axes_vertices(l,2) = _r02*x + _r12*y + _r22*z;
            }
            axes_opacities(0,0) = (rotated_axes_vertices(1,2)>0)?0.5f:1.0f;
            axes_opacities(1,0) = (rotated_axes_vertices(2,2)>0)?0.5f:1.0f;
            axes_opacities(2,0) = (rotated_axes_vertices(3,2)>0)?0.5f:1.0f;
            visu.draw_object3d(Xaxes,Yaxes,0,rotated_axes_vertices,axes_primitives,
                               axes_colors,axes_opacities,1,false,focale).
              draw_text((int)(Xaxes+rotated_axes_vertices(4,0)),
                        (int)(Yaxes+rotated_axes_vertices(4,1)),
                        "X",axes_colors[0]._data,0,axes_opacities(0,0),13).
              draw_text((int)(Xaxes+rotated_axes_vertices(5,0)),
                        (int)(Yaxes+rotated_axes_vertices(5,1)),
                        "Y",axes_colors[1]._data,0,axes_opacities(1,0),13).
              draw_text((int)(Xaxes+rotated_axes_vertices(6,0)),
                        (int)(Yaxes+rotated_axes_vertices(6,1)),
                        "Z",axes_colors[2]._data,0,axes_opacities(2,0),13);
          }
          visu.display(disp);
          if (!clicked || nrender_motion==nrender_static) redraw = false;
        }


        disp.wait();
        if ((disp.button() || disp.wheel()) && disp.mouse_x()>=0 && disp.mouse_y()>=0) {
          redraw = true;
          if (!clicked) { x0 = x1 = disp.mouse_x(); y0 = y1 = disp.mouse_y(); if (!disp.wheel()) clicked = true; }
          else { x1 = disp.mouse_x(); y1 = disp.mouse_y(); }
          if (disp.button()&1) {
            const float
              R = 0.45f*cimg::min(disp.width(),disp.height()),
              R2 = R*R,
              u0 = (float)(x0-disp.width()/2),
              v0 = (float)(y0-disp.height()/2),
              u1 = (float)(x1-disp.width()/2),
              v1 = (float)(y1-disp.height()/2),
              n0 = (float)std::sqrt(u0*u0+v0*v0),
              n1 = (float)std::sqrt(u1*u1+v1*v1),
              nu0 = n0>R?(u0*R/n0):u0,
              nv0 = n0>R?(v0*R/n0):v0,
              nw0 = (float)std::sqrt(cimg::max(0,R2-nu0*nu0-nv0*nv0)),
              nu1 = n1>R?(u1*R/n1):u1,
              nv1 = n1>R?(v1*R/n1):v1,
              nw1 = (float)std::sqrt(cimg::max(0,R2-nu1*nu1-nv1*nv1)),
              u = nv0*nw1-nw0*nv1,
              v = nw0*nu1-nu0*nw1,
              w = nv0*nu1-nu0*nv1,
              n = (float)std::sqrt(u*u+v*v+w*w),
              alpha = (float)std::asin(n/R2);
            (CImg<floatT>::rotation_matrix(u,v,w,alpha)*pose).move_to(pose);
            x0 = x1; y0 = y1;
          }
          if (disp.button()&2) {
            if (focale>0) Zoff-=(y0-y1)*focale/400;
            else { const float s = std::exp((y0-y1)/400.0f); pose*=s; sprite_scale*=s; }
            x0 = x1; y0 = y1;
          }
          if (disp.wheel()) {
            if (focale>0) Zoff-=disp.wheel()*focale/20;
            else { const float s = std::exp(disp.wheel()/20.0f); pose*=s; sprite_scale*=s; }
            disp.set_wheel();
          }
          if (disp.button()&4) { Xoff+=(x1-x0); Yoff+=(y1-y0); x0 = x1; y0 = y1; }
          if ((disp.button()&1) && (disp.button()&2)) {
            init_pose = true; disp.set_button(); x0 = x1; y0 = y1;
            pose = CImg<floatT>(4,3,1,1, 1,0,0,0, 0,1,0,0, 0,0,1,0);
          }
        } else if (clicked) { x0 = x1; y0 = y1; clicked = false; redraw = true; }

        switch (key = disp.key()) {

        case cimg::keyCTRLRIGHT :

        case 0 : case cimg::keyCTRLLEFT : key = 0; break;
        case cimg::keyD: if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).
              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
              _is_resized = true;
            disp.set_key(key,false); key = 0;
          } break;
        case cimg::keyC : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).
              resize(CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,false), CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,true),false)._is_resized = true;
            disp.set_key(key,false); key = 0;
          } break;
        case cimg::keyR : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).resize(CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,false), CImgDisplay::_fitscreen(_width,_height,_depth,128,-85,true),false)._is_resized = true;
            disp.set_key(key,false); key = 0;
          } break;
        case cimg::keyF : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            if (!ns_width || !ns_height ||
                ns_width>(unsigned int)disp.screen_width() || ns_height>(unsigned int)disp.screen_height()) {
              ns_width = disp.screen_width()*3U/4;
              ns_height = disp.screen_height()*3U/4;
            }
            if (disp.is_fullscreen()) disp.resize(ns_width,ns_height,false);
            else {
              ns_width = (unsigned int)disp.width(); ns_height = disp.height();
              disp.resize(disp.screen_width(),disp.screen_height(),false);
            }
            disp.toggle_fullscreen()._is_resized = true;
            disp.set_key(key,false); key = 0;
          } break;
        case cimg::keyT : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {

            if (--_is_double_sided==-2) _is_double_sided = 1;
            if (_is_double_sided>=0) reverse_primitives.assign();
            else primitives.get_reverse_object3d().move_to(reverse_primitives);
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyZ : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            if (zbuffer) zbuffer.assign();
            else zbuffer.assign(visu0.width(),visu0.height(),1,1,0);
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyA : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            ndisplay_axes = !ndisplay_axes;
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyF1 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            nrender_motion = (nrender_static==0 && nrender_motion!=0)?0:-1; nrender_static = 0;
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyF2 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            nrender_motion = (nrender_static==1 && nrender_motion!=1)?1:-1; nrender_static = 1;
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyF3 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            nrender_motion = (nrender_static==2 && nrender_motion!=2)?2:-1; nrender_static = 2;
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyF4 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            nrender_motion = (nrender_static==3 && nrender_motion!=3)?3:-1; nrender_static = 3;
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyF5 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {

            nrender_motion = (nrender_static==4 && nrender_motion!=4)?4:-1; nrender_static = 4;
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyF6 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            nrender_motion = (nrender_static==5 && nrender_motion!=5)?5:-1; nrender_static = 5;
            disp.set_key(key,false); key = 0; redraw = true;
          } break;
        case cimg::keyS : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            char filename[32] = { 0 };
            std::FILE *file;
            do {
              snprintf(filename,sizeof(filename),"CImg" "_%.4u.bmp",snap_number++);
              if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
            } while (file);
            (+visu).draw_text(0,0," Saving snapshot... ",
                              foreground_color._data,background_color._data,0.7f,13).display(disp);
            visu.save(filename);
            (+visu).draw_text(0,0," Snapshot '%s' saved. ",
                              foreground_color._data,background_color._data,0.7f,13,filename).display(disp);
            disp.set_key(key,false); key = 0;
          } break;
        case cimg::keyG : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            char filename[32] = { 0 };
            std::FILE *file;
            do {
              snprintf(filename,sizeof(filename),"CImg" "_%.4u.off",snap_number++);
              if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
            } while (file);
            (+visu).draw_text(0,0," Saving object... ",
                              foreground_color._data,background_color._data,0.7f,13).display(disp);
            vertices.save_off(reverse_primitives?reverse_primitives:primitives,colors,filename);
            (+visu).draw_text(0,0," Object '%s' saved. ",
                              foreground_color._data,background_color._data,0.7f,13,filename).display(disp);
            disp.set_key(key,false); key = 0;
          } break;
        case cimg::keyO : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            char filename[32] = { 0 };
            std::FILE *file;
            do {



              snprintf(filename,sizeof(filename),"CImg" "_%.4u.cimg",snap_number++);

              if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
            } while (file);
            (+visu).draw_text(0,0," Saving object... ",
                              foreground_color._data,background_color._data,0.7f,13).display(disp);
            vertices.get_object3dtoCImg3d(reverse_primitives?reverse_primitives:primitives,colors,opacities).
              save(filename);
            (+visu).draw_text(0,0," Object '%s' saved. ",
                              foreground_color._data,background_color._data,0.7f,13,filename).display(disp);
            disp.set_key(key,false); key = 0;
          } break;
# 41938 "../src/CImg.h"
        }
        if (disp.is_resized()) {
          disp.resize(false); visu0 = get_resize(disp,1);
          if (zbuffer) zbuffer.assign(disp.width(),disp.height());
          redraw = true;
        }
      }
      if (pose_matrix) {
        std::memcpy(pose_matrix,pose._data,12*sizeof(float));
        pose_matrix[12] = Xoff; pose_matrix[13] = Yoff; pose_matrix[14] = Zoff; pose_matrix[15] = sprite_scale;
      }
      disp.set_button().set_key(key);
      return *this;
    }
# 41965 "../src/CImg.h"
    const CImg<T>& display_graph(CImgDisplay &disp,
                                 const unsigned int plot_type=1, const unsigned int vertex_type=1,
                                 const char *const labelx=0, const double xmin=0, const double xmax=0,
                                 const char *const labely=0, const double ymin=0, const double ymax=0) const {
      return _display_graph(disp,0,plot_type,vertex_type,labelx,xmin,xmax,labely,ymin,ymax);
    }


    const CImg<T>& display_graph(const char *const title=0,
                                 const unsigned int plot_type=1, const unsigned int vertex_type=1,
                                 const char *const labelx=0, const double xmin=0, const double xmax=0,
                                 const char *const labely=0, const double ymin=0, const double ymax=0) const {
      CImgDisplay disp;
      return _display_graph(disp,title,plot_type,vertex_type,labelx,xmin,xmax,labely,ymin,ymax);
    }

    const CImg<T>& _display_graph(CImgDisplay &disp, const char *const title=0,
                                 const unsigned int plot_type=1, const unsigned int vertex_type=1,
                                 const char *const labelx=0, const double xmin=0, const double xmax=0,
                                 const char *const labely=0, const double ymin=0, const double ymax=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "display_graph(): Empty instance.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (!disp) disp.assign(CImgDisplay::_fitscreen(CImgDisplay::screen_width()/2,CImgDisplay::screen_height()/2,1,128,-85,false), CImgDisplay::_fitscreen(CImgDisplay::screen_width()/2,CImgDisplay::screen_height()/2,1,128,-85,true),0,0).
                   set_title(title?"%s":"CImg<%s>",title?title:pixel_type());
      const unsigned long siz = (unsigned long)_width*_height*_depth, siz1 = cimg::max(1U,siz-1);
      const unsigned int old_normalization = disp.normalization();
      disp.show().flush()._normalization = 0;

      double y0 = ymin, y1 = ymax, nxmin = xmin, nxmax = xmax;
      if (nxmin==nxmax) { nxmin = 0; nxmax = siz1; }
      int x0 = 0, x1 = width()*height()*depth() - 1, key = 0;

      for (bool reset_view = true; !key && !disp.is_closed(); ) {
        if (reset_view) { x0 = 0; x1 = width()*height()*depth()-1; y0 = ymin; y1 = ymax; reset_view = false; }
        CImg<T> zoom(x1-x0+1,1,1,spectrum());
        for (int c = 0; c<(int)((*this)._spectrum); ++c) zoom.get_shared_channel(c) = CImg<T>(data(x0,0,0,c),x1-x0+1,1,1,1,true);
        if (y0==y1) { y0 = zoom.min_max(y1); const double dy = y1 - y0; y0-=dy/20; y1+=dy/20; }
        if (y0==y1) { --y0; ++y1; }

        const CImg<intT> selection = zoom.get_select_graph(disp,plot_type,vertex_type,
                                                           labelx,
                                                           nxmin + x0*(nxmax-nxmin)/siz1,
                                                           nxmin + x1*(nxmax-nxmin)/siz1,
                                                           labely,y0,y1);
        const int mouse_x = disp.mouse_x(), mouse_y = disp.mouse_y();
        if (selection[0]>=0) {
          if (selection[2]<0) reset_view = true;
          else {
            x1 = x0 + selection[2]; x0+=selection[0];
            if (selection[1]>=0 && selection[3]>=0) {
              y0 = y1 - selection[3]*(y1-y0)/(disp.height()-32);
              y1-=selection[1]*(y1-y0)/(disp.height()-32);
            }
          }
        } else {
          bool go_in = false, go_out = false, go_left = false, go_right = false, go_up = false, go_down = false;
          switch (key = disp.key()) {
          case cimg::keyHOME : reset_view = true; key = 0; disp.set_key(); break;
          case cimg::keyPADADD : go_in = true; go_out = false; key = 0; disp.set_key(); break;
          case cimg::keyPADSUB : go_out = true; go_in = false; key = 0; disp.set_key(); break;
          case cimg::keyARROWLEFT : case cimg::keyPAD4 : go_left = true; go_right = false; key = 0; disp.set_key();
            break;
          case cimg::keyARROWRIGHT : case cimg::keyPAD6 : go_right = true; go_left = false; key = 0; disp.set_key();
            break;
          case cimg::keyARROWUP : case cimg::keyPAD8 : go_up = true; go_down = false; key = 0; disp.set_key(); break;
          case cimg::keyARROWDOWN : case cimg::keyPAD2 : go_down = true; go_up = false; key = 0; disp.set_key(); break;
          case cimg::keyPAD7 : go_left = true; go_up = true; key = 0; disp.set_key(); break;
          case cimg::keyPAD9 : go_right = true; go_up = true; key = 0; disp.set_key(); break;
          case cimg::keyPAD1 : go_left = true; go_down = true; key = 0; disp.set_key(); break;
          case cimg::keyPAD3 : go_right = true; go_down = true; key = 0; disp.set_key(); break;
          }
          if (disp.wheel()) {
            if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) go_out = !(go_in = disp.wheel()>0);
            else if (disp.is_keySHIFTLEFT() || disp.is_keySHIFTRIGHT()) go_left = !(go_right = disp.wheel()>0);
            else go_up = !(go_down = disp.wheel()<0);
            key = 0;
          }

          if (go_in) {
            const int
              xsiz = x1 - x0,
              mx = (mouse_x-16)*xsiz/(disp.width()-32),
              cx = x0 + (mx<0?0:(mx>=xsiz?xsiz:mx));
            if (x1-x0>4) {
              x0 = cx - 7*(cx-x0)/8; x1 = cx + 7*(x1-cx)/8;
              if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
                const double
                  ysiz = y1 - y0,
                  my = (mouse_y-16)*ysiz/(disp.height()-32),
                  cy = y1 - (my<0?0:(my>=ysiz?ysiz:my));
                y0 = cy - 7*(cy-y0)/8; y1 = cy + 7*(y1-cy)/8;
              } else y0 = y1 = 0;
            }
          }
          if (go_out) {
            if (x0>0 || x1<(int)siz1) {
              const int delta_x = (x1-x0)/8, ndelta_x = delta_x?delta_x:(siz>1?1:0);
              const double ndelta_y = (y1-y0)/8;
              x0-=ndelta_x; x1+=ndelta_x;
              y0-=ndelta_y; y1+=ndelta_y;
              if (x0<0) { x1-=x0; x0 = 0; if (x1>=(int)siz) x1 = (int)siz1; }
              if (x1>=(int)siz) { x0-=(x1-siz1); x1 = (int)siz1; if (x0<0) x0 = 0; }
            }
          }
          if (go_left) {
            const int delta = (x1-x0)/5, ndelta = delta?delta:1;
            if (x0-ndelta>=0) { x0-=ndelta; x1-=ndelta; }
            else { x1-=x0; x0 = 0; }
            go_left = false;
          }
          if (go_right) {
            const int delta = (x1-x0)/5, ndelta = delta?delta:1;
            if (x1+ndelta<(int)siz) { x0+=ndelta; x1+=ndelta; }
            else { x0+=(siz1-x1); x1 = siz1; }
            go_right = false;
          }
          if (go_up) {
            const double delta = (y1-y0)/10, ndelta = delta?delta:1;
            y0+=ndelta; y1+=ndelta;
            go_up = false;
          }
          if (go_down) {
            const double delta = (y1-y0)/10, ndelta = delta?delta:1;
            y0-=ndelta; y1-=ndelta;
            go_down = false;
          }
        }
      }
      disp._normalization = old_normalization;
      return *this;
    }
# 42109 "../src/CImg.h"
    const CImg<T>& save(const char *const filename, const int number=-1, const unsigned int digits=6) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());

      const bool is_stdout = *filename=='-' && (!filename[1] || filename[1]=='.');
      const char *const ext = cimg::split_filename(filename);
      char nfilename[1024] = { 0 };
      const char *const fn = is_stdout?filename:(number>=0)?cimg::number_filename(filename,number,digits,nfilename):
        filename;
# 42149 "../src/CImg.h"
      if (!cimg::strcasecmp(ext,"asc")) return save_ascii(fn);
      else if (!cimg::strcasecmp(ext,"dlm") ||
               !cimg::strcasecmp(ext,"txt")) return save_dlm(fn);
      else if (!cimg::strcasecmp(ext,"cpp") ||
               !cimg::strcasecmp(ext,"hpp") ||
               !cimg::strcasecmp(ext,"h") ||
               !cimg::strcasecmp(ext,"c")) return save_cpp(fn);


      else if (!cimg::strcasecmp(ext,"bmp")) return save_bmp(fn);
      else if (!cimg::strcasecmp(ext,"jpg") ||
               !cimg::strcasecmp(ext,"jpeg") ||
               !cimg::strcasecmp(ext,"jpe") ||
               !cimg::strcasecmp(ext,"jfif") ||
               !cimg::strcasecmp(ext,"jif")) return save_jpeg(fn);
      else if (!cimg::strcasecmp(ext,"rgb")) return save_rgb(fn);
      else if (!cimg::strcasecmp(ext,"rgba")) return save_rgba(fn);
      else if (!cimg::strcasecmp(ext,"png")) return save_png(fn);
      else if (!cimg::strcasecmp(ext,"pgm") ||
               !cimg::strcasecmp(ext,"ppm") ||
               !cimg::strcasecmp(ext,"pnm")) return save_pnm(fn);
      else if (!cimg::strcasecmp(ext,"pnk")) return save_pnk(fn);
      else if (!cimg::strcasecmp(ext,"pfm")) return save_pfm(fn);
      else if (!cimg::strcasecmp(ext,"exr")) return save_exr(fn);
      else if (!cimg::strcasecmp(ext,"tif") ||
               !cimg::strcasecmp(ext,"tiff")) return save_tiff(fn);


      else if (!cimg::strcasecmp(ext,"cimgz")) return save_cimg(fn,true);
      else if (!cimg::strcasecmp(ext,"cimg") || !*ext) return save_cimg(fn,false);
      else if (!cimg::strcasecmp(ext,"dcm")) return save_medcon_external(fn);
      else if (!cimg::strcasecmp(ext,"hdr") ||
               !cimg::strcasecmp(ext,"nii")) return save_analyze(fn);
      else if (!cimg::strcasecmp(ext,"inr")) return save_inr(fn);
      else if (!cimg::strcasecmp(ext,"mnc")) return save_minc2(fn);
      else if (!cimg::strcasecmp(ext,"pan")) return save_pandore(fn);
      else if (!cimg::strcasecmp(ext,"raw")) return save_raw(fn);


      else if (!cimg::strcasecmp(ext,"gz")) return save_gzip_external(fn);


      else if (!cimg::strcasecmp(ext,"yuv")) return save_yuv(fn,true);
      else if (!cimg::strcasecmp(ext,"avi") ||
               !cimg::strcasecmp(ext,"mov") ||
               !cimg::strcasecmp(ext,"asf") ||
               !cimg::strcasecmp(ext,"divx") ||
               !cimg::strcasecmp(ext,"flv") ||
               !cimg::strcasecmp(ext,"mpg") ||
               !cimg::strcasecmp(ext,"m1v") ||
               !cimg::strcasecmp(ext,"m2v") ||
               !cimg::strcasecmp(ext,"m4v") ||
               !cimg::strcasecmp(ext,"mjp") ||
               !cimg::strcasecmp(ext,"mp4") ||
               !cimg::strcasecmp(ext,"mkv") ||
               !cimg::strcasecmp(ext,"mpe") ||
               !cimg::strcasecmp(ext,"movie") ||
               !cimg::strcasecmp(ext,"ogm") ||
               !cimg::strcasecmp(ext,"ogg") ||
               !cimg::strcasecmp(ext,"ogv") ||
               !cimg::strcasecmp(ext,"qt") ||
               !cimg::strcasecmp(ext,"rm") ||
               !cimg::strcasecmp(ext,"vob") ||
               !cimg::strcasecmp(ext,"wmv") ||
               !cimg::strcasecmp(ext,"xvid") ||
               !cimg::strcasecmp(ext,"mpeg")) return save_ffmpeg(fn);
      return save_other(fn);
    }





    const CImg<T>& save_ascii(const char *const filename) const {
      return _save_ascii(0,filename);
    }


    const CImg<T>& save_ascii(std::FILE *const file) const {
      return _save_ascii(file,0);
    }

    const CImg<T>& _save_ascii(std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_ascii(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      std::FILE *const nfile = file?file:cimg::fopen(filename,"w");
      std::fprintf(nfile,"%u %u %u %u\n",_width,_height,_depth,_spectrum);
      const T* ptrs = _data;
      for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
        for (int x = 0; x<(int)((*this)._width); ++x) std::fprintf(nfile,"%.16g ",(double)*(ptrs++));
        std::fputc('\n',nfile);
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    const CImg<T>& save_cpp(const char *const filename) const {
      return _save_cpp(0,filename);
    }


    const CImg<T>& save_cpp(std::FILE *const file) const {
      return _save_cpp(file,0);
    }

    const CImg<T>& _save_cpp(std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_cpp(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      std::FILE *const nfile = file?file:cimg::fopen(filename,"w");
      char varname[1024] = { 0 };
      if (filename) std::sscanf(cimg::basename(filename),"%1023[a-zA-Z0-9_]",varname);
      if (!*varname) snprintf(varname,sizeof(varname),"unnamed");
      std::fprintf(nfile,
                   "/* Define image '%s' of size %ux%ux%ux%u and type '%s' */\n"
                   "%s data_%s[] = { %s\n  ",
                   varname,_width,_height,_depth,_spectrum,pixel_type(),pixel_type(),varname,
                   is_empty()?"};":"");
      if (!is_empty()) for (unsigned long off = 0, siz = size()-1; off<=siz; ++off) {
        std::fprintf(nfile,cimg::type<T>::format(),cimg::type<T>::format((*this)[off]));
        if (off==siz) std::fprintf(nfile," };\n");
        else if (!((off+1)%16)) std::fprintf(nfile,",\n  ");
        else std::fprintf(nfile,", ");
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    const CImg<T>& save_dlm(const char *const filename) const {
      return _save_dlm(0,filename);
    }


    const CImg<T>& save_dlm(std::FILE *const file) const {
      return _save_dlm(file,0);
    }

    const CImg<T>& _save_dlm(std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_dlm(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }
      if (_depth>1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_dlm(): Instance is volumetric, values along Z will be unrolled in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");
      if (_spectrum>1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_dlm(): Instance is multispectral, values along C will be unrolled in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"w");
      const T* ptrs = _data;
      for (int c = 0; c<(int)((*this)._spectrum); ++c) for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) {
        for (int x = 0; x<(int)((*this)._width); ++x) std::fprintf(nfile,"%.16g%s",(double)*(ptrs++),(x==width()-1)?"":",");
        std::fputc('\n',nfile);
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    const CImg<T>& save_bmp(const char *const filename) const {
      return _save_bmp(0,filename);
    }


    const CImg<T>& save_bmp(std::FILE *const file) const {
      return _save_bmp(file,0);
    }

    const CImg<T>& _save_bmp(std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_bmp(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }
      if (_depth>1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_bmp(): Instance is volumetric, only the first slice will be saved in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");
      if (_spectrum>3)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_bmp(): Instance is multispectral, only the three first channels will be saved in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      unsigned char header[54] = { 0 }, align_buf[4] = { 0 };
      const unsigned int
        align = (4 - (3*_width)%4)%4,
        buf_size = (3*_width + align)*height(),
        file_size = 54 + buf_size;
      header[0] = 'B'; header[1] = 'M';
      header[0x02] = file_size&0xFF;
      header[0x03] = (file_size>>8)&0xFF;
      header[0x04] = (file_size>>16)&0xFF;
      header[0x05] = (file_size>>24)&0xFF;
      header[0x0A] = 0x36;
      header[0x0E] = 0x28;
      header[0x12] = _width&0xFF;
      header[0x13] = (_width>>8)&0xFF;
      header[0x14] = (_width>>16)&0xFF;
      header[0x15] = (_width>>24)&0xFF;
      header[0x16] = _height&0xFF;
      header[0x17] = (_height>>8)&0xFF;
      header[0x18] = (_height>>16)&0xFF;
      header[0x19] = (_height>>24)&0xFF;
      header[0x1A] = 1;
      header[0x1B] = 0;
      header[0x1C] = 24;
      header[0x1D] = 0;
      header[0x22] = buf_size&0xFF;
      header[0x23] = (buf_size>>8)&0xFF;
      header[0x24] = (buf_size>>16)&0xFF;
      header[0x25] = (buf_size>>24)&0xFF;
      header[0x27] = 0x1;
      header[0x2B] = 0x1;
      cimg::fwrite(header,54,nfile);

      const T
        *ptr_r = data(0,_height-1,0,0),
        *ptr_g = (_spectrum>=2)?data(0,_height-1,0,1):0,
        *ptr_b = (_spectrum>=3)?data(0,_height-1,0,2):0;

      switch (_spectrum) {
      case 1 : {
        for (int y = 0; y<(int)((*this)._height); ++y) {
          for (int x = 0; x<(int)((*this)._width); ++x) {
            const unsigned char val = (unsigned char)*(ptr_r++);
            std::fputc(val,nfile); std::fputc(val,nfile); std::fputc(val,nfile);
          }
          cimg::fwrite(align_buf,align,nfile);
          ptr_r-=2*_width;
        }
      } break;
      case 2 : {
        for (int y = 0; y<(int)((*this)._height); ++y) {
          for (int x = 0; x<(int)((*this)._width); ++x) {
            std::fputc(0,nfile);
            std::fputc((unsigned char)(*(ptr_g++)),nfile);
            std::fputc((unsigned char)(*(ptr_r++)),nfile);
          }
          cimg::fwrite(align_buf,align,nfile);
          ptr_r-=2*_width; ptr_g-=2*_width;
        }
      } break;
      default : {
        for (int y = 0; y<(int)((*this)._height); ++y) {
          for (int x = 0; x<(int)((*this)._width); ++x) {
            std::fputc((unsigned char)(*(ptr_b++)),nfile);
            std::fputc((unsigned char)(*(ptr_g++)),nfile);
            std::fputc((unsigned char)(*(ptr_r++)),nfile);
          }
          cimg::fwrite(align_buf,align,nfile);
          ptr_r-=2*_width; ptr_g-=2*_width; ptr_b-=2*_width;
        }
      }
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }






    const CImg<T>& save_jpeg(const char *const filename, const unsigned int quality=100) const {
      return _save_jpeg(0,filename,quality);
    }


    const CImg<T>& save_jpeg(std::FILE *const file, const unsigned int quality=100) const {
      return _save_jpeg(file,0,quality);
    }

    const CImg<T>& _save_jpeg(std::FILE *const file, const char *const filename, const unsigned int quality) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_jpeg(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }
      if (_depth>1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_jpeg(): Instance is volumetric, only the first slice will be saved in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");


      if (!file) return save_other(filename,quality);
      else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                 "save_jpeg(): Unable to save data in '(*FILE)' unless libjpeg is enabled.",
                                 _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
# 42540 "../src/CImg.h"
    }






    const CImg<T>& save_magick(const char *const filename, const unsigned int bytes_per_pixel=0) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_magick(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }
# 42609 "../src/CImg.h"
      cimg::unused(bytes_per_pixel);
      throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                            "save_magick(): Unable to save file '%s' unless libMagick++ is enabled.",
                            _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                            filename);

    }






    const CImg<T>& save_png(const char *const filename, const unsigned int bytes_per_pixel=0) const {
      return _save_png(0,filename,bytes_per_pixel);
    }


    const CImg<T>& save_png(std::FILE *const file, const unsigned int bytes_per_pixel=0) const {
      return _save_png(file,0,bytes_per_pixel);
    }

    const CImg<T>& _save_png(std::FILE *const file, const char *const filename,
                             const unsigned int bytes_per_pixel=0) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_png(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }


      cimg::unused(bytes_per_pixel);
      if (!file) return save_other(filename);
      else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                 "save_png(): Unable to save data in '(*FILE)' unless libpng is enabled.",
                                 _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
# 42822 "../src/CImg.h"
    }






    const CImg<T>& save_pnm(const char *const filename, const unsigned int bytes_per_pixel=0) const {
      return _save_pnm(0,filename,bytes_per_pixel);
    }


    const CImg<T>& save_pnm(std::FILE *const file, const unsigned int bytes_per_pixel=0) const {
      return _save_pnm(file,0,bytes_per_pixel);
    }

    const CImg<T>& _save_pnm(std::FILE *const file, const char *const filename,
                             const unsigned int bytes_per_pixel=0) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_pnm(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }

      double stmin, stmax = (double)max_min(stmin);
      if (_depth>1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_pnm(): Instance is volumetric, only the first slice will be saved in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");
      if (_spectrum>3)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_pnm(): Instance is multispectral, only the three first channels will be saved in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");
      if (stmin<0 || (bytes_per_pixel==1 && stmax>=256) || stmax>=65536)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_pnm(): Instance has pixel values in [%g,%g], probable type overflow in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   stmin,stmax,filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      const T
        *ptr_r = data(0,0,0,0),
        *ptr_g = (_spectrum>=2)?data(0,0,0,1):0,
        *ptr_b = (_spectrum>=3)?data(0,0,0,2):0;
      const unsigned long buf_size = cimg::min(1024*1024UL,_width*_height*(_spectrum==1?1UL:3UL));

      std::fprintf(nfile,"P%c\n%u %u\n%u\n",
                   (_spectrum==1?'5':'6'),_width,_height,stmax<256?255:(stmax<4096?4095:65535));

      switch (_spectrum) {
      case 1 : {
        if (bytes_per_pixel==1 || (!bytes_per_pixel && stmax<256)) {
          CImg<ucharT> buf(buf_size);
          for (long to_write = (long)_width*_height; to_write>0; ) {
            const unsigned long N = cimg::min((unsigned long)to_write,buf_size);
            unsigned char *ptrd = buf._data;
            for (unsigned long i = N; i>0; --i) *(ptrd++) = (unsigned char)*(ptr_r++);
            cimg::fwrite(buf._data,N,nfile);
            to_write-=N;
          }
        } else {
          CImg<ushortT> buf(buf_size);
          for (long to_write = (long)_width*_height; to_write>0; ) {
            const unsigned long N = cimg::min((unsigned long)to_write,buf_size);
            unsigned short *ptrd = buf._data;
            for (unsigned long i = N; i>0; --i) *(ptrd++) = (unsigned short)*(ptr_r++);
            if (!cimg::endianness()) cimg::invert_endianness(buf._data,buf_size);
            cimg::fwrite(buf._data,N,nfile);
            to_write-=N;
          }
        }
      } break;
      case 2 : {
        if (bytes_per_pixel==1 || (!bytes_per_pixel && stmax<256)) {
          CImg<ucharT> buf(buf_size);
          for (long to_write = (long)_width*_height; to_write>0; ) {
            const unsigned long N = cimg::min((unsigned long)to_write,buf_size/3);
            unsigned char *ptrd = buf._data;
            for (unsigned long i = N; i>0; --i) {
              *(ptrd++) = (unsigned char)*(ptr_r++);
              *(ptrd++) = (unsigned char)*(ptr_g++);
              *(ptrd++) = 0;
            }
            cimg::fwrite(buf._data,3*N,nfile);
            to_write-=N;
          }
        } else {
          CImg<ushortT> buf(buf_size);
          for (long to_write = (long)_width*_height; to_write>0; ) {
            const unsigned long N = cimg::min((unsigned long)to_write,buf_size/3);
            unsigned short *ptrd = buf._data;
            for (unsigned long i = N; i>0; --i) {
              *(ptrd++) = (unsigned short)*(ptr_r++);
              *(ptrd++) = (unsigned short)*(ptr_g++);
              *(ptrd++) = 0;
            }
            if (!cimg::endianness()) cimg::invert_endianness(buf._data,buf_size);
            cimg::fwrite(buf._data,3*N,nfile);
            to_write-=N;
          }
        }
      } break;
      default : {
        if (bytes_per_pixel==1 || (!bytes_per_pixel && stmax<256)) {
          CImg<ucharT> buf(buf_size);
          for (long to_write = (long)_width*_height; to_write>0; ) {
            const unsigned long N = cimg::min((unsigned long)to_write,buf_size/3);
            unsigned char *ptrd = buf._data;
            for (unsigned long i = N; i>0; --i) {
              *(ptrd++) = (unsigned char)*(ptr_r++);
              *(ptrd++) = (unsigned char)*(ptr_g++);
              *(ptrd++) = (unsigned char)*(ptr_b++);
            }
            cimg::fwrite(buf._data,3*N,nfile);
            to_write-=N;
          }
        } else {
          CImg<ushortT> buf(buf_size);
          for (long to_write = (long)_width*_height; to_write>0; ) {
            const unsigned long N = cimg::min((unsigned long)to_write,buf_size/3);
            unsigned short *ptrd = buf._data;
            for (unsigned long i = N; i>0; --i) {
              *(ptrd++) = (unsigned short)*(ptr_r++);
              *(ptrd++) = (unsigned short)*(ptr_g++);
              *(ptrd++) = (unsigned short)*(ptr_b++);
            }
            if (!cimg::endianness()) cimg::invert_endianness(buf._data,buf_size);
            cimg::fwrite(buf._data,3*N,nfile);
            to_write-=N;
          }
        }
      }
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    const CImg<T>& save_pnk(const char *const filename) const {
      return _save_pnk(0,filename);
    }


    const CImg<T>& save_pnk(std::FILE *const file) const {
      return _save_pnk(file,0);
    }

    const CImg<T>& _save_pnk(std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_pnk(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }
      if (_spectrum>1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_pnk(): Instance is multispectral, only the first channel will be saved in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");

      const unsigned long buf_size = cimg::min(1024*1024LU,_width*_height*_depth);
      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      const T *ptr = data(0,0,0,0);

      if (!cimg::type<T>::is_float() && sizeof(T)==1 && _depth<2)
        _save_pnm(file,filename,0);
      else if (!cimg::type<T>::is_float() && sizeof(T)==1) {
        std::fprintf(nfile,"P5\n%u %u %u\n255\n",_width,_height,_depth);
        CImg<ucharT> buf(buf_size);
        for (long to_write = (long)_width*_height*_depth; to_write>0; ) {
          const unsigned long N = cimg::min((unsigned long)to_write,buf_size);
          unsigned char *ptrd = buf._data;
          for (unsigned long i = N; i>0; --i) *(ptrd++) = (unsigned char)*(ptr++);
          cimg::fwrite(buf._data,N,nfile);
          to_write-=N;
        }
      } else if (!cimg::type<T>::is_float()) {
        if (_depth>1) std::fprintf(nfile,"P8\n%u %u %u\n%d\n",_width,_height,_depth,(int)max());
        else std::fprintf(nfile,"P8\n%u %u\n%d\n",_width,_height,(int)max());
        CImg<intT> buf(buf_size);
        for (long to_write = (long)_width*_height*_depth; to_write>0; ) {
          const unsigned long N = cimg::min((unsigned long)to_write,buf_size);
          int *ptrd = buf._data;
          for (unsigned long i = N; i>0; --i) *(ptrd++) = (int)*(ptr++);
          cimg::fwrite(buf._data,N,nfile);
          to_write-=N;
        }
      } else {
        if (_depth>1) std::fprintf(nfile,"P9\n%u %u %u\n%g\n",_width,_height,_depth,(double)max());
        else std::fprintf(nfile,"P9\n%u %u\n%g\n",_width,_height,(double)max());
        CImg<floatT> buf(buf_size);
        for (long to_write = (long)_width*_height*_depth; to_write>0; ) {
          const unsigned long N = cimg::min((unsigned long)to_write,buf_size);
          float *ptrd = buf._data;
          for (unsigned long i = N; i>0; --i) *(ptrd++) = (float)*(ptr++);
          cimg::fwrite(buf._data,N,nfile);
          to_write-=N;
        }
      }

      if (!file) cimg::fclose(nfile);
      return *this;
    }





    const CImg<T>& save_pfm(const char *const filename) const {
      return get_mirror('y')._save_pfm(0,filename);
    }


    const CImg<T>& save_pfm(std::FILE *const file) const {
      return get_mirror('y')._save_pfm(file,0);
    }

    const CImg<T>& _save_pfm(std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_pfm(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }
      if (_depth>1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_pfm(): Instance is volumetric, only the first slice will be saved in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");
      if (_spectrum>3)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_pfm(): image instance is multispectral, only the three first channels will be saved "
                   "in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      const T
        *ptr_r = data(0,0,0,0),
        *ptr_g = (_spectrum>=2)?data(0,0,0,1):0,
        *ptr_b = (_spectrum>=3)?data(0,0,0,2):0;
      const unsigned int buf_size = cimg::min(1024*1024U,_width*_height*(_spectrum==1?1:3));

      std::fprintf(nfile,"P%c\n%u %u\n1.0\n",
                   (_spectrum==1?'f':'F'),_width,_height);

      switch (_spectrum) {
      case 1 : {
        CImg<floatT> buf(buf_size);
        for (long to_write = (long)_width*_height; to_write>0; ) {
          const unsigned long N = cimg::min((unsigned long)to_write,buf_size);
          float *ptrd = buf._data;
          for (unsigned long i = N; i>0; --i) *(ptrd++) = (float)*(ptr_r++);
          if (!cimg::endianness()) cimg::invert_endianness(buf._data,buf_size);
          cimg::fwrite(buf._data,N,nfile);
          to_write-=N;
        }
      } break;
      case 2 : {
        CImg<floatT> buf(buf_size);
        for (long to_write = (long)_width*_height; to_write>0; ) {
          const unsigned int N = cimg::min((unsigned int)to_write,buf_size/3);
          float *ptrd = buf._data;
          for (unsigned long i = N; i>0; --i) {
            *(ptrd++) = (float)*(ptr_r++);
            *(ptrd++) = (float)*(ptr_g++);
            *(ptrd++) = 0;
          }
          if (!cimg::endianness()) cimg::invert_endianness(buf._data,buf_size);
          cimg::fwrite(buf._data,3*N,nfile);
          to_write-=N;
        }
      } break;
      default : {
        CImg<floatT> buf(buf_size);
        for (long to_write = (long)_width*_height; to_write>0; ) {
          const unsigned int N = cimg::min((unsigned int)to_write,buf_size/3);
          float *ptrd = buf._data;
          for (unsigned long i = N; i>0; --i) {
            *(ptrd++) = (float)*(ptr_r++);
            *(ptrd++) = (float)*(ptr_g++);
            *(ptrd++) = (float)*(ptr_b++);
          }
          if (!cimg::endianness()) cimg::invert_endianness(buf._data,buf_size);
          cimg::fwrite(buf._data,3*N,nfile);
          to_write-=N;
        }
      }
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    const CImg<T>& save_rgb(const char *const filename) const {
      return _save_rgb(0,filename);
    }


    const CImg<T>& save_rgb(std::FILE *const file) const {
      return _save_rgb(file,0);
    }

    const CImg<T>& _save_rgb(std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_rgb(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }
      if (_spectrum!=3)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_rgb(): image instance has not exactly 3 channels, for file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      const unsigned long wh = (unsigned long)_width*_height;
      unsigned char *const buffer = new unsigned char[3*wh], *nbuffer = buffer;
      const T
        *ptr1 = data(0,0,0,0),
        *ptr2 = _spectrum>1?data(0,0,0,1):0,
        *ptr3 = _spectrum>2?data(0,0,0,2):0;
      switch (_spectrum) {
      case 1 : {
        for (unsigned long k = 0; k<wh; ++k) {
          const unsigned char val = (unsigned char)*(ptr1++);
          *(nbuffer++) = val;
          *(nbuffer++) = val;
          *(nbuffer++) = val;
        }
      } break;
      case 2 : {
        for (unsigned long k = 0; k<wh; ++k) {
          *(nbuffer++) = (unsigned char)(*(ptr1++));
          *(nbuffer++) = (unsigned char)(*(ptr2++));
          *(nbuffer++) = 0;
        }
      } break;
      default : {
        for (unsigned long k = 0; k<wh; ++k) {
          *(nbuffer++) = (unsigned char)(*(ptr1++));
          *(nbuffer++) = (unsigned char)(*(ptr2++));
          *(nbuffer++) = (unsigned char)(*(ptr3++));
        }
      }
      }
      cimg::fwrite(buffer,3*wh,nfile);
      if (!file) cimg::fclose(nfile);
      delete[] buffer;
      return *this;
    }





    const CImg<T>& save_rgba(const char *const filename) const {
      return _save_rgba(0,filename);
    }


    const CImg<T>& save_rgba(std::FILE *const file) const {
      return _save_rgba(file,0);
    }

    const CImg<T>& _save_rgba(std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_rgba(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }
      if (_spectrum!=4)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_rgba(): image instance has not exactly 4 channels, for file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      const unsigned long wh = (unsigned long)_width*_height;
      unsigned char *const buffer = new unsigned char[4*wh], *nbuffer = buffer;
      const T
        *ptr1 = data(0,0,0,0),
        *ptr2 = _spectrum>1?data(0,0,0,1):0,
        *ptr3 = _spectrum>2?data(0,0,0,2):0,
        *ptr4 = _spectrum>3?data(0,0,0,3):0;
      switch (_spectrum) {
      case 1 : {
        for (unsigned long k = 0; k<wh; ++k) {
          const unsigned char val = (unsigned char)*(ptr1++);
          *(nbuffer++) = val;
          *(nbuffer++) = val;
          *(nbuffer++) = val;
          *(nbuffer++) = 255;
        }
      } break;
      case 2 : {
        for (unsigned long k = 0; k<wh; ++k) {
          *(nbuffer++) = (unsigned char)(*(ptr1++));
          *(nbuffer++) = (unsigned char)(*(ptr2++));
          *(nbuffer++) = 0;
          *(nbuffer++) = 255;
        }
      } break;
      case 3 : {
        for (unsigned long k = 0; k<wh; ++k) {
          *(nbuffer++) = (unsigned char)(*(ptr1++));
          *(nbuffer++) = (unsigned char)(*(ptr2++));
          *(nbuffer++) = (unsigned char)(*(ptr3++));
          *(nbuffer++) = 255;
        }
      } break;
      default : {
        for (unsigned long k = 0; k<wh; ++k) {
          *(nbuffer++) = (unsigned char)(*(ptr1++));
          *(nbuffer++) = (unsigned char)(*(ptr2++));
          *(nbuffer++) = (unsigned char)(*(ptr3++));
          *(nbuffer++) = (unsigned char)(*(ptr4++));
        }
      }
      }
      cimg::fwrite(buffer,4*wh,nfile);
      if (!file) cimg::fclose(nfile);
      delete[] buffer;
      return *this;
    }
# 43267 "../src/CImg.h"
    const CImg<T>& save_tiff(const char *const filename, const unsigned int compression_type=0,
                             const float *const voxel_size=0, const char *const description=0) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_tiff(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }
# 43286 "../src/CImg.h"
      cimg::unused(compression_type,voxel_size,description);
      return save_other(filename);

    }
# 43383 "../src/CImg.h"
    const CImg<T>& save_minc2(const char *const filename,
                              const char *const imitate_file=0) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                   "save_minc2(): Specified filename is (null).",
                                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }


     cimg::unused(imitate_file);
     return save_other(filename);
# 43417 "../src/CImg.h"
    }






    const CImg<T>& save_analyze(const char *const filename, const float *const voxel_size=0) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_analyze(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }

      std::FILE *file;
      char header[348] = { 0 }, hname[1024] = { 0 }, iname[1024] = { 0 };
      const char *const ext = cimg::split_filename(filename);
      short datatype=-1;
      std::memset(header,0,348);
      if (!*ext) {
        snprintf(hname,sizeof(hname),"%s.hdr",filename);
        snprintf(iname,sizeof(iname),"%s.img",filename);
      }
      if (!cimg::strncasecmp(ext,"hdr",3)) {
        std::strcpy(hname,filename);
        std::strncpy(iname,filename,sizeof(iname)-1);
        std::sprintf(iname + std::strlen(iname)-3,"img");
      }
      if (!cimg::strncasecmp(ext,"img",3)) {
        std::strcpy(hname,filename);
        std::strncpy(iname,filename,sizeof(iname)-1);
        std::sprintf(hname + std::strlen(iname)-3,"hdr");
      }
      if (!cimg::strncasecmp(ext,"nii",3)) {
        std::strncpy(hname,filename,sizeof(hname)-1); *iname = 0;
      }
      int *const iheader = (int*)header;
      *iheader = 348;
      std::strcpy(header + 4,"CImg");
      std::strcpy(header + 14," ");
      ((short*)(header + 36))[0] = 4096;
      ((char*)(header + 38))[0] = 114;
      ((short*)(header + 40))[0] = 4;
      ((short*)(header + 40))[1] = _width;
      ((short*)(header + 40))[2] = _height;
      ((short*)(header + 40))[3] = _depth;
      ((short*)(header + 40))[4] = _spectrum;
      if (!cimg::strcasecmp(pixel_type(),"bool")) datatype = 2;
      if (!cimg::strcasecmp(pixel_type(),"unsigned char")) datatype = 2;
      if (!cimg::strcasecmp(pixel_type(),"char")) datatype = 2;
      if (!cimg::strcasecmp(pixel_type(),"unsigned short")) datatype = 4;
      if (!cimg::strcasecmp(pixel_type(),"short")) datatype = 4;
      if (!cimg::strcasecmp(pixel_type(),"unsigned int")) datatype = 8;
      if (!cimg::strcasecmp(pixel_type(),"int")) datatype = 8;
      if (!cimg::strcasecmp(pixel_type(),"unsigned long")) datatype = 8;
      if (!cimg::strcasecmp(pixel_type(),"long")) datatype = 8;
      if (!cimg::strcasecmp(pixel_type(),"float")) datatype = 16;
      if (!cimg::strcasecmp(pixel_type(),"double")) datatype = 64;
      if (datatype<0)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "save_analyze(): Unsupported pixel type '%s' for file '%s'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              pixel_type(),filename);

      ((short*)(header+70))[0] = datatype;
      ((short*)(header+72))[0] = sizeof(T);
      ((float*)(header+112))[0] = 1;
      ((float*)(header+76))[0] = 0;
      if (voxel_size) {
        ((float*)(header+76))[1] = voxel_size[0];
        ((float*)(header+76))[2] = voxel_size[1];
        ((float*)(header+76))[3] = voxel_size[2];
      } else ((float*)(header+76))[1] = ((float*)(header+76))[2] = ((float*)(header+76))[3] = 1;
      file = cimg::fopen(hname,"wb");
      cimg::fwrite(header,348,file);
      if (*iname) { cimg::fclose(file); file = cimg::fopen(iname,"wb"); }
      cimg::fwrite(_data,size(),file);
      cimg::fclose(file);
      return *this;
    }






    const CImg<T>& save_cimg(const char *const filename, const bool is_compressed=false) const {
      CImgList<T>(*this,true).save_cimg(filename,is_compressed);
      return *this;
    }


    const CImg<T>& save_cimg(std::FILE *const file, const bool is_compressed=false) const {
      CImgList<T>(*this,true).save_cimg(file,is_compressed);
      return *this;
    }
# 43523 "../src/CImg.h"
    const CImg<T>& save_cimg(const char *const filename,
                             const unsigned int n0,
                             const unsigned int x0, const unsigned int y0,
                             const unsigned int z0, const unsigned int c0) const {
      CImgList<T>(*this,true).save_cimg(filename,n0,x0,y0,z0,c0);
      return *this;
    }


    const CImg<T>& save_cimg(std::FILE *const file,
                             const unsigned int n0,
                             const unsigned int x0, const unsigned int y0,
                             const unsigned int z0, const unsigned int c0) const {
      CImgList<T>(*this,true).save_cimg(file,n0,x0,y0,z0,c0);
      return *this;
    }
# 43551 "../src/CImg.h"
    static void save_empty_cimg(const char *const filename,
                                const unsigned int dx, const unsigned int dy=1,
                                const unsigned int dz=1, const unsigned int dc=1) {
      return CImgList<T>::save_empty_cimg(filename,1,dx,dy,dz,dc);
    }






    static void save_empty_cimg(std::FILE *const file,
                                const unsigned int dx, const unsigned int dy=1,
                                const unsigned int dz=1, const unsigned int dc=1) {
      return CImgList<T>::save_empty_cimg(file,1,dx,dy,dz,dc);
    }






    const CImg<T>& save_inr(const char *const filename, const float *const voxel_size=0) const {
      return _save_inr(0,filename,voxel_size);
    }


    const CImg<T>& save_inr(std::FILE *const file, const float *const voxel_size=0) const {
      return _save_inr(file,0,voxel_size);
    }

    const CImg<T>& _save_inr(std::FILE *const file, const char *const filename, const float *const voxel_size) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_inr(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }

      int inrpixsize=-1;
      const char *inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0";
      if (!cimg::strcasecmp(pixel_type(),"unsigned char")) {
        inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1;
      }
      if (!cimg::strcasecmp(pixel_type(),"char")) {
        inrtype = "fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1;
      }
      if (!cimg::strcasecmp(pixel_type(),"unsigned short")) {
        inrtype = "unsigned fixed\nPIXSIZE=16 bits\nSCALE=2**0";inrpixsize = 2;
      }
      if (!cimg::strcasecmp(pixel_type(),"short")) {
        inrtype = "fixed\nPIXSIZE=16 bits\nSCALE=2**0"; inrpixsize = 2;
      }
      if (!cimg::strcasecmp(pixel_type(),"unsigned int")) {
        inrtype = "unsigned fixed\nPIXSIZE=32 bits\nSCALE=2**0";inrpixsize = 4;
      }
      if (!cimg::strcasecmp(pixel_type(),"int")) {
        inrtype = "fixed\nPIXSIZE=32 bits\nSCALE=2**0"; inrpixsize = 4;
      }
      if (!cimg::strcasecmp(pixel_type(),"float")) {
        inrtype = "float\nPIXSIZE=32 bits"; inrpixsize = 4;
      }
      if (!cimg::strcasecmp(pixel_type(),"double")) {
        inrtype = "float\nPIXSIZE=64 bits"; inrpixsize = 8;
      }
      if (inrpixsize<=0)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "save_inr(): Unsupported pixel type '%s' for file '%s'",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              pixel_type(),filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      char header[257] = { 0 };
      int err = snprintf(header,sizeof(header),"#INRIMAGE-4#{\nXDIM=%u\nYDIM=%u\nZDIM=%u\nVDIM=%u\n",
                              _width,_height,_depth,_spectrum);
      if (voxel_size) err+=std::sprintf(header + err,"VX=%g\nVY=%g\nVZ=%g\n",voxel_size[0],voxel_size[1],voxel_size[2]);
      err+=std::sprintf(header + err,"TYPE=%s\nCPU=%s\n",inrtype,cimg::endianness()?"sun":"decm");
      std::memset(header + err,'\n',252 - err);
      std::memcpy(header + 252,"##}\n",4);
      cimg::fwrite(header,256,nfile);
      for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) for (int c = 0; c<(int)((*this)._spectrum); ++c) cimg::fwrite(&((*this)(x,y,z,c)),1,nfile);
      if (!file) cimg::fclose(nfile);
      return *this;
    }






    const CImg<T>& save_exr(const char *const filename) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_exr(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }
      if (_depth>1)
        cimg::warn("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                   "save_exr(): Instance is volumetric, only the first slice will be saved in file '%s'.",
                   _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                   filename);


      return save_other(filename);
# 43703 "../src/CImg.h"
    }
# 43712 "../src/CImg.h"
    const CImg<T>& save_pandore(const char *const filename, const unsigned int colorspace=0) const {
      return _save_pandore(0,filename,colorspace);
    }






    const CImg<T>& save_pandore(std::FILE *const file, const unsigned int colorspace=0) const {
      return _save_pandore(file,0,colorspace);
    }

    unsigned int _save_pandore_header_length(unsigned int id, unsigned int *dims, const unsigned int colorspace) const {
      unsigned int nbdims = 0;
      if (id==2 || id==3 || id==4) {
        dims[0] = 1; dims[1] = _width; nbdims = 2;
      }
      if (id==5 || id==6 || id==7) {
        dims[0] = 1; dims[1] = _height; dims[2] = _width; nbdims=3;
      }
      if (id==8 || id==9 || id==10) {
        dims[0] = _spectrum; dims[1] = _depth; dims[2] = _height; dims[3] = _width; nbdims = 4;
      }
      if (id==16 || id==17 || id==18) {
        dims[0] = 3; dims[1] = _height; dims[2] = _width; dims[3] = colorspace; nbdims = 4;
      }
      if (id==19 || id==20 || id==21) {
        dims[0] = 3; dims[1] = _depth; dims[2] = _height; dims[3] = _width; dims[4] = colorspace; nbdims = 5;
      }
      if (id==22 || id==23 || id==25) {
        dims[0] = _spectrum; dims[1] = _width; nbdims = 2;
      }
      if (id==26 || id==27 || id==29) {
        dims[0] = _spectrum; dims[1] = _height; dims[2] = _width; nbdims=3;
      }
      if (id==30 || id==31 || id==33) {
        dims[0] = _spectrum; dims[1] = _depth; dims[2] = _height; dims[3] = _width; nbdims = 4;
      }
      return nbdims;
    }

    const CImg<T>& _save_pandore(std::FILE *const file, const char *const filename,
                                 const unsigned int colorspace) const {
# 43802 "../src/CImg.h"
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_pandore(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      unsigned char header[36] = { 'P','A','N','D','O','R','E','0','4',0,0,0,
                                   0,0,0,0,'C','I','m','g',0,0,0,0,0,'N','o',' ','d','a','t','e',0,0,0,0 };
      unsigned int nbdims, dims[5] = { 0 };
      bool saved = false;
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=2),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (2==2 || 2==5 || 2==8 || 2==16 || 2==19 || 2==22 || 2==26 || 2==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (2==3 || 2==6 || 2==9 || 2==17 || 2==20 || 2==23 || 2==27 || 2==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (2==4 || 2==7 || 2==10 || 2==18 || 2==21 || 2==25 || 2==29 || 2==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=3),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (3==2 || 3==5 || 3==8 || 3==16 || 3==19 || 3==22 || 3==26 || 3==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (3==3 || 3==6 || 3==9 || 3==17 || 3==20 || 3==23 || 3==27 || 3==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (3==4 || 3==7 || 3==10 || 3==18 || 3==21 || 3==25 || 3==29 || 3==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=3),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (3==2 || 3==5 || 3==8 || 3==16 || 3==19 || 3==22 || 3==26 || 3==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (3==3 || 3==6 || 3==9 || 3==17 || 3==20 || 3==23 || 3==27 || 3==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (3==4 || 3==7 || 3==10 || 3==18 || 3==21 || 3==25 || 3==29 || 3==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=3),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (3==2 || 3==5 || 3==8 || 3==16 || 3==19 || 3==22 || 3==26 || 3==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (3==3 || 3==6 || 3==9 || 3==17 || 3==20 || 3==23 || 3==27 || 3==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (3==4 || 3==7 || 3==10 || 3==18 || 3==21 || 3==25 || 3==29 || 3==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=3),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (3==2 || 3==5 || 3==8 || 3==16 || 3==19 || 3==22 || 3==26 || 3==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (3==3 || 3==6 || 3==9 || 3==17 || 3==20 || 3==23 || 3==27 || 3==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (3==4 || 3==7 || 3==10 || 3==18 || 3==21 || 3==25 || 3==29 || 3==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=3),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (3==2 || 3==5 || 3==8 || 3==16 || 3==19 || 3==22 || 3==26 || 3==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (3==3 || 3==6 || 3==9 || 3==17 || 3==20 || 3==23 || 3==27 || 3==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (3==4 || 3==7 || 3==10 || 3==18 || 3==21 || 3==25 || 3==29 || 3==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=4),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (4==2 || 4==5 || 4==8 || 4==16 || 4==19 || 4==22 || 4==26 || 4==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (4==3 || 4==6 || 4==9 || 4==17 || 4==20 || 4==23 || 4==27 || 4==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (4==4 || 4==7 || 4==10 || 4==18 || 4==21 || 4==25 || 4==29 || 4==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=3),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (3==2 || 3==5 || 3==8 || 3==16 || 3==19 || 3==22 || 3==26 || 3==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (3==3 || 3==6 || 3==9 || 3==17 || 3==20 || 3==23 || 3==27 || 3==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (3==4 || 3==7 || 3==10 || 3==18 || 3==21 || 3==25 || 3==29 || 3==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("float",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=4),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (4==2 || 4==5 || 4==8 || 4==16 || 4==19 || 4==22 || 4==26 || 4==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (4==3 || 4==6 || 4==9 || 4==17 || 4==20 || 4==23 || 4==27 || 4==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (4==4 || 4==7 || 4==10 || 4==18 || 4==21 || 4==25 || 4==29 || 4==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("double",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=4),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (4==2 || 4==5 || 4==8 || 4==16 || 4==19 || 4==22 || 4==26 || 4==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (4==3 || 4==6 || 4==9 || 4==17 || 4==20 || 4==23 || 4==27 || 4==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (4==4 || 4==7 || 4==10 || 4==18 || 4==21 || 4==25 || 4==29 || 4==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };

      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=5),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (5==2 || 5==5 || 5==8 || 5==16 || 5==19 || 5==22 || 5==26 || 5==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (5==3 || 5==6 || 5==9 || 5==17 || 5==20 || 5==23 || 5==27 || 5==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (5==4 || 5==7 || 5==10 || 5==18 || 5==21 || 5==25 || 5==29 || 5==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=6),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (6==2 || 6==5 || 6==8 || 6==16 || 6==19 || 6==22 || 6==26 || 6==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (6==3 || 6==6 || 6==9 || 6==17 || 6==20 || 6==23 || 6==27 || 6==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (6==4 || 6==7 || 6==10 || 6==18 || 6==21 || 6==25 || 6==29 || 6==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=6),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (6==2 || 6==5 || 6==8 || 6==16 || 6==19 || 6==22 || 6==26 || 6==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (6==3 || 6==6 || 6==9 || 6==17 || 6==20 || 6==23 || 6==27 || 6==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (6==4 || 6==7 || 6==10 || 6==18 || 6==21 || 6==25 || 6==29 || 6==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=6),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (6==2 || 6==5 || 6==8 || 6==16 || 6==19 || 6==22 || 6==26 || 6==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (6==3 || 6==6 || 6==9 || 6==17 || 6==20 || 6==23 || 6==27 || 6==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (6==4 || 6==7 || 6==10 || 6==18 || 6==21 || 6==25 || 6==29 || 6==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=6),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (6==2 || 6==5 || 6==8 || 6==16 || 6==19 || 6==22 || 6==26 || 6==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (6==3 || 6==6 || 6==9 || 6==17 || 6==20 || 6==23 || 6==27 || 6==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (6==4 || 6==7 || 6==10 || 6==18 || 6==21 || 6==25 || 6==29 || 6==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=6),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (6==2 || 6==5 || 6==8 || 6==16 || 6==19 || 6==22 || 6==26 || 6==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (6==3 || 6==6 || 6==9 || 6==17 || 6==20 || 6==23 || 6==27 || 6==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (6==4 || 6==7 || 6==10 || 6==18 || 6==21 || 6==25 || 6==29 || 6==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=7),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (7==2 || 7==5 || 7==8 || 7==16 || 7==19 || 7==22 || 7==26 || 7==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (7==3 || 7==6 || 7==9 || 7==17 || 7==20 || 7==23 || 7==27 || 7==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (7==4 || 7==7 || 7==10 || 7==18 || 7==21 || 7==25 || 7==29 || 7==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=6),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (6==2 || 6==5 || 6==8 || 6==16 || 6==19 || 6==22 || 6==26 || 6==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (6==3 || 6==6 || 6==9 || 6==17 || 6==20 || 6==23 || 6==27 || 6==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (6==4 || 6==7 || 6==10 || 6==18 || 6==21 || 6==25 || 6==29 || 6==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("float",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=7),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (7==2 || 7==5 || 7==8 || 7==16 || 7==19 || 7==22 || 7==26 || 7==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (7==3 || 7==6 || 7==9 || 7==17 || 7==20 || 7==23 || 7==27 || 7==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (7==4 || 7==7 || 7==10 || 7==18 || 7==21 || 7==25 || 7==29 || 7==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("double",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=7),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (7==2 || 7==5 || 7==8 || 7==16 || 7==19 || 7==22 || 7==26 || 7==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (7==3 || 7==6 || 7==9 || 7==17 || 7==20 || 7==23 || 7==27 || 7==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (7==4 || 7==7 || 7==10 || 7==18 || 7==21 || 7==25 || 7==29 || 7==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };

      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=8),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (8==2 || 8==5 || 8==8 || 8==16 || 8==19 || 8==22 || 8==26 || 8==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (8==3 || 8==6 || 8==9 || 8==17 || 8==20 || 8==23 || 8==27 || 8==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (8==4 || 8==7 || 8==10 || 8==18 || 8==21 || 8==25 || 8==29 || 8==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=9),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (9==2 || 9==5 || 9==8 || 9==16 || 9==19 || 9==22 || 9==26 || 9==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (9==3 || 9==6 || 9==9 || 9==17 || 9==20 || 9==23 || 9==27 || 9==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (9==4 || 9==7 || 9==10 || 9==18 || 9==21 || 9==25 || 9==29 || 9==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=9),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (9==2 || 9==5 || 9==8 || 9==16 || 9==19 || 9==22 || 9==26 || 9==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (9==3 || 9==6 || 9==9 || 9==17 || 9==20 || 9==23 || 9==27 || 9==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (9==4 || 9==7 || 9==10 || 9==18 || 9==21 || 9==25 || 9==29 || 9==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=9),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (9==2 || 9==5 || 9==8 || 9==16 || 9==19 || 9==22 || 9==26 || 9==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (9==3 || 9==6 || 9==9 || 9==17 || 9==20 || 9==23 || 9==27 || 9==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (9==4 || 9==7 || 9==10 || 9==18 || 9==21 || 9==25 || 9==29 || 9==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=9),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (9==2 || 9==5 || 9==8 || 9==16 || 9==19 || 9==22 || 9==26 || 9==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (9==3 || 9==6 || 9==9 || 9==17 || 9==20 || 9==23 || 9==27 || 9==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (9==4 || 9==7 || 9==10 || 9==18 || 9==21 || 9==25 || 9==29 || 9==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=9),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (9==2 || 9==5 || 9==8 || 9==16 || 9==19 || 9==22 || 9==26 || 9==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (9==3 || 9==6 || 9==9 || 9==17 || 9==20 || 9==23 || 9==27 || 9==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (9==4 || 9==7 || 9==10 || 9==18 || 9==21 || 9==25 || 9==29 || 9==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("unsigned long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=10),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (10==2 || 10==5 || 10==8 || 10==16 || 10==19 || 10==22 || 10==26 || 10==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (10==3 || 10==6 || 10==9 || 10==17 || 10==20 || 10==23 || 10==27 || 10==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (10==4 || 10==7 || 10==10 || 10==18 || 10==21 || 10==25 || 10==29 || 10==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=9),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (9==2 || 9==5 || 9==8 || 9==16 || 9==19 || 9==22 || 9==26 || 9==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (9==3 || 9==6 || 9==9 || 9==17 || 9==20 || 9==23 || 9==27 || 9==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (9==4 || 9==7 || 9==10 || 9==18 || 9==21 || 9==25 || 9==29 || 9==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("float",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=10),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (10==2 || 10==5 || 10==8 || 10==16 || 10==19 || 10==22 || 10==26 || 10==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (10==3 || 10==6 || 10==9 || 10==17 || 10==20 || 10==23 || 10==27 || 10==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (10==4 || 10==7 || 10==10 || 10==18 || 10==21 || 10==25 || 10==29 || 10==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (1?(1==_spectrum):true) && !std::strcmp("double",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=10),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (10==2 || 10==5 || 10==8 || 10==16 || 10==19 || 10==22 || 10==26 || 10==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (10==3 || 10==6 || 10==9 || 10==17 || 10==20 || 10==23 || 10==27 || 10==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (10==4 || 10==7 || 10==10 || 10==18 || 10==21 || 10==25 || 10==29 || 10==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };

      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("unsigned char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=16),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (16==2 || 16==5 || 16==8 || 16==16 || 16==19 || 16==22 || 16==26 || 16==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (16==3 || 16==6 || 16==9 || 16==17 || 16==20 || 16==23 || 16==27 || 16==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (16==4 || 16==7 || 16==10 || 16==18 || 16==21 || 16==25 || 16==29 || 16==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=17),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (17==2 || 17==5 || 17==8 || 17==16 || 17==19 || 17==22 || 17==26 || 17==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (17==3 || 17==6 || 17==9 || 17==17 || 17==20 || 17==23 || 17==27 || 17==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (17==4 || 17==7 || 17==10 || 17==18 || 17==21 || 17==25 || 17==29 || 17==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=17),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (17==2 || 17==5 || 17==8 || 17==16 || 17==19 || 17==22 || 17==26 || 17==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (17==3 || 17==6 || 17==9 || 17==17 || 17==20 || 17==23 || 17==27 || 17==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (17==4 || 17==7 || 17==10 || 17==18 || 17==21 || 17==25 || 17==29 || 17==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("unsigned short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=17),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (17==2 || 17==5 || 17==8 || 17==16 || 17==19 || 17==22 || 17==26 || 17==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (17==3 || 17==6 || 17==9 || 17==17 || 17==20 || 17==23 || 17==27 || 17==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (17==4 || 17==7 || 17==10 || 17==18 || 17==21 || 17==25 || 17==29 || 17==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("unsigned int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=17),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (17==2 || 17==5 || 17==8 || 17==16 || 17==19 || 17==22 || 17==26 || 17==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (17==3 || 17==6 || 17==9 || 17==17 || 17==20 || 17==23 || 17==27 || 17==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (17==4 || 17==7 || 17==10 || 17==18 || 17==21 || 17==25 || 17==29 || 17==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=17),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (17==2 || 17==5 || 17==8 || 17==16 || 17==19 || 17==22 || 17==26 || 17==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (17==3 || 17==6 || 17==9 || 17==17 || 17==20 || 17==23 || 17==27 || 17==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (17==4 || 17==7 || 17==10 || 17==18 || 17==21 || 17==25 || 17==29 || 17==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("unsigned long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=18),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (18==2 || 18==5 || 18==8 || 18==16 || 18==19 || 18==22 || 18==26 || 18==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (18==3 || 18==6 || 18==9 || 18==17 || 18==20 || 18==23 || 18==27 || 18==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (18==4 || 18==7 || 18==10 || 18==18 || 18==21 || 18==25 || 18==29 || 18==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=17),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (17==2 || 17==5 || 17==8 || 17==16 || 17==19 || 17==22 || 17==26 || 17==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (17==3 || 17==6 || 17==9 || 17==17 || 17==20 || 17==23 || 17==27 || 17==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (17==4 || 17==7 || 17==10 || 17==18 || 17==21 || 17==25 || 17==29 || 17==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("float",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=18),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (18==2 || 18==5 || 18==8 || 18==16 || 18==19 || 18==22 || 18==26 || 18==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (18==3 || 18==6 || 18==9 || 18==17 || 18==20 || 18==23 || 18==27 || 18==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (18==4 || 18==7 || 18==10 || 18==18 || 18==21 || 18==25 || 18==29 || 18==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("double",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=18),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (18==2 || 18==5 || 18==8 || 18==16 || 18==19 || 18==22 || 18==26 || 18==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (18==3 || 18==6 || 18==9 || 18==17 || 18==20 || 18==23 || 18==27 || 18==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (18==4 || 18==7 || 18==10 || 18==18 || 18==21 || 18==25 || 18==29 || 18==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };

      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("unsigned char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=19),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (19==2 || 19==5 || 19==8 || 19==16 || 19==19 || 19==22 || 19==26 || 19==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (19==3 || 19==6 || 19==9 || 19==17 || 19==20 || 19==23 || 19==27 || 19==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (19==4 || 19==7 || 19==10 || 19==18 || 19==21 || 19==25 || 19==29 || 19==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=20),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (20==2 || 20==5 || 20==8 || 20==16 || 20==19 || 20==22 || 20==26 || 20==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (20==3 || 20==6 || 20==9 || 20==17 || 20==20 || 20==23 || 20==27 || 20==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (20==4 || 20==7 || 20==10 || 20==18 || 20==21 || 20==25 || 20==29 || 20==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=20),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (20==2 || 20==5 || 20==8 || 20==16 || 20==19 || 20==22 || 20==26 || 20==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (20==3 || 20==6 || 20==9 || 20==17 || 20==20 || 20==23 || 20==27 || 20==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (20==4 || 20==7 || 20==10 || 20==18 || 20==21 || 20==25 || 20==29 || 20==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("unsigned short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=20),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (20==2 || 20==5 || 20==8 || 20==16 || 20==19 || 20==22 || 20==26 || 20==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (20==3 || 20==6 || 20==9 || 20==17 || 20==20 || 20==23 || 20==27 || 20==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (20==4 || 20==7 || 20==10 || 20==18 || 20==21 || 20==25 || 20==29 || 20==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("unsigned int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=20),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (20==2 || 20==5 || 20==8 || 20==16 || 20==19 || 20==22 || 20==26 || 20==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (20==3 || 20==6 || 20==9 || 20==17 || 20==20 || 20==23 || 20==27 || 20==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (20==4 || 20==7 || 20==10 || 20==18 || 20==21 || 20==25 || 20==29 || 20==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=20),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (20==2 || 20==5 || 20==8 || 20==16 || 20==19 || 20==22 || 20==26 || 20==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (20==3 || 20==6 || 20==9 || 20==17 || 20==20 || 20==23 || 20==27 || 20==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (20==4 || 20==7 || 20==10 || 20==18 || 20==21 || 20==25 || 20==29 || 20==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("unsigned long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=21),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (21==2 || 21==5 || 21==8 || 21==16 || 21==19 || 21==22 || 21==26 || 21==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (21==3 || 21==6 || 21==9 || 21==17 || 21==20 || 21==23 || 21==27 || 21==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (21==4 || 21==7 || 21==10 || 21==18 || 21==21 || 21==25 || 21==29 || 21==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=20),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (20==2 || 20==5 || 20==8 || 20==16 || 20==19 || 20==22 || 20==26 || 20==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (20==3 || 20==6 || 20==9 || 20==17 || 20==20 || 20==23 || 20==27 || 20==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (20==4 || 20==7 || 20==10 || 20==18 || 20==21 || 20==25 || 20==29 || 20==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("float",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=21),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (21==2 || 21==5 || 21==8 || 21==16 || 21==19 || 21==22 || 21==26 || 21==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (21==3 || 21==6 || 21==9 || 21==17 || 21==20 || 21==23 || 21==27 || 21==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (21==4 || 21==7 || 21==10 || 21==18 || 21==21 || 21==25 || 21==29 || 21==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (3?(3==_spectrum):true) && !std::strcmp("double",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=21),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (21==2 || 21==5 || 21==8 || 21==16 || 21==19 || 21==22 || 21==26 || 21==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (21==3 || 21==6 || 21==9 || 21==17 || 21==20 || 21==23 || 21==27 || 21==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (21==4 || 21==7 || 21==10 || 21==18 || 21==21 || 21==25 || 21==29 || 21==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };

      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=22),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (22==2 || 22==5 || 22==8 || 22==16 || 22==19 || 22==22 || 22==26 || 22==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (22==3 || 22==6 || 22==9 || 22==17 || 22==20 || 22==23 || 22==27 || 22==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (22==4 || 22==7 || 22==10 || 22==18 || 22==21 || 22==25 || 22==29 || 22==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=23),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (23==2 || 23==5 || 23==8 || 23==16 || 23==19 || 23==22 || 23==26 || 23==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (23==3 || 23==6 || 23==9 || 23==17 || 23==20 || 23==23 || 23==27 || 23==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (23==4 || 23==7 || 23==10 || 23==18 || 23==21 || 23==25 || 23==29 || 23==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=23),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (23==2 || 23==5 || 23==8 || 23==16 || 23==19 || 23==22 || 23==26 || 23==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (23==3 || 23==6 || 23==9 || 23==17 || 23==20 || 23==23 || 23==27 || 23==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (23==4 || 23==7 || 23==10 || 23==18 || 23==21 || 23==25 || 23==29 || 23==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=23),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (23==2 || 23==5 || 23==8 || 23==16 || 23==19 || 23==22 || 23==26 || 23==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (23==3 || 23==6 || 23==9 || 23==17 || 23==20 || 23==23 || 23==27 || 23==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (23==4 || 23==7 || 23==10 || 23==18 || 23==21 || 23==25 || 23==29 || 23==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=23),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (23==2 || 23==5 || 23==8 || 23==16 || 23==19 || 23==22 || 23==26 || 23==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (23==3 || 23==6 || 23==9 || 23==17 || 23==20 || 23==23 || 23==27 || 23==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (23==4 || 23==7 || 23==10 || 23==18 || 23==21 || 23==25 || 23==29 || 23==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=23),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (23==2 || 23==5 || 23==8 || 23==16 || 23==19 || 23==22 || 23==26 || 23==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (23==3 || 23==6 || 23==9 || 23==17 || 23==20 || 23==23 || 23==27 || 23==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (23==4 || 23==7 || 23==10 || 23==18 || 23==21 || 23==25 || 23==29 || 23==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=25),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (25==2 || 25==5 || 25==8 || 25==16 || 25==19 || 25==22 || 25==26 || 25==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (25==3 || 25==6 || 25==9 || 25==17 || 25==20 || 25==23 || 25==27 || 25==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (25==4 || 25==7 || 25==10 || 25==18 || 25==21 || 25==25 || 25==29 || 25==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=23),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (23==2 || 23==5 || 23==8 || 23==16 || 23==19 || 23==22 || 23==26 || 23==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (23==3 || 23==6 || 23==9 || 23==17 || 23==20 || 23==23 || 23==27 || 23==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (23==4 || 23==7 || 23==10 || 23==18 || 23==21 || 23==25 || 23==29 || 23==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("float",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=25),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (25==2 || 25==5 || 25==8 || 25==16 || 25==19 || 25==22 || 25==26 || 25==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (25==3 || 25==6 || 25==9 || 25==17 || 25==20 || 25==23 || 25==27 || 25==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (25==4 || 25==7 || 25==10 || 25==18 || 25==21 || 25==25 || 25==29 || 25==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (1?(1==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("double",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=25),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (25==2 || 25==5 || 25==8 || 25==16 || 25==19 || 25==22 || 25==26 || 25==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (25==3 || 25==6 || 25==9 || 25==17 || 25==20 || 25==23 || 25==27 || 25==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (25==4 || 25==7 || 25==10 || 25==18 || 25==21 || 25==25 || 25==29 || 25==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };

      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=26),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (26==2 || 26==5 || 26==8 || 26==16 || 26==19 || 26==22 || 26==26 || 26==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (26==3 || 26==6 || 26==9 || 26==17 || 26==20 || 26==23 || 26==27 || 26==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (26==4 || 26==7 || 26==10 || 26==18 || 26==21 || 26==25 || 26==29 || 26==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=27),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (27==2 || 27==5 || 27==8 || 27==16 || 27==19 || 27==22 || 27==26 || 27==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (27==3 || 27==6 || 27==9 || 27==17 || 27==20 || 27==23 || 27==27 || 27==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (27==4 || 27==7 || 27==10 || 27==18 || 27==21 || 27==25 || 27==29 || 27==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=27),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (27==2 || 27==5 || 27==8 || 27==16 || 27==19 || 27==22 || 27==26 || 27==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (27==3 || 27==6 || 27==9 || 27==17 || 27==20 || 27==23 || 27==27 || 27==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (27==4 || 27==7 || 27==10 || 27==18 || 27==21 || 27==25 || 27==29 || 27==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=27),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (27==2 || 27==5 || 27==8 || 27==16 || 27==19 || 27==22 || 27==26 || 27==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (27==3 || 27==6 || 27==9 || 27==17 || 27==20 || 27==23 || 27==27 || 27==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (27==4 || 27==7 || 27==10 || 27==18 || 27==21 || 27==25 || 27==29 || 27==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=27),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (27==2 || 27==5 || 27==8 || 27==16 || 27==19 || 27==22 || 27==26 || 27==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (27==3 || 27==6 || 27==9 || 27==17 || 27==20 || 27==23 || 27==27 || 27==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (27==4 || 27==7 || 27==10 || 27==18 || 27==21 || 27==25 || 27==29 || 27==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=27),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (27==2 || 27==5 || 27==8 || 27==16 || 27==19 || 27==22 || 27==26 || 27==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (27==3 || 27==6 || 27==9 || 27==17 || 27==20 || 27==23 || 27==27 || 27==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (27==4 || 27==7 || 27==10 || 27==18 || 27==21 || 27==25 || 27==29 || 27==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=29),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (29==2 || 29==5 || 29==8 || 29==16 || 29==19 || 29==22 || 29==26 || 29==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (29==3 || 29==6 || 29==9 || 29==17 || 29==20 || 29==23 || 29==27 || 29==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (29==4 || 29==7 || 29==10 || 29==18 || 29==21 || 29==25 || 29==29 || 29==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=27),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (27==2 || 27==5 || 27==8 || 27==16 || 27==19 || 27==22 || 27==26 || 27==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (27==3 || 27==6 || 27==9 || 27==17 || 27==20 || 27==23 || 27==27 || 27==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (27==4 || 27==7 || 27==10 || 27==18 || 27==21 || 27==25 || 27==29 || 27==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("float",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=29),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (29==2 || 29==5 || 29==8 || 29==16 || 29==19 || 29==22 || 29==26 || 29==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (29==3 || 29==6 || 29==9 || 29==17 || 29==20 || 29==23 || 29==27 || 29==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (29==4 || 29==7 || 29==10 || 29==18 || 29==21 || 29==25 || 29==29 || 29==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (1?(1==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("double",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=29),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (29==2 || 29==5 || 29==8 || 29==16 || 29==19 || 29==22 || 29==26 || 29==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (29==3 || 29==6 || 29==9 || 29==17 || 29==20 || 29==23 || 29==27 || 29==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (29==4 || 29==7 || 29==10 || 29==18 || 29==21 || 29==25 || 29==29 || 29==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };

      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=30),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (30==2 || 30==5 || 30==8 || 30==16 || 30==19 || 30==22 || 30==26 || 30==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (30==3 || 30==6 || 30==9 || 30==17 || 30==20 || 30==23 || 30==27 || 30==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (30==4 || 30==7 || 30==10 || 30==18 || 30==21 || 30==25 || 30==29 || 30==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("char",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=31),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (31==2 || 31==5 || 31==8 || 31==16 || 31==19 || 31==22 || 31==26 || 31==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (31==3 || 31==6 || 31==9 || 31==17 || 31==20 || 31==23 || 31==27 || 31==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (31==4 || 31==7 || 31==10 || 31==18 || 31==21 || 31==25 || 31==29 || 31==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=31),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (31==2 || 31==5 || 31==8 || 31==16 || 31==19 || 31==22 || 31==26 || 31==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (31==3 || 31==6 || 31==9 || 31==17 || 31==20 || 31==23 || 31==27 || 31==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (31==4 || 31==7 || 31==10 || 31==18 || 31==21 || 31==25 || 31==29 || 31==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned short",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=31),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (31==2 || 31==5 || 31==8 || 31==16 || 31==19 || 31==22 || 31==26 || 31==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (31==3 || 31==6 || 31==9 || 31==17 || 31==20 || 31==23 || 31==27 || 31==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (31==4 || 31==7 || 31==10 || 31==18 || 31==21 || 31==25 || 31==29 || 31==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=31),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (31==2 || 31==5 || 31==8 || 31==16 || 31==19 || 31==22 || 31==26 || 31==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (31==3 || 31==6 || 31==9 || 31==17 || 31==20 || 31==23 || 31==27 || 31==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (31==4 || 31==7 || 31==10 || 31==18 || 31==21 || 31==25 || 31==29 || 31==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("int",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=31),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (31==2 || 31==5 || 31==8 || 31==16 || 31==19 || 31==22 || 31==26 || 31==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (31==3 || 31==6 || 31==9 || 31==17 || 31==20 || 31==23 || 31==27 || 31==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (31==4 || 31==7 || 31==10 || 31==18 || 31==21 || 31==25 || 31==29 || 31==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("unsigned long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=33),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (33==2 || 33==5 || 33==8 || 33==16 || 33==19 || 33==22 || 33==26 || 33==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (33==3 || 33==6 || 33==9 || 33==17 || 33==20 || 33==23 || 33==27 || 33==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (33==4 || 33==7 || 33==10 || 33==18 || 33==21 || 33==25 || 33==29 || 33==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("long",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=31),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (31==2 || 31==5 || 31==8 || 31==16 || 31==19 || 31==22 || 31==26 || 31==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (31==3 || 31==6 || 31==9 || 31==17 || 31==20 || 31==23 || 31==27 || 31==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (31==4 || 31==7 || 31==10 || 31==18 || 31==21 || 31==25 || 31==29 || 31==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("float",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=33),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (33==2 || 33==5 || 33==8 || 33==16 || 33==19 || 33==22 || 33==26 || 33==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (33==3 || 33==6 || 33==9 || 33==17 || 33==20 || 33==23 || 33==27 || 33==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (33==4 || 33==7 || 33==10 || 33==18 || 33==21 || 33==25 || 33==29 || 33==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };
      if (!saved && (0?(0==_height):true) && (0?(0==_depth):true) && (0?(0==_spectrum):true) && !std::strcmp("double",pixel_type())) { unsigned int *iheader = (unsigned int*)(header+12); nbdims = _save_pandore_header_length((*iheader=33),dims,colorspace); cimg::fwrite(header,36,nfile); if (sizeof(unsigned long)==4) { unsigned long ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned long)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned int)==4) { unsigned int ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned int)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else if (sizeof(unsigned short)==4) { unsigned short ndims[5] = { 0 }; for (int d = 0; d<5; ++d) ndims[d] = (unsigned short)dims[d]; cimg::fwrite(ndims,nbdims,nfile); } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); if (33==2 || 33==5 || 33==8 || 33==16 || 33==19 || 33==22 || 33==26 || 33==30) { unsigned char *buffer = new unsigned char[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned char)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (33==3 || 33==6 || 33==9 || 33==17 || 33==20 || 33==23 || 33==27 || 33==31) { if (sizeof(unsigned long)==4) { unsigned long *buffer = new unsigned long[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned long)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned int)==4) { unsigned int *buffer = new unsigned int[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned int)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(unsigned short)==4) { unsigned short *buffer = new unsigned short[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (unsigned short)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } else if (33==4 || 33==7 || 33==10 || 33==18 || 33==21 || 33==25 || 33==29 || 33==33) { if (sizeof(double)==4) { double *buffer = new double[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (double)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else if (sizeof(float)==4) { float *buffer = new float[size()]; const T *ptrs = _data; for (unsigned long off = 0, _maxoff = (*this).size(); off<_maxoff; ++off) *(buffer++) = (float)(*(ptrs++)); buffer-=size(); cimg::fwrite(buffer,size(),nfile); delete[] buffer; } else throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::" "save_pandore(): Unsupported datatype for file '%s'.", _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(), filename?filename:"(FILE*)"); } saved = true; };

      if (!file) cimg::fclose(nfile);
      return *this;
    }
# 43912 "../src/CImg.h"
    const CImg<T>& save_raw(const char *const filename, const bool is_multiplexed=false) const {
      return _save_raw(0,filename,is_multiplexed);
    }






    const CImg<T>& save_raw(std::FILE *const file, const bool is_multiplexed=false) const {
      return _save_raw(file,0,is_multiplexed);
    }

    const CImg<T>& _save_raw(std::FILE *const file, const char *const filename, const bool is_multiplexed) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_raw(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      if (!is_multiplexed) cimg::fwrite(_data,size(),nfile);
      else {
        CImg<T> buf(_spectrum);
        for (int z = 0; z<(int)((*this)._depth); ++z) for (int y = 0; y<(int)((*this)._height); ++y) for (int x = 0; x<(int)((*this)._width); ++x) {
          for (int c = 0; c<(int)((*this)._spectrum); ++c) buf[c] = (*this)(x,y,z,c);
          cimg::fwrite(buf._data,_spectrum,nfile);
        }
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }
# 43957 "../src/CImg.h"
    const CImg<T>& save_ffmpeg(const char *const filename, const unsigned int fps=25,
                               const unsigned int bitrate=2048) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_ffmpeg(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (!fps)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_ffmpeg(): Invalid specified framerate 0, for file '%s'.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    filename);
      if (is_empty()) { cimg::fempty(0,filename); return *this; }


      return save_ffmpeg_external(filename,0,fps,bitrate);






    }







    const CImg<T>& save_yuv(const char *const filename, const bool is_rgb=true) const {
      get_split('z').save_yuv(filename,is_rgb);
      return *this;
    }






    const CImg<T>& save_yuv(std::FILE *const file, const bool is_rgb=true) const {
      get_split('z').save_yuv(file,is_rgb);
      return *this;
    }
# 44012 "../src/CImg.h"
    template<typename tf, typename tc>
    const CImg<T>& save_off(const CImgList<tf>& primitives, const CImgList<tc>& colors,
                            const char *const filename) const {
      return _save_off(primitives,colors,0,filename);
    }






    template<typename tf, typename tc>
    const CImg<T>& save_off(const CImgList<tf>& primitives, const CImgList<tc>& colors,
                            std::FILE *const file) const {
      return _save_off(primitives,colors,file,0);
    }

    template<typename tf, typename tc>
    const CImg<T>& _save_off(const CImgList<tf>& primitives, const CImgList<tc>& colors,
                             std::FILE *const file, const char *const filename) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_off(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_off(): Empty instance, for file '%s'.",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    filename?filename:"(FILE*)");

      CImgList<T> opacities;
      char error_message[1024] = { 0 };
      if (!is_object3d(primitives,colors,opacities,true,error_message))
        throw CImgInstanceException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_off(): Invalid specified 3d object, for file '%s' (%s).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                    filename?filename:"(FILE*)",error_message);

      const CImg<tc> default_color(1,3,1,1,200);
      std::FILE *const nfile = file?file:cimg::fopen(filename,"w");
      unsigned int supported_primitives = 0;
      for (int l = 0; l<(int)(primitives)._width; ++l) if (primitives[l].size()!=5) ++supported_primitives;
      std::fprintf(nfile,"OFF\n%u %u %u\n",_width,supported_primitives,3*primitives._width);
      for (int i = 0; i<(int)((*this)._width); ++i) std::fprintf(nfile,"%f %f %f\n",
                                      (float)((*this)(i,0)),(float)((*this)(i,1)),(float)((*this)(i,2)));
      for (int l = 0; l<(int)(primitives)._width; ++l) {
        const CImg<tc>& color = l<colors.width()?colors[l]:default_color;
        const unsigned int psiz = primitives[l].size(), csiz = color.size();
        const float r = color[0]/255.0f, g = (csiz>1?color[1]:r)/255.0f, b = (csiz>2?color[2]:g)/255.0f;
        switch (psiz) {
        case 1 : std::fprintf(nfile,"1 %u %f %f %f\n",
                              (unsigned int)primitives(l,0),r,g,b); break;
        case 2 : std::fprintf(nfile,"2 %u %u %f %f %f\n",
                              (unsigned int)primitives(l,0),(unsigned int)primitives(l,1),r,g,b); break;
        case 3 : std::fprintf(nfile,"3 %u %u %u %f %f %f\n",
                              (unsigned int)primitives(l,0),(unsigned int)primitives(l,2),
                              (unsigned int)primitives(l,1),r,g,b); break;
        case 4 : std::fprintf(nfile,"4 %u %u %u %u %f %f %f\n",
                              (unsigned int)primitives(l,0),(unsigned int)primitives(l,3),
                              (unsigned int)primitives(l,2),(unsigned int)primitives(l,1),r,g,b); break;
        case 5 : std::fprintf(nfile,"2 %u %u %f %f %f\n",
                              (unsigned int)primitives(l,0),(unsigned int)primitives(l,1),r,g,b); break;
        case 6 : {
          const unsigned int xt = (unsigned int)primitives(l,2), yt = (unsigned int)primitives(l,3);
          const float
            rt = color.atXY(xt,yt,0)/255.0f,
            gt = (csiz>1?color.atXY(xt,yt,1):r)/255.0f,
            bt = (csiz>2?color.atXY(xt,yt,2):g)/255.0f;
          std::fprintf(nfile,"2 %u %u %f %f %f\n",
                       (unsigned int)primitives(l,0),(unsigned int)primitives(l,1),rt,gt,bt);
        } break;
        case 9 : {
          const unsigned int xt = (unsigned int)primitives(l,3), yt = (unsigned int)primitives(l,4);
          const float
            rt = color.atXY(xt,yt,0)/255.0f,
            gt = (csiz>1?color.atXY(xt,yt,1):r)/255.0f,
            bt = (csiz>2?color.atXY(xt,yt,2):g)/255.0f;
          std::fprintf(nfile,"3 %u %u %u %f %f %f\n",
                       (unsigned int)primitives(l,0),(unsigned int)primitives(l,2),
                       (unsigned int)primitives(l,1),rt,gt,bt);
        } break;
        case 12 : {
          const unsigned int xt = (unsigned int)primitives(l,4), yt = (unsigned int)primitives(l,5);
          const float
            rt = color.atXY(xt,yt,0)/255.0f,
            gt = (csiz>1?color.atXY(xt,yt,1):r)/255.0f,
            bt = (csiz>2?color.atXY(xt,yt,2):g)/255.0f;
          std::fprintf(nfile,"4 %u %u %u %u %f %f %f\n",
                       (unsigned int)primitives(l,0),(unsigned int)primitives(l,3),
                       (unsigned int)primitives(l,2),(unsigned int)primitives(l,1),rt,gt,bt);
        } break;
        }
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }
# 44121 "../src/CImg.h"
    const CImg<T>& save_ffmpeg_external(const char *const filename, const char *const codec=0,
                                        const unsigned int fps=25, const unsigned int bitrate=2048) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_ffmpeg_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }

      CImgList<T> list;
      get_split('z').move_to(list);
      list.save_ffmpeg_external(filename,codec,fps,bitrate);
      return *this;
    }
# 44142 "../src/CImg.h"
    const CImg<T>& save_gzip_external(const char *const filename) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_gzip_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }

      char command[1024] = { 0 }, filetmp[512] = { 0 }, body[512] = { 0 };
      const char
        *ext = cimg::split_filename(filename,body),
        *ext2 = cimg::split_filename(body,0);
      std::FILE *file;
      do {
        if (!cimg::strcasecmp(ext,"gz")) {
          if (*ext2) snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                                   cimg::temporary_path(),'/',cimg::filenamerand(),ext2);
          else snprintf(filetmp,sizeof(filetmp),"%s%c%s.cimg",
                             cimg::temporary_path(),'/',cimg::filenamerand());
        } else {
          if (*ext) snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                                  cimg::temporary_path(),'/',cimg::filenamerand(),ext);
          else snprintf(filetmp,sizeof(filetmp),"%s%c%s.cimg",
                             cimg::temporary_path(),'/',cimg::filenamerand());
        }
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);
      save(filetmp);
      snprintf(command,sizeof(command),"%s -c \"%s\" > \"%s\"",
                    cimg::gzip_path(),
                    CImg<charT>::string(filetmp)._system_strescape().data(),
                    CImg<charT>::string(filename)._system_strescape().data());
      cimg::system(command);
      file = std::fopen(filename,"rb");
      if (!file)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "save_gzip_external(): Failed to save file '%s' with external command 'gzip'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename);

      else cimg::fclose(file);
      std::remove(filetmp);
      return *this;
    }
# 44194 "../src/CImg.h"
    const CImg<T>& save_graphicsmagick_external(const char *const filename, const unsigned int quality=100) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_graphicsmagick_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }
# 44208 "../src/CImg.h"
      char command[1024] = { 0 }, filetmp[512] = { 0 };
      std::FILE *file;
      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                      cimg::temporary_path(),'/',cimg::filenamerand(),
                      _spectrum==1?"pgm":"ppm");
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);



      save_pnm(filetmp);

      snprintf(command,sizeof(command),"%s convert -quality %u \"%s\" \"%s\"",
                    cimg::graphicsmagick_path(),quality,
                    CImg<charT>::string(filetmp)._system_strescape().data(),
                    CImg<charT>::string(filename)._system_strescape().data());
      cimg::system(command);
      file = std::fopen(filename,"rb");
      if (!file)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "save_graphicsmagick_external(): Failed to save file '%s' with external command 'gm'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename);

      if (file) cimg::fclose(file);
      std::remove(filetmp);
      return *this;
    }
# 44246 "../src/CImg.h"
    const CImg<T>& save_imagemagick_external(const char *const filename, const unsigned int quality=100) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_imagemagick_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }
# 44260 "../src/CImg.h"
      char command[1024] = { 0 }, filetmp[512] = { 0 };
      std::FILE *file;
      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",cimg::temporary_path(),
                      '/',cimg::filenamerand(),_spectrum==1?"pgm":"ppm");
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);



      save_pnm(filetmp);

      snprintf(command,sizeof(command),"%s -quality %u \"%s\" \"%s\"",
                    cimg::imagemagick_path(),quality,
                    CImg<charT>::string(filetmp)._system_strescape().data(),
                    CImg<charT>::string(filename)._system_strescape().data());
      cimg::system(command);
      file = std::fopen(filename,"rb");
      if (!file)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "save_imagemagick_external(): Failed to save file '%s' with external command 'convert'.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename);

      if (file) cimg::fclose(file);
      std::remove(filetmp);
      return *this;
    }
# 44296 "../src/CImg.h"
    const CImg<T>& save_medcon_external(const char *const filename) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_medcon_external(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }

      char command[1024] = { 0 }, filetmp[512] = { 0 }, body[512] = { 0 };
      std::FILE *file;
      do {
        snprintf(filetmp,sizeof(filetmp),"%s.hdr",cimg::filenamerand());
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);
      save_analyze(filetmp);
      snprintf(command,sizeof(command),"%s -w -c dicom -o \"%s\" -f \"%s\"",
                    cimg::medcon_path(),
                    CImg<charT>::string(filename)._system_strescape().data(),
                    CImg<charT>::string(filetmp)._system_strescape().data());
      cimg::system(command);
      std::remove(filetmp);
      cimg::split_filename(filetmp,body);
      snprintf(filetmp,sizeof(filetmp),"%s.img",body);
      std::remove(filetmp);

      file = std::fopen(filename,"rb");
      if (!file) {
        snprintf(command,sizeof(command),"m000-%s",filename);
        file = std::fopen(command,"rb");
        if (!file) {
          cimg::fclose(cimg::fopen(filename,"r"));
          throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                "save_medcon_external(): Failed to save file '%s' with external command 'medcon'.",
                                _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                                filename);
        }
      }
      cimg::fclose(file);
      std::rename(command,filename);
      return *this;
    }
# 44350 "../src/CImg.h"
    const CImg<T>& save_other(const char *const filename, const unsigned int quality=100) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                                    "save_other(): Specified filename is (null).",
                                    _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }

      const unsigned int omode = cimg::exception_mode();
      bool is_saved = true;
      cimg::exception_mode() = 0;
      try { save_magick(filename); }
      catch (CImgException&) {
        try { save_imagemagick_external(filename,quality); }
        catch (CImgException&) {
          try { save_graphicsmagick_external(filename,quality); }
          catch (CImgException&) {
            is_saved = false;
          }
        }
      }
      cimg::exception_mode() = omode;
      if (!is_saved)
        throw CImgIOException("[instance(%u,%u,%u,%u,%p,%sshared)] CImg<%s>::"
                              "save_other(): Failed to save file '%s'. Format is not natively supported, "
                              "and no external commands succeeded.",
                              _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type(),
                              filename);
      return *this;
    }


    static CImg<T> _logo40x38() {
      CImg<T> res(40,38,1,3);
      const unsigned char *ptrs = cimg::logo40x38;
      T *ptr1 = res.data(0,0,0,0), *ptr2 = res.data(0,0,0,1), *ptr3 = res.data(0,0,0,2);
      for (unsigned long off = 0; off<(unsigned long)res._width*res._height;) {
        const unsigned char n = *(ptrs++), r = *(ptrs++), g = *(ptrs++), b = *(ptrs++);
        for (unsigned int l = 0; l<n; ++off, ++l) { *(ptr1++) = (T)r; *(ptr2++) = (T)g; *(ptr3++) = (T)b; }
      }
      return res;
    }


  };
# 44407 "../src/CImg.h"
  template<typename T>
  struct CImgList {
    unsigned int _width, _allocated_width;
    CImg<T> *_data;
# 44426 "../src/CImg.h"
    typedef CImg<T>* iterator;







    typedef const CImg<T>* const_iterator;
# 44445 "../src/CImg.h"
    typedef T value_type;


    typedef typename cimg::superset<T,bool>::type Tbool;
    typedef typename cimg::superset<T,unsigned char>::type Tuchar;
    typedef typename cimg::superset<T,char>::type Tchar;
    typedef typename cimg::superset<T,unsigned short>::type Tushort;
    typedef typename cimg::superset<T,short>::type Tshort;
    typedef typename cimg::superset<T,unsigned int>::type Tuint;
    typedef typename cimg::superset<T,int>::type Tint;
    typedef typename cimg::superset<T,unsigned long>::type Tulong;
    typedef typename cimg::superset<T,long>::type Tlong;
    typedef typename cimg::superset<T,float>::type Tfloat;
    typedef typename cimg::superset<T,double>::type Tdouble;
    typedef typename cimg::last<T,bool>::type boolT;
    typedef typename cimg::last<T,unsigned char>::type ucharT;
    typedef typename cimg::last<T,char>::type charT;
    typedef typename cimg::last<T,unsigned short>::type ushortT;
    typedef typename cimg::last<T,short>::type shortT;
    typedef typename cimg::last<T,unsigned int>::type uintT;
    typedef typename cimg::last<T,int>::type intT;
    typedef typename cimg::last<T,unsigned long>::type ulongT;
    typedef typename cimg::last<T,long>::type longT;
    typedef typename cimg::last<T,float>::type floatT;
    typedef typename cimg::last<T,double>::type doubleT;
# 44519 "../src/CImg.h"
    ~CImgList() {
      delete[] _data;
    }
# 44532 "../src/CImg.h"
    CImgList():
      _width(0),_allocated_width(0),_data(0) {}
# 44542 "../src/CImg.h"
    explicit CImgList(const unsigned int n):_width(n) {
      if (n) _data = new CImg<T>[_allocated_width = cimg::max(16UL,cimg::nearest_pow2(n))];
      else { _allocated_width = 0; _data = 0; }
    }
# 44556 "../src/CImg.h"
    CImgList(const unsigned int n, const unsigned int width, const unsigned int height=1,
             const unsigned int depth=1, const unsigned int spectrum=1):
      _width(0),_allocated_width(0),_data(0) {
      assign(n);
      for (int __assign = 0; __assign<(int)(*this)._width; ++__assign) (*this)[__assign].assign(width,height,depth,spectrum);
    }
# 44572 "../src/CImg.h"
    CImgList(const unsigned int n, const unsigned int width, const unsigned int height,
             const unsigned int depth, const unsigned int spectrum, const T val):
      _width(0),_allocated_width(0),_data(0) {
      assign(n);
      for (int __assign = 0; __assign<(int)(*this)._width; ++__assign) (*this)[__assign].assign(width,height,depth,spectrum,val);
    }
# 44591 "../src/CImg.h"
    CImgList(const unsigned int n, const unsigned int width, const unsigned int height,
             const unsigned int depth, const unsigned int spectrum, const int val0, const int val1, ...):
      _width(0),_allocated_width(0),_data(0) {
# 44606 "../src/CImg.h"
      { assign(n,width,height,depth,spectrum); const unsigned long siz = (unsigned long)width*height*depth*spectrum, nsiz = siz*n; T *ptrd = _data->_data; va_list ap; __builtin_va_start(ap,val1); for (unsigned long l = 0, s = 0, i = 0; i<nsiz; ++i) { *(ptrd++) = (T)(i==0?val0:(i==1?val1:__builtin_va_arg(ap,int))); if ((++s)==siz) { ptrd = _data[++l]._data; s = 0; } } __builtin_va_end(ap); };
    }
# 44621 "../src/CImg.h"
    CImgList(const unsigned int n, const unsigned int width, const unsigned int height,
             const unsigned int depth, const unsigned int spectrum, const double val0, const double val1, ...):
      _width(0),_allocated_width(0),_data(0) {
      { assign(n,width,height,depth,spectrum); const unsigned long siz = (unsigned long)width*height*depth*spectrum, nsiz = siz*n; T *ptrd = _data->_data; va_list ap; __builtin_va_start(ap,val1); for (unsigned long l = 0, s = 0, i = 0; i<nsiz; ++i) { *(ptrd++) = (T)(i==0?val0:(i==1?val1:__builtin_va_arg(ap,double))); if ((++s)==siz) { ptrd = _data[++l]._data; s = 0; } } __builtin_va_end(ap); };
    }







    template<typename t>
    CImgList(const unsigned int n, const CImg<t>& img, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(n);
      for (int __assign = 0; __assign<(int)(*this)._width; ++__assign) (*this)[__assign].assign(img,is_shared);
    }






    template<typename t>
    explicit CImgList(const CImg<t>& img, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(1);
      _data[0].assign(img,is_shared);
    }







    template<typename t1, typename t2>
    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(2);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared);
    }
# 44672 "../src/CImg.h"
    template<typename t1, typename t2, typename t3>
    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(3);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
    }
# 44687 "../src/CImg.h"
    template<typename t1, typename t2, typename t3, typename t4>
    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
             const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(4);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared);
    }
# 44705 "../src/CImg.h"
    template<typename t1, typename t2, typename t3, typename t4, typename t5>
    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
             const CImg<t5>& img5, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(5);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared); _data[4].assign(img5,is_shared);
    }
# 44724 "../src/CImg.h"
    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6>
    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
             const CImg<t5>& img5, const CImg<t6>& img6, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(6);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared); _data[4].assign(img5,is_shared); _data[5].assign(img6,is_shared);
    }
# 44744 "../src/CImg.h"
    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7>
    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
             const CImg<t5>& img5, const CImg<t6>& img6, const CImg<t7>& img7, const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(7);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared); _data[4].assign(img5,is_shared); _data[5].assign(img6,is_shared);
      _data[6].assign(img7,is_shared);
    }
# 44766 "../src/CImg.h"
    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8>
    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
             const CImg<t5>& img5, const CImg<t6>& img6, const CImg<t7>& img7, const CImg<t8>& img8,
             const bool is_shared=false):
      _width(0),_allocated_width(0),_data(0) {
      assign(8);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared); _data[4].assign(img5,is_shared); _data[5].assign(img6,is_shared);
      _data[6].assign(img7,is_shared); _data[7].assign(img8,is_shared);
    }






    template<typename t>
    CImgList(const CImgList<t>& list):_width(0),_allocated_width(0),_data(0) {
      assign(list._width);
      for (int l = 0; l<(int)(*this)._width; ++l) _data[l].assign(list[l],false);
    }


    CImgList(const CImgList<T>& list):_width(0),_allocated_width(0),_data(0) {
      assign(list._width);
      for (int l = 0; l<(int)(*this)._width; ++l) _data[l].assign(list[l],list[l]._is_shared);
    }






    template<typename t>
    CImgList(const CImgList<t>& list, const bool is_shared):_width(0),_allocated_width(0),_data(0) {
      assign(list._width);
      for (int l = 0; l<(int)(*this)._width; ++l) _data[l].assign(list[l],is_shared);
    }





    explicit CImgList(const char *const filename):_width(0),_allocated_width(0),_data(0) {
      assign(filename);
    }






    explicit CImgList(const CImgDisplay& disp):_width(0),_allocated_width(0),_data(0) {
      assign(disp);
    }





    CImgList<T> get_shared() {
      CImgList<T> res(_width);
      for (int l = 0; l<(int)(*this)._width; ++l) res[l].assign(_data[l],true);
      return res;
    }


    const CImgList<T> get_shared() const {
      CImgList<T> res(_width);
      for (int l = 0; l<(int)(*this)._width; ++l) res[l].assign(_data[l],true);
      return res;
    }





    CImgList<T>& assign() {
      delete[] _data;
      _width = _allocated_width = 0;
      _data = 0;
      return *this;
    }






    CImgList<T>& clear() {
      return assign();
    }





    CImgList<T>& assign(const unsigned int n) {
      if (!n) return assign();
      if (_allocated_width<n || _allocated_width>(n<<2)) {
        delete[] _data;
        _data = new CImg<T>[_allocated_width=cimg::max(16UL,cimg::nearest_pow2(n))];
      }
      _width = n;
      return *this;
    }





    CImgList<T>& assign(const unsigned int n, const unsigned int width, const unsigned int height=1,
                        const unsigned int depth=1, const unsigned int spectrum=1) {
      assign(n);
      for (int __assign = 0; __assign<(int)(*this)._width; ++__assign) (*this)[__assign].assign(width,height,depth,spectrum);
      return *this;
    }





    CImgList<T>& assign(const unsigned int n, const unsigned int width, const unsigned int height,
                        const unsigned int depth, const unsigned int spectrum, const T val) {
      assign(n);
      for (int __assign = 0; __assign<(int)(*this)._width; ++__assign) (*this)[__assign].assign(width,height,depth,spectrum,val);
      return *this;
    }





    CImgList<T>& assign(const unsigned int n, const unsigned int width, const unsigned int height,
                        const unsigned int depth, const unsigned int spectrum, const int val0, const int val1, ...) {
      { assign(n,width,height,depth,spectrum); const unsigned long siz = (unsigned long)width*height*depth*spectrum, nsiz = siz*n; T *ptrd = _data->_data; va_list ap; __builtin_va_start(ap,val1); for (unsigned long l = 0, s = 0, i = 0; i<nsiz; ++i) { *(ptrd++) = (T)(i==0?val0:(i==1?val1:__builtin_va_arg(ap,int))); if ((++s)==siz) { ptrd = _data[++l]._data; s = 0; } } __builtin_va_end(ap); };
      return *this;
    }





    CImgList<T>& assign(const unsigned int n, const unsigned int width, const unsigned int height,
                        const unsigned int depth, const unsigned int spectrum,
                        const double val0, const double val1, ...) {
      { assign(n,width,height,depth,spectrum); const unsigned long siz = (unsigned long)width*height*depth*spectrum, nsiz = siz*n; T *ptrd = _data->_data; va_list ap; __builtin_va_start(ap,val1); for (unsigned long l = 0, s = 0, i = 0; i<nsiz; ++i) { *(ptrd++) = (T)(i==0?val0:(i==1?val1:__builtin_va_arg(ap,double))); if ((++s)==siz) { ptrd = _data[++l]._data; s = 0; } } __builtin_va_end(ap); };
      return *this;
    }





    template<typename t>
    CImgList<T>& assign(const unsigned int n, const CImg<t>& img, const bool is_shared=false) {
      assign(n);
      for (int __assign = 0; __assign<(int)(*this)._width; ++__assign) (*this)[__assign].assign(img,is_shared);
      return *this;
    }





    template<typename t>
    CImgList<T>& assign(const CImg<t>& img, const bool is_shared=false) {
      assign(1);
      _data[0].assign(img,is_shared);
      return *this;
    }





    template<typename t1, typename t2>
    CImgList<T>& assign(const CImg<t1>& img1, const CImg<t2>& img2, const bool is_shared=false) {
      assign(2);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared);
      return *this;
    }





    template<typename t1, typename t2, typename t3>
    CImgList<T>& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const bool is_shared=false) {
      assign(3);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      return *this;
    }





    template<typename t1, typename t2, typename t3, typename t4>
    CImgList<T>& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
                        const bool is_shared=false) {
      assign(4);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared);
      return *this;
    }





    template<typename t1, typename t2, typename t3, typename t4, typename t5>
    CImgList<T>& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
                        const CImg<t5>& img5, const bool is_shared=false) {
      assign(5);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared); _data[4].assign(img5,is_shared);
      return *this;
    }





    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6>
    CImgList<T>& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
                        const CImg<t5>& img5, const CImg<t6>& img6, const bool is_shared=false) {
      assign(6);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared); _data[4].assign(img5,is_shared); _data[5].assign(img6,is_shared);
      return *this;
    }





    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7>
    CImgList<T>& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
                        const CImg<t5>& img5, const CImg<t6>& img6, const CImg<t7>& img7, const bool is_shared=false) {
      assign(7);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared); _data[4].assign(img5,is_shared); _data[5].assign(img6,is_shared);
      _data[6].assign(img7,is_shared);
      return *this;
    }





    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8>
    CImgList<T>& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4,
                        const CImg<t5>& img5, const CImg<t6>& img6, const CImg<t7>& img7, const CImg<t8>& img8,
                        const bool is_shared=false) {
      assign(8);
      _data[0].assign(img1,is_shared); _data[1].assign(img2,is_shared); _data[2].assign(img3,is_shared);
      _data[3].assign(img4,is_shared); _data[4].assign(img5,is_shared); _data[5].assign(img6,is_shared);
      _data[6].assign(img7,is_shared); _data[7].assign(img8,is_shared);
      return *this;
    }





    template<typename t>
    CImgList<T>& assign(const CImgList<t>& list, const bool is_shared=false) {
      cimg::unused(is_shared);
      assign(list._width);
      for (int l = 0; l<(int)(*this)._width; ++l) _data[l].assign(list[l],false);
      return *this;
    }


    CImgList<T>& assign(const CImgList<T>& list, const bool is_shared=false) {
      if (this==&list) return *this;
      CImgList<T> res(list._width);
      for (int l = 0; l<(int)(res)._width; ++l) res[l].assign(list[l],is_shared);
      return res.move_to(*this);
    }





    CImgList<T>& assign(const char *const filename) {
      return load(filename);
    }





    CImgList<T>& assign(const CImgDisplay &disp) {
      return assign(CImg<T>(disp));
    }






    template<typename t>
    CImgList<t>& move_to(CImgList<t>& list) {
      list.assign(_width);
      bool is_one_shared_element = false;
      for (int l = 0; l<(int)(*this)._width; ++l) is_one_shared_element|=_data[l]._is_shared;
      if (is_one_shared_element) for (int l = 0; l<(int)(*this)._width; ++l) list[l].assign(_data[l]);
      else for (int l = 0; l<(int)(*this)._width; ++l) _data[l].move_to(list[l]);
      assign();
      return list;
    }
# 45087 "../src/CImg.h"
    template<typename t>
    CImgList<t>& move_to(CImgList<t>& list, const unsigned int pos) {
      if (is_empty()) return list;
      const unsigned int npos = pos>list._width?list._width:pos;
      list.insert(_width,npos);
      bool is_one_shared_element = false;
      for (int l = 0; l<(int)(*this)._width; ++l) is_one_shared_element|=_data[l]._is_shared;
      if (is_one_shared_element) for (int l = 0; l<(int)(*this)._width; ++l) list[npos+l].assign(_data[l]);
      else for (int l = 0; l<(int)(*this)._width; ++l) _data[l].move_to(list[npos+l]);
      assign();
      return list;
    }






    CImgList<T>& swap(CImgList<T>& list) {
      cimg::swap(_width,list._width);
      cimg::swap(_allocated_width,list._allocated_width);
      cimg::swap(_data,list._data);
      return list;
    }
# 45119 "../src/CImg.h"
    static CImgList<T>& empty() {
      static CImgList<T> _empty;
      return _empty.assign();
    }
# 45135 "../src/CImg.h"
    CImg<T>& operator()(const unsigned int pos) {
# 45145 "../src/CImg.h"
      return _data[pos];
    }





    const CImg<T>& operator()(const unsigned int pos) const {
      return const_cast<CImgList<T>*>(this)->operator()(pos);
    }
# 45165 "../src/CImg.h"
    T& operator()(const unsigned int pos, const unsigned int x, const unsigned int y=0,
                  const unsigned int z=0, const unsigned int c=0) {
      return (*this)[pos](x,y,z,c);
    }


    const T& operator()(const unsigned int pos, const unsigned int x, const unsigned int y=0,
                        const unsigned int z=0, const unsigned int c=0) const {
      return (*this)[pos](x,y,z,c);
    }





    operator CImg<T>*() {
      return _data;
    }


    operator const CImg<T>*() const {
      return _data;
    }






    template<typename t>
    CImgList<T>& operator=(const CImg<t>& img) {
      return assign(img);
    }






    template<typename t>
    CImgList<T>& operator=(const CImgList<t>& list) {
      return assign(list);
    }


    CImgList<T>& operator=(const CImgList<T>& list) {
      return assign(list);
    }





    CImgList<T>& operator=(const char *const filename) {
      return assign(filename);
    }





    CImgList<T>& operator=(const CImgDisplay& disp) {
      return assign(disp);
    }






    CImgList<T> operator+() const {
      return CImgList<T>(*this,false);
    }
# 45247 "../src/CImg.h"
    template<typename t>
    CImgList<T>& operator,(const CImg<t>& img) {
      return insert(img);
    }


    template<typename t>
    CImgList<T> operator,(const CImg<t>& img) const {
      return (+*this).insert(img);
    }





    template<typename t>
    CImgList<T>& operator,(const CImgList<t>& list) {
      return insert(list);
    }


    template<typename t>
    CImgList<T>& operator,(const CImgList<t>& list) const {
      return (+*this).insert(list);
    }






    CImg<T> operator>(const char axis) const {
      return get_append(axis,0);
    }






    CImgList<T> operator<(const char axis) const {
      return get_split(axis);
    }
# 45306 "../src/CImg.h"
    static const char* pixel_type() {
      return cimg::type<T>::string();
    }





    int width() const {
      return (int)_width;
    }





    unsigned int size() const {
      return _width;
    }





    CImg<T> *data() {
      return _data;
    }


    const CImg<T> *data() const {
      return _data;
    }
# 45358 "../src/CImg.h"
    CImg<T> *data(const unsigned int l) {
      return _data + l;
    }


    const CImg<T> *data(const unsigned int l) const {
      return _data + l;
    }





    iterator begin() {
      return _data;
    }


    const_iterator begin() const {
      return _data;
    }




    iterator end() {
      return _data + _width;
    }


    const_iterator end() const {
      return _data + _width;
    }




    CImg<T>& front() {
      return *_data;
    }


    const CImg<T>& front() const {
      return *_data;
    }




    const CImg<T>& back() const {
      return *(_data + _width - 1);
    }


    CImg<T>& back() {
      return *(_data + _width - 1);
    }





    CImg<T>& at(const int pos) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "at(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _data[pos<0?0:pos>=(int)_width?(int)_width-1:pos];
    }
# 45439 "../src/CImg.h"
    T& atNXYZC(const int pos, const int x, const int y, const int z, const int c, const T out_value) {
      return (pos<0 || pos>=(int)_width)?(cimg::temporary(out_value)=out_value):_data[pos].atXYZC(x,y,z,c,out_value);
    }


    T atNXYZC(const int pos, const int x, const int y, const int z, const int c, const T out_value) const {
      return (pos<0 || pos>=(int)_width)?out_value:_data[pos].atXYZC(x,y,z,c,out_value);
    }
# 45457 "../src/CImg.h"
    T& atNXYZC(const int pos, const int x, const int y, const int z, const int c) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atNXYZC(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _atNXYZC(pos,x,y,z,c);
    }


    T atNXYZC(const int pos, const int x, const int y, const int z, const int c) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atNXYZC(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _atNXYZC(pos,x,y,z,c);
    }

    T& _atNXYZC(const int pos, const int x, const int y, const int z, const int c) {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)].atXYZC(x,y,z,c);
    }

    T _atNXYZC(const int pos, const int x, const int y, const int z, const int c) const {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)].atXYZC(x,y,z,c);
    }
# 45494 "../src/CImg.h"
    T& atNXYZ(const int pos, const int x, const int y, const int z, const int c, const T out_value) {
      return (pos<0 || pos>=(int)_width)?(cimg::temporary(out_value)=out_value):_data[pos].atXYZ(x,y,z,c,out_value);
    }


    T atNXYZ(const int pos, const int x, const int y, const int z, const int c, const T out_value) const {
      return (pos<0 || pos>=(int)_width)?out_value:_data[pos].atXYZ(x,y,z,c,out_value);
    }
# 45512 "../src/CImg.h"
   T& atNXYZ(const int pos, const int x, const int y, const int z, const int c=0) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atNXYZ(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _atNXYZ(pos,x,y,z,c);
    }


    T atNXYZ(const int pos, const int x, const int y, const int z, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atNXYZ(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _atNXYZ(pos,x,y,z,c);
    }

    T& _atNXYZ(const int pos, const int x, const int y, const int z, const int c=0) {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)].atXYZ(x,y,z,c);
    }

    T _atNXYZ(const int pos, const int x, const int y, const int z, const int c=0) const {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)].atXYZ(x,y,z,c);
    }
# 45549 "../src/CImg.h"
    T& atNXY(const int pos, const int x, const int y, const int z, const int c, const T out_value) {
      return (pos<0 || pos>=(int)_width)?(cimg::temporary(out_value)=out_value):_data[pos].atXY(x,y,z,c,out_value);
    }


    T atNXY(const int pos, const int x, const int y, const int z, const int c, const T out_value) const {
      return (pos<0 || pos>=(int)_width)?out_value:_data[pos].atXY(x,y,z,c,out_value);
    }
# 45567 "../src/CImg.h"
    T& atNXY(const int pos, const int x, const int y, const int z=0, const int c=0) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atNXY(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _atNXY(pos,x,y,z,c);
    }


    T atNXY(const int pos, const int x, const int y, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atNXY(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _atNXY(pos,x,y,z,c);
    }

    T& _atNXY(const int pos, const int x, const int y, const int z=0, const int c=0) {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)].atXY(x,y,z,c);
    }

    T _atNXY(const int pos, const int x, const int y, const int z=0, const int c=0) const {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)].atXY(x,y,z,c);
    }
# 45604 "../src/CImg.h"
    T& atNX(const int pos, const int x, const int y, const int z, const int c, const T out_value) {
      return (pos<0 || pos>=(int)_width)?(cimg::temporary(out_value)=out_value):_data[pos].atX(x,y,z,c,out_value);
    }


    T atNX(const int pos, const int x, const int y, const int z, const int c, const T out_value) const {
      return (pos<0 || pos>=(int)_width)?out_value:_data[pos].atX(x,y,z,c,out_value);
    }
# 45622 "../src/CImg.h"
    T& atNX(const int pos, const int x, const int y=0, const int z=0, const int c=0) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atNX(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _atNX(pos,x,y,z,c);
    }


    T atNX(const int pos, const int x, const int y=0, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atNX(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());

      return _atNX(pos,x,y,z,c);
    }

    T& _atNX(const int pos, const int x, const int y=0, const int z=0, const int c=0) {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)].atX(x,y,z,c);
    }

    T _atNX(const int pos, const int x, const int y=0, const int z=0, const int c=0) const {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)].atX(x,y,z,c);
    }
# 45659 "../src/CImg.h"
    T& atN(const int pos, const int x, const int y, const int z, const int c, const T out_value) {
      return (pos<0 || pos>=(int)_width)?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);
    }


    T atN(const int pos, const int x, const int y, const int z, const int c, const T out_value) const {
      return (pos<0 || pos>=(int)_width)?out_value:(*this)(pos,x,y,z,c);
    }
# 45677 "../src/CImg.h"
    T& atN(const int pos, const int x=0, const int y=0, const int z=0, const int c=0) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atN(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      return _atN(pos,x,y,z,c);
    }


    T atN(const int pos, const int x=0, const int y=0, const int z=0, const int c=0) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "atN(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      return _atN(pos,x,y,z,c);
    }

    T& _atN(const int pos, const int x=0, const int y=0, const int z=0, const int c=0) {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)](x,y,z,c);
    }

    T _atN(const int pos, const int x=0, const int y=0, const int z=0, const int c=0) const {
      return _data[pos<0?0:(pos>=(int)_width?(int)_width-1:pos)](x,y,z,c);
    }







    CImg<charT> value_string(const char separator=',', const unsigned int max_size=0) const {
      if (is_empty()) return CImg<ucharT>(1,1,1,1,0);
      CImgList<charT> items;
      for (unsigned int l = 0; l<_width-1; ++l) {
        CImg<charT> item = _data[l].value_string(separator,0);
        item.back() = separator;
        item.move_to(items);
      }
      _data[_width-1].value_string(separator,0).move_to(items);
      CImg<charT> res; (items>'x').move_to(res);
      if (max_size) { res.crop(0,max_size); res(max_size) = 0; }
      return res;
    }
# 45732 "../src/CImg.h"
    bool is_empty() const {
      return (!_data || !_width);
    }





    bool is_sameN(const unsigned int size_n) const {
      return _width==size_n;
    }





    template<typename t>
    bool is_sameN(const CImgList<t>& list) const {
      return is_sameN(list._width);
    }
# 45800 "../src/CImg.h"
    template<typename t> bool is_sameXY(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXY(img); return res; } template<typename t> bool is_sameXY(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameXY(list[l]); return res; } template<typename t> bool is_sameNXY(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameXY(img)); } template<typename t> bool is_sameNXY(const CImgList<t>& list) const { return (is_sameN(list) && is_sameXY(list)); }
    template<typename t> bool is_sameXZ(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXZ(img); return res; } template<typename t> bool is_sameXZ(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameXZ(list[l]); return res; } template<typename t> bool is_sameNXZ(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameXZ(img)); } template<typename t> bool is_sameNXZ(const CImgList<t>& list) const { return (is_sameN(list) && is_sameXZ(list)); }
    template<typename t> bool is_sameXC(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXC(img); return res; } template<typename t> bool is_sameXC(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameXC(list[l]); return res; } template<typename t> bool is_sameNXC(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameXC(img)); } template<typename t> bool is_sameNXC(const CImgList<t>& list) const { return (is_sameN(list) && is_sameXC(list)); }
    template<typename t> bool is_sameYZ(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameYZ(img); return res; } template<typename t> bool is_sameYZ(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameYZ(list[l]); return res; } template<typename t> bool is_sameNYZ(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameYZ(img)); } template<typename t> bool is_sameNYZ(const CImgList<t>& list) const { return (is_sameN(list) && is_sameYZ(list)); }
    template<typename t> bool is_sameYC(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameYC(img); return res; } template<typename t> bool is_sameYC(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameYC(list[l]); return res; } template<typename t> bool is_sameNYC(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameYC(img)); } template<typename t> bool is_sameNYC(const CImgList<t>& list) const { return (is_sameN(list) && is_sameYC(list)); }
    template<typename t> bool is_sameXYZ(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXYZ(img); return res; } template<typename t> bool is_sameXYZ(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameXYZ(list[l]); return res; } template<typename t> bool is_sameNXYZ(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameXYZ(img)); } template<typename t> bool is_sameNXYZ(const CImgList<t>& list) const { return (is_sameN(list) && is_sameXYZ(list)); }
    template<typename t> bool is_sameXYC(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXYC(img); return res; } template<typename t> bool is_sameXYC(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameXYC(list[l]); return res; } template<typename t> bool is_sameNXYC(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameXYC(img)); } template<typename t> bool is_sameNXYC(const CImgList<t>& list) const { return (is_sameN(list) && is_sameXYC(list)); }
    template<typename t> bool is_sameYZC(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameYZC(img); return res; } template<typename t> bool is_sameYZC(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameYZC(list[l]); return res; } template<typename t> bool is_sameNYZC(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameYZC(img)); } template<typename t> bool is_sameNYZC(const CImgList<t>& list) const { return (is_sameN(list) && is_sameYZC(list)); }
    template<typename t> bool is_sameXYZC(const CImg<t>& img) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXYZC(img); return res; } template<typename t> bool is_sameXYZC(const CImgList<t>& list) const { const unsigned int lmin = cimg::min(_width,list._width); bool res = true; for (unsigned int l = 0; l<lmin && res; ++l) res = _data[l].is_sameXYZC(list[l]); return res; } template<typename t> bool is_sameNXYZC(const unsigned int n, const CImg<t>& img) const { return (is_sameN(n) && is_sameXYZC(img)); } template<typename t> bool is_sameNXYZC(const CImgList<t>& list) const { return (is_sameN(list) && is_sameXYZC(list)); }
    bool is_sameX(const unsigned int val) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameX(val); return res; } bool is_sameNX(const unsigned int n, const unsigned int val) const { return is_sameN(n) && is_sameX(val); }
    bool is_sameY(const unsigned int val) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameY(val); return res; } bool is_sameNY(const unsigned int n, const unsigned int val) const { return is_sameN(n) && is_sameY(val); }
    bool is_sameZ(const unsigned int val) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameZ(val); return res; } bool is_sameNZ(const unsigned int n, const unsigned int val) const { return is_sameN(n) && is_sameZ(val); }
    bool is_sameC(const unsigned int val) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameC(val); return res; } bool is_sameNC(const unsigned int n, const unsigned int val) const { return is_sameN(n) && is_sameC(val); }
    bool is_sameXY(const unsigned int val1, const unsigned int val2) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXY(val1,val2); return res; } bool is_sameNXY(const unsigned int n, const unsigned int val1, const unsigned int val2) const { return is_sameN(n) && is_sameXY(val1,val2); }
    bool is_sameXZ(const unsigned int val1, const unsigned int val2) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXZ(val1,val2); return res; } bool is_sameNXZ(const unsigned int n, const unsigned int val1, const unsigned int val2) const { return is_sameN(n) && is_sameXZ(val1,val2); }
    bool is_sameXC(const unsigned int val1, const unsigned int val2) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXC(val1,val2); return res; } bool is_sameNXC(const unsigned int n, const unsigned int val1, const unsigned int val2) const { return is_sameN(n) && is_sameXC(val1,val2); }
    bool is_sameYZ(const unsigned int val1, const unsigned int val2) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameYZ(val1,val2); return res; } bool is_sameNYZ(const unsigned int n, const unsigned int val1, const unsigned int val2) const { return is_sameN(n) && is_sameYZ(val1,val2); }
    bool is_sameYC(const unsigned int val1, const unsigned int val2) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameYC(val1,val2); return res; } bool is_sameNYC(const unsigned int n, const unsigned int val1, const unsigned int val2) const { return is_sameN(n) && is_sameYC(val1,val2); }
    bool is_sameZC(const unsigned int val1, const unsigned int val2) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameZC(val1,val2); return res; } bool is_sameNZC(const unsigned int n, const unsigned int val1, const unsigned int val2) const { return is_sameN(n) && is_sameZC(val1,val2); }
    bool is_sameXYZ(const unsigned int val1, const unsigned int val2, const unsigned int val3) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXYZ(val1,val2,val3); return res; } bool is_sameNXYZ(const unsigned int n, const unsigned int val1, const unsigned int val2, const unsigned int val3) const { return is_sameN(n) && is_sameXYZ(val1,val2,val3); }
    bool is_sameXYC(const unsigned int val1, const unsigned int val2, const unsigned int val3) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXYC(val1,val2,val3); return res; } bool is_sameNXYC(const unsigned int n, const unsigned int val1, const unsigned int val2, const unsigned int val3) const { return is_sameN(n) && is_sameXYC(val1,val2,val3); }
    bool is_sameXZC(const unsigned int val1, const unsigned int val2, const unsigned int val3) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXZC(val1,val2,val3); return res; } bool is_sameNXZC(const unsigned int n, const unsigned int val1, const unsigned int val2, const unsigned int val3) const { return is_sameN(n) && is_sameXZC(val1,val2,val3); }
    bool is_sameYZC(const unsigned int val1, const unsigned int val2, const unsigned int val3) const { bool res = true; for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameYZC(val1,val2,val3); return res; } bool is_sameNYZC(const unsigned int n, const unsigned int val1, const unsigned int val2, const unsigned int val3) const { return is_sameN(n) && is_sameYZC(val1,val2,val3); }
# 45831 "../src/CImg.h"
    bool is_sameXYZC(const unsigned int dx, const unsigned int dy,
                     const unsigned int dz, const unsigned int dc) const {
      bool res = true;
      for (unsigned int l = 0; l<_width && res; ++l) res = _data[l].is_sameXYZC(dx,dy,dz,dc);
      return res;
    }
# 45846 "../src/CImg.h"
    bool is_sameNXYZC(const unsigned int n,
                      const unsigned int dx, const unsigned int dy,
                      const unsigned int dz, const unsigned int dc) const {
      return is_sameN(n) && is_sameXYZC(dx,dy,dz,dc);
    }
# 45860 "../src/CImg.h"
    bool containsNXYZC(const int n, const int x=0, const int y=0, const int z=0, const int c=0) const {
      if (is_empty()) return false;
      return n>=0 && n<(int)_width && x>=0 && x<_data[n].width() && y>=0 && y<_data[n].height() &&
        z>=0 && z<_data[n].depth() && c>=0 && c<_data[n].spectrum();
    }





    bool containsN(const int n) const {
      if (is_empty()) return false;
      return n>=0 && n<(int)_width;
    }
# 45885 "../src/CImg.h"
    template<typename t>
    bool contains(const T& pixel, t& n, t& x, t&y, t& z, t& c) const {
      if (is_empty()) return false;
      for (int l = 0; l<(int)(*this)._width; ++l) if (_data[l].contains(pixel,x,y,z,c)) { n = (t)l; return true; }
      return false;
    }
# 45901 "../src/CImg.h"
    template<typename t>
    bool contains(const T& pixel, t& n, t& x, t&y, t& z) const {
      t c;
      return contains(pixel,n,x,y,z,c);
    }
# 45915 "../src/CImg.h"
    template<typename t>
    bool contains(const T& pixel, t& n, t& x, t&y) const {
      t z, c;
      return contains(pixel,n,x,y,z,c);
    }
# 45928 "../src/CImg.h"
    template<typename t>
    bool contains(const T& pixel, t& n, t& x) const {
      t y, z, c;
      return contains(pixel,n,x,y,z,c);
    }







    template<typename t>
    bool contains(const T& pixel, t& n) const {
      t x, y, z, c;
      return contains(pixel,n,x,y,z,c);
    }





    bool contains(const T& pixel) const {
      unsigned int n, x, y, z, c;
      return contains(pixel,n,x,y,z,c);
    }







    template<typename t>
    bool contains(const CImg<T>& img, t& n) const {
      if (is_empty()) return false;
      const CImg<T> *const ptr = &img;
      for (int i = 0; i<(int)(*this)._width; ++i) if (_data+i==ptr) { n = (t)i; return true; }
      return false;
    }





    bool contains(const CImg<T>& img) const {
      unsigned int n;
      return contains(img,n);
    }
# 45988 "../src/CImg.h"
    T& min() {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "min(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      T *ptr_min = _data->_data;
      T min_value = *ptr_min;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        for (T *ptrs = (img)._data, *_maxptrs = (img)._data + (img).size(); ptrs<_maxptrs; ++ptrs) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      }
      return *ptr_min;
    }


    const T& min() const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "min(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      const T *ptr_min = _data->_data;
      T min_value = *ptr_min;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        for (T *ptrs = (img)._data, *_maxptrs = (img)._data + (img).size(); ptrs<_maxptrs; ++ptrs) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      }
      return *ptr_min;
    }




    T& max() {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "max(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      T *ptr_max = _data->_data;
      T max_value = *ptr_max;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        for (T *ptrs = (img)._data, *_maxptrs = (img)._data + (img).size(); ptrs<_maxptrs; ++ptrs) if (*ptrs>max_value) max_value = *(ptr_max=ptrs);
      }
      return *ptr_max;
    }


    const T& max() const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "max(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      const T *ptr_max = _data->_data;
      T max_value = *ptr_max;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        for (T *ptrs = (img)._data, *_maxptrs = (img)._data + (img).size(); ptrs<_maxptrs; ++ptrs) if (*ptrs>max_value) max_value = *(ptr_max=ptrs);
      }
      return *ptr_max;
    }





    template<typename t>
    T& min_max(t& max_val) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "min_max(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      T *ptr_min = _data->_data;
      T min_value = *ptr_min, max_value = min_value;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        for (T *ptrs = (img)._data, *_maxptrs = (img)._data + (img).size(); ptrs<_maxptrs; ++ptrs) {
          const T val = *ptrs;
          if (val<min_value) { min_value = val; ptr_min = ptrs; }
          if (val>max_value) max_value = val;
        }
      }
      max_val = (t)max_value;
      return *ptr_min;
    }





    template<typename t>
    const T& min_max(t& max_val) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "min_max(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      const T *ptr_min = _data->_data;
      T min_value = *ptr_min, max_value = min_value;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        for (T *ptrs = (img)._data, *_maxptrs = (img)._data + (img).size(); ptrs<_maxptrs; ++ptrs) {
          const T val = *ptrs;
          if (val<min_value) { min_value = val; ptr_min = ptrs; }
          if (val>max_value) max_value = val;
        }
      }
      max_val = (t)max_value;
      return *ptr_min;
    }





    template<typename t>
    T& max_min(t& min_val) {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "max_min(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      T *ptr_max = _data->_data;
      T min_value = *ptr_max, max_value = min_value;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        for (T *ptrs = (img)._data, *_maxptrs = (img)._data + (img).size(); ptrs<_maxptrs; ++ptrs) {
          const T val = *ptrs;
          if (val>max_value) { max_value = val; ptr_max = ptrs; }
          if (val<min_value) min_value = val;
        }
      }
      min_val = (t)min_value;
      return *ptr_max;
    }


    template<typename t>
    const T& max_min(t& min_val) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "max_min(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      const T *ptr_max = _data->_data;
      T min_value = *ptr_max, max_value = min_value;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        for (T *ptrs = (img)._data, *_maxptrs = (img)._data + (img).size(); ptrs<_maxptrs; ++ptrs) {
          const T val = *ptrs;
          if (val>max_value) { max_value = val; ptr_max = ptrs; }
          if (val<min_value) min_value = val;
        }
      }
      min_val = (t)min_value;
      return *ptr_max;
    }
# 46155 "../src/CImg.h"
    template<typename t>
    CImgList<T>& insert(const CImg<t>& img, const unsigned int pos=~0U, const bool is_shared=false) {
      const unsigned int npos = pos==~0U?_width:pos;
      if (npos>_width)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "insert(): Invalid insertion request of specified image (%u,%u,%u,%u,%p) "
                                    "at position %u.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    img._width,img._height,img._depth,img._spectrum,img._data,npos);
      if (is_shared)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "insert(): Invalid insertion request of specified shared image "
                                    "CImg<%s>(%u,%u,%u,%u,%p) at position %u (pixel types are different).",
                                    _width,_allocated_width,_data,pixel_type(),
                                    img.pixel_type(),img._width,img._height,img._depth,img._spectrum,img._data,npos);

      CImg<T> *const new_data = (++_width>_allocated_width)?new CImg<T>[_allocated_width?(_allocated_width<<=1):
                                                                        (_allocated_width=16)]:0;
      if (!_data) {
        _data = new_data;
        *_data = img;
      } else {
        if (new_data) {
          if (npos) std::memcpy(new_data,_data,sizeof(CImg<T>)*npos);
          if (npos!=_width-1) std::memcpy(new_data+npos+1,_data+npos,sizeof(CImg<T>)*(_width-1-npos));
          std::memset(_data,0,sizeof(CImg<T>)*(_width-1));
          delete[] _data;
          _data = new_data;
        } else if (npos!=_width-1)
          std::memmove(_data+npos+1,_data+npos,sizeof(CImg<T>)*(_width-1-npos));
        _data[npos]._width = _data[npos]._height = _data[npos]._depth = _data[npos]._spectrum = 0; _data[npos]._data = 0;
        _data[npos] = img;
      }
      return *this;
    }


    CImgList<T>& insert(const CImg<T>& img, const unsigned int pos=~0U, const bool is_shared=false) {
      const unsigned int npos = pos==~0U?_width:pos;
      if (npos>_width)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "insert(): Invalid insertion request of specified image (%u,%u,%u,%u,%p) "
                                    "at position %u.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    img._width,img._height,img._depth,img._spectrum,img._data,npos);
      CImg<T> *const new_data = (++_width>_allocated_width)?new CImg<T>[_allocated_width?(_allocated_width<<=1):
                                                                        (_allocated_width=16)]:0;
      if (!_data) {
        _data = new_data;
        if (is_shared && img) {
          _data->_width = img._width;
          _data->_height = img._height;
          _data->_depth = img._depth;
          _data->_spectrum = img._spectrum;
          _data->_is_shared = true;
          _data->_data = img._data;
        } else *_data = img;
      }
      else {
        if (new_data) {
          if (npos) std::memcpy(new_data,_data,sizeof(CImg<T>)*npos);
          if (npos!=_width-1) std::memcpy(new_data+npos+1,_data+npos,sizeof(CImg<T>)*(_width-1-npos));
          if (is_shared && img) {
            new_data[npos]._width = img._width;
            new_data[npos]._height = img._height;
            new_data[npos]._depth = img._depth;
            new_data[npos]._spectrum = img._spectrum;
            new_data[npos]._is_shared = true;
            new_data[npos]._data = img._data;
          } else {
            new_data[npos]._width = new_data[npos]._height = new_data[npos]._depth = new_data[npos]._spectrum = 0;
            new_data[npos]._data = 0;
            new_data[npos] = img;
          }
          std::memset(_data,0,sizeof(CImg<T>)*(_width-1));
          delete[] _data;
          _data = new_data;
        } else {
          if (npos!=_width-1) std::memmove(_data+npos+1,_data+npos,sizeof(CImg<T>)*(_width-1-npos));
          if (is_shared && img) {
            _data[npos]._width = img._width;
            _data[npos]._height = img._height;
            _data[npos]._depth = img._depth;
            _data[npos]._spectrum = img._spectrum;
            _data[npos]._is_shared = true;
            _data[npos]._data = img._data;
          } else {
            _data[npos]._width = _data[npos]._height = _data[npos]._depth = _data[npos]._spectrum = 0;
            _data[npos]._data = 0;
            _data[npos] = img;
          }
        }
      }
      return *this;
    }


    template<typename t>
    CImgList<T> get_insert(const CImg<t>& img, const unsigned int pos=~0U, const bool is_shared=false) const {
      return (+*this).insert(img,pos,is_shared);
    }






    CImgList<T>& insert(const unsigned int n, const unsigned int pos=~0U) {
      CImg<T> empty;
      if (!n) return *this;
      const unsigned int npos = pos==~0U?_width:pos;
      for (unsigned int i = 0; i<n; ++i) insert(empty,npos+i);
      return *this;
    }


    CImgList<T> get_insert(const unsigned int n, const unsigned int pos=~0U) const {
      return (+*this).insert(n,pos);
    }
# 46282 "../src/CImg.h"
    template<typename t>
    CImgList<T>& insert(const unsigned int n, const CImg<t>& img, const unsigned int pos=~0U,
                        const bool is_shared=false) {
      if (!n) return *this;
      const unsigned int npos = pos==~0U?_width:pos;
      insert(img,npos,is_shared);
      for (unsigned int i = 1; i<n; ++i) insert(_data[npos],npos+i,is_shared);
      return *this;
    }


    template<typename t>
    CImgList<T> get_insert(const unsigned int n, const CImg<t>& img, const unsigned int pos=~0U,
                           const bool is_shared=false) const {
      return (+*this).insert(n,img,pos,is_shared);
    }







    template<typename t>
    CImgList<T>& insert(const CImgList<t>& list, const unsigned int pos=~0U, const bool is_shared=false) {
      const unsigned int npos = pos==~0U?_width:pos;
      if ((void*)this!=(void*)&list) for (int l = 0; l<(int)(list)._width; ++l) insert(list[l],npos+l,is_shared);
      else insert(CImgList<T>(list),npos,is_shared);
      return *this;
    }


    template<typename t>
    CImgList<T> get_insert(const CImgList<t>& list, const unsigned int pos=~0U, const bool is_shared=false) const {
      return (+*this).insert(list,pos,is_shared);
    }
# 46326 "../src/CImg.h"
    template<typename t>
    CImgList<T>& insert(const unsigned int n, const CImgList<t>& list, const unsigned int pos=~0U,
                        const bool is_shared=false) {
      if (!n) return *this;
      const unsigned int npos = pos==~0U?_width:pos;
      for (unsigned int i = 0; i<n; ++i) insert(list,npos,is_shared);
      return *this;
    }


    template<typename t>
    CImgList<T> get_insert(const unsigned int n, const CImgList<t>& list, const unsigned int pos=~0U,
                           const bool is_shared=false) const {
      return (+*this).insert(n,list,pos,is_shared);
    }






    CImgList<T>& remove(const unsigned int pos1, const unsigned int pos2) {
      const unsigned int
        npos1 = pos1<pos2?pos1:pos2,
        tpos2 = pos1<pos2?pos2:pos1,
        npos2 = tpos2<_width?tpos2:_width-1;
      if (npos1>=_width)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "remove(): Invalid remove request at positions %u->%u.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    npos1,tpos2);
      else {
        if (tpos2>=_width)
          throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                      "remove(): Invalid remove request at positions %u->%u.",
                                      _width,_allocated_width,_data,pixel_type(),
                                      npos1,tpos2);

        for (unsigned int k = npos1; k<=npos2; ++k) _data[k].assign();
        const unsigned int nb = 1 + npos2 - npos1;
        if (!(_width-=nb)) return assign();
        if (_width>(_allocated_width>>2) || _allocated_width<=16) {
          if (npos1!=_width) std::memmove(_data+npos1,_data+npos2+1,sizeof(CImg<T>)*(_width - npos1));
          std::memset(_data + _width,0,sizeof(CImg<T>)*nb);
        } else {
          _allocated_width>>=2;
          while (_allocated_width>16 && _width<(_allocated_width>>1)) _allocated_width>>=1;
          CImg<T> *const new_data = new CImg<T>[_allocated_width];
          if (npos1) std::memcpy(new_data,_data,sizeof(CImg<T>)*npos1);
          if (npos1!=_width) std::memcpy(new_data+npos1,_data+npos2+1,sizeof(CImg<T>)*(_width-npos1));
          if (_width!=_allocated_width) std::memset(new_data+_width,0,sizeof(_allocated_width - _width));
          std::memset(_data,0,sizeof(CImg<T>)*(_width+nb));
          delete[] _data;
          _data = new_data;
        }
      }
      return *this;
    }


    CImgList<T> get_remove(const unsigned int pos1, const unsigned int pos2) const {
      return (+*this).remove(pos1,pos2);
    }





    CImgList<T>& remove(const unsigned int pos) {
      return remove(pos,pos);
    }


    CImgList<T> get_remove(const unsigned int pos) const {
      return (+*this).remove(pos);
    }




    CImgList<T>& remove() {
      return remove(_width-1);
    }


    CImgList<T> get_remove() const {
      return (+*this).remove();
    }


    CImgList<T>& reverse() {
      for (unsigned int l = 0; l<_width/2; ++l) (*this)[l].swap((*this)[_width-1-l]);
      return *this;
    }


    CImgList<T> get_reverse() const {
      return (+*this).reverse();
    }






    CImgList<T>& images(const unsigned int pos0, const unsigned int pos1) {
      return get_images(pos0,pos1).move_to(*this);
    }


    CImgList<T> get_images(const unsigned int pos0, const unsigned int pos1) const {
      if (pos0>pos1 || pos1>=_width)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "images(): Specified sub-list indices (%u->%u) are out of bounds.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    pos0,pos1);
      CImgList<T> res(pos1-pos0+1);
      for (int l = 0; l<(int)(res)._width; ++l) res[l].assign(_data[pos0+l]);
      return res;
    }






    CImgList<T> get_shared_images(const unsigned int pos0, const unsigned int pos1) {
      if (pos0>pos1 || pos1>=_width)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "get_shared_images(): Specified sub-list indices (%u->%u) are out of bounds.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    pos0,pos1);
      CImgList<T> res(pos1-pos0+1);
      for (int l = 0; l<(int)(res)._width; ++l) res[l].assign(_data[pos0+l],_data[pos0+l]?true:false);
      return res;
    }


    const CImgList<T> get_shared_images(const unsigned int pos0, const unsigned int pos1) const {
      if (pos0>pos1 || pos1>=_width)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "get_shared_images(): Specified sub-list indices (%u->%u) are out of bounds.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    pos0,pos1);
      CImgList<T> res(pos1-pos0+1);
      for (int l = 0; l<(int)(res)._width; ++l) res[l].assign(_data[pos0+l],_data[pos0+l]?true:false);
      return res;
    }






    CImg<T> get_append(const char axis, const float align=0) const {
      if (is_empty()) return CImg<T>();
      if (_width==1) return +((*this)[0]);
      unsigned int dx = 0, dy = 0, dz = 0, dc = 0, pos = 0;
      CImg<T> res;
      switch (cimg::uncase(axis)) {
      case 'x' : {
        for (int l = 0; l<(int)(*this)._width; ++l) {
          const CImg<T>& img = (*this)[l];
          if (img) {
            dx+=img._width;
            dy = cimg::max(dy,img._height);
            dz = cimg::max(dz,img._depth);
            dc = cimg::max(dc,img._spectrum);
          }
        }
        res.assign(dx,dy,dz,dc,0);
        if (res) for (int l = 0; l<(int)(*this)._width; ++l) {
            const CImg<T>& img = (*this)[l];
            if (img) res.draw_image(pos,
                                    (int)(align*(dy-img._height)),
                                    (int)(align*(dz-img._depth)),
                                    (int)(align*(dc-img._spectrum)),
                                    img);
            pos+=img._width;
          }
      } break;
      case 'y' : {
        for (int l = 0; l<(int)(*this)._width; ++l) {
          const CImg<T>& img = (*this)[l];
          if (img) {
            dx = cimg::max(dx,img._width);
            dy+=img._height;
            dz = cimg::max(dz,img._depth);
            dc = cimg::max(dc,img._spectrum);
          }
        }
        res.assign(dx,dy,dz,dc,0);
        if (res) for (int l = 0; l<(int)(*this)._width; ++l) {
            const CImg<T>& img = (*this)[l];
            if (img) res.draw_image((int)(align*(dx-img._width)),
                                    pos,
                                    (int)(align*(dz-img._depth)),
                                    (int)(align*(dc-img._spectrum)),
                                    img);
            pos+=img._height;
          }
      } break;
      case 'z' : {
        for (int l = 0; l<(int)(*this)._width; ++l) {
          const CImg<T>& img = (*this)[l];
          if (img) {
            dx = cimg::max(dx,img._width);
            dy = cimg::max(dy,img._height);
            dz+=img._depth;
            dc = cimg::max(dc,img._spectrum);
          }
        }
        res.assign(dx,dy,dz,dc,0);
        if (res) for (int l = 0; l<(int)(*this)._width; ++l) {
            const CImg<T>& img = (*this)[l];
            if (img) res.draw_image((int)(align*(dx-img._width)),
                                    (int)(align*(dy-img._height)),
                                    pos,
                                    (int)(align*(dc-img._spectrum)),
                                    img);
            pos+=img._depth;
          }
      } break;
      default : {
        for (int l = 0; l<(int)(*this)._width; ++l) {
          const CImg<T>& img = (*this)[l];
          if (img) {
            dx = cimg::max(dx,img._width);
            dy = cimg::max(dy,img._height);
            dz = cimg::max(dz,img._depth);
            dc+=img._spectrum;
          }
        }
        res.assign(dx,dy,dz,dc,0);
        if (res) for (int l = 0; l<(int)(*this)._width; ++l) {
            const CImg<T>& img = (*this)[l];
            if (img) res.draw_image((int)(align*(dx-img._width)),
                                    (int)(align*(dy-img._height)),
                                    (int)(align*(dz-img._depth)),
                                    pos,
                                    img);
            pos+=img._spectrum;
          }
      }
      }
      return res;
    }






    CImgList<T>& split(const char axis, const int nb=0) {
      return get_split(axis,nb).move_to(*this);
    }


    CImgList<T> get_split(const char axis, const int nb=0) const {
      CImgList<T> res;
      for (int l = 0; l<(int)(*this)._width; ++l) _data[l].get_split(axis,nb).move_to(res,~0U);
      return res;
    }





    template<typename t>
    CImgList<T>& push_back(const CImg<t>& img) {
      return insert(img);
    }





    template<typename t>
    CImgList<T>& push_front(const CImg<t>& img) {
      return insert(img,0);
    }





    template<typename t>
    CImgList<T>& push_back(const CImgList<t>& list) {
      return insert(list);
    }





    template<typename t>
    CImgList<T>& push_front(const CImgList<t>& list) {
      return insert(list,0);
    }




    CImgList<T>& pop_back() {
      return remove(_width-1);
    }




    CImgList<T>& pop_front() {
      return remove(0);
    }





    CImgList<T>& erase(const iterator iter) {
      return remove(iter-_data);
    }
# 46663 "../src/CImg.h"
    CImg<intT> get_select(CImgDisplay &disp, const bool feature_type=true,
                          const char axis='x', const float align=0) const {
      return _get_select(disp,0,feature_type,axis,align,0,false,false,false);
    }
# 46676 "../src/CImg.h"
    CImg<intT> get_select(const char *const title, const bool feature_type=true,
                          const char axis='x', const float align=0) const {
      CImgDisplay disp;
      return _get_select(disp,title,feature_type,axis,align,0,false,false,false);
    }

    CImg<intT> _get_select(CImgDisplay &disp, const char *const title, const bool feature_type,
                           const char axis, const float align,
                           const unsigned int orig, const bool resize_disp,
                           const bool exit_on_rightbutton, const bool exit_on_wheel) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "select(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());


      CImgList<uintT> _indices;
      unsigned int max_width = 0, max_height = 0, sum_width = 0, sum_height = 0;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        const unsigned int
          w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
          h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
        if (w>max_width) max_width = w;
        if (h>max_height) max_height = h;
        sum_width+=w; sum_height+=h;
        if (axis=='x') CImg<uintT>(w,1,1,1,(unsigned int)l).move_to(_indices);
        else CImg<uintT>(h,1,1,1,(unsigned int)l).move_to(_indices);
      }
      const CImg<uintT> indices0 = _indices>'x';


      if (!disp) {
        if (axis=='x') disp.assign(CImgDisplay::_fitscreen(sum_width,max_height,1,128,-85,false), CImgDisplay::_fitscreen(sum_width,max_height,1,128,-85,true),title?title:0,1);
        else disp.assign(CImgDisplay::_fitscreen(max_width,sum_height,1,128,-85,false), CImgDisplay::_fitscreen(max_width,sum_height,1,128,-85,true),title?title:0,1);
        if (!title) disp.set_title("CImgList<%s> (%u)",pixel_type(),_width);
      } else if (title) disp.set_title("%s",title);
      if (resize_disp) {
        if (axis=='x') disp.resize(CImgDisplay::_fitscreen(sum_width,max_height,1,128,-85,false), CImgDisplay::_fitscreen(sum_width,max_height,1,128,-85,true),false);
        else disp.resize(CImgDisplay::_fitscreen(max_width,sum_height,1,128,-85,false), CImgDisplay::_fitscreen(max_width,sum_height,1,128,-85,true),false);
      }

      const unsigned int old_normalization = disp.normalization();
      bool old_is_resized = disp.is_resized();
      disp._normalization = 0;
      disp.show().set_key(0);
      const unsigned char foreground_color[] = { 255,255,255 }, background_color[] = { 0,0,0 };


      CImg<ucharT> visu0, visu;
      CImg<uintT> indices;
      CImg<intT> positions(_width,4,1,1,-1);
      int oindice0 = -1, oindice1 = -1, indice0 = -1, indice1 = -1;
      bool is_clicked = false, is_selected = false, text_down = false, update_display = true;
      unsigned int key = 0;
      while (!is_selected && !disp.is_closed() && !key) {


        if (!visu0) {
          visu0.assign(disp._width,disp._height,1,3,0); visu.assign();
          (indices0.get_resize(axis=='x'?visu0._width:visu0._height,1)).move_to(indices);
          unsigned int ind = 0;
          if (axis=='x') for (unsigned int x = 0; x<visu0._width; ) {
              const unsigned int x0 = x;
              ind = indices[x];
              while (x<indices._width && indices[x++]==ind) {}
              const CImg<T>
                onexone(1,1,1,1,0),
                &src = _data[ind]?_data[ind]:onexone;
              CImg<ucharT> res;
              src.__get_select(disp,old_normalization,(src._width-1)/2,(src._height-1)/2,(src._depth-1)/2).move_to(res);
              const unsigned int h = CImgDisplay::_fitscreen(res._width,res._height,1,128,-85,true);
              res.resize(x - x0,cimg::max(32U,h*disp._height/max_height),1,res._spectrum==1?3:-100);
              positions(ind,0) = positions(ind,2) = (int)x0;
              positions(ind,1) = positions(ind,3) = (int)(align*(visu0.height()-res.height()));
              positions(ind,2)+=res._width;
              positions(ind,3)+=res._height - 1;
              visu0.draw_image(positions(ind,0),positions(ind,1),res);
            } else for (unsigned int y = 0; y<visu0._height; ) {
              const unsigned int y0 = y;
              ind = indices[y];
              while (y<visu0._height && indices[++y]==ind) {}
              const CImg<T>
                &src = _data[ind],
                _img2d = src._depth>1?src.get_projections2d((src._width-1)/2,(src._height-1)/2,(src._depth-1)/2):
                  CImg<T>(),
                &img2d = _img2d?_img2d:src;
              CImg<ucharT> res = old_normalization==1 ||
                (old_normalization==3 && cimg::type<T>::string()!=cimg::type<unsigned char>::string())?
                CImg<ucharT>(img2d.get_normalize(0,255)):
                CImg<ucharT>(img2d);
              if (res._spectrum>3) res.channels(0,2);
              const unsigned int w = CImgDisplay::_fitscreen(res._width,res._height,1,128,-85,false);
              res.resize(cimg::max(32U,w*disp._width/max_width),y - y0,1,res._spectrum==1?3:-100);
              positions(ind,0) = positions(ind,2) = (int)(align*(visu0.width()-res.width()));
              positions(ind,1) = positions(ind,3) = (int)y0;
              positions(ind,2)+=res._width - 1;
              positions(ind,3)+=res._height;
              visu0.draw_image(positions(ind,0),positions(ind,1),res);
            }
          if (axis=='x') --positions(ind,2); else --positions(ind,3);
          update_display = true;
        }

        if (!visu || oindice0!=indice0 || oindice1!=indice1) {
          if (indice0>=0 && indice1>=0) {
            visu.assign(visu0,false);
            const int indm = cimg::min(indice0,indice1), indM = cimg::max(indice0,indice1);
            for (int ind = indm; ind<=indM; ++ind) if (positions(ind,0)>=0) {
                visu.draw_rectangle(positions(ind,0),positions(ind,1),positions(ind,2),positions(ind,3),
                                    background_color,0.2f);
                if ((axis=='x' && positions(ind,2) - positions(ind,0)>=8) ||
                    (axis!='x' && positions(ind,3) - positions(ind,1)>=8))
                  visu.draw_rectangle(positions(ind,0),positions(ind,1),positions(ind,2),positions(ind,3),
                                      foreground_color,0.9f,0xAAAAAAAA);
              }
            const int yt = (int)text_down?visu.height()-13:0;
            if (is_clicked) visu.draw_text(0,yt," Images #%u - #%u, Size = %u",
                                           foreground_color,background_color,0.7f,13,
                                           orig + indm,orig + indM,indM - indm + 1);
            else visu.draw_text(0,yt," Image #%u (%u,%u,%u,%u)",foreground_color,background_color,0.7f,13,
                                orig + indice0,
                                _data[orig+indice0]._width,
                                _data[orig+indice0]._height,
                                _data[orig+indice0]._depth,
                                _data[orig+indice0]._spectrum);
            update_display = true;
          } else visu.assign();
        }
        if (!visu) { visu.assign(visu0,true); update_display = true; }
        if (update_display) { visu.display(disp); update_display = false; }
        disp.wait();


        const int xm = disp.mouse_x(), ym = disp.mouse_y();
        int indice = -1;

        if (xm>=0) {
          indice = (int)indices(axis=='x'?xm:ym);
          if (disp.button()&1) {
            if (!is_clicked) { is_clicked = true; oindice0 = indice0; indice0 = indice; }
            oindice1 = indice1; indice1 = indice;
            if (!feature_type) is_selected = true;
          } else {
            if (!is_clicked) { oindice0 = oindice1 = indice0; indice0 = indice1 = indice; }
            else is_selected = true;
          }
        } else {
          if (is_clicked) {
            if (!(disp.button()&1)) { is_clicked = is_selected = false; indice0 = indice1 = -1; }
            else indice1 = -1;
          } else indice0 = indice1 = -1;
        }

        if (disp.button()&4) { is_clicked = is_selected = false; indice0 = indice1 = -1; }
        if (disp.button()&2 && exit_on_rightbutton) { is_selected = true; indice1 = indice0 = -1; }
        if (disp.wheel() && exit_on_wheel) is_selected = true;

        switch (key = disp.key()) {

        case cimg::keyCTRLRIGHT :

        case 0 : case cimg::keyCTRLLEFT : key = 0; break;
        case cimg::keyD : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).
              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
              _is_resized = true;
            disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyC : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).
              resize(CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,false), CImgDisplay::_fitscreen(2*disp.width()/3,2*disp.height()/3,1,128,-85,true),false)._is_resized = true;
            disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyR : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.set_fullscreen(false).
              resize(CImgDisplay::_fitscreen(axis=='x'?sum_width:max_width,axis=='x'?max_height:sum_height,1,128,-85,false), CImgDisplay::_fitscreen(axis=='x'?sum_width:max_width,axis=='x'?max_height:sum_height,1,128,-85,true),false).
              _is_resized = true;
            disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyF : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            disp.resize(disp.screen_width(),disp.screen_height(),false).toggle_fullscreen()._is_resized = true;
            disp.set_key(key,false); key = 0; visu0.assign();
          } break;
        case cimg::keyS : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            char filename[32] = { 0 };
            std::FILE *file;
            do {
              snprintf(filename,sizeof(filename),"CImg" "_%.4u.bmp",snap_number++);
              if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
            } while (file);
            if (visu0) {
              (+visu0).draw_text(0,0," Saving snapshot... ",
                                 foreground_color,background_color,0.7f,13).display(disp);
              visu0.save(filename);
              (+visu0).draw_text(0,0," Snapshot '%s' saved. ",
                                 foreground_color,background_color,0.7f,13,filename).display(disp);
            }
            disp.set_key(key,false).wait(); key = 0;
          } break;
        case cimg::keyO :
          if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) {
            static unsigned int snap_number = 0;
            char filename[32] = { 0 };
            std::FILE *file;
            do {



              snprintf(filename,sizeof(filename),"CImg" "_%.4u.cimg",snap_number++);

              if ((file=std::fopen(filename,"r"))!=0) cimg::fclose(file);
            } while (file);
            (+visu0).draw_text(0,0," Saving instance... ",
                               foreground_color,background_color,0.7f,13).display(disp);
            save(filename);
            (+visu0).draw_text(0,0," Instance '%s' saved. ",
                               foreground_color,background_color,0.7f,13,filename).display(disp);
            disp.set_key(key,false).wait(); key = 0;
          } break;
        }
        if (disp.is_resized()) { disp.resize(false); visu0.assign(); }
        if (ym>=0 && ym<13) { if (!text_down) { visu.assign(); text_down = true; }}
        else if (ym>=visu.height()-13) { if(text_down) { visu.assign(); text_down = false; }}
      }
      CImg<intT> res(1,2,1,1,-1);
      if (is_selected) {
        if (feature_type) res.fill(cimg::min(indice0,indice1),cimg::max(indice0,indice1));
        else res.fill(indice0);
      }
      if (!(disp.button()&2)) disp.set_button();
      disp._normalization = old_normalization;
      disp._is_resized = old_is_resized;
      disp.set_key(key);
      return res;
    }





    CImgList<T>& load(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());

      if (!cimg::strncasecmp(filename,"http://",7) || !cimg::strncasecmp(filename,"https://",8)) {
        char filename_local[1024] = { 0 };
        load(cimg::load_network_external(filename,filename_local));
        std::remove(filename_local);
        return *this;
      }

      const char *const ext = cimg::split_filename(filename);
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      try {
# 46963 "../src/CImg.h"
        if (!cimg::strcasecmp(ext,"tif") ||
            !cimg::strcasecmp(ext,"tiff")) load_tiff(filename);
        else if (!cimg::strcasecmp(ext,"gif")) load_gif_external(filename);
        else if (!cimg::strcasecmp(ext,"cimg") ||
                 !cimg::strcasecmp(ext,"cimgz") ||
                 !*ext) load_cimg(filename);
        else if (!cimg::strcasecmp(ext,"rec") ||
                 !cimg::strcasecmp(ext,"par")) load_parrec(filename);
        else if (!cimg::strcasecmp(ext,"avi") ||
                 !cimg::strcasecmp(ext,"mov") ||
                 !cimg::strcasecmp(ext,"asf") ||
                 !cimg::strcasecmp(ext,"divx") ||
                 !cimg::strcasecmp(ext,"flv") ||
                 !cimg::strcasecmp(ext,"mpg") ||
                 !cimg::strcasecmp(ext,"m1v") ||
                 !cimg::strcasecmp(ext,"m2v") ||
                 !cimg::strcasecmp(ext,"m4v") ||
                 !cimg::strcasecmp(ext,"mjp") ||
                 !cimg::strcasecmp(ext,"mp4") ||
                 !cimg::strcasecmp(ext,"mkv") ||
                 !cimg::strcasecmp(ext,"mpe") ||
                 !cimg::strcasecmp(ext,"movie") ||
                 !cimg::strcasecmp(ext,"ogm") ||
                 !cimg::strcasecmp(ext,"ogg") ||
                 !cimg::strcasecmp(ext,"ogv") ||
                 !cimg::strcasecmp(ext,"qt") ||
                 !cimg::strcasecmp(ext,"rm") ||
                 !cimg::strcasecmp(ext,"vob") ||
                 !cimg::strcasecmp(ext,"wmv") ||
                 !cimg::strcasecmp(ext,"xvid") ||
                 !cimg::strcasecmp(ext,"mpeg")) load_ffmpeg(filename);
        else if (!cimg::strcasecmp(ext,"gz")) load_gzip_external(filename);
        else throw CImgIOException("CImgList<%s>::load()",
                                   pixel_type());
      } catch (CImgIOException&) {
        try {
          cimg::fclose(cimg::fopen(filename,"rb"));
        } catch (CImgIOException&) {
          cimg::exception_mode() = omode;
          throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                                "load(): Failed to open file '%s'.",
                                _width,_allocated_width,_data,pixel_type(),
                                filename);
        }
        assign(1);
        try {
          _data->load(filename);
        } catch (CImgIOException&) {
          cimg::exception_mode() = omode;
          throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                                "load(): Failed to recognize format of file '%s'.",
                                _width,_allocated_width,_data,pixel_type(),
                                filename);
        }
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    static CImgList<T> get_load(const char *const filename) {
      return CImgList<T>().load(filename);
    }





    CImgList<T>& load_cimg(const char *const filename) {
      return _load_cimg(0,filename);
    }


    static CImgList<T> get_load_cimg(const char *const filename) {
      return CImgList<T>().load_cimg(filename);
    }





    CImgList<T>& load_cimg(std::FILE *const file) {
      return _load_cimg(file,0);
    }


    static CImgList<T> get_load_cimg(std::FILE *const file) {
      return CImgList<T>().load_cimg(file);
    }

    CImgList<T>& _load_cimg(std::FILE *const file, const char *const filename) {
# 47102 "../src/CImg.h"
      if (!filename && !file)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_cimg(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());

      const int cimg_iobuffer = 12*1024*1024;
      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      bool loaded = false, endian = cimg::endianness();
      char tmp[256] = { 0 }, str_pixeltype[256] = { 0 }, str_endian[256] = { 0 };
      unsigned int j, err, N = 0, W, H, D, C, csiz;
      int i;
      do {
        j = 0; while ((i=std::fgetc(nfile))!='\n' && i!=(-1) && j<256) tmp[j++] = (char)i; tmp[j] = 0;
      } while (*tmp=='#' && i!=(-1));
      err = std::sscanf(tmp,"%u%*c%255[A-Za-z_]%*c%255[sA-Za-z_ ]",&N,str_pixeltype,str_endian);
      if (err<2) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_cimg(): CImg header not found in file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename?filename:"(FILE*)");
      }
      if (!cimg::strncasecmp("little",str_endian,6)) endian = false;
      else if (!cimg::strncasecmp("big",str_endian,3)) endian = true;
      assign(N);
      if (!loaded && !cimg::strcasecmp("bool",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<bool> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const bool *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("unsigned_char",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<unsigned char> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const unsigned char *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("uchar",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<unsigned char> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const unsigned char *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("char",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<char> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const char *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("unsigned_short",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<unsigned short> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const unsigned short *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("ushort",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<unsigned short> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const unsigned short *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("short",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<short> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const short *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("unsigned_int",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<unsigned int> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const unsigned int *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("uint",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<unsigned int> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const unsigned int *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("int",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<int> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const int *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("unsigned_long",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<unsigned long> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const unsigned long *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("ulong",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<unsigned long> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const unsigned long *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("long",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<long> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const long *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("float",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<float> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const float *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("double",str_pixeltype)) { for (unsigned int l = 0; l<N; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; csiz = 0; if ((err = std::sscanf(tmp,"%u %u %u %u #%u",&W,&H,&D,&C,&csiz))<4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:("(FILE*)")); if (W*H*D*C>0) { CImg<double> raw; CImg<T> &img = _data[l]; img.assign(W,H,D,C); T *ptrd = img._data; if (err==5) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Unable to load compressed data from file '%s' unless zlib is enabled.", _width,_allocated_width,_data,pixel_type(), filename?filename:"(FILE*)"); else for (long to_read = (long)img.size(); to_read>0; ) { raw.assign(cimg::min(to_read,cimg_iobuffer)); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); to_read-=raw._width; const double *ptrs = raw._data; for (unsigned long off = (unsigned long)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); } } } loaded = true; };
      if (!loaded) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_cimg(): Unsupported pixel type '%s' for file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),
                              str_pixeltype,filename?filename:"(FILE*)");
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }
# 47167 "../src/CImg.h"
    CImgList<T>& load_cimg(const char *const filename,
                           const unsigned int n0, const unsigned int n1,
                           const unsigned int x0, const unsigned int y0,
                           const unsigned int z0, const unsigned int c0,
                           const unsigned int x1, const unsigned int y1,
                           const unsigned int z1, const unsigned int c1) {
      return _load_cimg(0,filename,n0,n1,x0,y0,z0,c0,x1,y1,z1,c1);
    }


    static CImgList<T> get_load_cimg(const char *const filename,
                                     const unsigned int n0, const unsigned int n1,
                                     const unsigned int x0, const unsigned int y0,
                                     const unsigned int z0, const unsigned int c0,
                                     const unsigned int x1, const unsigned int y1,
                                     const unsigned int z1, const unsigned int c1) {
      return CImgList<T>().load_cimg(filename,n0,n1,x0,y0,z0,c0,x1,y1,z1,c1);
    }


    CImgList<T>& load_cimg(std::FILE *const file,
                           const unsigned int n0, const unsigned int n1,
                           const unsigned int x0, const unsigned int y0,
                           const unsigned int z0, const unsigned int c0,
                           const unsigned int x1, const unsigned int y1,
                           const unsigned int z1, const unsigned int c1) {
      return _load_cimg(file,0,n0,n1,x0,y0,z0,c0,x1,y1,z1,c1);
    }


    static CImgList<T> get_load_cimg(std::FILE *const file,
                                     const unsigned int n0, const unsigned int n1,
                                     const unsigned int x0, const unsigned int y0,
                                     const unsigned int z0, const unsigned int c0,
                                     const unsigned int x1, const unsigned int y1,
                                     const unsigned int z1, const unsigned int c1) {
      return CImgList<T>().load_cimg(file,n0,n1,x0,y0,z0,c0,x1,y1,z1,c1);
    }

    CImgList<T>& _load_cimg(std::FILE *const file, const char *const filename,
                            const unsigned int n0, const unsigned int n1,
                            const unsigned int x0, const unsigned int y0,
                            const unsigned int z0, const unsigned int c0,
                            const unsigned int x1, const unsigned int y1,
                            const unsigned int z1, const unsigned int c1) {
# 47273 "../src/CImg.h"
      if (!filename && !file)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_cimg(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      unsigned int
        nn0 = cimg::min(n0,n1), nn1 = cimg::max(n0,n1),
        nx0 = cimg::min(x0,x1), nx1 = cimg::max(x0,x1),
        ny0 = cimg::min(y0,y1), ny1 = cimg::max(y0,y1),
        nz0 = cimg::min(z0,z1), nz1 = cimg::max(z0,z1),
        nc0 = cimg::min(c0,c1), nc1 = cimg::max(c0,c1);

      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      bool loaded = false, endian = cimg::endianness();
      char tmp[256] = { 0 }, str_pixeltype[256] = { 0 }, str_endian[256] = { 0 };
      unsigned int j, err, N, W, H, D, C;
      int i;
      j = 0; while((i=std::fgetc(nfile))!='\n' && i!=(-1) && j<256) tmp[j++] = (char)i; tmp[j] = 0;
      err = std::sscanf(tmp,"%u%*c%255[A-Za-z_]%*c%255[sA-Za-z_ ]",&N,str_pixeltype,str_endian);
      if (err<2) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_cimg(): CImg header not found in file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename?filename:"(FILE*)");
      }
      if (!cimg::strncasecmp("little",str_endian,6)) endian = false;
      else if (!cimg::strncasecmp("big",str_endian,3)) endian = true;
      nn1 = n1==~0U?N-1:n1;
      if (nn1>=N)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_cimg(): Invalid specified coordinates [%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) "
                                    "because file '%s' contains only %u images.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,filename?filename:"(FILE*)",N);
      assign(1+nn1-n0);
      if (!loaded && !cimg::strcasecmp("bool",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(bool),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<bool> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(bool); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(bool); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(bool); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(bool); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const bool *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(bool); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(bool); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(bool); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(bool); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("unsigned_char",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(unsigned char),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<unsigned char> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(unsigned char); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(unsigned char); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(unsigned char); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(unsigned char); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const unsigned char *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(unsigned char); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(unsigned char); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(unsigned char); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(unsigned char); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("uchar",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(unsigned char),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<unsigned char> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(unsigned char); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(unsigned char); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(unsigned char); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(unsigned char); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const unsigned char *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(unsigned char); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(unsigned char); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(unsigned char); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(unsigned char); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("char",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(char),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<char> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(char); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(char); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(char); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(char); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const char *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(char); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(char); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(char); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(char); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("unsigned_short",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(unsigned short),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<unsigned short> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(unsigned short); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(unsigned short); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(unsigned short); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(unsigned short); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const unsigned short *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(unsigned short); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(unsigned short); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(unsigned short); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(unsigned short); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("ushort",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(unsigned short),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<unsigned short> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(unsigned short); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(unsigned short); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(unsigned short); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(unsigned short); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const unsigned short *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(unsigned short); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(unsigned short); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(unsigned short); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(unsigned short); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("short",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(short),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<short> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(short); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(short); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(short); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(short); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const short *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(short); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(short); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(short); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(short); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("unsigned_int",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(unsigned int),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<unsigned int> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(unsigned int); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(unsigned int); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(unsigned int); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(unsigned int); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const unsigned int *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(unsigned int); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(unsigned int); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(unsigned int); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(unsigned int); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("uint",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(unsigned int),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<unsigned int> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(unsigned int); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(unsigned int); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(unsigned int); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(unsigned int); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const unsigned int *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(unsigned int); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(unsigned int); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(unsigned int); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(unsigned int); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("int",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(int),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<int> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(int); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(int); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(int); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(int); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const int *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(int); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(int); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(int); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(int); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("unsigned_long",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(unsigned long),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<unsigned long> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(unsigned long); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(unsigned long); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(unsigned long); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(unsigned long); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const unsigned long *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(unsigned long); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(unsigned long); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(unsigned long); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(unsigned long); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("ulong",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(unsigned long),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<unsigned long> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(unsigned long); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(unsigned long); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(unsigned long); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(unsigned long); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const unsigned long *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(unsigned long); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(unsigned long); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(unsigned long); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(unsigned long); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("long",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(long),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<long> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(long); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(long); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(long); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(long); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const long *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(long); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(long); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(long); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(long); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("float",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(float),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<float> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(float); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(float); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(float); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(float); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const float *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(float); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(float); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(float); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(float); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded && !cimg::strcasecmp("double",str_pixeltype)) { for (unsigned int l = 0; l<=nn1; ++l) { j = 0; while ((i=std::fgetc(nfile))!='\n' && i>=0) tmp[j++] = (char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified size (%u,%u,%u,%u) of image %u in file '%s'", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<nn0 || nx0>=W || ny0>=H || nz0>=D || nc0>=C) std::fseek(nfile,W*H*D*C*sizeof(double),1); else { const unsigned int _nx1 = nx1==~0U?W-1:nx1, _ny1 = ny1==~0U?H-1:ny1, _nz1 = nz1==~0U?D-1:nz1, _nc1 = nc1==~0U?C-1:nc1; if (_nx1>=W || _ny1>=H || _nz1>=D || _nc1>=C) throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::" "load_cimg(): Invalid specified coordinates " "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " "because image [%u] in file '%s' has size (%u,%u,%u,%u).", _width,_allocated_width,_data,pixel_type(), n0,x0,y0,z0,c0,n1,x1,y1,z1,c1,l,filename?filename:"(FILE*)",W,H,D,C); CImg<double> raw(1 + _nx1 - nx0); CImg<T> &img = _data[l - nn0]; img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); T *ptrd = img._data; const unsigned int skipvb = nc0*W*H*D*sizeof(double); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int c = 1 + _nc1 - nc0; c; --c) { const unsigned int skipzb = nz0*W*H*sizeof(double); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + _nz1 - nz0; z; --z) { const unsigned int skipyb = ny0*W*sizeof(double); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + _ny1 - ny0; y; --y) { const unsigned int skipxb = nx0*sizeof(double); if (skipxb) std::fseek(nfile,skipxb,1); cimg::fread(raw._data,raw._width,nfile); if (endian!=cimg::endianness()) cimg::invert_endianness(raw._data,raw._width); const double *ptrs = raw._data; for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); const unsigned int skipxe = (W-1-_nx1)*sizeof(double); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H-1-_ny1)*W*sizeof(double); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D-1-_nz1)*W*H*sizeof(double); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C-1-_nc1)*W*H*D*sizeof(double); if (skipve) std::fseek(nfile,skipve,1); } } } loaded = true; };
      if (!loaded) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_cimg(): Unsupported pixel type '%s' for file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),
                              str_pixeltype,filename?filename:"(FILE*)");
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }





    CImgList<T>& load_parrec(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_parrec(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());

      char body[1024] = { 0 }, filenamepar[1024] = { 0 }, filenamerec[1024] = { 0 };
      const char *const ext = cimg::split_filename(filename,body);
      if (!std::strcmp(ext,"par")) {
        std::strncpy(filenamepar,filename,sizeof(filenamepar)-1);
        snprintf(filenamerec,sizeof(filenamerec),"%s.rec",body);
      }
      if (!std::strcmp(ext,"PAR")) {
        std::strncpy(filenamepar,filename,sizeof(filenamepar)-1);
        snprintf(filenamerec,sizeof(filenamerec),"%s.REC",body);
      }
      if (!std::strcmp(ext,"rec")) {
        std::strncpy(filenamerec,filename,sizeof(filenamerec)-1);
        snprintf(filenamepar,sizeof(filenamepar),"%s.par",body);
      }
      if (!std::strcmp(ext,"REC")) {
        std::strncpy(filenamerec,filename,sizeof(filenamerec)-1);
        snprintf(filenamepar,sizeof(filenamepar),"%s.PAR",body);
      }
      std::FILE *file = cimg::fopen(filenamepar,"r");


      CImgList<floatT> st_slices;
      CImgList<uintT> st_global;
      int err;
      char line[256] = { 0 };
      do { err=std::fscanf(file,"%255[^\n]%*c",line); } while (err!=(-1) && (*line=='#' || *line=='.'));
      do {
        unsigned int sn,size_x,size_y,pixsize;
        float rs,ri,ss;
        err = std::fscanf(file,"%u%*u%*u%*u%*u%*u%*u%u%*u%u%u%g%g%g%*[^\n]",&sn,&pixsize,&size_x,&size_y,&ri,&rs,&ss);
        if (err==7) {
          CImg<floatT>::vector((float)sn,(float)pixsize,(float)size_x,(float)size_y,ri,rs,ss,0).move_to(st_slices);
          unsigned int i; for (i = 0; i<st_global._width && sn<=st_global[i][2]; ++i) {}
          if (i==st_global._width) CImg<uintT>::vector(size_x,size_y,sn).move_to(st_global);
          else {
            CImg<uintT> &vec = st_global[i];
            if (size_x>vec[0]) vec[0] = size_x;
            if (size_y>vec[1]) vec[1] = size_y;
            vec[2] = sn;
          }
          st_slices[st_slices._width-1][7] = (float)i;
        }
      } while (err==7);


      std::FILE *file2 = cimg::fopen(filenamerec,"rb");
      for (int l = 0; l<(int)(st_global)._width; ++l) {
        const CImg<uintT>& vec = st_global[l];
        CImg<T>(vec[0],vec[1],vec[2]).move_to(*this);
      }

      for (int l = 0; l<(int)(st_slices)._width; ++l) {
        const CImg<floatT>& vec = st_slices[l];
        const unsigned int
          sn = (unsigned int)vec[0] - 1,
          pixsize = (unsigned int)vec[1],
          size_x = (unsigned int)vec[2],
          size_y = (unsigned int)vec[3],
          imn = (unsigned int)vec[7];
        const float ri = vec[4], rs = vec[5], ss = vec[6];
        switch (pixsize) {
        case 8 : {
          CImg<ucharT> buf(size_x,size_y);
          cimg::fread(buf._data,size_x*size_y,file2);
          if (cimg::endianness()) cimg::invert_endianness(buf._data,size_x*size_y);
          CImg<T>& img = (*this)[imn];
          for (int y = 0; y<(int)((img)._height); ++y) for (int x = 0; x<(int)((img)._width); ++x) img(x,y,sn) = (T)(( buf(x,y)*rs + ri )/(rs*ss));
        } break;
        case 16 : {
          CImg<ushortT> buf(size_x,size_y);
          cimg::fread(buf._data,size_x*size_y,file2);
          if (cimg::endianness()) cimg::invert_endianness(buf._data,size_x*size_y);
          CImg<T>& img = (*this)[imn];
          for (int y = 0; y<(int)((img)._height); ++y) for (int x = 0; x<(int)((img)._width); ++x) img(x,y,sn) = (T)(( buf(x,y)*rs + ri )/(rs*ss));
        } break;
        case 32 : {
          CImg<uintT> buf(size_x,size_y);
          cimg::fread(buf._data,size_x*size_y,file2);
          if (cimg::endianness()) cimg::invert_endianness(buf._data,size_x*size_y);
          CImg<T>& img = (*this)[imn];
          for (int y = 0; y<(int)((img)._height); ++y) for (int x = 0; x<(int)((img)._width); ++x) img(x,y,sn) = (T)(( buf(x,y)*rs + ri )/(rs*ss));
        } break;
        default :
          cimg::fclose(file);
          cimg::fclose(file2);
          throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                                "load_parrec(): Unsupported %d-bits pixel type for file '%s'.",
                                _width,_allocated_width,_data,pixel_type(),
                                pixsize,filename);
        }
      }
      cimg::fclose(file);
      cimg::fclose(file2);
      if (!_width)
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_parrec(): Failed to recognize valid PAR-REC data in file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename);
      return *this;
    }


    static CImgList<T> get_load_parrec(const char *const filename) {
      return CImgList<T>().load_parrec(filename);
    }
# 47460 "../src/CImg.h"
    CImgList<T>& load_yuv(const char *const filename,
                          const unsigned int size_x, const unsigned int size_y,
                          const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                          const unsigned int step_frame=1, const bool yuv2rgb=true) {
      return _load_yuv(0,filename,size_x,size_y,first_frame,last_frame,step_frame,yuv2rgb);
    }


    static CImgList<T> get_load_yuv(const char *const filename,
                                    const unsigned int size_x, const unsigned int size_y=1,
                                    const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                    const unsigned int step_frame=1, const bool yuv2rgb=true) {
      return CImgList<T>().load_yuv(filename,size_x,size_y,first_frame,last_frame,step_frame,yuv2rgb);
    }


    CImgList<T>& load_yuv(std::FILE *const file,
                          const unsigned int size_x, const unsigned int size_y,
                          const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                          const unsigned int step_frame=1, const bool yuv2rgb=true) {
      return _load_yuv(file,0,size_x,size_y,first_frame,last_frame,step_frame,yuv2rgb);
    }


    static CImgList<T> get_load_yuv(std::FILE *const file,
                                    const unsigned int size_x, const unsigned int size_y=1,
                                    const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                    const unsigned int step_frame=1, const bool yuv2rgb=true) {
      return CImgList<T>().load_yuv(file,size_x,size_y,first_frame,last_frame,step_frame,yuv2rgb);
    }

    CImgList<T>& _load_yuv(std::FILE *const file, const char *const filename,
                           const unsigned int size_x, const unsigned int size_y,
                           const unsigned int first_frame, const unsigned int last_frame,
                           const unsigned int step_frame, const bool yuv2rgb) {
      if (!filename && !file)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_yuv(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      if (size_x%2 || size_y%2)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_yuv(): Invalid odd XY dimensions %ux%u in file '%s'.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    size_x,size_y,filename?filename:"(FILE*)");
      if (!size_x || !size_y)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_yuv(): Invalid sequence size (%u,%u) in file '%s'.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    size_x,size_y,filename?filename:"(FILE*)");

      const unsigned int
        nfirst_frame = first_frame<last_frame?first_frame:last_frame,
        nlast_frame = first_frame<last_frame?last_frame:first_frame,
        nstep_frame = step_frame?step_frame:1;

      CImg<ucharT> tmp(size_x,size_y,1,3), UV(size_x/2,size_y/2,1,2);
      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
      bool stop_flag = false;
      int err;
      if (nfirst_frame) {
        err = std::fseek(nfile,nfirst_frame*(size_x*size_y + size_x*size_y/2),1);
        if (err) {
          if (!file) cimg::fclose(nfile);
          throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                                "load_yuv(): File '%s' doesn't contain frame number %u.",
                                _width,_allocated_width,_data,pixel_type(),
                                filename?filename:"(FILE*)",nfirst_frame);
        }
      }
      unsigned int frame;
      for (frame = nfirst_frame; !stop_flag && frame<=nlast_frame; frame+=nstep_frame) {
        tmp.fill(0);

        err = (int)std::fread((void*)(tmp._data),1,(unsigned long)tmp._width*tmp._height,nfile);
        if (err!=(int)(tmp._width*tmp._height)) {
          stop_flag = true;
          if (err>0)
            cimg::warn("[instance(%u,%u,%p)] CImgList<%s>::"
                       "load_yuv(): File '%s' contains incomplete data or given image dimensions "
                       "(%u,%u) are incorrect.",
                       _width,_allocated_width,_data,pixel_type(),
                       filename?filename:"(FILE*)",size_x,size_y);
        } else {
          UV.fill(0);

          err = (int)std::fread((void*)(UV._data),1,(size_t)(UV.size()),nfile);
          if (err!=(int)(UV.size())) {
            stop_flag = true;
            if (err>0)
              cimg::warn("[instance(%u,%u,%p)] CImgList<%s>::"
                         "load_yuv(): File '%s' contains incomplete data or given image dimensions (%u,%u) "
                         "are incorrect.",
                         _width,_allocated_width,_data,pixel_type(),
                         filename?filename:"(FILE*)",size_x,size_y);
          } else {
            for (int y = 0; y<(int)((UV)._height); ++y) for (int x = 0; x<(int)((UV)._width); ++x) {
              const int x2 = x*2, y2 = y*2;
              tmp(x2,y2,1) = tmp(x2+1,y2,1) = tmp(x2,y2+1,1) = tmp(x2+1,y2+1,1) = UV(x,y,0);
              tmp(x2,y2,2) = tmp(x2+1,y2,2) = tmp(x2,y2+1,2) = tmp(x2+1,y2+1,2) = UV(x,y,1);
            }
            if (yuv2rgb) tmp.YCbCrtoRGB();
            insert(tmp);
            if (nstep_frame>1) std::fseek(nfile,(nstep_frame-1)*(size_x*size_y + size_x*size_y/2),1);
          }
        }
      }
      if (stop_flag && nlast_frame!=~0U && frame!=nlast_frame)
        cimg::warn("[instance(%u,%u,%p)] CImgList<%s>::"
                   "load_yuv(): Frame %d not reached since only %u frames were found in file '%s'.",
                   _width,_allocated_width,_data,pixel_type(),
                   nlast_frame,frame-1,filename?filename:"(FILE*)");

      if (!file) cimg::fclose(nfile);
      return *this;
    }
# 47587 "../src/CImg.h"
    CImgList<T>& load_ffmpeg(const char *const filename,
                             const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                             const unsigned int step_frame=1, const bool pixel_format=true, const bool resume=false) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_ffmpeg(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());

      const unsigned int
        nfirst_frame = first_frame<last_frame?first_frame:last_frame,
        nlast_frame = first_frame<last_frame?last_frame:first_frame,
        nstep_frame = step_frame?step_frame:1;
      assign();


      if ((nfirst_frame || nlast_frame!=~0U || nstep_frame>1) || (resume && (pixel_format || !pixel_format)))
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_ffmpeg(): Unable to load sub-frames from file '%s' unless libffmpeg "
                                    "is enabled.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    filename);

      return load_ffmpeg_external(filename);
# 47736 "../src/CImg.h"
    }


    static CImgList<T> get_load_ffmpeg(const char *const filename,
                                       const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                       const unsigned int step_frame=1, const bool pixel_format=true) {
      return CImgList<T>().load_ffmpeg(filename,first_frame,last_frame,step_frame,pixel_format);
    }





    CImgList<T>& load_ffmpeg_external(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_ffmpeg_external(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      std::fclose(cimg::fopen(filename,"rb"));
      char command[1024] = { 0 }, filetmp[512] = { 0 }, filetmp2[512] = { 0 };
      std::FILE *file = 0;
      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s",cimg::temporary_path(),'/',cimg::filenamerand());
        snprintf(filetmp2,sizeof(filetmp2),"%s_000001.ppm",filetmp);
        if ((file=std::fopen(filetmp2,"rb"))!=0) cimg::fclose(file);
      } while (file);
      snprintf(filetmp2,sizeof(filetmp2),"%s_%%6d.ppm",filetmp);

      snprintf(command,sizeof(command),"%s -i \"%s\" \"%s\" >/dev/null 2>&1",
                    cimg::ffmpeg_path(),
                    CImg<charT>::string(filename)._system_strescape().data(),
                    CImg<charT>::string(filetmp2)._system_strescape().data());






      cimg::system(command,0);
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      assign();
      unsigned int i = 1;
      for (bool stop_flag = false; !stop_flag; ++i) {
        snprintf(filetmp2,sizeof(filetmp2),"%s_%.6u.ppm",filetmp,i);
        CImg<T> img;
        try { img.load_pnm(filetmp2); }
        catch (CImgException&) { stop_flag = true; }
        if (img) { img.move_to(*this); std::remove(filetmp2); }
      }
      cimg::exception_mode() = omode;
      if (is_empty())
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_ffmpeg_external(): Failed to open file '%s' with external command 'ffmpeg'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename);
      return *this;
    }


    static CImgList<T> get_load_ffmpeg_external(const char *const filename) {
      return CImgList<T>().load_ffmpeg_external(filename);
    }






    CImgList<T>& load_gif_external(const char *const filename) {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_gif_external(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      std::fclose(cimg::fopen(filename,"rb"));
      if (!_load_gif_external(filename,false))
        if (!_load_gif_external(filename,true))
          try { assign(CImg<T>().load_other(filename)); } catch (CImgException&) { assign(); }
      if (is_empty())
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_gif_external(): Failed to open file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),filename);
      return *this;
    }

    CImgList<T>& _load_gif_external(const char *const filename, const bool use_graphicsmagick=false) {
      char command[1024] = { 0 }, filetmp[512] = { 0 }, filetmp2[512] = { 0 };
      std::FILE *file = 0;
      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s",cimg::temporary_path(),'/',cimg::filenamerand());
        if (use_graphicsmagick) snprintf(filetmp2,sizeof(filetmp2),"%s.png.0",filetmp);
        else snprintf(filetmp2,sizeof(filetmp2),"%s-0.png",filetmp);
        if ((file=std::fopen(filetmp2,"rb"))!=0) cimg::fclose(file);
      } while (file);

      if (use_graphicsmagick) snprintf(command,sizeof(command),"%s convert \"%s\" \"%s.png\" >/dev/null 2>&1",
                                            cimg::graphicsmagick_path(),
                                            CImg<charT>::string(filename)._system_strescape().data(),
                                            CImg<charT>::string(filetmp)._system_strescape().data());
      else snprintf(command,sizeof(command),"%s \"%s\" \"%s.png\" >/dev/null 2>&1",
                         cimg::imagemagick_path(),
                         CImg<charT>::string(filename)._system_strescape().data(),
                         CImg<charT>::string(filetmp)._system_strescape().data());
# 47849 "../src/CImg.h"
      cimg::system(command,0);
      const unsigned int omode = cimg::exception_mode();
      cimg::exception_mode() = 0;
      assign();


      snprintf(filetmp2,sizeof(filetmp2),"%s.png",filetmp);
      CImg<T> img;
      try { img.load_png(filetmp2); }
      catch (CImgException&) { }
      if (img) { img.move_to(*this); std::remove(filetmp2); }
      else {
        unsigned int i = 0;
        for (bool stop_flag = false; !stop_flag; ++i) {
          if (use_graphicsmagick) snprintf(filetmp2,sizeof(filetmp2),"%s.png.%u",filetmp,i);
          else snprintf(filetmp2,sizeof(filetmp2),"%s-%u.png",filetmp,i);
          CImg<T> img;
          try { img.load_png(filetmp2); }
          catch (CImgException&) { stop_flag = true; }
          if (img) { img.move_to(*this); std::remove(filetmp2); }
        }
      }
      cimg::exception_mode() = omode;
      return *this;
    }


    static CImgList<T> get_load_gif_external(const char *const filename) {
      return CImgList<T>().load_gif_external(filename);
    }





    CImgList<T>& load_gzip_external(const char *const filename) {
      if (!filename)
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_gzip_external(): Specified filename is (null).",
                              _width,_allocated_width,_data,pixel_type());
      std::fclose(cimg::fopen(filename,"rb"));
      char command[1024] = { 0 }, filetmp[512] = { 0 }, body[512] = { 0 };
      const char
        *ext = cimg::split_filename(filename,body),
        *ext2 = cimg::split_filename(body,0);
      std::FILE *file = 0;
      do {
        if (!cimg::strcasecmp(ext,"gz")) {
          if (*ext2) snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                                   cimg::temporary_path(),'/',cimg::filenamerand(),ext2);
          else snprintf(filetmp,sizeof(filetmp),"%s%c%s",
                             cimg::temporary_path(),'/',cimg::filenamerand());
        } else {
          if (*ext) snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                                  cimg::temporary_path(),'/',cimg::filenamerand(),ext);
          else snprintf(filetmp,sizeof(filetmp),"%s%c%s",
                             cimg::temporary_path(),'/',cimg::filenamerand());
        }
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);
      snprintf(command,sizeof(command),"%s -c \"%s\" > \"%s\"",
                    cimg::gunzip_path(),
                    CImg<charT>::string(filename)._system_strescape().data(),
                    CImg<charT>::string(filetmp)._system_strescape().data());
      cimg::system(command);
      if (!(file = std::fopen(filetmp,"rb"))) {
        cimg::fclose(cimg::fopen(filename,"r"));
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "load_gzip_external(): Failed to open file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename);

      } else cimg::fclose(file);
      load(filetmp);
      std::remove(filetmp);
      return *this;
    }


    static CImgList<T> get_load_gzip_external(const char *const filename) {
      return CImgList<T>().load_gzip_external(filename);
    }
# 47939 "../src/CImg.h"
    template<typename tf, typename tc>
    CImgList<T>& load_off(const char *const filename,
                          CImgList<tf>& primitives, CImgList<tc>& colors) {
      return get_load_off(filename,primitives,colors).move_to(*this);
    }


    template<typename tf, typename tc>
      static CImgList<T> get_load_off(const char *const filename,
                                      CImgList<tf>& primitives, CImgList<tc>& colors) {
      return CImg<T>().load_off(filename,primitives,colors)<'x';
    }
# 47959 "../src/CImg.h"
    CImgList<T>& load_tiff(const char *const filename,
                           const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                           const unsigned int step_frame=1,
                           float *const voxel_size=0,
                           CImg<charT> *const description=0) {
      const unsigned int
        nfirst_frame = first_frame<last_frame?first_frame:last_frame,
        nstep_frame = step_frame?step_frame:1;
      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;

      cimg::unused(voxel_size,description);
      if (nfirst_frame || nlast_frame!=~0U || nstep_frame!=1)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "load_tiff(): Unable to load sub-images from file '%s' unless libtiff is enabled.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    filename);

      return assign(CImg<T>::get_load_tiff(filename));
# 48005 "../src/CImg.h"
    }


    static CImgList<T> get_load_tiff(const char *const filename,
                                     const unsigned int first_frame=0, const unsigned int last_frame=~0U,
                                     const unsigned int step_frame=1,
                                     float *const voxel_size=0,
                                     CImg<charT> *const description=0) {
      return CImgList<T>().load_tiff(filename,first_frame,last_frame,step_frame,voxel_size,description);
    }
# 48028 "../src/CImg.h"
    const CImgList<T>& print(const char *const title=0, const bool display_stats=true) const {
      unsigned int msiz = 0;
      for (int l = 0; l<(int)(*this)._width; ++l) msiz+=_data[l].size();
      msiz*=sizeof(T);
      const unsigned int mdisp = msiz<8*1024?0:(msiz<8*1024*1024?1:2);
      char _title[64] = { 0 };
      if (!title) snprintf(_title,sizeof(_title),"CImgList<%s>",pixel_type());
      std::fprintf(cimg::output(),"%s%s%s%s: %sthis%s = %p, %ssize%s = %u/%u [%u %s], %sdata%s = (CImg<%s>*)%p",
                   cimg::t_magenta,cimg::t_bold,title?title:_title,cimg::t_normal,
                   cimg::t_bold,cimg::t_normal,(void*)this,
                   cimg::t_bold,cimg::t_normal,_width,_allocated_width,
                   mdisp==0?msiz:(mdisp==1?(msiz>>10):(msiz>>20)),
                   mdisp==0?"b":(mdisp==1?"Kio":"Mio"),
                   cimg::t_bold,cimg::t_normal,pixel_type(),(void*)begin());
      if (_data) std::fprintf(cimg::output(),"..%p.\n",(void*)((char*)end()-1));
      else std::fprintf(cimg::output(),".\n");

      char tmp[16] = { 0 };
      for (int ll = 0; ll<(int)(*this)._width; ++ll) {
        snprintf(tmp,sizeof(tmp),"[%d]",ll);
        std::fprintf(cimg::output(),"  ");
        _data[ll].print(tmp,display_stats);
        if (ll==3 && _width>8) { ll = _width-5; std::fprintf(cimg::output(),"  ...\n"); }
      }
      std::fflush(cimg::output());
      return *this;
    }
# 48066 "../src/CImg.h"
    const CImgList<T>& display(CImgDisplay &disp, const char axis='x', const float align=0) const {
      disp.display(*this,axis,align);
      return *this;
    }
# 48082 "../src/CImg.h"
    const CImgList<T>& display(CImgDisplay &disp, const bool display_info,
                               const char axis='x', const float align=0,
                               unsigned int *const XYZ=0) const {
      bool is_exit = false;
      return _display(disp,0,display_info,axis,align,XYZ,0,true,is_exit);
    }
# 48096 "../src/CImg.h"
    const CImgList<T>& display(const char *const title=0, const bool display_info=true,
                               const char axis='x', const float align=0,
                               unsigned int *const XYZ=0) const {
      CImgDisplay disp;
      bool is_exit = false;
      return _display(disp,title,display_info,axis,align,XYZ,0,true,is_exit);
    }

    const CImgList<T>& _display(CImgDisplay &disp, const char *const title, const bool display_info,
                                const char axis, const float align, unsigned int *const XYZ,
                                const unsigned int orig, const bool is_first_call, bool &is_exit) const {
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "display(): Empty instance.",
                                    _width,_allocated_width,_data,pixel_type());
      if (!disp) {
        if (axis=='x') {
          unsigned int sum_width = 0, max_height = 0;
          for (int l = 0; l<(int)(*this)._width; ++l) {
            const CImg<T> &img = _data[l];
            const unsigned int
              w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
              h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
            sum_width+=w;
            if (h>max_height) max_height = h;
          }
          disp.assign(CImgDisplay::_fitscreen(sum_width,max_height,1,128,-85,false), CImgDisplay::_fitscreen(sum_width,max_height,1,128,-85,true),title?title:0,1);
        } else {
          unsigned int max_width = 0, sum_height = 0;
          for (int l = 0; l<(int)(*this)._width; ++l) {
            const CImg<T> &img = _data[l];
            const unsigned int
              w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
              h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
            if (w>max_width) max_width = w;
            sum_height+=h;
          }
          disp.assign(CImgDisplay::_fitscreen(max_width,sum_height,1,128,-85,false), CImgDisplay::_fitscreen(max_width,sum_height,1,128,-85,true),title?title:0,1);
        }
        if (!title) disp.set_title("CImgList<%s> (%u)",pixel_type(),_width);
      } else if (title) disp.set_title("%s",title);
      const CImg<char> dtitle = CImg<char>::string(disp.title());
      if (display_info) print(disp.title());
      disp.show().flush();

      if (_width==1) {
        const unsigned int dw = disp._width, dh = disp._height;
        if (!is_first_call)
          disp.resize(CImgDisplay::_fitscreen(_data[0]._width,_data[0]._height,_data[0]._depth,128,-85,false), CImgDisplay::_fitscreen(_data[0]._width,_data[0]._height,_data[0]._depth,128,-85,true),false).
            set_title("%s (%ux%ux%ux%u)",
                      dtitle.data(),_data[0]._width,_data[0]._height,_data[0]._depth,_data[0]._spectrum);
        _data[0]._display(disp,0,false,XYZ,!is_first_call);
        if (disp.key()) is_exit = true;
        disp.resize(CImgDisplay::_fitscreen(dw,dh,1,128,-85,false), CImgDisplay::_fitscreen(dw,dh,1,128,-85,true),false).set_title("%s",dtitle.data());
      } else {
        bool disp_resize = !is_first_call;
        while (!disp.is_closed() && !is_exit) {
          const CImg<intT> s = _get_select(disp,0,true,axis,align,orig,disp_resize,!is_first_call,true);
          disp_resize = true;
          if (s[0]<0) {
            if (disp.button()&2) { disp.flush(); break; }
            is_exit = true;
          } else if (disp.wheel()) {
            const int wheel = disp.wheel();
            disp.set_wheel();
            if (!is_first_call && wheel<0) break;
            if (wheel>0 && _width>=4) {
              const unsigned int
                delta = cimg::max(1U,(unsigned int)cimg::round(0.3*_width)),
                ind0 = (unsigned int)cimg::max(0,s[0] - (int)delta),
                ind1 = (unsigned int)cimg::min(width() - 1,s[0] + (int)delta);
              if ((ind0!=0 || ind1!=_width-1) && ind1 - ind0>=3)
                get_shared_images(ind0,ind1)._display(disp,0,false,axis,align,XYZ,orig + ind0,false,is_exit);
            }
          } else if (s[0]!=0 || s[1]!=width()-1)
            get_shared_images(s[0],s[1])._display(disp,0,false,axis,align,XYZ,orig+s[0],false,is_exit);
        }
      }
      return *this;
    }







    const CImgList<T>& save(const char *const filename, const int number=-1, const unsigned int digits=6) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());

      const bool is_stdout = *filename=='-' && (!filename[1] || filename[1]=='.');
      const char *const ext = cimg::split_filename(filename);
      char nfilename[1024] = { 0 };
      const char *const fn = is_stdout?filename:number>=0?cimg::number_filename(filename,number,digits,nfilename):
        filename;
# 48222 "../src/CImg.h"
      if (!cimg::strcasecmp(ext,"cimgz")) return save_cimg(fn,true);
      else if (!cimg::strcasecmp(ext,"cimg") || !*ext) return save_cimg(fn,false);
      else if (!cimg::strcasecmp(ext,"yuv")) return save_yuv(fn,true);
      else if (!cimg::strcasecmp(ext,"avi") ||
               !cimg::strcasecmp(ext,"mov") ||
               !cimg::strcasecmp(ext,"asf") ||
               !cimg::strcasecmp(ext,"divx") ||
               !cimg::strcasecmp(ext,"flv") ||
               !cimg::strcasecmp(ext,"mpg") ||
               !cimg::strcasecmp(ext,"m1v") ||
               !cimg::strcasecmp(ext,"m2v") ||
               !cimg::strcasecmp(ext,"m4v") ||
               !cimg::strcasecmp(ext,"mjp") ||
               !cimg::strcasecmp(ext,"mp4") ||
               !cimg::strcasecmp(ext,"mkv") ||
               !cimg::strcasecmp(ext,"mpe") ||
               !cimg::strcasecmp(ext,"movie") ||
               !cimg::strcasecmp(ext,"ogm") ||
               !cimg::strcasecmp(ext,"ogg") ||
               !cimg::strcasecmp(ext,"ogv") ||
               !cimg::strcasecmp(ext,"qt") ||
               !cimg::strcasecmp(ext,"rm") ||
               !cimg::strcasecmp(ext,"vob") ||
               !cimg::strcasecmp(ext,"wmv") ||
               !cimg::strcasecmp(ext,"xvid") ||
               !cimg::strcasecmp(ext,"mpeg")) return save_ffmpeg(fn);




      else if (!cimg::strcasecmp(ext,"gz")) return save_gzip_external(fn);
      else {
        if (_width==1) _data[0].save(fn,-1);
        else for (int l = 0; l<(int)(*this)._width; ++l) { _data[l].save(fn,is_stdout?-1:l); if (is_stdout) std::fputc((-1),stdout); }
      }
      return *this;
    }






    static bool is_saveable(const char *const filename) {
      const char *const ext = cimg::split_filename(filename);
      if (!cimg::strcasecmp(ext,"cimgz") ||




          !cimg::strcasecmp(ext,"yuv") ||
          !cimg::strcasecmp(ext,"avi") ||
          !cimg::strcasecmp(ext,"mov") ||
          !cimg::strcasecmp(ext,"asf") ||
          !cimg::strcasecmp(ext,"divx") ||
          !cimg::strcasecmp(ext,"flv") ||
          !cimg::strcasecmp(ext,"mpg") ||
          !cimg::strcasecmp(ext,"m1v") ||
          !cimg::strcasecmp(ext,"m2v") ||
          !cimg::strcasecmp(ext,"m4v") ||
          !cimg::strcasecmp(ext,"mjp") ||
          !cimg::strcasecmp(ext,"mp4") ||
          !cimg::strcasecmp(ext,"mkv") ||
          !cimg::strcasecmp(ext,"mpe") ||
          !cimg::strcasecmp(ext,"movie") ||
          !cimg::strcasecmp(ext,"ogm") ||
          !cimg::strcasecmp(ext,"ogg") ||
          !cimg::strcasecmp(ext,"ogv") ||
          !cimg::strcasecmp(ext,"qt") ||
          !cimg::strcasecmp(ext,"rm") ||
          !cimg::strcasecmp(ext,"vob") ||
          !cimg::strcasecmp(ext,"wmv") ||
          !cimg::strcasecmp(ext,"xvid") ||
          !cimg::strcasecmp(ext,"mpeg")) return true;
      return false;
    }







    const CImgList<T>& save_gif_external(const char *const filename, const unsigned int fps=25,
                                         const unsigned int nb_loops=0) {
      char command[1024] = { 0 }, filetmp[512] = { 0 }, filetmp2[512] = { 0 };
      CImgList<charT> filenames;
      std::FILE *file = 0;







      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s",cimg::temporary_path(),'/',cimg::filenamerand());
        snprintf(filetmp2,sizeof(filetmp2),"%s_000001." "ppm",filetmp);
        if ((file=std::fopen(filetmp2,"rb"))!=0) cimg::fclose(file);
      } while (file);
      for (int l = 0; l<(int)(*this)._width; ++l) {
        snprintf(filetmp2,sizeof(filetmp2),"%s_%.6u." "ppm",filetmp,l+1);
        CImg<charT>::string(filetmp2).move_to(filenames);
        if (_data[l]._depth>1 || _data[l]._spectrum!=3) _data[l].get_resize(-100,-100,1,3).save(filetmp2);
        else _data[l].save(filetmp2);
      }


      snprintf(command,sizeof(command),"%s -delay 1x%u -loop %u",
                    cimg::imagemagick_path(),fps,nb_loops);
      CImg<ucharT>::string(command).move_to(filenames,0);
      snprintf(command,sizeof(command),"\"%s\" >/dev/null 2>&1",
                    CImg<charT>::string(filename)._system_strescape().data());
      CImg<ucharT>::string(command).move_to(filenames);
# 48344 "../src/CImg.h"
      CImg<charT> _command = filenames>'x';
      for (char *p = (_command)._data, *_maxp = (_command)._data + (_command).size(); p<_maxp; ++p) if (!*p) *p = ' ';
      _command.back() = 0;

      cimg::system(_command);
      file = std::fopen(filename,"rb");
      if (!file)
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "save_gif_external(): Failed to save file '%s' with external command 'convert'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename);
      else cimg::fclose(file);
      for (int l = (int)(1)<0?0:(int)(1), _maxl = (unsigned int)filenames._width-1<(*this)._width?(int)(filenames._width-1):(int)(*this)._width-1; l<=_maxl; ++l) std::remove(filenames[l]);
      return *this;
    }
# 48367 "../src/CImg.h"
    const CImgList<T>& save_ffmpeg(const char *const filename, const unsigned int fps=25,
                                   const unsigned int bitrate=2048) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_ffmpeg(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      if (!fps)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_ffmpeg(): Invalid specified framerate 0, for file '%s'.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    filename);
      if (is_empty()) { cimg::fempty(0,filename); return *this; }

      for (int l = 0; l<(int)(*this)._width; ++l) if (!_data[l].is_sameXYZ(_data[0]))
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_ffmpeg(): Invalid instance dimensions, for file '%s'.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    filename);


      return save_ffmpeg_external(filename,0,fps,bitrate);
# 48660 "../src/CImg.h"
    }

    const CImgList<T>& _save_yuv(std::FILE *const file, const char *const filename, const bool is_rgb) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_yuv(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      if (is_empty()) { cimg::fempty(file,filename); return *this; }
      if ((*this)[0].width()%2 || (*this)[0].height()%2)
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_yuv(): Invalid odd instance dimensions (%u,%u) for file '%s'.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    (*this)[0].width(),(*this)[0].height(),
                                    filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      for (int l = 0; l<(int)(*this)._width; ++l) {
        CImg<ucharT> YCbCr((*this)[l]);
        if (is_rgb) YCbCr.RGBtoYCbCr();
        cimg::fwrite(YCbCr._data,(unsigned long)YCbCr._width*YCbCr._height,nfile);
        cimg::fwrite(YCbCr.get_resize(YCbCr._width/2, YCbCr._height/2,1,3,3).data(0,0,0,1),
                     (unsigned long)YCbCr._width*YCbCr._height/2,nfile);
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }






    const CImgList<T>& save_yuv(const char *const filename=0, const bool is_rgb=true) const {
      return _save_yuv(0,filename,is_rgb);
    }






    const CImgList<T>& save_yuv(std::FILE *const file, const bool is_rgb=true) const {
      return _save_yuv(file,0,is_rgb);
    }

    const CImgList<T>& _save_cimg(std::FILE *const file, const char *const filename, const bool is_compressed) const {
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_cimg(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());

      if (is_compressed)
        cimg::warn("[instance(%u,%u,%p)] CImgList<%s>::"
                   "save_cimg(): Unable to save compressed data in file '%s' unless zlib is enabled, "
                   "saving them uncompressed.",
                   _width,_allocated_width,_data,pixel_type(),
                   filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      const char *const ptype = pixel_type(), *const etype = cimg::endianness()?"big":"little";
      if (std::strstr(ptype,"unsigned")==ptype) std::fprintf(nfile,"%u unsigned_%s %s_endian\n",_width,ptype+9,etype);
      else std::fprintf(nfile,"%u %s %s_endian\n",_width,ptype,etype);
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& img = _data[l];
        std::fprintf(nfile,"%u %u %u %u",img._width,img._height,img._depth,img._spectrum);
        if (img._data) {
          CImg<T> tmp;
          if (cimg::endianness()) { tmp = img; cimg::invert_endianness(tmp._data,tmp.size()); }
          const CImg<T>& ref = cimg::endianness()?tmp:img;
          bool failed_to_compress = true;
          if (is_compressed) {
# 48747 "../src/CImg.h"
          }
          if (failed_to_compress) {
            std::fputc('\n',nfile);
            cimg::fwrite(ref._data,ref.size(),nfile);
          }
        } else std::fputc('\n',nfile);
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }






    const CImgList<T>& save_cimg(const char *const filename, const bool is_compressed=false) const {
      return _save_cimg(0,filename,is_compressed);
    }






    const CImgList<T>& save_cimg(std::FILE *file, const bool is_compressed=false) const {
      return _save_cimg(file,0,is_compressed);
    }

    const CImgList<T>& _save_cimg(std::FILE *const file, const char *const filename,
                                 const unsigned int n0,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0) const {
# 48837 "../src/CImg.h"
      if (!file && !filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_cimg(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      if (is_empty())
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_cimg(): Empty instance, for file '%s'.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    filename?filename:"(FILE*)");

      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb+");
      bool saved = false, endian = cimg::endianness();
      char tmp[256] = { 0 }, str_pixeltype[256] = { 0 }, str_endian[256] = { 0 };
      unsigned int j, err, N, W, H, D, C;
      int i;
      j = 0; while((i=std::fgetc(nfile))!='\n' && i!=(-1) && j<256) tmp[j++] = (char)i; tmp[j] = 0;
      err = std::sscanf(tmp,"%u%*c%255[A-Za-z_]%*c%255[sA-Za-z_ ]",&N,str_pixeltype,str_endian);
      if (err<2) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "save_cimg(): CImg header not found in file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename?filename:"(FILE*)");
      }
      if (!cimg::strncasecmp("little",str_endian,6)) endian = false;
      else if (!cimg::strncasecmp("big",str_endian,3)) endian = true;
      const unsigned int lmax = cimg::min(N,n0+_width);
      if (!saved && !cimg::strcasecmp("bool",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(bool),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<bool> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(bool); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(bool); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(bool); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(bool); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(bool); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(bool); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(bool); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(bool); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("unsigned_char",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(unsigned char),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<unsigned char> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(unsigned char); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(unsigned char); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(unsigned char); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(unsigned char); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(unsigned char); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(unsigned char); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(unsigned char); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(unsigned char); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("uchar",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(unsigned char),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<unsigned char> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(unsigned char); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(unsigned char); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(unsigned char); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(unsigned char); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(unsigned char); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(unsigned char); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(unsigned char); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(unsigned char); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("char",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(char),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<char> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(char); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(char); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(char); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(char); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(char); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(char); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(char); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(char); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("unsigned_short",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(unsigned short),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<unsigned short> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(unsigned short); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(unsigned short); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(unsigned short); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(unsigned short); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(unsigned short); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(unsigned short); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(unsigned short); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(unsigned short); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("ushort",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(unsigned short),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<unsigned short> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(unsigned short); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(unsigned short); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(unsigned short); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(unsigned short); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(unsigned short); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(unsigned short); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(unsigned short); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(unsigned short); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("short",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(short),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<short> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(short); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(short); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(short); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(short); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(short); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(short); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(short); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(short); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("unsigned_int",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(unsigned int),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<unsigned int> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(unsigned int); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(unsigned int); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(unsigned int); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(unsigned int); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(unsigned int); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(unsigned int); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(unsigned int); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(unsigned int); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("uint",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(unsigned int),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<unsigned int> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(unsigned int); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(unsigned int); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(unsigned int); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(unsigned int); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(unsigned int); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(unsigned int); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(unsigned int); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(unsigned int); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("int",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(int),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<int> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(int); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(int); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(int); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(int); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(int); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(int); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(int); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(int); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("unsigned_long",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(unsigned long),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<unsigned long> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(unsigned long); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(unsigned long); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(unsigned long); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(unsigned long); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(unsigned long); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(unsigned long); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(unsigned long); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(unsigned long); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("ulong",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(unsigned long),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<unsigned long> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(unsigned long); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(unsigned long); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(unsigned long); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(unsigned long); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(unsigned long); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(unsigned long); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(unsigned long); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(unsigned long); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("long",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(long),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<long> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(long); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(long); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(long); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(long); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(long); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(long); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(long); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(long); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("float",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(float),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<float> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(float); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(float); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(float); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(float); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(float); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(float); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(float); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(float); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved && !cimg::strcasecmp("double",str_pixeltype)) { for (unsigned int l = 0; l<lmax; ++l) { j = 0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j] = 0; W = H = D = C = 0; if (std::sscanf(tmp,"%u %u %u %u",&W,&H,&D,&C)!=4) throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::" "save_cimg(): Invalid size (%u,%u,%u,%u) of image[%u], for file '%s'.", _width,_allocated_width,_data,pixel_type(), W,H,D,C,l,filename?filename:"(FILE*)"); if (W*H*D*C>0) { if (l<n0 || x0>=W || y0>=H || z0>=D || c0>=D) std::fseek(nfile,W*H*D*C*sizeof(double),1); else { const CImg<T>& img = (*this)[l - n0]; const T *ptrs = img._data; const unsigned int x1 = x0 + img._width - 1, y1 = y0 + img._height - 1, z1 = z0 + img._depth - 1, c1 = c0 + img._spectrum - 1, nx1 = x1>=W?W-1:x1, ny1 = y1>=H?H-1:y1, nz1 = z1>=D?D-1:z1, nc1 = c1>=C?C-1:c1; CImg<double> raw(1+nx1-x0); const unsigned int skipvb = c0*W*H*D*sizeof(double); if (skipvb) std::fseek(nfile,skipvb,1); for (unsigned int v = 1 + nc1 - c0; v; --v) { const unsigned int skipzb = z0*W*H*sizeof(double); if (skipzb) std::fseek(nfile,skipzb,1); for (unsigned int z = 1 + nz1 - z0; z; --z) { const unsigned int skipyb = y0*W*sizeof(double); if (skipyb) std::fseek(nfile,skipyb,1); for (unsigned int y = 1 + ny1 - y0; y; --y) { const unsigned int skipxb = x0*sizeof(double); if (skipxb) std::fseek(nfile,skipxb,1); raw.assign(ptrs, raw._width); ptrs+=img._width; if (endian) cimg::invert_endianness(raw._data,raw._width); cimg::fwrite(raw._data,raw._width,nfile); const unsigned int skipxe = (W - 1 - nx1)*sizeof(double); if (skipxe) std::fseek(nfile,skipxe,1); } const unsigned int skipye = (H - 1 - ny1)*W*sizeof(double); if (skipye) std::fseek(nfile,skipye,1); } const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(double); if (skipze) std::fseek(nfile,skipze,1); } const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(double); if (skipve) std::fseek(nfile,skipve,1); } } } saved = true; };
      if (!saved) {
        if (!file) cimg::fclose(nfile);
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "save_cimg(): Unsupported data type '%s' for file '%s'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename?filename:"(FILE*)",str_pixeltype);
      }
      if (!file) cimg::fclose(nfile);
      return *this;
    }
# 48899 "../src/CImg.h"
    const CImgList<T>& save_cimg(const char *const filename,
                                 const unsigned int n0,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0) const {
      return _save_cimg(0,filename,n0,x0,y0,z0,c0);
    }
# 48915 "../src/CImg.h"
    const CImgList<T>& save_cimg(std::FILE *const file,
                                 const unsigned int n0,
                                 const unsigned int x0, const unsigned int y0,
                                 const unsigned int z0, const unsigned int c0) const {
      return _save_cimg(file,0,n0,x0,y0,z0,c0);
    }

    static void _save_empty_cimg(std::FILE *const file, const char *const filename,
                                const unsigned int nb,
                                const unsigned int dx, const unsigned int dy,
                                const unsigned int dz, const unsigned int dc) {
      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
      const unsigned long siz = (unsigned long)dx*dy*dz*dc*sizeof(T);
      std::fprintf(nfile,"%u %s\n",nb,pixel_type());
      for (unsigned int i=nb; i; --i) {
        std::fprintf(nfile,"%u %u %u %u\n",dx,dy,dz,dc);
        for (unsigned long off=siz; off; --off) std::fputc(0,nfile);
      }
      if (!file) cimg::fclose(nfile);
    }
# 48945 "../src/CImg.h"
    static void save_empty_cimg(const char *const filename,
                                const unsigned int nb,
                                const unsigned int dx, const unsigned int dy=1,
                                const unsigned int dz=1, const unsigned int dc=1) {
      return _save_empty_cimg(0,filename,nb,dx,dy,dz,dc);
    }
# 48961 "../src/CImg.h"
    static void save_empty_cimg(std::FILE *const file,
                                const unsigned int nb,
                                const unsigned int dx, const unsigned int dy=1,
                                const unsigned int dz=1, const unsigned int dc=1) {
      return _save_empty_cimg(file,0,nb,dx,dy,dz,dc);
    }






    const CImgList<T>& save_tiff(const char *const filename, const unsigned int compression_type=0,
                                 const float *const voxel_size=0, const char *const description=0) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_tiff(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }


      if (_width==1) _data[0].save_tiff(filename,compression_type,voxel_size,description);
      else for (int l = 0; l<(int)(*this)._width; ++l) {
          char nfilename[1024] = { 0 };
          cimg::number_filename(filename,l,6,nfilename);
          _data[l].save_tiff(nfilename,compression_type,voxel_size,description);
        }
# 49005 "../src/CImg.h"
      return *this;
    }






    const CImgList<T>& save_gzip_external(const char *const filename) const {
      if (!filename)
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "save_gzip_external(): Specified filename is (null).",
                              _width,_allocated_width,_data,pixel_type());

      char command[1024] = { 0 }, filetmp[512] = { 0 }, body[512] = { 0 };
      const char
        *ext = cimg::split_filename(filename,body),
        *ext2 = cimg::split_filename(body,0);
      std::FILE *file;
      do {
        if (!cimg::strcasecmp(ext,"gz")) {
          if (*ext2) snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                                   cimg::temporary_path(),'/',cimg::filenamerand(),ext2);
          else snprintf(filetmp,sizeof(filetmp),"%s%c%s.cimg",
                             cimg::temporary_path(),'/',cimg::filenamerand());
        } else {
          if (*ext) snprintf(filetmp,sizeof(filetmp),"%s%c%s.%s",
                                  cimg::temporary_path(),'/',cimg::filenamerand(),ext);
          else snprintf(filetmp,sizeof(filetmp),"%s%c%s.cimg",
                             cimg::temporary_path(),'/',cimg::filenamerand());
        }
        if ((file=std::fopen(filetmp,"rb"))!=0) cimg::fclose(file);
      } while (file);

      if (is_saveable(body)) {
        save(filetmp);
        snprintf(command,sizeof(command),"%s -c \"%s\" > \"%s\"",
                      cimg::gzip_path(),
                      CImg<charT>::string(filetmp)._system_strescape().data(),
                      CImg<charT>::string(filename)._system_strescape().data());
        cimg::system(command);
        file = std::fopen(filename,"rb");
        if (!file)
          throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                                "save_gzip_external(): Failed to save file '%s' with external command 'gzip'.",
                                _width,_allocated_width,_data,pixel_type(),
                                filename);
        else cimg::fclose(file);
        std::remove(filetmp);
      } else {
        char nfilename[1024] = { 0 };
        for (int l = 0; l<(int)(*this)._width; ++l) {
          cimg::number_filename(body,l,6,nfilename);
          if (*ext) std::sprintf(nfilename + std::strlen(nfilename),".%s",ext);
          _data[l].save_gzip_external(nfilename);
        }
      }
      return *this;
    }
# 49072 "../src/CImg.h"
    const CImgList<T>& save_ffmpeg_external(const char *const filename, const char *const codec=0,
                                            const unsigned int fps=25, const unsigned int bitrate=2048) const {
      if (!filename)
        throw CImgArgumentException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_ffmpeg_external(): Specified filename is (null).",
                                    _width,_allocated_width,_data,pixel_type());
      if (is_empty()) { cimg::fempty(0,filename); return *this; }

      const char
        *const ext = cimg::split_filename(filename),
        *const _codec = codec?codec:!cimg::strcasecmp(ext,"flv")?"flv":"mpeg2video";

      char command[1024] = { 0 }, filetmp[512] = { 0 }, filetmp2[512] = { 0 };
      CImgList<charT> filenames;
      std::FILE *file = 0;
      for (int l = 0; l<(int)(*this)._width; ++l) if (!_data[l].is_sameXYZ(_data[0]))
        throw CImgInstanceException("[instance(%u,%u,%p)] CImgList<%s>::"
                                    "save_ffmpeg_external(): Invalid instance dimensions for file '%s'.",
                                    _width,_allocated_width,_data,pixel_type(),
                                    filename);
      do {
        snprintf(filetmp,sizeof(filetmp),"%s%c%s",cimg::temporary_path(),'/',cimg::filenamerand());
        snprintf(filetmp2,sizeof(filetmp2),"%s_000001.ppm",filetmp);
        if ((file=std::fopen(filetmp2,"rb"))!=0) cimg::fclose(file);
      } while (file);
      for (int l = 0; l<(int)(*this)._width; ++l) {
        snprintf(filetmp2,sizeof(filetmp2),"%s_%.6u.ppm",filetmp,l+1);
        CImg<charT>::string(filetmp2).move_to(filenames);
        if (_data[l]._depth>1 || _data[l]._spectrum!=3) _data[l].get_resize(-100,-100,1,3).save_pnm(filetmp2);
        else _data[l].save_pnm(filetmp2);
      }

      snprintf(command,sizeof(command),"%s -i \"%s_%%6d.ppm\" -vcodec %s -b %uk -r %u -y \"%s\" >/dev/null 2>&1",
                    cimg::ffmpeg_path(),
                    CImg<charT>::string(filetmp)._system_strescape().data(),
                    _codec,bitrate,fps,
                    CImg<charT>::string(filename)._system_strescape().data());







      cimg::system(command);
      file = std::fopen(filename,"rb");
      if (!file)
        throw CImgIOException("[instance(%u,%u,%p)] CImgList<%s>::"
                              "save_ffmpeg_external(): Failed to save file '%s' with external command 'ffmpeg'.",
                              _width,_allocated_width,_data,pixel_type(),
                              filename);
      else cimg::fclose(file);
      for (int l = 0; l<(int)(*this)._width; ++l) std::remove(filenames[l]);
      return *this;
    }
# 49138 "../src/CImg.h"
    CImgList<T>& crop_font() {
      return get_crop_font().move_to(*this);
    }




    CImgList<T> get_crop_font() const {
      CImgList<T> res;
      for (int l = 0; l<(int)(*this)._width; ++l) {
        const CImg<T>& letter = (*this)[l];
        int xmin = letter._width, xmax = 0;
        for (int y = 0; y<(int)((letter)._height); ++y) for (int x = 0; x<(int)((letter)._width); ++x) if (letter(x,y)) { if (x<xmin) xmin = x; if (x>xmax) xmax = x; }
        if (xmin>xmax) CImg<T>(letter._width,letter._height,1,letter._spectrum,0).move_to(res);
        else letter.get_crop(xmin,0,xmax,letter._height-1).move_to(res);
      }
      res[' '].resize(res['f']._width,-100,-100,-100,0);
      if (' '+256<res.size()) res[' '+256].resize(res['f']._width,-100,-100,-100,0);
      return res;
    }






    static const CImgList<ucharT>& font(const unsigned int font_height, const bool is_variable_width=true) {
      if (!font_height) return CImgList<ucharT>::empty();
      cimg::mutex(11);


      const char *data_fonts[] = { cimg::data_font12x13, cimg::data_font20x23, cimg::data_font47x53, 0 };
      const unsigned int data_widths[] = { 12,20,47,90 }, data_heights[] = { 13,23,53,103 },
        data_Ms[] = { 86,79,57,47 };
      const unsigned int data_ind = font_height<=13?0:font_height<=23?1:font_height<=53?2:3;
      static CImg<ucharT> base_fonts[4];
      CImg<ucharT> &base_font = base_fonts[data_ind];
      if (!base_font) {
        const unsigned int w = data_widths[data_ind], h = data_heights[data_ind], M = data_Ms[data_ind];
        base_font.assign(256*w,h);
        const char *data_font = data_fonts[data_ind];
        unsigned char *ptrd = base_font;
        const unsigned char *const ptrde = base_font.end();


        CImg<char> data90x103;
        if (!data_font) {
          ((CImg<char>(cimg::_data_font90x103[0],
                       (unsigned int)std::strlen(cimg::_data_font90x103[0]),1,1,1,true),
            CImg<char>(cimg::_data_font90x103[1],
                       (unsigned int)std::strlen(cimg::_data_font90x103[1])+1,1,1,1,true))>'x').
            move_to(data90x103);
          data_font = data90x103.data();
        }


        for (const char *ptrs = data_font; *ptrs; ++ptrs) {
          const int c = *ptrs-M-32, v = c>=0?255:0, n = c>=0?c:-c;
          if (ptrd+n<=ptrde) { std::memset(ptrd,v,n); ptrd+=n; }
          else { std::memset(ptrd,v,ptrde-ptrd); break; }
        }
      }


      static CImgList<ucharT> fonts[16];
      static bool is_variable_widths[16] = { 0 };
      unsigned int ind = ~0U;
      for (int i = 0; i<16; ++i)
        if (!fonts[i] || (is_variable_widths[i]==is_variable_width && font_height==fonts[i][0]._height)) {
          ind = i; break;
        }
      if (ind==~0U) {
        std::memmove(fonts,fonts+1,15*sizeof(CImgList<ucharT>));
        std::memmove(is_variable_widths,is_variable_widths+1,15*sizeof(bool));
        std::memset(fonts+(ind=15),0,sizeof(CImgList<ucharT>));
      }
      CImgList<ucharT> &font = fonts[ind];


      if (!font) {
        const unsigned int padding_x = font_height<33?1:font_height<53?2:font_height<103?3:4;
        is_variable_widths[ind] = is_variable_width;
        font = base_font.get_split('x',256);
        if (font_height!=font[0]._height)
          for (int l = 0; l<(int)(font)._width; ++l)
            font[l].resize(cimg::max(1U,font[l]._width*font_height/font[l]._height),font_height,-100,-100,
                           font[0]._height>font_height?2:5);
        if (is_variable_width) font.crop_font();
        for (int l = 0; l<(int)(font)._width; ++l) font[l].resize(font[l]._width + padding_x,-100,1,1,0,0,0.5);
        font.insert(256,0);
        for (int l = (int)(0)<0?0:(int)(0), _maxl = (unsigned int)255<(font)._width?(int)(255):(int)(font)._width-1; l<=_maxl; ++l) font[l].assign(font[l+256]._width,font[l+256]._height,1,3,1);
      }
      cimg::mutex(11,0);
      return font;
    }






    CImgList<T>& FFT(const char axis, const bool invert=false) {
      if (is_empty()) return *this;
      if (_width==1) insert(1);
      if (_width>2)
        cimg::warn("[instance(%u,%u,%p)] CImgList<%s>::"
                   "FFT(): Instance has more than 2 images",
                   _width,_allocated_width,_data,pixel_type());

      CImg<T>::FFT(_data[0],_data[1],axis,invert);
      return *this;
    }


    CImgList<Tfloat> get_FFT(const char axis, const bool invert=false) const {
      return CImgList<Tfloat>(*this,false).FFT(axis,invert);
    }





    CImgList<T>& FFT(const bool invert=false) {
      if (is_empty()) return *this;
      if (_width==1) insert(1);
      if (_width>2)
        cimg::warn("[instance(%u,%u,%p)] CImgList<%s>::"
                   "FFT(): Instance has more than 2 images",
                   _width,_allocated_width,_data,pixel_type());

      CImg<T>::FFT(_data[0],_data[1],invert);
      return *this;
    }


    CImgList<Tfloat> get_FFT(const bool invert=false) const {
      return CImgList<Tfloat>(*this,false).FFT(invert);
    }




    CImgList<T>& reverse_object3d() {
      for (int l = 0; l<(int)(*this)._width; ++l) {
        CImg<T>& p = _data[l];
        switch (p.size()) {
        case 2: case 3: cimg::swap(p[0],p[1]); break;
        case 6: cimg::swap(p[0],p[1],p[2],p[4],p[3],p[5]); break;
        case 9: cimg::swap(p[0],p[1],p[3],p[5],p[4],p[6]); break;
        case 4: cimg::swap(p[0],p[1],p[2],p[3]); break;
        case 12: cimg::swap(p[0],p[1],p[2],p[3],p[4],p[6],p[5],p[7],p[8],p[10],p[9],p[11]); break;
        }
      }
      return *this;
    }


    CImgList<T> get_reverse_object3d() const {
      return (+*this).reverse_object3d();
    }


  };
# 49310 "../src/CImg.h"
namespace cimg {


    inline unsigned long tictoc(const bool is_tic) {
      cimg::mutex(2);
      static CImg<unsigned long> times(64);
      static unsigned int pos = 0;
      const unsigned long t1 = cimg::time();
      if (is_tic) {
        times[pos++] = t1;
        if (pos>=times._width)
          throw CImgArgumentException("cimg::tic(): Too much calls to 'cimg::tic()' without calls to 'cimg::toc()'.");
        cimg::mutex(2,0);
        return t1;
      }

      if (!pos)
        throw CImgArgumentException("cimg::toc(): No previous call to 'cimg::tic()' has been made.");
      const unsigned long
        t0 = times[--pos],
        dt = t1>=t0?(t1-t0):cimg::type<unsigned long>::max();
      const unsigned int
        edays = (unsigned int)(dt/86400000.0),
        ehours = (unsigned int)((dt - edays*86400000.0)/3600000.0),
        emin = (unsigned int)((dt - edays*86400000.0 - ehours*3600000.0)/60000.0),
        esec = (unsigned int)((dt - edays*86400000.0 - ehours*3600000.0 - emin*60000.0)/1000.0),
        ems = (unsigned int)(dt - edays*86400000.0 - ehours*3600000.0 - emin*60000.0 - esec*1000.0);
      if (!edays && !ehours && !emin && !esec)
        std::fprintf(cimg::output(),"%s[CImg]%*sElapsed time: %u ms%s\n",
                     cimg::t_red,1+2*pos,"",ems,cimg::t_normal);
      else {
        if (!edays && !ehours && !emin)
          std::fprintf(cimg::output(),"%s[CImg]%*sElapsed time: %u sec %u ms%s\n",
                       cimg::t_red,1+2*pos,"",esec,ems,cimg::t_normal);
        else {
          if (!edays && !ehours)
            std::fprintf(cimg::output(),"%s[CImg]%*sElapsed time: %u min %u sec %u ms%s\n",
                         cimg::t_red,1+2*pos,"",emin,esec,ems,cimg::t_normal);
          else{
            if (!edays)
              std::fprintf(cimg::output(),"%s[CImg]%*sElapsed time: %u hours %u min %u sec %u ms%s\n",
                           cimg::t_red,1+2*pos,"",ehours,emin,esec,ems,cimg::t_normal);
            else{
              std::fprintf(cimg::output(),"%s[CImg]%*sElapsed time: %u days %u hours %u min %u sec %u ms%s\n",
                           cimg::t_red,1+2*pos,"",edays,ehours,emin,esec,ems,cimg::t_normal);
            }
          }
        }
      }
      cimg::mutex(2,0);
      return dt;
    }
# 49382 "../src/CImg.h"
  template<typename t>
  inline int dialog(const char *const title, const char *const msg,
                    const char *const button1_label, const char *const button2_label,
                    const char *const button3_label, const char *const button4_label,
                    const char *const button5_label, const char *const button6_label,
                    const CImg<t>& logo, const bool is_centered = false) {





    const unsigned char
      black[] = { 0,0,0 }, white[] = { 255,255,255 }, gray[] = { 200,200,200 }, gray2[] = { 150,150,150 };


    CImgList<unsigned char> buttons, cbuttons, sbuttons;
    if (button1_label) { CImg<unsigned char>().draw_text(0,0,button1_label,black,gray,1,13).move_to(buttons);
      if (button2_label) { CImg<unsigned char>().draw_text(0,0,button2_label,black,gray,1,13).move_to(buttons);
        if (button3_label) { CImg<unsigned char>().draw_text(0,0,button3_label,black,gray,1,13).move_to(buttons);
          if (button4_label) { CImg<unsigned char>().draw_text(0,0,button4_label,black,gray,1,13).move_to(buttons);
            if (button5_label) { CImg<unsigned char>().draw_text(0,0,button5_label,black,gray,1,13).move_to(buttons);
              if (button6_label) { CImg<unsigned char>().draw_text(0,0,button6_label,black,gray,1,13).move_to(buttons);
              }}}}}}
    if (!buttons._width)
      throw CImgArgumentException("cimg::dialog(): No buttons have been defined.");
    for (int l = 0; l<(int)(buttons)._width; ++l) buttons[l].resize(-100,-100,1,3);

    unsigned int bw = 0, bh = 0;
    for (int l = 0; l<(int)(buttons)._width; ++l) { bw = cimg::max(bw,buttons[l]._width); bh = cimg::max(bh,buttons[l]._height); }
    bw+=8; bh+=8;
    if (bw<64) bw = 64;
    if (bw>128) bw = 128;
    if (bh<24) bh = 24;
    if (bh>48) bh = 48;

    CImg<unsigned char> button(bw,bh,1,3);
    button.draw_rectangle(0,0,bw-1,bh-1,gray);
    button.draw_line(0,0,bw-1,0,white).draw_line(0,bh-1,0,0,white);
    button.draw_line(bw-1,0,bw-1,bh-1,black).draw_line(bw-1,bh-1,0,bh-1,black);
    button.draw_line(1,bh-2,bw-2,bh-2,gray2).draw_line(bw-2,bh-2,bw-2,1,gray2);
    CImg<unsigned char> sbutton(bw,bh,1,3);
    sbutton.draw_rectangle(0,0,bw-1,bh-1,gray);
    sbutton.draw_line(0,0,bw-1,0,black).draw_line(bw-1,0,bw-1,bh-1,black);
    sbutton.draw_line(bw-1,bh-1,0,bh-1,black).draw_line(0,bh-1,0,0,black);
    sbutton.draw_line(1,1,bw-2,1,white).draw_line(1,bh-2,1,1,white);
    sbutton.draw_line(bw-2,1,bw-2,bh-2,black).draw_line(bw-2,bh-2,1,bh-2,black);
    sbutton.draw_line(2,bh-3,bw-3,bh-3,gray2).draw_line(bw-3,bh-3,bw-3,2,gray2);
    sbutton.draw_line(4,4,bw-5,4,black,1,0xAAAAAAAA,true).draw_line(bw-5,4,bw-5,bh-5,black,1,0xAAAAAAAA,false);
    sbutton.draw_line(bw-5,bh-5,4,bh-5,black,1,0xAAAAAAAA,false).draw_line(4,bh-5,4,4,black,1,0xAAAAAAAA,false);
    CImg<unsigned char> cbutton(bw,bh,1,3);
    cbutton.draw_rectangle(0,0,bw-1,bh-1,black).draw_rectangle(1,1,bw-2,bh-2,gray2).draw_rectangle(2,2,bw-3,bh-3,gray);
    cbutton.draw_line(4,4,bw-5,4,black,1,0xAAAAAAAA,true).draw_line(bw-5,4,bw-5,bh-5,black,1,0xAAAAAAAA,false);
    cbutton.draw_line(bw-5,bh-5,4,bh-5,black,1,0xAAAAAAAA,false).draw_line(4,bh-5,4,4,black,1,0xAAAAAAAA,false);

    for (int ll = 0; ll<(int)(buttons)._width; ++ll) {
      CImg<unsigned char>(cbutton).draw_image(1+(bw-buttons[ll].width())/2,1+(bh-buttons[ll].height())/2,buttons[ll]).
        move_to(cbuttons);
      CImg<unsigned char>(sbutton).draw_image((bw-buttons[ll].width())/2,(bh-buttons[ll].height())/2,buttons[ll]).
        move_to(sbuttons);
      CImg<unsigned char>(button).draw_image((bw-buttons[ll].width())/2,(bh-buttons[ll].height())/2,buttons[ll]).
        move_to(buttons[ll]);
    }

    CImg<unsigned char> canvas;
    if (msg)
      ((CImg<unsigned char>().draw_text(0,0,"%s",gray,0,1,13,msg)*=-1)+=200).resize(-100,-100,1,3).move_to(canvas);

    const unsigned int
      bwall = (buttons._width-1)*(12+bw) + bw,
      w = cimg::max(196U,36+logo._width+canvas._width,24+bwall),
      h = cimg::max(96U,36+canvas._height+bh,36+logo._height+bh),
      lx = 12 + (canvas._data?0:((w-24-logo._width)/2)),
      ly = (h-12-bh-logo._height)/2,
      tx = lx+logo._width+12,
      ty = (h-12-bh-canvas._height)/2,
      bx = (w-bwall)/2,
      by = h-12-bh;

    if (canvas._data)
      canvas = CImg<unsigned char>(w,h,1,3).
        draw_rectangle(0,0,w-1,h-1,gray).
        draw_line(0,0,w-1,0,white).draw_line(0,h-1,0,0,white).
        draw_line(w-1,0,w-1,h-1,black).draw_line(w-1,h-1,0,h-1,black).
        draw_image(tx,ty,canvas);
    else
      canvas = CImg<unsigned char>(w,h,1,3).
        draw_rectangle(0,0,w-1,h-1,gray).
        draw_line(0,0,w-1,0,white).draw_line(0,h-1,0,0,white).
        draw_line(w-1,0,w-1,h-1,black).draw_line(w-1,h-1,0,h-1,black);
    if (logo._data) canvas.draw_image(lx,ly,logo);

    unsigned int xbuttons[6] = { 0 };
    for (int lll = 0; lll<(int)(buttons)._width; ++lll) { xbuttons[lll] = bx+(bw+12)*lll; canvas.draw_image(xbuttons[lll],by,buttons[lll]); }


    CImgDisplay disp(canvas,title?title:" ",0,false,is_centered?true:false);
    if (is_centered) disp.move((CImgDisplay::screen_width() - disp.width())/2,
                             (CImgDisplay::screen_height() - disp.height())/2);
    bool stop_flag = false, refresh = false;
    int oselected = -1, oclicked = -1, selected = -1, clicked = -1;
    while (!disp.is_closed() && !stop_flag) {
      if (refresh) {
        if (clicked>=0)
          CImg<unsigned char>(canvas).draw_image(xbuttons[clicked],by,cbuttons[clicked]).display(disp);
        else {
          if (selected>=0)
            CImg<unsigned char>(canvas).draw_image(xbuttons[selected],by,sbuttons[selected]).display(disp);
          else canvas.display(disp);
        }
        refresh = false;
      }
      disp.wait(15);
      if (disp.is_resized()) disp.resize(disp,false);

      if (disp.button()&1) {
        oclicked = clicked;
        clicked = -1;
        for (int l = 0; l<(int)(buttons)._width; ++l)
          if (disp.mouse_y()>=(int)by && disp.mouse_y()<(int)(by+bh) &&
              disp.mouse_x()>=(int)xbuttons[l] && disp.mouse_x()<(int)(xbuttons[l]+bw)) {
            clicked = selected = l;
            refresh = true;
          }
        if (clicked!=oclicked) refresh = true;
      } else if (clicked>=0) stop_flag = true;

      if (disp.key()) {
        oselected = selected;
        switch (disp.key()) {
        case cimg::keyESC : selected=-1; stop_flag = true; break;
        case cimg::keyENTER : if (selected<0) selected = 0; stop_flag = true; break;
        case cimg::keyTAB :
        case cimg::keyARROWRIGHT :
        case cimg::keyARROWDOWN : selected = (selected+1)%buttons._width; break;
        case cimg::keyARROWLEFT :
        case cimg::keyARROWUP : selected = (selected+buttons._width-1)%buttons._width; break;
        }
        disp.set_key();
        if (selected!=oselected) refresh = true;
      }
    }
    if (!disp) selected = -1;
    return selected;

  }


  inline int dialog(const char *const title, const char *const msg,
                    const char *const button1_label, const char *const button2_label, const char *const button3_label,
                    const char *const button4_label, const char *const button5_label, const char *const button6_label,
                    const bool is_centered) {
    return dialog(title,msg,button1_label,button2_label,button3_label,button4_label,button5_label,button6_label,
                  CImg<unsigned char>::_logo40x38(),is_centered);
  }
# 49553 "../src/CImg.h"
  inline double eval(const char *const expression, const double x, const double y, const double z, const double c) {
    static const CImg<float> empty;
    return empty.eval(expression,x,y,z,c);
  }

  template<typename t>
  inline CImg<typename cimg::superset<double,t>::type> eval(const char *const expression, const CImg<t>& xyzc) {
    static const CImg<float> empty;
    return empty.eval(expression,xyzc);
  }


}


}


namespace cil = cimg_library;
# 25 "../src/Vec2.hpp" 2
using namespace cimg_library;

class Vec2 {
public:

 __attribute__((device)) __attribute__((host)) inline int width() const;
 __attribute__((device)) __attribute__((host)) inline int height() const;
 __attribute__((device)) __attribute__((host)) inline size_t size() const;
 __attribute__((device)) __attribute__((host)) inline float2* getConstPtr() const;
 __attribute__((device)) __attribute__((host)) inline float2* getPtr();
 __attribute__((device)) __attribute__((host)) inline float2* getPtr(unsigned int x, unsigned int y);
 __attribute__((device)) __attribute__((host)) inline float2* getConstPtr(unsigned int x, unsigned int y) const;
 __attribute__((device)) __attribute__((host)) inline float2 get(unsigned int x, unsigned int y) const;
 __attribute__((device)) __attribute__((host)) Vec2(const Vec2& _vec);

 __attribute__((device)) __attribute__((host)) Vec2(int width, int height);
 __attribute__((device)) __attribute__((host)) Vec2();
 __attribute__((device)) __attribute__((host)) ~Vec2();



 float2* data;
 int imWidth;
 int imHeight;
 size_t imSize;

};

__attribute__((device)) __attribute__((host)) inline float2 Vec2::get(unsigned int x, unsigned int y) const {



 return data[y * imWidth + x];
}

__attribute__((device)) __attribute__((host)) inline int Vec2::width() const {
 return imWidth;
}
__attribute__((device)) __attribute__((host)) inline int Vec2::height() const {
 return imHeight;
}
__attribute__((device)) __attribute__((host)) inline size_t Vec2::size() const {
 return imSize;
}

__attribute__((device)) __attribute__((host)) inline float2* Vec2::getConstPtr() const {
 return data;
}

__attribute__((device)) __attribute__((host)) inline float2* Vec2::getPtr() {
 return data;
}

__attribute__((device)) __attribute__((host)) inline float2* Vec2::getPtr(unsigned int x, unsigned int y) {
 return &data[y * imWidth + x];
}
__attribute__((device)) __attribute__((host)) inline float2* Vec2::getConstPtr(unsigned int x, unsigned int y) const {
 return &data[y * imWidth + x];
}
# 15 "../src/Vec2.cu" 2

__attribute__((device)) __attribute__((host)) Vec2::Vec2(int width, int height) {
 imWidth = width;
 imHeight = height;
 imSize = imWidth * imHeight;
 data = new float2[imSize];
}

__attribute__((device)) __attribute__((host)) Vec2::Vec2() {
 data = 0;
 imHeight = 0;
 imWidth = 0;
 imSize = 0;

}

__attribute__((device)) __attribute__((host)) Vec2::Vec2(const Vec2& _vec)

{

 imWidth = _vec.width();
 imHeight = _vec.height();
 imSize = imWidth * imHeight;
 data = new float2[imSize];


 const float2* _vecPtr = _vec.getConstPtr();
 unsigned int i = 0;
 for (i = 0; i < imSize; i++) {
  data[i].x = _vecPtr[i].x;
  data[i].y = _vecPtr[i].y;

 }
}

__attribute__((device)) __attribute__((host)) Vec2::~Vec2() {
 delete[] data;
 data = 0;
}
